/*	$TITLE :SYNSOU:LINKMOD:LINKSOU  -  Module for:	Routines which connect the screen and the synclavier data structure.	*//*Modified:2002/08/24 - TY  - UPDATE.CLICK.FIELD() now shows the click field as milliseconds when the sequence is unmapped and microseconds when mapped2000/04/25 - TY  - Replaced floating point math in SET.SYNCLAV.CLICK.RATE and UPDATE.CLICK.FIELD with equivalent						 multiple-precision math which runs five times faster2000/04/15 - TY  - Added convert_msec_to_frames, convert_usec_to_frames, convert_frames_to_msec, convert_frames_to_usec,						 and further reworked items to handle frames per beat tempos1999/11/18 - CJ  - Reworked numerous items to handle frames/per/beat tempos1999/04/11 - TY  - Modified UPDATE.SYNCLAV.CLICK.MODE, UPDATE.CLICK.STATE.VARS and						 UPDATE.CLICK.DISP.FORMAT to account for the independence of						 CLICK.DISP.MODE from CLICK.TRACK.MODE.1998/06/24 - TY  - Modified UPDATE.SYNCLAV.CLICK.MODE, UPDATE.CLICK.STATE.VARS and						 UPDATE.CLICK.DISP.FORMAT to account for the independence of						 CLICK.TRACK.MODE from CLICKON.1991/02/13 - CJ  - Combined new and old usage of click rate1991/02/07 - PF  - Updated click and bpm routines for use with Tempo/Meter maps1989/09/28 - CJ  - Added Take System Real Time1989/08/24 - PF  - Modified sync mode code to accommodate MIDInet sync1988/10/23 - cj  - Make Take System Sync Time detect old SMPTE firmware						 to fix Record/VITC bug1988/08/08 - cj  - stored S$Fmode in sequence1988/07/19 - CJ  - added take.system.sequence.time, stake.system.smpte.time1988/06/29 - MWH - Remove unused inserts1987/12/02 - cj  - reset slocked in set syncl smpte offset1987/10/04 - eg  - modified feet routines to handle 16mm, 30fps1987/08/14 - eg  - added set.synclav.feet.mode1987/08/11 - eg  - added update.click.field, set.synclav.click.rate1987/08/10 - eg  - added handle.click.mode.switch1987/07/23 - eg  - added smpte routines and click routines1987/07/22 -cj,eg- added ext sync routines1987/02/25 - eg  - created this file*/module linkmod;insert ':-xpl:intrprtr';insert ':synlits:alltlits';	/*	get all terminal literals		*/insert ':synmods:giddcl';		/*	gid/pid								*/insert ':synmods:smgrdcl';		/*	smgr routines, deposit, etc.	*/insert ':synmods:globdcl';insert ':synmods:gprmdcl';insert ':synmods:mathdcl';insert ':synmods:parmdcl';insert ':synmods:getvdcl';insert ':synmods:tformdcl';insert ':synrdcls:03-pdcls';insert ':synrdcls:04-sdcls';insert ':synrdcls:05-bdcls';insert ':synrdcls:10-intdc';insert ':synlits:synclits';//	The following two procedures, "convert_msec_to_frames" and "convert_usec_to_frames" report the actual//	resultant frames per beat taking all considerations into account (sequence speed, frame rate, etc.)  //	The caller must specify whether to utilize the current Film frame rate or the current SMPTE frame rate.//	The whole part of the result is returned in the upper word of the referenced array, and the fractional//	part (modulo 800) is returned	in the lower word./*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE convert_msec_to_frames											*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	For use with UNMAPPED sequencesconvert_msec_to_frames: proc (value,frame_type,output32) public swapable;	dcl value		fixed;	//	passed millisecond click rate (usually samp.click.rate)	dcl frame_type fixed;	//	0 = Film Frames,  1 = SMPTE Frames	dcl output32	fixed array;	dcl numerator	fixed;	//	constant based on frame rate	//	иииииииииииииииииииииииииииииииNиEиRиDиииNиOиTиEиSиииииииииииииииииииииииииииииии	//	(note: "subframe" means 1/800th of a frame here)	//	//	for millisecond tempos:	//		subframes_per_beat(  24/1  ) = 19200 * samp.click.rate / samp.speed	//		subframes_per_beat(  25/1  ) = 20000 * samp.click.rate / samp.speed	//		subframes_per_beat(  30/1  ) = 24000 * samp.click.rate / samp.speed	//		subframes_per_beat(2997/100) = 23976 * samp.click.rate / samp.speed	//		//		samp.click.rate can vary from 25 to 2,000	//		samp.speed can vary from 0 to 10,000	//		therefore ratio_multiply() can be used with all frame rates without fear of overflow	//		//	in all cases, if samp.speed gets too low, final result might exceed 2^16-1		if (samp.speed == 0) {output32(0) = "100000"; output32(1) = "100000"; return;}	//	avoid division by zero, return "infinity"	//	step 1: set numerator based on frame rate	write(mam) = bas.ptr;	if (frame_type == 0) {	//	using film frame rate		write(mal) = seq.fmode;		load film.fps(read(md));	//	returns 30, 25 or 24		mul 800; numerator = res;	}	else {						//	using smpte frame rate		write(mal) = seq.smode;		if ((read(md) == 0) || (read(md) == 4)) numerator = 23976;	//	if smpte mode is drop or ntsc 29.97, use 8*2997		else {			load frames.per.second(read(md));	//	returns 30, 25 or 24			mul 800; numerator = res;		}	}	//	step 2: get 32-bit rounded result of numerator * samp.click.rate / samp.speed	//			  (this is the number of 800ths of a frame per beat)	bitmsb = 0; bitlsb = value;	ratio_multiply(numerator,samp.speed);	//	step 3: separate into whole and fractional parts	//	let caller know if whole part is too large	load bitlsb; uload bitmsb; div 800;	if (bitmsb ige 800)	output32(0) = "100000";	//	if ludicrously small values of samp.speed cause overflow, treat as "infinity"	else						output32(0) = res;		//	whole part	output32(1) = rem;									//	fractional partend convert_msec_to_frames;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE convert_usec_to_frames											*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	For use with MAPPED sequencesconvert_usec_to_frames: proc (frame_type,output32) public swapable;	dcl frame_type fixed;	//	0 = Film Frames,  1 = SMPTE Frames	dcl output32	fixed array;	dcl numerator			fixed;	//	constant based on frame rate	dcl denominator(1)	fixed;	//	constant based on frame rate	//	иииииииииииииииииииииииииииииииNиEиRиDиииNиOиTиEиSиииииииииииииииииииииииииииииии	//	(note: "subframe" means 1/800th of a frame here)	//	//	for microsecond tempos:	//		subframes_per_beat(  24/1  ) =   96 * microseconds_per_beat / (  5 * samp.speed)	//		subframes_per_beat(  25/1  ) =   20 * microseconds_per_beat / (  1 * samp.speed)	//		subframes_per_beat(  30/1  ) =   24 * microseconds_per_beat / (  1 * samp.speed)	//		subframes_per_beat(2997/100) = 2997 * microseconds_per_beat / (125 * samp.speed)	//		//		microseconds_per_beat can vary from 25,000 to 2,000,000	//		samp.speed can vary from 0 to 10,000	//		therefore denominator might exceed 2^16-1 only in the case of 29.97 frame rate	//		ratio_multiply() can be used unless denominator exceeds 2^16-1, in which case	//		{disable;mul_32by32();div_64by32();enable;} must be used	//		//	in all cases, if samp.speed gets too low, final result might exceed 2^16-1	if (samp.speed == 0) {output32(0) = "100000"; output32(1) = "100000"; return;}	//	avoid division by zero, return "infinity"	//	step 1: get frame rate	write(mam) = bas.ptr;	if (frame_type == 0) {	//	using film frame rate		write(mal) = seq.fmode;		numerator = film.fps(read(md));	//	returns 30, 25 or 24	}	else {						//	using smpte frame rate		write(mal) = seq.smode;		if ((read(md) == 0) || (read(md) == 4)) {			//	if smpte mode is drop or ntsc 29.97			numerator = 2997;			load samp.speed; mul 125;			denominator(0) = ures; denominator(1) = res;		}		else numerator = frames.per.second(read(md));	//	returns 30, 25 or 24	}	//	step 2: set numerator and denominator based on frame rate	if		  (numerator == 24) {numerator = 96; load samp.speed; mul 5; denominator(1) = res;}	else if (numerator == 30) {numerator = 24; denominator(1) = samp.speed;}	else if (numerator == 25) {numerator = 20; denominator(1) = samp.speed;}	lookup.tempo(loc(addr(sampled.actual.sequence.time.msb)),BitMsbArray);	//	get current microseconds per beat handy	//	step 3: get 32-bit rounded result of numerator * microseconds_per_beat / denominator	//			  (this is the number of 800ths of a frame per beat)	//	determine whether we must divide by a 32-bit or a 16-bit denominator	if (denominator(0) == 0) ratio_multiply(numerator,denominator(1));	//	the result is in bitmsb,bitlsb	else {		str32(0,numerator,output32);	//	temporarily hold 32-bit version of numerator in output32		disable;		mul_32by32(BitMsbArray,output32);		//	(the interim 64-bit value is in MATHMOD's static array multiply.result)		div_64by32(denominator,BitMsbArray);	//	the result is in bitmsb,bitlsb		enable;	}	//	step 4: separate into whole and fractional parts	//	let caller know if whole part is too large	load bitlsb; uload bitmsb; div 800;	if (bitmsb ige 800)	output32(0) = "100000";	//	if ludicrously small values of samp.speed cause overflow, treat as "infinity"	else						output32(0) = res;		//	whole part	output32(1) = rem;									//	fractional partend convert_usec_to_frames;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE convert_frames_to_msec											*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	"convert_frames_to_msec" returns the nearest millisecond tempo corresponding to the input sf.time array//	interpreted as frames, taking	all considerations into account (sequence speed, frame rate, etc.)  //	The caller must specify whether to utilize the current Film frame rate or the current SMPTE frame rate.//	For use with UNMAPPED sequencesconvert_frames_to_msec: proc (frame_type,input32) returns (fixed) swapable;	dcl frame_type 	fixed;	//	0 = Film Frames,  1 = SMPTE Frames	dcl input32			fixed array;	dcl denominator	fixed;	//	constant based on frame rate	//	иииииииииииииииииииииииииииииииNиEиRиDиииNиOиTиEиSиииииииииииииииииииииииииииииии	//	(note: "subframe" means 1/800th of a frame here)	//	//	for millisecond tempos:	//		milliseconds_per_beat(  24/1  ) = subframes_per_beat * samp.speed / 19200	//		milliseconds_per_beat(  25/1  ) = subframes_per_beat * samp.speed / 20000	//		milliseconds_per_beat(  30/1  ) = subframes_per_beat * samp.speed / 24000	//		milliseconds_per_beat(2997/100) = subframes_per_beat * samp.speed / 23976	//		//		milliseconds_per_beat can vary from 25 to 2,000	//		samp.speed can vary from 0 to 10,000	//		therefore ratio_multiply() can be used with all frame rates without fear of overflow	//	step 1: set denominator based on frame rate	write(mam) = bas.ptr;	if (frame_type == 0) {	//	using film frame rate		write(mal) = seq.fmode;		load film.fps(read(md));	//	returns 30, 25 or 24		mul 800; denominator = res;	}	else {						//	using smpte frame rate		write(mal) = seq.smode;		if ((read(md) == 0) || (read(md) == 4)) denominator = 23976;	//	if smpte mode is drop or ntsc 29.97, use (8 * 2997)		else {			load frames.per.second(read(md));	//	returns 30, 25 or 24			mul 800; denominator = res;		}	}	//	step 2: convert whole_frames.subframes to total_subframes	load input32(0);	// we have to cheat a little to prevent jogging down from X.000 to X.199	if (input32(1) == 999)	uload 799;	else							uload input32(1);	mul 800;	bitmsb = ures; bitlsb = res;	//	step 3: get 32-bit rounded result of subframes_per_beat * samp.speed / denominator	ratio_multiply(samp.speed,denominator);	//	step 4: limit to legal range	if	((bitmsb != 0) || (bitlsb igt 2000)) return 2000;	if	(bitlsb ilt 25)							 return 25;	return bitlsb;end convert_frames_to_msec;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE convert_frames_to_usec											*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	"convert_frames_to_usec" returns the nearest microsecond tempo corresponding to the input sf.time array//	interpreted as frames, taking	all considerations into account (sequence speed, frame rate, etc.)  //	The caller must specify whether to utilize the current Film frame rate or the current SMPTE frame rate.//	The result is returned in the passed array "output32".//	For use with MAPPED sequencesconvert_frames_to_usec: proc (frame_type,input32,output32) swapable;	dcl frame_type fixed;	//	0 = Film Frames,  1 = SMPTE Frames	dcl input32		fixed array;	dcl output32	fixed array;	dcl (numerator,denominator)	fixed;	//	constants based on frame rate	//	иииииииииииииииииииииииииииииииNиEиRиDиииNиOиTиEиSиииииииииииииииииииииииииииииии	//	(note: "subframe" means 1/800th of a frame here)	//	//	for microsecond tempos:	//		microseconds_per_beat(  24/1  ) = subframes_per_beat * samp.speed *   5 /   96	//		microseconds_per_beat(  25/1  ) = subframes_per_beat * samp.speed *   1 /   20	//		microseconds_per_beat(  30/1  ) = subframes_per_beat * samp.speed *   1 /   24	//		microseconds_per_beat(2997/100) = subframes_per_beat * samp.speed * 125 / 2997	//		//		microseconds_per_beat can vary from 25,000 to 2,000,000	//		samp.speed can vary from 0 to 10,000	//		(subframes_per_beat * numerator) can only overflow if user types in 42950 whole frames or more	//		therefore ratio_multiply() can be used with all frame rates without fear of overflow	//	step 1: get frame rate	write(mam) = bas.ptr;	if (frame_type == 0) {	//	using film frame rate		write(mal) = seq.fmode;		denominator = film.fps(read(md));	//	returns 30, 25 or 24	}	else {						//	using smpte frame rate		write(mal) = seq.smode;		if ((read(md) == 0) || (read(md) == 4)) {			//	if smpte mode is drop or ntsc 29.97			numerator = 125; denominator = 2997;		}		else denominator = frames.per.second(read(md));	//	returns 30, 25 or 24	}	//	step 2: set numerator and denominator based on frame rate	if		  (denominator == 24) {numerator = 5; denominator = 96;}	else if (denominator == 30) {numerator = 1; denominator = 24;}	else if (denominator == 25) {numerator = 1; denominator = 20;}	//	step 3: convert whole_frames.subframes to total_subframes	load input32(0);	// we have to cheat a little to prevent jogging down from X.000 to X.199	if (input32(1) == 999)	uload 799;	else							uload input32(1);	mul 800;	bitmsb = ures;	if (numerator == 1) bitlsb = res;	else {		//	get 32-bit (subframes_per_beat * numerator)		load res;	//	do this to clear the upper register		mul numerator;		bitlsb = res; write("313") = ures;	// save for the addend below		load bitmsb; uload read("313");		mul numerator;		bitmsb = res;	}	//	step 4: get 32-bit rounded result of (subframes_per_beat * numerator) * samp.speed / denominator	ratio_multiply(samp.speed,denominator);	//	step 5: limit to legal range	if			((bitmsb igt 30) || ((bitmsb == 30) && (bitlsb igt 33920)))	{output32(0) =		 30; output32(1) =  33920;}	else if	((bitmsb == 0) && (bitlsb ilt 25000))								{output32(0) =		  0; output32(1) =  25000;}	else																						{output32(0) = bitmsb; output32(1) = bitlsb;}end convert_frames_to_usec;//	actually changes synclav click.track.mode, click.track.mode and clickon//	based on current value of the click state variablesUPDATE.SYNCLAV.CLICK.MODE: proc public swapable;	clickon = gid(sync.click.sound);	/*	find out if sound is on or off	*/	do case (gid(sync.click.mode));		/*	Case 0: internal	*/		{			click.track.mode = 0;			click.disp.mode = gid(sync.click.format);	//	beats/minute, msec/beat, Film F/B, SmpteF/B		}		/*	Case 1: external	*/		click.track.mode = 3;		/*	Case 2: live click	*/		click.track.mode = gid(live.click.track)-num.kbd.tracks+4;	end;	call select.parameter(click.l-par.l);	/*	update display - generate new seq info constant change	*/	call display.sequencer.status;			/*	generates new seq info motion change	*/end UPDATE.SYNCLAV.CLICK.MODE;/*	updates the various state variables based on current click.track.mode	NOTE: the sync.click.format does not get updated, this allows the	user to see the times in beats or msec independent of the synclavier mode*/UPDATE.CLICK.STATE.VARS: proc public swapable;	pid(sync.click.sound, CLICKON);	//	click on/off status	if			(click.track.mode == 0) pid(sync.click.mode, 0);	//	internal	else if	(click.track.mode == 3) pid(sync.click.mode, 1);	//	external	else {																		//	live		pid(sync.click.mode, 2);		pid(live.click.track, click.track.mode-4+num.kbd.tracks);	/*	update live click variable	*/	}end UPDATE.CLICK.STATE.VARS;/*	sets up beats/min or msec format based on current click.track.mode	*///	APPARENTLY THIS IS NEVER CALLED ANYWHERE	- TY 2002/08/22////	UPDATE.CLICK.DISP.FORMAT: proc public swapable;//		pid (sync.click.format, click.disp.mode);	//	beats/minute, msec/beat, Film F/B, SmpteF/B//	end UPDATE.CLICK.DISP.FORMAT;/*	$subtitle - routines to set and retrieve click state variables	*/GET.SYNCLAV.CLICK.MODE: proc returns (fixed) public swapable;	return gid(sync.click.mode);end GET.SYNCLAV.CLICK.MODE;GET.SYNCLAV.CLICK.DISP.FORMAT: proc returns (fixed) public swapable;	return gid(sync.click.format);end GET.SYNCLAV.CLICK.DISP.FORMAT;GET.SYNCLAV.CLICK.SOUND: proc returns (fixed) public swapable;	return gid(sync.click.sound);end GET.SYNCLAV.CLICK.SOUND;GET.SYNCLAV.LIVE.CLICK.TRACK: proc returns (fixed) public swapable;	return gid(live.click.track);end GET.SYNCLAV.LIVE.CLICK.TRACK;/*	sets variable indicating whether internal, external, or live click	*/SET.SYNCLAV.CLICK.MODE: proc (mode) public swapable;	dcl mode	fixed;			/*	0-internal, 1-external, 2-live click	*/	call pid(sync.click.mode, mode);	call UPDATE.SYNCLAV.CLICK.MODE;end SET.SYNCLAV.CLICK.MODE;/*	sets variable indicating whether internal sync times are displayed in beats/min or msec	*/SET.SYNCLAV.CLICK.DISP.FORMAT: proc(format) public swapable;	dcl format	fixed;		/*	0-beats/min, 1-msec, 2-Film F/B, 3-SmpteF/B	*/	call pid(sync.click.format, format);	call UPDATE.SYNCLAV.CLICK.MODE;end SET.SYNCLAV.CLICK.DISP.FORMAT;/*	sets variable indicating whether click sound is on or off	*/SET.SYNCLAV.CLICK.SOUND: proc (whichway) public swapable;	dcl whichway	fixed;	/*	0 => off; 1 => on	*/	call pid(sync.click.sound, whichway);	call UPDATE.SYNCLAV.CLICK.MODE;end SET.SYNCLAV.CLICK.SOUND;/*	sets variable indicating which track is the live click track	*/SET.SYNCLAV.LIVE.CLICK.TRACK: proc (track) public swapable;	dcl track	fixed;		/*	abs. track # for live click track	*/	call pid(live.click.track, (track&511));	call UPDATE.SYNCLAV.CLICK.MODE;end SET.SYNCLAV.LIVE.CLICK.TRACK;/*	called when click.mode.switch is changed, updates state vars	*/HANDLE.CLICK.MODE.SWITCH: proc(click.mode.sw.pos) public swapable;	dcl click.mode.sw.pos	fixed;	if (click.mode.sw.pos ilt 4)	/*	this sets display format to beats/min, msec/beat, Film F/B or SmpteF/B	*/	{		call set.synclav.click.disp.format(click.mode.sw.pos);		set.synclav.click.mode(0);	}		else if (click.mode.sw.pos == 4)	// External		set.synclav.click.mode(1);			else if (click.mode.sw.pos == 5)	// Live		set.synclav.click.mode(2);end HANDLE.CLICK.MODE.SWITCH;/*	called to update synclavier click info when changed from screen	*/SET.SYNCLAV.CLICK.RATE: proc(time, mode) public swapable;	dcl time		array;	/*	sound file format time	*/	dcl mode		fixed;	/*	current display mode (beats/min, msec, frames/beat etc.)	*/	dcl (i, j)	fixed;	//	keep these in order	if (mode == 4) return;	//	EXTERNAL CLICK: nothing to do	if (mode == 5) {			//	CLICK TRACK		if			(time(0) ilt	1) time(0) =	1;		else if	(time(0) igt 200) time(0) = 200;		set.synclav.live.click.track(time(0)+num.kbd.tracks-1);	//	pass abs trk #		return;	}	if (tempo.map.ptr == null)	then do;										//	HANDLE UNMAPPED SEQUENCES		do case mode;			//	CASE 0: BEATS PER MINUTE			{	load	time(0);				uload	time(1);	//	addend				mul 1000;				i = ures; j = res;				if (time(2) ige 500) {	//	round					j = j+1;					if (j == 0) i = i+1;				}				//	limit to legal range of 30.000 to 2400.000 beats/minute				if			((i == 0) && (j ilt 30000))						j = 30000;				else if	((i igt 36) || ((i == 36) && (j igt 40704)))	{i = 36; j = 40704;}				disable;				//	put 60,000,000 into multiply.result				multiply.result(0) =		 0;				multiply.result(1) =		 0;				multiply.result(2) =	  915;				multiply.result(3) =	34560;				div_64by32(loc(addr(i)),loc(addr(i)));				enable;			}			//	CASE 1: MILLISECONDS PER BEAT			{	load	time(0);				uload	time(1);	//	addend				mul 1000;				i = ures; j = res;				if (time(2) ige 500) {	//	round					j = j+1;					if (j == 0) i = i+1;				}				//	limit to legal range of 25 to 2000 milliseconds/beat				if			((i != 0) || (j igt 2000))	j = 2000;				else if	(j ilt 25)						j =	25;			}			//	CASE 2: FILM FRAMES PER BEAT			j = convert_frames_to_msec(0,time);			//	CASE 3: SMPTE FRAMES PER BEAT			j = convert_frames_to_msec(1,time);		end;	//	end of do case		store.syncl.param(3, 0, click.l, j);	//	update samp.click.rate global variable	end;	else do;										//	HANDLE MAPPED SEQUENCES		do case mode;			//	CASE 0: BEATS PER MINUTE			{	load	time(0);				uload	time(1);	//	addend				mul 1000;				i = ures; j = res;				if (time(2) ige 500) {					j = j+1;					if (j == 0) i = i+1;				}				//	limit to legal range of 30.000 to 2400.000 beats/minute				if			((i == 0) && (j ilt 30000))						j = 30000;				else if	((i igt 36) || ((i == 36) && (j igt 40704)))	{i = 36; j = 40704;}				disable;				//	put 60,000,000,000 into multiply.result				multiply.result(0) =		 0;				multiply.result(1) =		13;				multiply.result(2) =	63559;				multiply.result(3) =	22528;				div_64by32(loc(addr(i)),loc(addr(i)));				enable;			}			//	CASE 1: MICROSECONDS PER BEAT			{	load	time(0);				uload	time(1);	//	addend				mul 1000;				mwait;				uload	time(2);	//	addend				mul 1000;				i = ures; j = res;			}			//	CASE 2: FILM FRAMES PER BEAT			convert_frames_to_usec(0,time,loc(addr(i)));			//	CASE 3: SMPTE FRAMES PER BEAT			convert_frames_to_usec(1,time,loc(addr(i)));		end;	//	end of do case		Set.Tempo(loc(addr(SAMPLED.ACTUAL.SEQUENCE.TIME.MSB)),loc(addr(i)));		display.click.rate(0);	end;end SET.SYNCLAV.CLICK.RATE;/*	called when dialog is first opened, and when new seq info happens	*/UPDATE.CLICK.FIELD: proc(click.field.id, mode) public swapable;	dcl click.field.id	fixed;	dcl mode					fixed;	/*	switch position for click.mode.switch	*/	dcl time(2)				fixed;	dcl (i, j)				fixed;	disable.deposits = true;	if (mode == 4) {		//	EXTERNAL CLICK//		time(0) = 0;//		time(1) = 0;//		time(2) = 0;		call erase.object(click.field.id);		call disable.object(click.field.id);	}	else {		//	if click field object is disabled then enable it before proceeding		if ((fetch.object.info(click.field.id, O#Status)&bit0) == 0) enable.object(click.field.id);		if (mode == 5) {	//	CLICK TRACK			time(0) = get.synclav.live.click.track-num.kbd.tracks+1;//			time(1) = 0;//			time(2) = 0;			call deposit.object.info(click.field.id, O#SF.Maxl, 3);			call deposit.object.info(click.field.id, O#SF.Maxr, cf#suppress);		}		else {			if (tempo.map.ptr == null)			then do case mode;								//	HANDLE UNMAPPED SEQUENCES				//	CASE 0: BEATS PER MINUTE				{	bitmsb = 0; bitlsb = 60000;					ratio_multiply(1000,samp.click.rate);					// separate into whole and fractional parts					load bitlsb; uload bitmsb;					div 1000;					time(0) = res; time(1) = rem;	//	time(2) is already initialized to 0					call deposit.object.info(click.field.id, O#SF.Maxl, 4);					call deposit.object.info(click.field.id, O#SF.Maxr, 3);				}				//	CASE 1: MILLISECONDS PER BEAT				{	load samp.click.rate;					div 1000;					time(0) = res;					time(1) = rem;//					time(2) = 0;					call deposit.object.info(click.field.id, O#SF.Maxl, 1);					call deposit.object.info(click.field.id, O#SF.Maxr, 3);					//	When changing the sequence type from mapped to unmapped, the field would normally not update automatically because					//	the deposited time value hasn't changed.  Therefore, since we're changing O#SF.Maxr, we want to force an update.					Set.Object.Status(click.field.id, O#STAT.Update, 1);				}				//	CASE 2: FILM FRAMES PER BEAT				{	convert_msec_to_frames(samp.click.rate,0,time);					call deposit.object.info(click.field.id, O#SF.Maxl, 2);					call deposit.object.info(click.field.id, O#SF.Maxr, 3);				}				//	CASE 3: SMPTE FRAMES PER BEAT				{	convert_msec_to_frames(samp.click.rate,1,time);					call deposit.object.info(click.field.id, O#SF.Maxl, 2);					call deposit.object.info(click.field.id, O#SF.Maxr, 3);				}			end;			else do case mode;								//	HANDLE MAPPED SEQUENCES				//	CASE 0: BEATS PER MINUTE				{	call Lookup.Tempo(loc(addr(sampled.actual.sequence.time.msb)), loc(addr(i)));	/*	get current microseconds/beat	*/					disable;					//	put 60,000,000,000 into multiply.result					multiply.result(0) =		 0;					multiply.result(1) =		13;					multiply.result(2) =	63559;					multiply.result(3) =	22528;					div_64by32(loc(addr(i)),loc(addr(i)));					enable;					// separate into whole and fractional parts					load j; uload i;					div 1000;					time(0) = res; time(1) = rem;	//	time(2) is already initialized to 0					call deposit.object.info(click.field.id, O#SF.Maxl, 4);					call deposit.object.info(click.field.id, O#SF.Maxr, 3);				}				//	CASE 1: MICROSECONDS PER BEAT				{	call Lookup.Tempo(loc(addr(SAMPLED.ACTUAL.SEQUENCE.TIME.MSB)),time);					load  time(1);						/*	load 32 bit tempo	*/					uload time(0);					div 1000;					time(2) = rem;						/*	derive microseconds	*/					load res;							/*	reload whole result	*/					div 1000;					time(0) = res;						/*	derive seconds		*/					time(1) = rem;						/*	and milliseconds	*/					call deposit.object.info(click.field.id, O#SF.Maxl, 1);					call deposit.object.info(click.field.id, O#SF.Maxr, 7);					//	When changing the sequence type from unmapped to mapped, the field would normally not update automatically because					//	the deposited time value hasn't changed.  Therefore, since we're changing O#SF.Maxr, we want to force an update.					Set.Object.Status(click.field.id, O#STAT.Update, 1);				}				//	CASE 2: FILM FRAMES PER BEAT				{	convert_usec_to_frames(0,time);					call deposit.object.info(click.field.id, O#SF.Maxl, 2);					call deposit.object.info(click.field.id, O#SF.Maxr, 3);				}				//	CASE 3: SMPTE FRAMES PER BEAT				{	convert_usec_to_frames(1,time);					call deposit.object.info(click.field.id, O#SF.Maxl, 2);					call deposit.object.info(click.field.id, O#SF.Maxr, 3);				}			end;		}	//	end of mode == 0 through 3		deposit.sound.file.time(click.field.id, time);	}		//	end of not external click	call update.object(click.field.id);	disable.deposits = false;end UPDATE.CLICK.FIELD;/*	$subtitle - routines to set and retrieve smpte modes and ext. sync	*//*	sets synclavier smpte mode:	*/SET.SYNCLAV.SMPTE.MODE: proc (setting) public swapable;	dcl setting	fixed;	/*	Drop Frame|Non-Drop|25 Frame|24 Frame|NTSC	*/	write(mam)=bas.ptr;	write(mal)=seq.smode;	write(md )=setting;	call SPEED.COMP;		/*	set up internal memory variables	*/								/*	and create necessary network		*/								/*	events.									*/	call select.parameter(smpte.l-par.l);	if new.pan then call DISPLAY.SMODE(SM.MODE);	/*	DISPLAY NEW MODE	*/end SET.SYNCLAV.SMPTE.MODE;/*	sets synclavier smpte offset to passed smpte time	*/SET.SYNCLAV.SMPTE.OFFSET: proc (smpte.time) public swapable;	dcl smpte.time	fixed array;	dcl hrs	lit 'smpte.time(0)';	dcl min	lit 'smpte.time(1)';	dcl sec	lit 'smpte.time(2)';	dcl fra	lit 'smpte.time(3)';	dcl bit	lit 'smpte.time(4)';	call normalize.smpte(smpte.time, sm.mode);	/*	make sure time is valid	*/	WRITE(MAM)=BAS.PTR;	WRITE(MAL)=SEQ.SMBITS;	WRITE(MDI)=BIT;	WRITE(MDI)=FRA\SHL(SEC, 8);	WRITE(MD )=MIN\SHL(HRS, 8);	call SPEED.COMP;		/*	set up internal memory variables	*/								/*	and create necessary network		*/								/*	events.									*/	call select.parameter(smpte.l-par.l);	/*	unlock from smpte here	*/	/*	so we get synced up		*/	/*	again							*/	if slocked <> 0 then do;			/*	IF CURRENTLY LOCKED TO SMPTE AND CHANGING THE START TIME,	*/		SLOCKED=0;							/*	THEN BREAK OUT OF MIDI LOCK AND STOP ANY ASSOCIATED			*/		IF (MIDI.SYNC.OUT   != 0)		/*	MIDI PLAYBACK																*/		&& (MIDI.SYNC.IS.TC == 0)		THEN DO;			DISABLE;			TIME.BASE.MODE=0;						/*	FOR NOW				*/			CALL SEND.MIDI.STOP;		/*	TELL MIDI DEVICES TO STOP	*/			/*** NOTE: ABOVE CALL RE-ENABLES INTERRUPTS ***/		END;		ELSE TIME.BASE.MODE=0;		/*	Create a system event whenever smpte locks or unlocks		*/		NEW.SEQ.INFO = NEW.SEQ.INFO \ 128;		interpret_set_timebase_mode(TIME.BASE.MODE);	end;end SET.SYNCLAV.SMPTE.OFFSET;CONSTRUCT.SYNC.MODE.SWITCH.STRING:proc (str) PUBLIC SWAPABLE;	dcl str	array;	dcl tmp	fixed;	DCL SMPTE.ID	LIT '256';	/*	D51 BIT FOR SMPTE BOARD	*/	do tmp=0 to 4;		call pid(sync.mode.switch0+tmp, -1);	end;	call COPY.STRING('Internal|Ext 50hz|Beat', str);	tmp=3;	if max.midi.chan<>0	then do;		call append.to.str(str, '|MIDI In');		call pid(sync.mode.switch0+tmp-3, 3);	//	+3-3		tmp=tmp+1;	end;	if max.midi.chan>4	then do;		call append.to.str(str, '|MIDI Aux');		call pid(sync.mode.switch0+tmp-3, 4);	//	+4-3		tmp=tmp+1;	end;	if max.midinet.chan<>0	then do;		call append.to.str(str, '|MIDInet');		call pid(sync.mode.switch0+tmp-3, 5);	//	+5-3		tmp=tmp+1;	end;	if interp_is_running<>0	then do;		call append.to.str(str, '|OMS MIDI');		call pid(sync.mode.switch0+tmp-3, 7);	//	+6-3		tmp=tmp+1;	end;	IF ((READ("51")&SMPTE.ID)<>0) THEN DO;		DISABLE;							/*	PROTECT FROM INTERRUPTS	*/		WRITE(D70)=SMPTE.SUBSYS;	/*	SELECT SMPTE BOARD		*/		IF (READ(D70)&255)=8		THEN DO;							/*	MAKE SURE OK				*/			ENABLE;			call append.to.str(str, '|SMPTE');			call pid(sync.mode.switch0+tmp-3, 6);	//	+7-3			tmp=tmp+1;		END;		ENABLE;	END;end CONSTRUCT.SYNC.MODE.SWITCH.STRING;/*	set.system.synclav.sync.mode: is passed a code word to set	*//*	the correct mode:															*//*    7 = OMS MIDI Sync       *//*		6 = SMPTE					*//*		5 = MIDInet					*//*		4 = MIDI AUX IN SYNC		*//*		3 = MIDI IN SYNC			*//*		2 = EXT BEAT SYNC			*//*		1 = EXT 50 HZ SYNC		*//*		0 = INTERNAL SYNC			*/SET.SYSTEM.SYNCLAV.SYNC.MODE: proc (mode) PUBLIC SWAPABLE;	dcl mode	fixed;	if (mode=6) then do;							/*	smpte desired						*/		if (smpte.onoff=0) then do;			/*	smpte desired, not on			*/			call STOP.RECD.MOVE.PLAY;			/*	HAVE TO STOP MOVEMENT FIRST	*/			call TOGGLE.SMPTE;					/*	try to turn it on					*/			call DISPLAY.SEQUENCER.STATUS;	/*	UPDATE LITES						*/			call RESYNC.TIME.BASE;				/*	SET UP CORRECT SYNC PULSE TIMING WHEN CHANGING STATES	*/		end;	end;	else do;											/*	something other than smpte desired	*/		if (smpte.onoff<>0) then do;			/*	smpte is on - turn off			*/			call STOP.RECD.MOVE.PLAY;			/*	HAVE TO STOP MOVEMENT FIRST	*/			call TOGGLE.SMPTE;					/*	turn smpte off						*/			call DISPLAY.SEQUENCER.STATUS;	/*	UPDATE LITES						*/			call RESYNC.TIME.BASE;				/*	SET UP CORRECT SYNC PULSE TIMING WHEN CHANGING STATES	*/		end;		if  (mode=3)								/*	midi in sync					*/		and (max.midi.chan=0)					/*	but no midi						*/		then do;			CALL DISPLAY.ERR(40);				/*	MIDI IS NOT AVAILABLE		*/			mode=0;		end;		if  (mode=4)								/*	midi aux sync					*/		and (max.midi.chan<=4)		then do;			CALL DISPLAY.ERR(40);				/*	MIDI IS NOT AVAILABLE		*/			mode=0;		end;		if  (mode=5)								/*	MIDInet sync	*/		and (max.midinet.chan=0)				/*	no MIDInet out there			*/		then do;			CALL DISPLAY.ERR(40);				/*	MIDInet IS NOT AVAILABLE	*/			mode=0;		end;		if  (mode=7)								/*	OMS Midi SYnc */		and (interp_is_running=0)				/*	no interpreter out there	*/		then do;			CALL DISPLAY.ERR(40);				/*	MIDInet IS NOT AVAILABLE	*/			mode=0;		end;		if ext.clock.mode<>mode then do;		/*	acual mode change		*/			CALL STOP.RECD.MOVE.PLAY;			/*	HAVE TO STOP MOVEMENT FIRST	*/			TIMING.CLOCK.ENABLE=0;				/*	DISABLE MIDI CLOCKS	*/						interp_init_oms_midi_sync(0);		// Shut-down OMS midi sync while we make changes			if (mode == 7)				ext.clock.mode = 6;			else				ext.clock.mode = mode;			/*	Create a system event when changing the sync mode:	*/			NEW.SEQ.INFO = NEW.SEQ.INFO \ 512;	/*	CHANGE IN EXT SYNC MODE	*/			IF EXT.CLOCK.MODE=4									/*	NOW LISTENING TO THE AUX INPUT	*/			THEN CALL INIT.MIDI.FIFO(MIDI.SUBSYS+1, 4);	/*	REZERO THE INPUT PORT SINCE IT MAY CONTAIN GARBAGE	*/			IF EXT.CLOCK.MODE=6								// if activating OMS midi sync, inform interp of our byte-pending flag			THEN CALL interp_init_oms_midi_sync(addr(ANY.OMS.MIDI.SYNC.BYTES));						CALL RESYNC.TIME.BASE;			CALL DISPLAY.SEQUENCER.STATUS;			CALL CLEAR.PARAMETERS;			/*	CLEAR OTHER PARAMETER BUTTONS FOR CHANGING SYNC DELAY	*/			IF EXT.CLOCK.MODE=2 THEN DO;	/*	DISPLAY DELAY	*/				ACTIVE.PARMS(0)=1;			/*	SET UP FOR CHANGE OF SYNC DELAY	*/				ACTIVE.PARMS(1)=(SDELAY.L-PAR.L)+SHL(SDELAY.L-PAR.L, 8);	/*	STORE ON STACK	*/				CALL DISPLAY.PAR;				/*	CAUSES DISPLAY OF SDELAY ON EXT.CLK BUTTON PRESS	*/			END;			IF NEW.PAN														/*	ONLY FOR NEW KBD		*/			THEN CALL DISPLAY.EXT.SYNC.MODE(EXT.CLOCK.MODE);	/*	GIVE WINDOW DISPLAY	*/		end;	end;end SET.SYSTEM.SYNCLAV.SYNC.MODE;/*	set.synclav.sync.mode: pass a mode variable which came	*//*	from fetch.switch														*/SET.SYNCLAV.SYNC.MODE: proc (mode) PUBLIC SWAPABLE;	dcl mode	fixed;	if (mode ige 3)		mode = gid(sync.mode.switch0+mode-3);		/*	get code for entry	*/	call SET.SYSTEM.SYNCLAV.SYNC.MODE(mode);end SET.SYNCLAV.SYNC.MODE;GET.SYNCLAV.SYNC.MODE:proc returns (fixed) PUBLIC SWAPABLE;	dcl mode	fixed;	dcl i		fixed;	if (smpte.onoff<>0)	then mode=6;	else if ext.clock.mode=6	then mode=7;	else mode=ext.clock.mode;	if (mode ilt 3)		return mode;			do i=0 to 4;			/*	see which switch pos is this sync mode	*/		if (gid(sync.mode.switch0+i)=mode)		then return i+3;	end;	return 0;				/*	mode mismatch?		*/end GET.SYNCLAV.SYNC.MODE;/*	extracts the fps from S$FMODE	*/GET.FEET.FPS: proc returns(fixed) public swapable;	dcl fps	fixed;	if (S$FMode=0) or (S$FMode=3)	then fps = 0;	else if (S$FMode = 1) or (S$FMode = 4)	then fps = 1;	else if (S$FMode = 2) or (S$FMode = 5)	then fps = 2;	return fps;end GET.FEET.FPS;/*	sets up S$FMODE based on screen information	*//*	if passed a -1 for either field, uses existing state info	*/SET.SYNCLAV.FEET.MODE: proc(width, fps) public swapable;	dcl width	fixed;	/*	these numbers are switch positions (sequence editor)	*/	dcl fps		fixed;	/*	or offsets from a base id (for AEE)	*/	if (width = -1)	/*	find current width state	*/	then width = (S$Fmode>2);	if (fps = -1)	then fps = get.feet.fps;	if (width = 0)				/*	35mm			*/	then S$FMode = fps;		/*	0-35mm, 30fps; 1-35mm, 25fps; 2-35mm, 24fps	*/	else S$FMode = fps+3;	/*	3-16mm, 30fps; 4-16mm, 25fps; 4-16mm, 24fps	*/	write(mam) = BAS.PTR;	write(mal) = SEQ.FMODE;	write(md ) = S$Fmode;	/*	Create a system event whenever the Footage mode	*/	/*	changes:														*/	new.seq.info = new.seq.info \ 8;		// update VK window if click rate in film frames per beat is being displayed	if ((upper.disp = (click.l-par.l)) && (click.disp.mode == 2)) display.click.rate(SAMP.CLICK.RATE);end SET.SYNCLAV.FEET.MODE;/*	sets synclavier footage offset to passed footage time	*/SET.SYNCLAV.FEET.OFFSET: proc (foot.time) public swapable;	dcl foot.time	fixed array;	dcl feet	lit 'foot.time(0)';	dcl fram	lit 'foot.time(1)';	dcl frac	lit 'foot.time(2)';	write(mam) = BAS.PTR;	write(mal) = SEQ.FOFFSET;	write(mdi) = feet;	write(mdi) = fram;	write(mdi) = frac;	/*	Create a system event whenever the Footage mode	*/	/*	changes:														*/	new.seq.info = new.seq.info \ 8;end SET.SYNCLAV.FEET.OFFSET;/*	Synclavier Parameter Parsing Routine used by TDS and Patch screens	*/PARSE.SYNCLAVIER.PARM: proc(frame,parm#)	fixed public swapable;	dcl frame	fixed;	/*	frame number -- used to parse timbre frame parameters	*/	dcl parm#	fixed;	/*	parameter number -- used to select type of number		*/	dcl sum		fixed;	tok.ptr=0;	if (frame=0) or (parm#>=12) then do;	/*	if not a timbre frame or a timbre frame harmonic	*/		if parm#=P.RATIO then do;				/*	need to handle FM RATIO in special way	*/			if byte(token,0)=asc.min			/*	look for minus as first char				*/			then sum=CONV.STR.TO.FIXED(token,1,1);	/*	negative FM Ratio only has 1 DP	*/			else sum=CONV.STR.TO.FIXED(token,3,1);	/*	positive FM Ratio has 3 DP			*/		end;		else do;			if par.limits(parm#)<0 then sum=1;			else								 sum=0;			sum=CONV.STR.TO.FIXED(token,par.points(parm#),sum);		end;		/*	handle two more special case parameters	*/		if (parm#=P.EATTACK) or (parm#=P.IATTACK) then do;	/*	need to rescale VOLUME and HARMONIC ATTACK times	*/			load 0; write(4)=sum; div 36864;			sum=res; if read(4)<>0 then sum=sum+1;	/*	round up since display truncates		*/		end;		else if parm#=P.VIBWAVE then sum=sum-1;	/*	need to subtract 1 from VIBRATO WAVE numbers	*/		/*	limit value returned by CONV.STR.TO.FIXED to allowed range for this parameter	*/		if sum<0 then do;	/*	negative or large positive	*/			if ((par.limits(parm#)<0) and (sum<par.limits(parm#)))			or ((par.limits(parm#)>0) and (sum IGT par.limits(parm#)))			then sum=par.limits(parm#);		end;		else if sum>abs(par.limits(parm#)) then sum=abs(par.limits(parm#));	end;	/*	of if not a timbre frame or a timbre frame harmonic	*/	else do;		/*	check synclavier parameter for timbre frame		*/		if e.seg.limits(parm#)<0 then	sum=1;		else									sum=0;		sum=CONV.STR.TO.FIXED(token,e.seg.points(parm#),sum);		/*	limit value returned by CONV.STR.TO.FIXED to allowed range for this parameter	*/		if sum<0 then do;	/*	negative or large positive	*/			if ((e.seg.limits(parm#)<0) and (sum<e.seg.limits(parm#)))			or ((e.seg.limits(parm#)>0) and (sum IGT e.seg.limits(parm#)))			then sum=e.seg.limits(parm#);		end;		else if sum>abs(e.seg.limits(parm#)) then sum=abs(e.seg.limits(parm#));	end;	return sum;end PARSE.SYNCLAVIER.PARM;/*	Take System Real Time is called to take a sequence time		*//*	from a take button.  Depending on the state of SMPTE, it		*//*	takes either the current sequencer time, or the most			*//*	recent in-coming smpte time (This is how we take a VITC		*//*	still frame time).														*/TAKE.SYSTEM.REAL.TIME: proc (time) PUBLIC swapable;	dcl time		array;	dcl tbuf(4)	fixed;	if (SMPTE.ONOFF	 = 0)		/*	if SMPTE is not being used		*/	or (TIME.BASE.MODE = 4)		/*	or we are locked to smpte		*/	or ((cur.hrs\cur.min\		/*	or we are using old SMPTE		*/		  cur.sec\cur.fra) = 0)	/*	firmware (reads all zeroes)	*/	then do;							/*	then use sequence time			*/		disable;			time(0) = Play.Time.Msb;			time(1) = Play.Time.Lsb;		enable;	end;	else do;							/*	else use most recent smpte	*/		tbuf(0) = cur.hrs;		/*	get most recently scanned	*/		tbuf(1) = cur.min;		/*	smtpe time						*/		tbuf(2) = cur.sec;		tbuf(3) = cur.fra;		tbuf(4) = 0;		call SMPTE.TO.MSEC(tbuf, CF#TIME, SAMP.SPEED,								 SM.MODE, loc(addr(sm.hrs)), time);	end;end TAKE.SYSTEM.REAL.TIME;/*	Take System Sequence time returns the value mapped to a	*//*	sequencer time:														*/TAKE.SYSTEM.SEQUENCE.TIME: proc (time) PUBLIC swapable;	dcl time		array;	call TAKE.SYSTEM.REAL.TIME(time);	if  (tempo.map.ptr <> 0)	/*	get corresponding sequence time	*/	and (time(0)		 >= 0)	/*	only valid for positive numbers	*/	then call Map.Real.Time.To.Sequence.Time(time, time);end TAKE.SYSTEM.SEQUENCE.TIME;TAKE.SYSTEM.SMPTE.TIME: proc (time) PUBLIC swapable;	dcl time	array;	time(0) = cur.hrs;	/*	set most recently scanned	*/	time(1) = cur.min;	/*	smpte time into offset		*/	time(2) = cur.sec;	/*	field always					*/	time(3) = cur.fra;	time(4) = 0;end TAKE.SYSTEM.SMPTE.TIME;end linkmod;