/* MOUSRSOU  $TITLE  MOUSE REAL TIME MODULE INSERT   03/31/88 - TSS - Modify routines to support MAC II mouse via Termulator*/MODULE MOUSRMOD;INSERT ':SYNLITS:COMLITS';   /* ALL MODULES MUST INSERT COMLITS    */INSERT ':SYNLITS:GLOBLITS';  /* PRACTICALLY ALL WILL WANT GLOBLITS */INSERT ':SYNAUXS:MOUSELIT';INSERT ':SYNMODS:GLOBDCL';INSERT ':SYNMODS:TTYDCL';begin;	DCL MOUSE.PORT.IS.D50           FIXED PUBLIC;  /* 1 => D50 (MAC II), 0 => D44 (LOGITECH) */end;DCL MOUSE.READY                     FIXED PUBLIC;  /* 1 => MOUSE USABLE, 0 => NO MOUSE RUNNING YET */DCL MOUSE.STATUS.REQUEST            FIXED PUBLIC;  /* SET TO 1 TO REQUEST NEW STATUS BYTE FROM MOUSE */DCL MOUSE.X                         FIXED PUBLIC;  /* MOUSE X POSITION; RANGE SET BY MOUSE.X.MIN,MOUSE.X.MAX */DCL MOUSE.Y                         FIXED PUBLIC;  /* MOUSE Y POSITION; RANGE SET BY MOUSE.Y.MIN, MOUSE.Y.MAX */DCL MOUSE.REAL.MILLISECONDS         FIXED PUBLIC;  /* TIME OF X/Y POSITION MEASUREMENT */DCL MOUSE.DX                        FIXED PUBLIC;  /* DELTA X */DCL MOUSE.DY                        FIXED PUBLIC;  /* DELTA Y */DCL (MOUSE.X.MIN,MOUSE.X.MAX)       FIXED PUBLIC;  /* SET BY USER; DEFINE RANGE FOR MOUSE.X */DCL (MOUSE.Y.MIN,MOUSE.Y.MAX)       FIXED PUBLIC;  /* SET BY USER; DEFINE RANGE OF MOUSE.Y */DCL MOUSE.STATUS                    FIXED PUBLIC;/* INTERNAL TO MOUSE ROUTINES */DCL MOUSE.COMMAND         FIXED PUBLIC;  /* LAST COMMAND SENT TO MOUSE; SHOULD BE SET IMMEDIATELY AFTER SENDING ANY COMMND TO MOUSE *//*                                          NOTE: MOUSE.COMMAND LITERALS ARE DEFINED IN 040-GLIT */DCL MOUSE.BUFFER (8)      FIXED PUBLIC;  /* BUFFER TO HOLD INCOMING MOUSE DATA */DCL MOUSE.XMIT.DONE       FIXED PUBLIC;  /* FLAG - INPUT FROM MOUSE RECEIVED *//* VARIABLES USED FOR MOUSE(n) FUNCTION */DCL M$PRESSES             FIXED PUBLIC;  /* ACCUMULATED BUTTON PRESSES */DCL M$RELEASES            FIXED PUBLIC;  /* ACCUMULATED BUTTON RELEASES */DCL M$BS                  FIXED PUBLIC;  /* BUTTONS STATUS     */DCL M$PT (2)              FIXED PUBLIC;  /* MOUSE PRESS TIME   */DCL M$RT (2)              FIXED PUBLIC;  /* MOUSE RELEASE TIME */DCL M$PX (2)              FIXED PUBLIC;  /* X POSITION AT MOUSE PRESS (ALL 3 BUTTONS) */DCL M$PY (2)              FIXED PUBLIC;  /* Y POSITION AT MOUSE PRESS */DCL M$RX (2)              FIXED PUBLIC;  /* X POSITION AT MOUSE RELEASE */DCL M$RY (2)              FIXED PUBLIC;  /* Y POSITION AT MOUSE RELEASE *//* MOUSE.LOOKUP MAPS A 3-BIT BUTTON WORD (0-7) TO A BIT # (0-2) *//* THAT REFLECTS WHICH BUTTON HAS CHANGED                       */DCL MOUSE.LOOKUP  DATA PUBLIC (0,0,1,0,2,0,1,0);MOUSE.SCAN.AND.POLL: PROC PUBLIC;              /* CALLED EVERY 20 MSEC */   DCL M$POSITION.CHAR     LIT '"120"';   DCL M$STATUS.CHAR       LIT '"163"';   DCL WASTE                 FIXED;   DCL (BUTTONS,BUTTON.MASK) FIXED STATIC;   DCL FORMAT                FIXED;   DCL K                     FIXED;   DCL MOUSE.PRESSES         FIXED STATIC;  /* 1-PRESSED  0-NOT PRESSED */   DCL MOUSE.RELEASES        FIXED STATIC;  /* 1-RELEASED 0-NOT RELEASED */   IF MOUSE.READY = 0 THEN RETURN; /* DON'T POLL IF MOUSE IS NOT UP AND RUNNING YET */   IF MOUSE.XMIT.DONE THEN DO;     /* MOUSE.BUFFER NOW CONTAINS NEW INFO */      IF (MOUSE.COMMAND = M$POSITION) /* WE POLLED LOGITECH FOR POSITION INFO */      OR (MOUSE.PORT.IS.D50)          /* WE HAVE POSITION INFO FROM TERMULATOR */      THEN DO;         MOUSE.REAL.MILLISECONDS = REAL.MILLISECONDS;         IF MOUSE.PORT.IS.D50 THEN DO;       /* GET POSITION INFO FROM BUFFER */            BUTTONS = MOUSE.BUFFER(0) & 7;   /* SNAPSHOT OF BUTTONS */            FORMAT=(MOUSE.BUFFER(0) & 8);    /* BIT WILL BE SET IF RELATIVE FORMAT, CLEAR IF ABSOLUTE FORMAT */            K = SHL(MOUSE.BUFFER(1)&"177",7) | (MOUSE.BUFFER(2)&"177"); /* X POSITION */            IF FORMAT=0 THEN DO;             /* ABSOLUTE FORMAT */               MOUSE.DX = K - MOUSE.X;       /* COMPUTE X DELTA SINCE LAST SCAN */               MOUSE.X  = K;            END;            ELSE DO;                         /* RELATIVE FORMAT */               IF (K&"020000")<>0 THEN K=K | "140000"; /* PERFORM SIGN EXTEND */               MOUSE.DX = K;               MOUSE.X  = MOUSE.X+K;         /* NEW COORDINATE BASED ON DELTA */            END;            K = SHL(MOUSE.BUFFER(3)&"177",7) | (MOUSE.BUFFER(4)&"177"); /* Y POSITION */            IF FORMAT=0 THEN DO;             /* ABSOLUTE FORMAT */               MOUSE.DY = K - MOUSE.Y;       /* COMPUTE Y DELTA SINCE LAST SCAN */               MOUSE.Y  = K;            END;            ELSE DO;                         /* RELATIVE FORMAT */               IF (K&"020000")<>0 THEN K=K | "140000"; /* PERFORM SIGN EXTEND */               MOUSE.DY = K;               MOUSE.Y = MOUSE.Y + K;        /* NEW COORDINATE BASED ON DELTA */            END;         END;         ELSE DO;            BUTTONS = MOUSE.BUFFER(0) & 7;   /* SNAPSHOT OF BUTTONS */            IF (MOUSE.BUFFER(1) > 25) THEN MOUSE.BUFFER(1)=SHL(MOUSE.BUFFER(1),1);  /* DYNAMIC SCALING */            IF (MOUSE.BUFFER(2) > 25) THEN MOUSE.BUFFER(2)=SHL(MOUSE.BUFFER(2),1);            IF (MOUSE.BUFFER(0) & 16) = 0 THEN DO;               MOUSE.X = MOUSE.X - MOUSE.BUFFER(1);               MOUSE.DX = - MOUSE.BUFFER(1);            END;            ELSE DO;               MOUSE.X = MOUSE.X + MOUSE.BUFFER(1);               MOUSE.DX = MOUSE.BUFFER(1);            END;            IF (MOUSE.BUFFER(0) & 8)  = 0 THEN DO;               MOUSE.Y = MOUSE.Y - MOUSE.BUFFER(2);               MOUSE.DY = - MOUSE.BUFFER(2);            END;            ELSE DO;               MOUSE.Y = MOUSE.Y + MOUSE.BUFFER(2);               MOUSE.DY = MOUSE.BUFFER(2);            END;         END;         IF      MOUSE.X > MOUSE.X.MAX THEN MOUSE.X = MOUSE.X.MAX;         ELSE IF MOUSE.X < MOUSE.X.MIN THEN MOUSE.X = MOUSE.X.MIN;         IF      MOUSE.Y > MOUSE.Y.MAX THEN MOUSE.Y = MOUSE.Y.MAX;         ELSE IF MOUSE.Y < MOUSE.Y.MIN THEN MOUSE.Y = MOUSE.Y.MIN;         /**** CREATE VALUES FOR MOUSE FUNCTION *****/         IF BUTTONS <> BUTTON.MASK THEN DO;             /* CHANGE DETECTED */            MOUSE.PRESSES  = (BUTTONS & NOT(BUTTON.MASK)); /* SNAPSHOT OF BUTTONS PRESSED */            MOUSE.RELEASES = (NOT(BUTTONS) & BUTTON.MASK); /* SNAPSHOT OF BUTTONS RELEASED */            DO WHILE MOUSE.PRESSES <> 0;                  /* SOME PRESSES       */               K=MOUSE.LOOKUP(MOUSE.PRESSES);             /* GET WHICH ONE TO RETURN */               IF (M$BS&BITS(K))=0 THEN DO;               /* IF UPPER LEVEL CODE IS THROUGH WITH PRIOR RELEASE,  THEN PROCESS NEW BUTTON PRESS.  COULD MEAN WE MISSED A WHOLE PRESS/RELEASE CYCLE */                  M$PRESSES  = M$PRESSES  \ BITS(K);      /* ACCUMULATE PRESSES */                  M$RELEASES = M$RELEASES & NOT(BITS(K)); /* REMOVE POSSIBLE RELEASE THAT WAS NEVER SEEN FOR PRESS THAT WAS NEVER SEEN */                  BUTTON.MASK = BUTTON.MASK XOR BITS(K);  /* ACKNOWLEDGE        */                  M$PT(K) = MOUSE.REAL.MILLISECONDS;      /* SAVE TIME OF PRESS */                  M$PX(K) = MOUSE.X;                      /* SAVE X POSITION AT PRESS */                  M$PY(K) = MOUSE.Y;                      /* SAVE Y POSITION AT PRESS */               END;               MOUSE.PRESSES = MOUSE.PRESSES XOR BITS(K);             END;            DO WHILE MOUSE.RELEASES <> 0;             /* SOME RELEASES           */               K=MOUSE.LOOKUP(MOUSE.RELEASES);        /* GET WHICH ONE TO RETURN */               M$RELEASES  = M$RELEASES  \ BITS(K);   /* ACCUMULATE RELEASES     */               BUTTON.MASK = BUTTON.MASK XOR BITS(K); /* ACKNOWLEDGE             */               MOUSE.RELEASES = MOUSE.RELEASES XOR BITS(K);               M$RT(K) = MOUSE.REAL.MILLISECONDS;     /* SAVE TIME OF RELEASE */               M$RX(K) = MOUSE.X;                     /* SAVE X POSITION AT RELEASE */               M$RY(K) = MOUSE.Y;                     /* SAVE Y POSITION AT RELEASE */            END;         END;      END;      ELSE IF MOUSE.COMMAND = M$STATUS THEN DO;         MOUSE.STATUS = MOUSE.BUFFER(0);      END;      MOUSE.XMIT.DONE = 0;               /* RESET FOR NEXT TIME AROUND */   END;   ELSE IF NOT MOUSE.PORT.IS.D50 THEN DO; /* IF WE GET HERE IT MEANS A */                                          /* TIMEOUT HAS OCCURRED. OR COULD BE FIRST TIME THROUGH */      IF (READ(D45) & 2) <> 0 THEN        /* CLEAR D44 INPUT BUFFER */         WASTE = READ(D44);               /* TRY TO CLEAR THINGS UP */      WRITE(D44) = M$POSITION.CHAR;       /* BY CLEARING THE D44 AND RESTARTING */      MOUSE.COMMAND = M$POSITION;         /* THE POLLING PROCESS */      RETURN;   END;                                                                    IF NOT MOUSE.PORT.IS.D50 THEN DO;        /* SEND NEXT POLL CMD TO LOGITECH MOUSE */      IF MOUSE.STATUS.REQUEST <> 0 THEN DO; /* STATUS REQUEST SEND */         WRITE(D44) = M$STATUS.CHAR;         MOUSE.COMMAND = M$STATUS;         MOUSE.STATUS.REQUEST = 0;      END;      ELSE DO;         WRITE(D44) = M$POSITION.CHAR;      /* DEFAULT: SEND A POSITION */         MOUSE.COMMAND=M$POSITION;          /* COMMAND TO KEEP MOUSE CURRENT */      END;   END;END MOUSE.SCAN.AND.POLL;END MOUSRMOD;