/* MOUSSSOU   $TITLE  Synclavier mouse cursor routine with stm sound playback   Modified:   11/21/88 - CJ - FIXED RELEASE O AUDIO SCRUBB PROBLEM   05/23/88 - TSS - Activated MOUSE.CURSOR.UPDATE for MAC II mouse switch updates   03/31/88 - TSS - Modify routines to support MAC II mouse via Termulator   12/17/87 - MWH - Merge poly updates with N-Final plus AEE sources   11/02/87 - MWH - Merge in Cameron's newest code   07/10/87 - MWH - Don't need to insert pmemmod anymore   */MODULE MOUSSMOD;insert ':synlits:COMLITS';     /* get configuration and pdl size */insert ':synlits:ASCIILIT';insert ':synlits:GLOBLITS';INSERT ':SYNAUXS:MOUSELIT';INSERT ':SYNMODS:GLOBDCL';INSERT ':SYNMODS:TTYDCL';INSERT ':SYNMODS:PLOTDCL';INSERT ':SYNMODS:MOUSRDCL';INSERT ':SYNMODS:MOUSFDCL';BEGIN;DCL OLD.MOUSE.X FIXED;DCL OLD.MOUSE.Y FIXED;DCL TMP.MOUSE.X FIXED;DCL TMP.MOUSE.Y FIXED;MOUSE.CURSOR.SUBROUTINE: PROC (OLD.CURSOR.TYPE) SWAPABLE;   DCL OLD.CURSOR.TYPE FIXED;   if inc.mouse=0 then return;   /* THE DRAWING ORDER OF THE CROSSHAIRS IS IMPORTANT:      . 1) ERASE OLD VERTICAL      . 2) ERASE OLD HORIZONTAL      . 3) DRAW  NEW HORIZONTAL      . 4) DRAW  NEW VERTICAL      .      . ERASE THE OLD CROSSHAIR IF IT IS ON THE SCREEN.  THEN      . DRAW THE NEW CROSSHAIR AND SAVE ITS POSITION SO THAT WE      . CAN ERASE IT THE NEXT TIME THROUGH.    */   ERASE.CROSSHAIR: PROC;      CALL CONNECT(OLD.MOUSE.X - M$CURSOR.SIZE,OLD.MOUSE.Y,OLD.MOUSE.X + M$CURSOR.SIZE,OLD.MOUSE.Y);      CALL CONNECT(OLD.MOUSE.X,OLD.MOUSE.Y + M$CURSOR.SIZE,OLD.MOUSE.X,OLD.MOUSE.Y - M$CURSOR.SIZE);      CROSSHAIR.ON = 0;   END;   DRAW.CROSSHAIR: PROC;      CALL CONNECT(TMP.MOUSE.X,TMP.MOUSE.Y + M$CURSOR.SIZE,TMP.MOUSE.X,TMP.MOUSE.Y - M$CURSOR.SIZE);      CALL CONNECT(TMP.MOUSE.X - M$CURSOR.SIZE,TMP.MOUSE.Y,TMP.MOUSE.X + M$CURSOR.SIZE,TMP.MOUSE.Y);      CROSSHAIR.ON = 1;   END;   DCL OK.TO.REFRESH FIXED;   IF VT100 THEN DO;                 /* CHECK FOR TERMINAL TYPE */      OK.TO.REFRESH = 0;      IF OLD.CURSOR.TYPE = 1 THEN OK.TO.REFRESH = 1;      IF OLD.CURSOR.TYPE <> MOUSE.CURSOR.TYPE THEN OK.TO.REFRESH = 1;      IF (OLD.MOUSE.X <> TMP.MOUSE.X)       OR (OLD.MOUSE.Y <> TMP.MOUSE.Y)       OR (MOUSE.REPLOT <> 0)      THEN OK.TO.REFRESH = 1;      IF OK.TO.REFRESH THEN DO;         CALL PUSH.GRAPHICS.ATTRIBUTES;         CALL VIEWPORT(0,SCREEN.WIDTH,0,SCREEN.HEIGHT);            CALL WINDOW  (0,SCREEN.WIDTH,0,SCREEN.HEIGHT);         /* HANDLE PERICOM BUG WHERE IF YOU ARE IN POINT MODE */         /* MUST BE IN TRANSPARENT MODE FOR VECTOR MODE TO HAPPEN */         /* BUT HAVE TO DO ALPHA MODE FIRST */         IF (MG600<>0) AND (#MODE=#POINT) THEN DO;            ALPHA_MODE;            TRANSPARENT_MODE;         END;         IF (#MODE <> #VECTOR) THEN VECTOR_MODE;          IF (#DATA.LEVEL <> 2) THEN CALL DATA_LEVEL(2);   /* WE ARE IN DESIRED MODES */         IF #BLOCKMODE<>0         THEN CALL BLOCKMODE_OFF;         IF CROSSHAIR.ON         THEN CALL ERASE.CROSSHAIR;        /* FIRST ERASE OLD */         IF MOUSE.CURSOR.ON THEN DO;            IF MOUSE.CURSOR.TYPE = 1            THEN CALL DRAW.CROSSHAIR;         END;         CALL POP.GRAPHICS.ATTRIBUTES;      END;   END;   ELSE DO;                            /* MOUSE CONFIGURED BUT */      MOUSE.CURSOR.ON = 0;             /* NO GRAPHICS IN SYSTEM */      RETURN;                          /* DISABLE FURTHER CHECKING */   END;                                /* MOUSE.CURSOR.ON=1 RE-ENABLES */END MOUSE.CURSOR.SUBROUTINE;DCL MOUSE.CURSOR.TIME    FIXED PUBLIC;  /* GLOBAL TIMER FOR USE WITH MOUSE.CURSOR.UPDATE */MOUSE.CURSOR.UPDATE: PROC RETURNS(FIXED) PUBLIC;   /* RETURN 0 MEANS MOUSE NOT UPDATED */   /* RETURN 1 MEANS MOUSE UPDATED     */   DCL OLD.CURSOR.TYPE FIXED STATIC;   DCL CODE            FIXED;   if inc.mouse=0       then return 0;   IF (MOUSE.CURSOR.ON = 0)              /* FIRST DO A QUICK CHECK TO SEE */   AND (CROSSHAIR.ON = 0)                /* IF WE NEED TO DO ANYTHING AT ALL */   THEN RETURN 0;   IF MOUSE.PORT.IS.D50 THEN DO;      IF (MOUSE.CURSOR.TYPE <> OLD.CURSOR.TYPE)      THEN DO;         IF MOUSE.CURSOR.TYPE=0         THEN CALL HIDE.TERMULATOR.CURSOR;         ELSE CALL SHOW.TERMULATOR.CURSOR;         OLD.CURSOR.TYPE=MOUSE.CURSOR.TYPE;         RETURN 1;   /* DON'T DRAW IF USING MAC II MOUSE CURSOR */      END;      RETURN 0;   /* DON'T DRAW IF USING MAC II MOUSE CURSOR */   END;   RECHECK:;   DISABLE;                              /* TAKE A SNAPSHOT OF CURRENT */   TMP.MOUSE.X = MOUSE.X;                /* MOUSE POSITION */   TMP.MOUSE.Y = MOUSE.Y;   ENABLE;   CODE = (TMP.MOUSE.X <> OLD.MOUSE.X) OR (TMP.MOUSE.Y <> OLD.MOUSE.Y);   IF  (MOUSE.REPLOT       <> 0              ) /* IF REPLOT NEEDED */   OR  (MOUSE.CURSOR.TYPE  <> OLD.CURSOR.TYPE) /* OR NEW TYPE      */   OR  ((MOUSE.CURSOR.TYPE <> 0)               /* OR DRAWN         */   AND  (CODE              <> 0))              /*    AND MOVED     */   THEN DO;      IF num.of.d50.out.chars > 10 THEN DO; 	/* WAIT FOR OUTPUT BUFFER TO EMPTY */         CHILL.OUT.AND.RUN.SYN();           	/* TO AVOID LAGGING BEHIND MOUSE   */         GOTO RECHECK;                      	/* MOVEMENTS                       */      END;      CALL MOUSE.CURSOR.SUBROUTINE(OLD.CURSOR.TYPE);      OLD.CURSOR.TYPE = MOUSE.CURSOR.TYPE;      MOUSE.REPLOT    = 0;      CODE            = 1; /* SET CODE ON REPLOT EVEN IF NO MOVEMENT */   END;   /* RETURN 1 IF MOUSE HAS MOVED,  EVEN IF NO CURSOR IS DRAWN */   OLD.MOUSE.X = TMP.MOUSE.X;      /* SAVE NEW CURSOR FOR COMPARISON */   OLD.MOUSE.Y = TMP.MOUSE.Y;      /* ON NEXT ITERATION */   RETURN CODE;                    /* NONZERO IF MOVEMENT OR REPLOT */END MOUSE.CURSOR.UPDATE;  /* procedure */END;end moussmod;