/* :SYNSOU:GIDMOD:GIDSOU  $TITLE  Some Handy External Memory Storage Routines *//*Modified:2001/09/08 - TY  - Added GID32() and PID32()*/Module GIDMOD;insert ':synlits:comlits';		/* get configuration and pdl size */insert ':synlits:globlits';insert ':synauxs:gidlits';		/* literals for this module */insert ':synmods:globdcl';         insert ':synmods:xmemdcl';dcl PID.GID.Base fixed;			/* Base Address of PID/GID area */PID: proc (ptr, val) public;	/* write word of info to PID/GID area */	dcl (ptr,val) fixed;	if ptr ige PID.GID.Len then return;		/* protect somewhat against bugs */	write(mam)=PID.GID.Base+shr(ptr,8);	write(mal)=ptr;	write(mdi)=val;	//	note: incrementend PID;GID: proc (ptr) fixed public;	/* get word of info from PID/GID area */	dcl ptr fixed;	if ptr ige PID.GID.Len then return 0;	/* protect somewhat against bugs */	write(mam)=PID.GID.Base+shr(ptr,8);	write(mal)=ptr;	return read(md);	//	note: no incrementend GID;PID32: proc (ptr, val32) public;	/* write 2 consecutive words of info to PID/GID area */	dcl ptr		fixed;	dcl val32	fixed array;	if ptr ige PID.GID.Len then return;		/* protect somewhat against bugs */	write(mam) = PID.GID.Base+shr(ptr, 8);	write(mal) = ptr;	write(mdi) = val32(0);	write(mdi) = val32(1);	//	note: incrementend PID32;GID32: proc (ptr, val32) public;	/* get 2 consecutive words of info from PID/GID area */	dcl ptr		fixed;	dcl val32	fixed array;	if ptr ige PID.GID.Len then return;		/* protect somewhat against bugs */	write(mam) = PID.GID.Base + shr(ptr, 8);	write(mal) = ptr;	val32(0) = read(mdi);	val32(1) = read(mdi);	//	note: incrementend GID32;Init.PID.GID.Area: proc public swapable;	/* zeros out dynamic area below static area */	dcl i fixed;	call PID(0,0);	do i=1 to (PID.GID.StaticStart-1);		/* don't zero out static area */		write(mdi)=0;	end;end Init.PID.GID.Area;Init.GIDMOD: proc swapable; /* allocates PID/GID area at startup */	PID.GID.Base=ALLOC.EXAMOUNT(shr(PID.GID.Len+255,8));	/* ALLOC.EXAMOUNT zeros out sectors when they are allocated */end Init.GIDMOD;call Init.GIDMOD;		/* initialize area */end GIDMOD;