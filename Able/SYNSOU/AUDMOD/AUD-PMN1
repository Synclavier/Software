/*	:SYNSOU:AUDMOD:AUD-PMN1  $TITLE  Panel Menu Routines (Part 2)	*//*Modified:1999/03/05 - TY  - Modified READ.DEFAULTS, WRITE.DEFAULTS and UPDATE.AEE.DEFAULTS to handle 4.20 user defaults1991/08/14 - cj  - Added UDIO/DDSYN stuff1989/05/02 - TSS - Merged changes for Optical disk to DTD transfer project1989/04/05 - JSS - Added & modified UDDT Format and Sync switches & labels1989/03/19 - TSS - Added defaults for MIDI Input Chan and Echo Modes1988/12/20 - cj  - different use of DTD.XFER.MODE for multi-track DDT						 DDT Format Select Dialog1988/11/16 - TSS - Moved defaults stuff into .SDEF-7 file1988/07/28 - SGS - Created. (split from AUD-PMEN)1988/07/27 - SGS - Added default buttons.1988/06/15 - CJ  - added dig xfer on/off buttons.  fixed pmgr bug.1988/05/25 - MWH - Make SMPTE true 24 hours; add take button for offset1988/05/20 - TSS - Added code to support Mac II1988/05/06 - TSS - Moved display notices & corner object to 24th line for termulator*/insert ':SYNLITS:TIMLITS';insert ':SYNLITS:SYNCLITS';dcl DISPLAY.PARAMETER.BUTTONS proc external;OPEN.LAYOUT.MACRO.DIALOG.PANEL: proc (Mem#)	fixed swapable;	dcl Mem#				fixed;	dcl Message.Label	fixed;	dcl OK.Button		fixed;	dcl Cancel.Button	fixed;	dcl Macro.Name		fixed;	dcl (exit,I)		fixed;	dcl Old.Name (4)	fixed;	dcl Layout (D#MacroSize-1)	fixed;	UPDATE.MACRO.DEF: proc (Mem#, Old.Name, New.Name);		dcl Mem#			fixed;		dcl Old.Name	array;		dcl New.Name	array;		dcl Info (D#MacroSize-1)	fixed;	/*	 0 -  7 words: panel info	*/														/*	 8 - 11 words: XPL name		*/														/*	12 - 43 words: globals		*/		dcl (i,j)		fixed;		dcl Seq.Tracks					fixed EXTERNAL;	/*	access seq panel settings directly...	*/		dcl Display.Note.Contents	fixed EXTERNAL;		dcl Display.Name.Length		fixed EXTERNAL;		if (New.Name(0) > 6)				/*	limit to 6 chars			*/			New.Name(0) = 6;		call GID(AEE.Screen.Layout);	/*	set MAM and MAL ptrs		*/		do i = 0 to D#MacroName-1;		/*	read current panel list	*/			Info(i) = read(mdi);			/*	from ext memory			*/		end;		do i = D#MacroName to D#MacroGlobals-1;	/*	store name	*/			Info(i) = New.Name(i-D#MacroName);		end;		Info(D#MacroSeqTracks	) = Seq.Tracks;		Info(D#MacroSeqContents	) = Display.Note.Contents;		Info(D#MacroSeqLength	) = Display.Name.Length;		call Write.Screen.Layout.Macro.Def(Mem#, Info);	/*	save def for current layout with new name	*/		/*	undraw original label, then draw new button label	*/				// Unhighlight to take care of cocoa drawing issues		if ((Panel.Bits & bits(Mem#+12)) != 0)		   Highlight.Graphics.Button.Table(Panel.Menu.Table,Panel.Bits XOR bits(Mem#+12),2,0);		   		call Deposit.Graphics.Button.Table.Label(Panel.Menu.Table,1,4+Mem#,1,Old.Name,NulStr);		call Deposit.Graphics.Button.Table.Label(Panel.Menu.Table,1,4+Mem#,1,New.Name,NulStr);		if ((Panel.Bits & bits(Mem#+12)) != 0)				   Highlight.Graphics.Button.Table(Panel.Menu.Table,Panel.Bits,2,0);	end UPDATE.MACRO.DEF;	call PUSH.AND.RESET.GET.ENABLE.WORDS;	call Set.Auto.Allocation.Id (Panel.Menu.Alloc+500);	call Set.Default.Action(O#ACT.Middle.Press);	call Set.Default.Attr(0,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);	call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse);	Message.Label = Define.Label (S#AA,2, 0,35,'');	call Set.Object.Mouse.Access(Message.Label,0);	call Set.Object.Erase		 (Message.Label,O#ERAS.Whole.Line);	Macro.Name	  = Define.String(S#AA,2,35,6,0);	call Set.Object.Attr(Macro.Name,0,ATTR#Normal);	OK.Button	  = Define.Label (S#AA,2,61,0,'[STORE]');	Cancel.Button = Define.Label (S#AA,2,70,0,'[CANCEL]');	Disable.Deposits = true;	call Deposit.Label (Message.Label,'Enter Label for User button:');	call Read.Screen.Layout.Macro.Defs(Mem# ,Layout);				/*	get current name		*/	call Copy.String(Loc(Addr(Layout(D#MacroName))), Old.Name);	/*	save original name	*/	call Deposit.String(Macro.Name, Old.Name);						/*	prestuff into object	*/	Disable.Deposits = false;	/*	10 Objects MAX in Dialog Bar for now	*/	call Activate.Object.Range		(Panel.Menu.Alloc+500,Cancel.Button);	call Set.Auto.Arrow.Link.Range(Panel.Menu.Alloc+500,Cancel.Button);	call Select.New.Cur.Obj			(Macro.Name,-1,-1);	call Update.Object.Range		(Panel.Menu.Alloc+500,Cancel.Button);	do while exit = 0;		i = Get.Next.Screen.Event;		if Screen.Event.Group = Panel.Menu.Group then do;			if i = Get.Screen.Event then do;				if Screen.Event.Id = OK.Button then do;					if (Screen.Event.Info = S#MouseSelect)					or (Screen.Event.Info = S#MouseActivate)					or (Screen.Event.Info = S#KeyActivate) then do;						call Fetch.String(Macro.Name,Layout);						call Update.Macro.Def(Mem#,Old.Name,Layout);						exit = 1;					end;				end;				else if (Screen.Event.Id = Cancel.Button) then do;					if (Screen.Event.Info = S#MouseSelect)					or (Screen.Event.Info = S#MouseActivate)					or (Screen.Event.Info = S#KeyActivate)					then exit = -1;				end;				else if (Screen.Event.Id = Macro.Name) then do;					if Screen.Event.Info = S#Deposit then do;						call Fetch.String(Macro.Name,Layout);						call Update.Macro.Def(Mem#,Old.Name,Layout);						exit = 1;					end;				end;				else if (Screen.Event.Info = S#MouseSelect)				or		  (Screen.Event.Info = S#MouseActivate) then do;					call Select.New.Cur.Obj(Cancel.Button,-1,-1);					call Display.Notice(NT#MustRespondToDialog,ATTR#Normal,NulStr,1,0,0);				end;			end;		end;		else do;	/*	Outside Panel Menu group	*/			if  (i = Get.Screen.Event) then do;				if (Screen.Event.Info = S#MouseSelect)				or (Screen.Event.Info = S#MouseActivate) then do;					call Select.New.Cur.Obj(Cancel.Button,-1,-1);					call Display.Notice(NT#MustRespondToDialog,ATTR#Normal,NulStr,2,0,0);				end;			end;		end;	end;	call Erase.Object(Message.Label);	/*	Erases message and whole line	*/	call Undefine.Object.Range(Panel.Menu.Alloc+500,Panel.Menu.Alloc+510);	call Select.New.Cur.Obj(Corner.Label,-1,-1);	call POP.GET.ENABLE.WORDS;	return (exit=1);end OPEN.LAYOUT.MACRO.DIALOG.PANEL;OPEN.SMPTE.OFFSET.DIALOG.PANEL: proc	fixed swapable;	dcl Message.Label	fixed;	dcl Cancel.Button	fixed;	dcl SMPTE.Offset	fixed;	dcl Take.Button	fixed;	dcl Ptr				fixed;	dcl Offset	(4)	fixed;	dcl (exit)			fixed;	dcl (i,j)			fixed;	dcl msec		(1)	fixed;	dcl doff		(1)	fixed;	call PUSH.AND.RESET.GET.ENABLE.WORDS;	call Set.Auto.Allocation.Id (Panel.Menu.Alloc+500);	call Set.Default.Action(0);	call Set.Default.Attr(0,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);	call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse);	Message.Label = Define.Label (S#AA,2, 0,35,'Enter new Sequencer SMPTE Offset:');	call Set.Object.Erase(Message.Label,O#ERAS.Whole.Line);	call Set.Default.Action(O#ACT.Left.Press|O#ACT.Middle.Press|O#ACT.Right.Press);	SMPTE.Offset = Define.32Bit.Msec(S#AA,2,39,14,O#MSEC.SMPTE\O#MSEC.Allow.Minus\O#MSEC.RealTime,cf#dur,cf#default,cf#default);	call Set.Default.Action(O#ACT.Middle.Press);	call Load.Take.Icon(Misc.Buf);	Take.Button = Define.Graphics.Icon(S#AA,3600,200,1,Misc.Buf);	Cancel.Button = Define.Label (S#AA,2,72,0,'[ DONE ]');	//	Note: if cf#time were passed to SMPTE.To.Msec() below, 5 words of zero would be needed in place of Zero.Zero	call SMPTE.To.Msec(S$Soffset, cf#dur, S$Speed, S$Smode, Zero.Zero, Msec);	Disable.Deposits=true;	call Deposit.32Bit.Msec(SMPTE.Offset,Zero.Zerotime,Msec);	Disable.Deposits=false;	/*	10 Objects MAX in Dialog Bar for now	*/	call Activate.Object.Range		(Panel.Menu.Alloc+500,Cancel.Button);	call Set.Auto.Arrow.Link.Range(Panel.Menu.Alloc+500,Cancel.Button);	call Select.New.Cur.Obj			(SMPTE.Offset,-1,-1);	call Update.Object.Range		(Panel.Menu.Alloc+500,Cancel.Button);	do while exit = 0;		i = Get.Next.Screen.Event;		if Screen.Event.Group = Panel.Menu.Group then do;			if i = Get.Screen.Event then do;				if (Screen.Event.Id = SMPTE.Offset) then do;					if (Screen.Event.Info = S#Deposit) then do;						call Fetch.32Bit.Msec(SMPTE.Offset,Msec);						/*	subtract out the display offset (if one) to get	*/						/*	smpte time to set											*/						call MSEC.TO.SBITS (Msec, cf#dur, S$Speed, S$Smode, Offset);						write(mam) = BAS.PTR;		/*	look up display offset stored with seq	*/						write(mal) = SEQ.DOFFSET;	/*	get smpte display offset					*/						doff(0) = read(mdi);						doff(1) = read(mdi);						if read(mdi) = 0								/*	if SEQ.DOFFDIS = 0, then display		*/						then call SUB32(offset, doff, offset);	/*	offset is enabled.  subtract it out	*/						call SBITS.TO.SMPTE(offset, S$Smode, offset);						call Set.Synclav.SMPTE.Offset(Offset);	/*	store in sequence	*/						call Sample.Syncl.Smgr.Globals;			/*	get info into smgr immediately		*/						/*	Update screen items here, since we do not leave	*/						/*	this dialog box:											*/						if Sync.Group <> 0						then call Update.Sync.Panel(false);	/*	update sync, click fields, bpm, speed, etc. (but not dialog, if any)	*/						if (Shuttle.Group or Cue.Group) <> 0	/*	if shuttle or cue, re-deposit sync times	*/						then call Display.Cue.And.Shuttle.Displays;						call Set.AEE.Time.Format(AEE.Time.Format);	/*	update all 32-bit variables	*/						call GET_Enable(Get.Mouse.Button);						call Update.Screen;						call GET_Disable(Get.Mouse.Button);					end;				end;				else if (Screen.Event.Id = Take.Button)				AND	  (Screen.Event.Info = S#MouseSelect)				then do;					call TAKE.SYSTEM.SMPTE.TIME(Offset);	/*	get current in-coming smpte time (hours/mins/secs/frames/bits)	*/					call Set.Synclav.SMPTE.Offset(Offset);	/*	store in sequence	*/					call Sample.Syncl.Smgr.Globals;			/*	get info into smgr immediately	*/					/*	Quickly refresh start time display to show correct	*/					/*	value:															*/					//	Note: if cf#time were passed to SMPTE.To.Msec() below, 5 words of zero would be needed in place of Zero.Zero					call SMPTE.To.Msec(S$Soffset, cf#dur, S$Speed, S$Smode, Zero.Zero, Msec);					disable.deposits = 1;					call Deposit.32Bit.Msec(SMPTE.Offset, Zero.Zerotime, Msec);					disable.deposits = 0;					call Update.Object(SMPTE.Offset);	/*	Draw promptly	*/					/*	Update screen items here, since we do not leave	*/					/*	this dialog box:											*/					if Sync.Group <> 0					then call Update.Sync.Panel(false);	/*	update sync, click fields, bpm, speed, etc. (but not dialog, if any)	*/					if (Shuttle.Group or Cue.Group) <> 0			/*	if shuttle or cue, re-deposit sync times	*/					then call Display.Cue.And.Shuttle.Displays;					call Set.AEE.Time.Format(AEE.Time.Format);	/*	update all 32-bit variables	*/					call GET_Enable(Get.Mouse.Button);					call Update.Screen;					call GET_Disable(Get.Mouse.Button);				end;				else if (Screen.Event.Id = Cancel.Button) then do;					if (Screen.Event.Info = S#MouseSelect)					or (Screen.Event.Info = S#MouseActivate)					or (Screen.Event.Info = S#KeyActivate)					then exit = -1;				end;				else if (Screen.Event.Info = S#MouseSelect)				or		  (Screen.Event.Info = S#MouseActivate) then do;					call Select.New.Cur.Obj(Cancel.Button,-1,-1);					call Display.Notice(NT#MustRespondToDialog,ATTR#Normal,NulStr,1,0,0);				end;			end;		end;		else do;										/*	Outside Panel Menu group	*/			if  (i = Get.Screen.Event) then do;				if (Screen.Event.Info = S#MouseSelect)				or (Screen.Event.Info = S#MouseActivate) then do;					call Select.New.Cur.Obj(Cancel.Button,-1,-1);					call Display.Notice(NT#MustRespondToDialog,ATTR#Normal,NulStr,2,0,0);				end;			end;		end;	end;	call Erase.Object(Message.Label);		/*	Erases message and whole line of text			*/	if Locate.Object(Take.Button) then do;	/*	Erase take button (filled graphics object)	*/		ptr = Object.Ptr;		call Area.Fill(Read.Object(ptr+O#ULX),							Read.Object(ptr+O#ULY),							Read.Object(ptr+O#LRX),							Read.Object(ptr+O#LRY),1,0);	end;	call Undefine.Object.Range(Panel.Menu.Alloc+500,Panel.Menu.Alloc+510);	call Select.New.Cur.Obj(Corner.Label,-1,-1);	call POP.GET.ENABLE.WORDS;	return (exit=1);end OPEN.SMPTE.OFFSET.DIALOG.PANEL;UPDATE.AEE.DEFAULTS: proc (SelectBits) public swapable;	dcl SelectBits	fixed;	/*	default settings to update	*/	/*	Refresh AEE panels, as necessary	*/	if (SelectBits&(D#In|D#Out|D#Samp))<>0 then do;		Display.New.Project.Info = (-1);	/*	will update proj mgr panel, if there	*/	end;	if ((SelectBits&(D#SIn|D#SDisp|D#SOffs|D#SDispOffs|D#FDisp|D#FOffs|D#DForm|D#Misc))<>0)	{		if (SelectBits&D#DForm)<>0 then call Set.AEE.Time.Format(AEE.Time.Format);		call Sample.Syncl.Smgr.Globals;	/*	sets S$SMode, S$SOffs, etc.	*/		/*	update sync panel (and dialog, if any)	*/		if Sync.Group<>0 then call Update.Sync.Panel(true);		/*	create an ABLE screen event when we are changing the AEE	*/		/*	time format.  This does not need to go out to the			*/		/*	other network devices, however:									*/		new.ABLE.seq.info = new.ABLE.seq.info \ 8;	}	//	if (SelectBits&D#RecM)<>0 then do;	//		/*	if Record.Group<>0 then call Update.Record.Panel;	*/	/*	done by Update.A.E.E below	*/	//	end;	call Update.Audio.Event.Editor;end UPDATE.AEE.DEFAULTS;READ.DEFAULTS: proc (SelectBits,Dev,Sec)	fixed public swapable;	dcl SelectBits			fixed;	/*	bits designating which settings to read	*/											/*	defined in SYNAUXS:AUDAUXS:ADEFLITS	*/	dcl (Dev,Sec)			fixed;	/*	defaults sector	*/	dcl i						fixed;	dcl exit					fixed;	/*	-1=failure; 1=success;	*/	dcl Default.Buf(255)	fixed;	dcl map.mm				data (0,0,0,1,1);	dcl map.rate			data (0,1,2,0,1);	dcl Initial			lit 'AEE#DefsInit';		/*	flag for initializing defs			*/	dcl InRout			lit 'AEE#InRout';			/*	Input routings (16 tracks)			*/	dcl OutRout			lit 'AEE#OutRout';		/*	Out & DDT routings (16 tracks)	*/	dcl SampleRate		lit 'AEE#SampRate';		/*	DTD sample rate						*/	dcl SMPTEIn			lit 'AEE#SMPTEIn';		/*	SMPTE in type and rate				*/	dcl SMPTEDisp		lit 'AEE#SMPTEDisp';		/*	SMPTE display type and rate		*/	dcl SMPTEOffs		lit 'AEE#SMPTEOffs';		/*	SMPTE offset							*/	dcl SMPTEDspOffs	lit 'AEE#SMPTEDspOffs';	/*	SMPTE display offset					*/	dcl FootDisp		lit 'AEE#FootDisp';		/*	Footage disp type and rate			*/	dcl FootOffs		lit 'AEE#FootOffs';		/*	Footage offset							*/	dcl RecModes		lit 'AEE#RecordMode';	/*	Record modes							*/	dcl DispForm		lit 'AEE#DispFormat';	/*	Time display format					*/	exit = 1;	/*	assume we will succeed	*/	if LOD.Running = 0 then	/*	can't set DTD defaults if DTD not running	*/		SelectBits = SelectBits|(not(D#In|D#Out|D#Samp));	if SelectBits=0 then return (-1);	call ReadData(Dev,Sec,Default.Buf,256);	/*	read in first defaults sector	*/	if Default.Buf(Initial)<>1 then do;			/*	initialize defaults	*/		if LOD.Running <> 0 then do;			do i = 0 to DTD.MAX.TRACKS-1;				Default.Buf(InRout+i)  = shl(  0,8)\(i+1);	/*	set input  routings to STM 1A	*/				Default.Buf(OutRout+i) = shl(i+1,8)\(i+1);	/*	set output routings to 1		*/			end;			Default.Buf(SampleRate) = 500;	/*	set to 50.0 kHz		*/		end;		Default.Buf(SMPTEIn)			 = 0;	/*	set to Drop Frame				*/		Default.Buf(SMPTEDisp)		 = 0;	/*	set to Drop Frame				*/		Default.Buf(SMPTEOffs)		 = 0;	/*	set to 00:00:00:00.00		*/		Default.Buf(SMPTEOffs+1)	 = 0;	/*	(in Hrs:Min:Sec:Fra.Bits)	*/		Default.Buf(SMPTEOffs+2)	 = 0;		Default.Buf(SMPTEOffs+3)	 = 0;		Default.Buf(SMPTEOffs+4)	 = 0;		Default.Buf(SMPTEDspOffs)	 = 0;	/*	set to 00:00:00:00.00		*/		Default.Buf(SMPTEDspOffs+1) = 0;	/*	(in SBits)						*/		Default.Buf(FootDisp)		 = 2;	/*	set to 35mm, 24fps			*/		Default.Buf(FootOffs)		 = 0;	/*	set to 00:00.00				*/		Default.Buf(FootOffs+1)		 = 0;		Default.Buf(FootOffs+2)		 = 0;		Default.Buf(RecModes)		 = 0;	/*	set Mode to Alloc				*/		Default.Buf(RecModes+2)		 = 0;	/*	set Trig to Manual			*/		Default.Buf(RecModes+3)		 = 0;	/*	set Rec  to Single			*/		Default.Buf(DispForm)		 = O#MSEC.SMPTE;		Default.Buf(MIDI#InputChan)	= -1;	/*	default to OMNI On		*/		Default.Buf(MIDI#EchoDisable)	=  0;	/*	default to MIDI Echo On	*/	end;	if (Default.Buf(Misc#DefsInit) != 1)	{	//	.SDEF-7 files from before release 4.20 won't contain these defaults		Default.Buf(Misc#KbdRouting)		= shl(64|(1-1),8)|(64|(2-1));	//	Use L=1, R=2 for default Keyboard Multichannel Routing		Default.Buf(Misc#ClickOn)			= true;				//	Use On for default On/Off status of the click		Default.Buf(Misc#ClickDispMode)	= 0;					//	Use BPM for default Click Display Mode		Default.Buf(Misc#ClickRate)		= 500;				//	Use 500 ms/beat (120 BPM) for default Click Rate		Default.Buf(Misc#Speed)				= 1000;				//	Use 1.000 for default Sequence Speed		Default.Buf(Misc#ActiveMIDIRTEs)	= "100000"|B.MWHEEL|B.PWHEEL|B.VELOCITY;	//	Default MIDI RTEs used for null timbre		Default.Buf(Misc#VelocitySens)	= shl(100,4)|3;	//	Use Sensitivity=100, Response=3		Default.Buf(Misc#FinalDecay)		= 100;				//	Use 100 milliseconds for default Final Decay when loading sound files	}	if (SelectBits&(D#In|D#Out))<>0 then do;		do i = 0 to DTD.MAX.TRACKS-1;			if (SelectBits&D#In)<>0 then do;		/*	set input routings			*/				call Set.DTD.Drive.Parameter(i,0,Default.Buf(InRout+i));			end;			if (SelectBits&D#Out)<>0 then do;	/*	set out and ddt routings	*/				call Set.DTD.Drive.Parameter(i,5,Default.Buf(OutRout+i)&255);				call Set.DTD.Drive.Parameter(i,6,shr(Default.Buf(OutRout+i),8));			end;		end;	end;	if (SelectBits&D#Samp)<>0 then do;		call Set.DTD.Project.Parameter(2,Default.Buf(SampleRate));	end;	if (SelectBits&D#SIn)<>0 then do;		/*	set internal SMPTE var - S$SMode set later by Update.AEE.Defaults	*/		call Set.Synclav.Smpte.Mode(Default.Buf(SMPTEIn));	end;	if (SelectBits&D#SDisp)<>0 then do;		/*	display mode is set = to incoming mode, in current implementation	*/	end;	if (SelectBits&D#SOffs)<>0 then do;		/*	set sequencer and internal SMPTE vars	*/		call Set.Synclav.SMPTE.Offset(loc(addr(Default.Buf(SMPTEOffs))));		sm.hrs = Default.Buf(SMPTEOffs);		/*	update internal memory variables		*/		sm.min = Default.Buf(SMPTEOffs+1);	/*	right here, in case speed.comp		*/		sm.sec = Default.Buf(SMPTEOffs+2);	/*	did not get called						*/		sm.fra = Default.Buf(SMPTEOffs+3);		sm.bit = Default.Buf(SMPTEOffs+4);	end;	if (SelectBits&D#SDispOffs)<>0 then do;		/*	set AEE display offset in the sequence	*/		write(mam) = BAS.PTR;		write(mal) = SEQ.DOFFSET;		write(mdi) = Default.Buf(SMPTEDspOffs);		write(mdi) = Default.Buf(SMPTEDspOffs+1);	end;	if (SelectBits&D#FDisp)<>0 then do;		/*	set sequencer var (and S$FMode)	*/		call Set.Synclav.Feet.Mode(map.mm(Default.Buf(FootDisp)),map.rate(Default.Buf(FootDisp)));	end;	if (SelectBits&D#FOffs)<>0 then do;		/*	set sequencer vars  - S$FOffset will be set later by Update.AEE.Defaults	*/		call Set.Synclav.Feet.Offset(loc(addr(Default.Buf(FootOffs))));	end;	if (SelectBits&D#DForm)<>0 then do;		/*	time format is local to AEE	*/		AEE.Time.Format = Default.Buf(DispForm);		PID(Saved.AEE.Time.Format, AEE.Time.Format);	end;	if (SelectBits&D#RecM)<>0 then do;		/*	record settings are local to AEE	*/		call PID(Record.Mode.Switch.Setting,	 Default.Buf(RecModes));		call PID(Record.Trigger.Switch.Setting, Default.Buf(RecModes+1));		call PID(Record.Rec.Switch.Setting,		 Default.Buf(RecModes+2));	end;	if (SelectBits&D#MIDI) <> 0 then do;	/*	MIDI Defaults	*/		MIDI.Input.Chan	 = Default.Buf(MIDI#InputChan);		MIDI.Echo.Disabled = Default.Buf(MIDI#EchoDisable);	end;	if ((SelectBits & D#Misc) != 0) {		//	Miscellaneous Defaults		//	Set default Keyboard Multichannel Routing		IF (INC.MULT != false) {			IF ((MULTI.THERE != false) && (MULTI.MAX != 0)) {				WRITE(MAM) = TRK.HEAD;	/*	POINT TO KEYBOARD'S MULTICHANNEL ROUTING	*/				WRITE(MAM) = READ(MD);				WRITE(MAL) = THD.TROU;				WRITE(MD ) = Default.Buf(Misc#KbdRouting);			}		}		ClickOn						 = Default.Buf(Misc#ClickOn);				//	Set default On/Off status of the click		Click.Disp.Mode			 = Default.Buf(Misc#ClickDispMode);		//	Set default Click Display Mode		PID(Default.Click.Rate,		Default.Buf(Misc#ClickRate));			//	Set default Click Rate		PID(Default.Speed,			Default.Buf(Misc#Speed));				//	Set default Sequence Speed		PID(Default.MIDI.RTEs,		Default.Buf(Misc#ActiveMIDIRTEs));	//	Set default MIDI RTEs (for null timbre)		PID(Default.VelocitySens,	Default.Buf(Misc#VelocitySens));		//	Set default Velocity Sensitivity & Response		PID(Default.FDecay,			Default.Buf(Misc#FinalDecay));		//	Set default Final Decay (for loading sound files)		DISPLAY.PARAMETER.BUTTONS();	//	Since "ClickOn" may have changed	}	return (exit);end READ.DEFAULTS;WRITE.DEFAULTS: proc (Source,Dev,Sec)	fixed public swapable;	dcl Source		fixed;	/*	0=save defaults from screen	*/									/*	1=save defaults from floppy	*/	dcl (Dev,Sec)	fixed;	/*	device and sector address for defaults	*/	dcl Default.Buf(255)	fixed;	dcl exit			fixed;	/*	-1=failure; 1=success	*/	dcl i				fixed;	dcl tmp(1)		fixed;	dcl Initial			lit 'AEE#DefsInit';		/*	flag for initializing defs			*/	dcl InRout			lit 'AEE#InRout';			/*	Input routings (16 tracks)			*/	dcl OutRout			lit 'AEE#OutRout';		/*	Out & DDT routings (16 tracks)	*/	dcl SampleRate		lit 'AEE#SampRate';		/*	DTD sample rate						*/	dcl SMPTEIn			lit 'AEE#SMPTEIn';		/*	SMPTE in type and rate				*/	dcl SMPTEDisp		lit 'AEE#SMPTEDisp';		/*	SMPTE display type and rate		*/	dcl SMPTEOffs		lit 'AEE#SMPTEOffs';		/*	SMPTE offset							*/	dcl SMPTEDspOffs	lit 'AEE#SMPTEDspOffs';	/*	SMPTE display offset					*/	dcl FootDisp		lit 'AEE#FootDisp';		/*	Footage disp type and rate			*/	dcl FootOffs		lit 'AEE#FootOffs';		/*	Footage offset							*/	dcl RecModes		lit 'AEE#RecordMode';	/*	Record modes							*/	dcl DispForm		lit 'AEE#DispFormat';	/*	Time display format					*/	if Source=0 then do;	/*	save defaults from screen	*/		call ReadData(Dev,Sec,Default.Buf,256);		Default.Buf(Initial)=1;	/*	set flag to show defaults have been written to	*/		if LOD.Running <> 0 then do;			if Send.For.Track.Directory<>0			then do;				/*	save input and output routings for each track	*/				do i = 0 to DTD.MAX.TRACKS-1;					/*	set input routings	*/					write(mam) = TRD.Ptr + shr(24+(16*i)+10,8);					write(mal) = 24+(16*i)+10;					Default.Buf(InRout+i)  = read(md);					/*	set output and ddt routings	*/					write(mam) = TRD.Ptr + shr(24+(16*i)+15,8);					write(mal) = 24+(16*i)+15;					Default.Buf(OutRout+i) = read(md);				end;			end;			/*	save DTD sample rate	*/			call Fetch.DTD.Song.Directory(AEE.Current.Project);			write(mam) = SCSI.Ptr;			write(mal) = 15;			Default.Buf(SampleRate) = read(md);		end;		/*	save SMPTE In type and rate	*/		Default.Buf(SMPTEIn)		=sm.mode;		/*	save SMPTE Disp type and rate	*/		Default.Buf(SMPTEDisp)	=sm.mode;		/*	save SMPTE offset	*/		Default.Buf(SMPTEOffs)	=sm.hrs;		Default.Buf(SMPTEOffs+1)=sm.min;		Default.Buf(SMPTEOffs+2)=sm.sec;		Default.Buf(SMPTEOffs+3)=sm.fra;		Default.Buf(SMPTEOffs+4)=sm.bit;		/*	save SMPTE display offset	*/		write(mam) = BAS.PTR;	/*	get display offset from sequence	*/		write(mal) = SEQ.DOFFSET;		Default.Buf(SMPTEDspOffs)	 = read(mdi);		Default.Buf(SMPTEDspOffs+1) = read(mdi);		/*	save Footage display type	*/		Default.Buf(FootDisp)	=S$FMode;		/*	save footage offset	*/		Default.Buf(FootOffs)  =S$FOffset(0);		Default.Buf(FootOffs+1)=S$FOffset(1);		Default.Buf(FootOffs+2)=S$FOffset(2);		/*	save record modes	*/		Default.Buf(RecModes)  =GID(Record.Mode.Switch.Setting);		Default.Buf(RecModes+1)=GID(Record.Trigger.Switch.Setting);		Default.Buf(RecModes+2)=GID(Record.Rec.Switch.Setting);		/*	save time display format	*/		Default.Buf(DispForm)  =AEE.Time.Format;		/*	save MIDI Input Chan & Echo Disable state	*/		Default.Buf(MIDI#InputChan)	= MIDI.Input.Chan;		Default.Buf(MIDI#EchoDisable)	= MIDI.Echo.Disabled;		//	Save Miscellaneous Defaults		Default.Buf(Misc#DefsInit) = 1;	//	Set flag to show 4.20 user defaults have been written to		//	USER DEFAULTS FOR RTP INITIALIZATION………………………………………		IF (INC.MULT != false) {			IF ((MULTI.THERE != false) && (MULTI.MAX != 0)) {				WRITE(MAM) = TRK.HEAD;		//	Point to keyboard's multichannel routing				WRITE(MAM) = READ(MD);				WRITE(MAL) = THD.TROU;				Default.Buf(Misc#KbdRouting) = read(md);			//	Use current Keyboard Multichannel Routing			}		}		Default.Buf(Misc#ClickOn)			= ClickOn;				//	Use current On/Off status of the click		Default.Buf(Misc#ClickDispMode)	= Click.Disp.Mode;	//	Use current Click Display Mode		//	USER DEFAULTS FOR NULL SEQUENCE……………………………………………………		Default.Buf(Misc#ClickRate)		= Samp.Click.Rate;	//	Use current Click Rate		Default.Buf(Misc#Speed)				= Samp.Speed;			//	Use current Sequence Speed		//	USER DEFAULTS FOR NULL TIMBRE…………………………………………………………		//	Use current Active MIDI RTEs from Keyboard Timbre		WRITE(MAM) = TRK.HEAD;		WRITE(MAM) = READ(MD);				//	Point to keyboard's track head		WRITE(MAL) = THD.ACTIVE.MIDI.RTES;		Default.Buf(Misc#ActiveMIDIRTEs)	= read(MD);		//	Use current Velocity Sensitivity and Response		Default.Buf(Misc#VelocitySens)	= shl(V.S.MIN,4) | V.S.CON;		//	USER DEFAULT FOR LOADING SOUND FILES………………………………………		//	Use current Partial 1 Final Decay		Default.Buf(Misc#FinalDecay)		= P.LOOKUP(TIM.HEAD.LOOKUP(0,TIM.PARTIAL.POINTERS)+3);		call WriteData(Dev,Sec,Default.Buf,256);	/*	write data back out	*/		//	Put new misc defaults in GID/PID area		call Read.Defaults(D#Misc,Dev,Sec);		exit = 1;	end;	else do;		/*	read defaults in from F0: and save	*/		if Locate(DefsFile,2) then do;			if (F#MS_Length <>  0)			or (F#LS_Length ige 32)			then do;				/*	transfer data from floppy to winchester	*/				tmp(0) = F#MS_Sector; tmp(1) = F#LS_Sector;				call ADD16(Info#AEEDefaults,tmp);	/*	get sector offset	*/				call ReadData(tmp(0),tmp(1),Default.Buf,256);				call WriteData(Dev,Sec,Default.Buf,256);				exit = 1;			end;			else do;				call Display.Notice(NT#WrongDefVersion,ATTR#Reverse,NulStr,2,0,0);				exit = -1;			end;		end;		else do;			if C#Status=e#no_floppy then			call Display.Notice(NT#NoFloppyInDrive,ATTR#Reverse,NulStr,0,0,0);			else if C#Status=e#no_file then			call Display.Notice(NT#FileNotFound,ATTR#Reverse,DefsFile,2,0,0);			else call Display.Notice(NT#FeatureNotAvail,ATTR#Reverse,NulStr,0,0,0);			exit = -1;		end;		/*	refresh settings if defaults were installed from F0:	*/		if (exit=1) then do;			call Read.Defaults		(D#FDisp|D#FOffs|D#RecM|D#DForm|D#PanLay|D#MIDI|D#Misc,Dev,Sec);			call Update.AEE.Defaults(D#FDisp|D#FOffs|D#RecM|D#DForm|D#PanLay|D#MIDI|D#Misc);		end;	end;	return (exit);end WRITE.DEFAULTS;OPEN.DEFAULTS.DIALOG.PANEL: proc (command)	fixed swapable;	dcl command				fixed;	/*	0=reading; 1=writing	*/	dcl Message.Label		fixed;	dcl OK.Button			fixed;	dcl Cancel.Button		fixed;	dcl Defaults.Switch	fixed;	dcl (exit)				fixed;	dcl (i,j)				fixed;	dcl tmp(1)				fixed;	Do.Default.Process: proc (Command,path,DoCommand)	fixed;		dcl Command		fixed;	/*	0=read; 1=write	*/		dcl path			fixed;	/*	for writing:										*/										/*	0= screen->w0:; 1=screen->f0:; 2=f0:->w0:	*/		dcl DoCommand	fixed;	/*	1=OK; 0=Cancel		*/		dcl (Dev,Sec)	fixed;		dcl exit			fixed;		dcl i				fixed;		/*	returns 1 if command was successfully performed	*/		/*			 -1 if command failed or was canceled		*/		if DoCommand=0 then return (-1);		/*	otherwise, OK	*/		if Command=1 then do;	/*	store new defaults	*/			if (path=0)												/*	save to W0:	*/			or (path=2)			then do;				Dev = DefDev;										/*	get DEFSFILE address		*/				Sec = DefSec+Info#AEEDefaults;				/*	default sector offset	*/				if Sec ILT Info#AEEDefaults then Dev=Dev+1;			end;			else if path=1 then do;								/*	save to F0:	*/				if Locate(DefsFile,2) then do;					if (F#MS_Length <>  0)					or (F#LS_Length ige 32)					then do;						Dev = F#MS_Sector;						Sec = F#LS_Sector+Info#AEEDefaults;	/*	get sector offset			*/						if Sec ILT Info#AEEDefaults then Dev=Dev+1;					end;					else do;						call Display.Notice(NT#WrongDefVersion,ATTR#Reverse,NulStr,2,0,0);						return (-1);					end;				end;				else do;					if Replace(DefsFile,t#data,0,32,shl(32,8),2) then do;						/*	zero out file we just created	*/						do i=0 to 255; misc.buf(i) = 0; end;						do i=0 to F#LS_LENGTH-1;	/*	loop over sectors				*/							dev = F#MS_SECTOR;		/*	and fill them with zeroes	*/							sec = F#LS_SECTOR;							sec = sec + i;							if sec ilt i then dev = dev + 1;							call writedata(dev,sec,misc.buf,256);						end;						Dev = F#MS_Sector;						Sec = F#LS_Sector+Info#AEEDefaults;	/*	get sector offset	*/						if Sec ILT Info#AEEDefaults then Dev=Dev+1;					end;					else do;	/*	print error message	*/						if C#Status=e#no_floppy then						call Display.Notice(NT#NoFloppyInDrive,ATTR#Reverse,NulStr,0,0,0);						else call Display.Notice(NT#CannotSaveFile,ATTR#Reverse,DefsFile,2,0,0);						return (-1);					end;				end;			end;			exit = Write.Defaults((path=2)&1, Dev, Sec);			return(exit);		end;		else do;					/*	install all defaults	*/			Dev = DefDev;			Sec = DefSec+Info#AEEDefaults;	/*	get sector offset	*/			if Sec ILT Info#AEEDefaults then Dev=Dev+1;			exit = Read.Defaults(-1,Dev,Sec);			call Update.AEE.Defaults(-1);			return(exit);		end;	end Do.Default.Process;	call PUSH.AND.RESET.GET.ENABLE.WORDS;	call Set.Auto.Allocation.Id (Panel.Menu.Alloc+500);	call Set.Default.Action(O#ACT.Middle.Press);	call Set.Default.Attr(0,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);	call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse);	if command=1 then do;	/*	writing	*/		Message.Label	 = Define.Label (S#AA,2, 0,28,'Store default settings from ');		Defaults.Switch = Define.Switch(S#AA,2,28,13,0,'[SCREEN to W0:]|[SCREEN to F0:]|[F0: to W0:]   ');	end;	else do;						/*	reading	*/		Message.Label	 = Define.Label (S#AA,2, 0,23,'Restore default settings');	end;	call Set.Object.Mouse.Access(Message.Label,0);	call Set.Object.Erase		 (Message.Label,O#ERAS.Whole.Line);	OK.Button	  = Define.Label (S#AA,2,66,0,'[OK]');	Cancel.Button = Define.Label (S#AA,2,72,0,'[CANCEL]');	call Set.Object.Arrow.Links(OK.Button,		-1,-1,-1,Cancel.Button);	call Set.Object.Arrow.Links(Cancel.Button,-1,-1,OK.Button,-1);	/*	10 Objects MAX in Dialog Bar for now	*/	call Activate.Object.Range	(Panel.Menu.Alloc+500,Cancel.Button);	call Update.Object.Range	(Panel.Menu.Alloc+500,Cancel.Button);	call Select.New.Cur.Obj		(OK.Button,-1,-1);	do while exit = 0;		i = Get.Next.Screen.Event;		if Screen.Event.Group = Panel.Menu.Group then do;			if i = Get.Screen.Event then do;				if (Screen.Event.Id = OK.Button) then do;					if (Screen.Event.Info = S#MouseSelect)					or (Screen.Event.Info = S#MouseActivate)					or (Screen.Event.Info = S#KeyActivate) then do;						exit = Do.Default.Process(command,Fetch.Switch(Defaults.Switch),1);					end;				end;				else if (Screen.Event.Id = Cancel.Button) then do;					if (Screen.Event.Info = S#MouseSelect)					or (Screen.Event.Info = S#MouseActivate)					or (Screen.Event.Info = S#KeyActivate)					then exit = -1;				end;				else if (Screen.Event.Id = Defaults.Switch) then do;					if (Screen.Event.Info = S#MouseSelect)					then do;						/*	not interested in this switch until OK hit	*/					end;				end;				else if (Screen.Event.Id = Defaults.Table) then do;					if (Screen.Event.Info = S#MouseSelect)					or (Screen.Event.Info = S#MouseSelect) then do;						call Map.Graphics.Button.Table.Mouse.Press(Defaults.Table, tmp);						if ((command=0) and (tmp(0)=0))						or ((command=1) and (tmp(0)=1))						then do;	/*	"click" on whatever is current obj in dialog bar	*/							if Prev.Obj.Id=OK.Button then								exit = Do.Default.Process(command,Fetch.Switch(Defaults.Switch),1);							else if Prev.Obj.Id=Cancel.Button then								exit = Do.Default.Process(command,Fetch.Switch(Defaults.Switch),0);							call Get.Next.Screen.Event;	/*	ignore return to prev obj	*/																	/*	just return exit				*/						end;					end;				end;				else if ((Screen.Event.Info = S#MouseSelect)				or			(Screen.Event.Info = S#MouseActivate))				then do;					call Select.New.Cur.Obj(Cancel.Button,-1,-1);					call Display.Notice(NT#MustRespondToDialog,ATTR#Normal,NulStr,1,0,0);				end;			end;		end;		else do;	/*	Outside Panel Menu group	*/			if  (i = Get.Screen.Event) then do;				if (Screen.Event.Info = S#MouseSelect)				or (Screen.Event.Info = S#MouseActivate) then do;					call Select.New.Cur.Obj(Cancel.Button,-1,-1);					call Display.Notice(NT#MustRespondToDialog,ATTR#Normal,NulStr,2,0,0);				end;			end;		end;	end;	call Erase.Object(Message.Label);		/*	Erases message and whole line of text	*/	call Undefine.Object.Range(Panel.Menu.Alloc+500,Panel.Menu.Alloc+510);	call Select.New.Cur.Obj(Corner.Label,-1,-1);	call POP.GET.ENABLE.WORDS;	return (exit=1);end OPEN.DEFAULTS.DIALOG.PANEL;/*	routine to send DDT format & sync info to LOD	*/Send.Sync.Info: proc (Format.Switch, Sync.Switch) swapable;	dcl Format.Switch	fixed;	dcl Sync.Switch	fixed;	dcl i					fixed;	i = Fetch.Switch(Format.Switch)		 \ shl(Fetch.Switch(Sync.Switch),4);	write(mam) = Scsi.Ptr;	write(mdi) = 42;	write(md ) = i;	call Send.To.Lod(144,4);end Send.Sync.Info;/*	Open dialog box for DDT format selection	*/OPEN.DDT.FORMAT.DIALOG.PANEL: proc	fixed swapable;	dcl Format.Label	fixed;	dcl Format.Switch	fixed;	dcl Sync.Label		fixed;	dcl Sync.Switch	fixed;	dcl OK.Button		fixed;	dcl Cancel.Button	fixed;	dcl (exit)			fixed;	dcl (i,j)			fixed;	dcl tmp(1)			fixed;	call PUSH.AND.RESET.GET.ENABLE.WORDS;	call Set.Auto.Allocation.Id (Panel.Menu.Alloc+500);	call Set.Default.Action(O#ACT.Middle.Press);	call Set.Default.Attr(0,ATTR#Normal);	call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse);	/*	          1         2         3         4         5         6         7         	*/	/*	01234567890123456789012345678901234567890123456789012345678901234567890123456789	*/	/*	Format: ProDigi 2 Track  Output Sync: Internal                   [OK]   [CANCEL]	*/	/*			  ProDigi Multi					  External Default		*/	/*			  SDIF 2 Track						  NTSC B+W					*/	/*			  SDIF Multi						  NTSC Color				*/	/*			  AES/EBU							  PAL/SECAM					*/	/*			  S/PDIF								  Ext ProDigi 2 Track	*/	/*													  Ext ProDigi Multi		*/	/*													  Ext SDIF					*/	/*													  Ext AES/EBU or S/PDIF	*/	Format.Label = Define.Label (S#AA, 2,  0,  0,'Format:');	Sync.Label	 = Define.Label (S#AA, 2, 25,  0,'Output Sync:');	call Set.Object.Mouse.Access(Format.Label, 0);	call Set.Object.Mouse.Access(Sync.Label, 0);	call Set.Object.Erase		 (Format.Label, O#ERAS.Whole.Line);	call Set.Default.Attr(0,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);	call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse);	Format.Switch = Define.Switch(S#AA, 2,  8, 15, 0,'ProDigi 2 Track|ProDigi Multi|SDIF 2 Track|SDIF Multi|AES/EBU|S/PDIF');	Sync.Switch   = Define.Switch(S#AA, 2, 38, 21, 0,'Internal|External Default|NTSC B+W|NTSC Color|PAL/SECAM|Ext ProDigi 2 Track|Ext ProDigi Multi|Ext SDIF|Ext AES/EBU or S/PDIF');	OK.Button	  = Define.Label (S#AA,2,65,0,'[OK]');	Cancel.Button = Define.Label (S#AA,2,72,0,'[CANCEL]');	call Set.Object.Arrow.Links(OK.Button,		-1,-1,-1,Cancel.Button);	call Set.Object.Arrow.Links(Cancel.Button,-1,-1,OK.Button,-1);	disable.deposits = 1;		call Deposit.Switch(Format.Switch, shr(DDT.Config,  8) & 15);		call Deposit.Switch(Sync.Switch,   shr(DDT.Config, 12) & 15);	disable.deposits = 0;	/*	10 Objects MAX in Dialog Bar for now	*/	call Activate.Object.Range (Panel.Menu.Alloc+500,Cancel.Button);	call Update.Object.Range	(Panel.Menu.Alloc+500,Cancel.Button);	call Select.New.Cur.Obj		(OK.Button,-1,-1);	do while exit = 0;		i = Get.Next.Screen.Event;		if Screen.Event.Group = Panel.Menu.Group then do;			if i = Get.Screen.Event then do;				if (Screen.Event.Id = OK.Button		)				or (Screen.Event.Id = Dig.Xfer.Label)				then do;					if (Screen.Event.Info = S#MouseSelect)					or (Screen.Event.Info = S#MouseActivate)					or (Screen.Event.Info = S#KeyActivate) then do;						call Send.Sync.Info(Format.Switch, Sync.Switch);						exit = 1;					end;				end;				else if (Screen.Event.Id = Cancel.Button) then do;					if (Screen.Event.Info = S#MouseSelect)					or (Screen.Event.Info = S#MouseActivate)					or (Screen.Event.Info = S#KeyActivate)					then exit = -1;				end;				else if (Screen.Event.Id = Format.Switch )					  or (Screen.Event.Id = Sync.Switch   )				then do;					/*	ignore switch events for now, but allow selection of	*/					/*	them so the user can change them.							*/				end;				else if ((Screen.Event.Info = S#MouseSelect)				or			(Screen.Event.Info = S#MouseActivate))				then do;					call Select.New.Cur.Obj(Cancel.Button,-1,-1);					call Display.Notice(NT#MustRespondToDialog,ATTR#Normal,NulStr,1,0,0);				end;			end;		end;		else do;	/*	Outside Panel Menu group	*/			if (i = Get.Screen.Event) then do;				if (Screen.Event.Info = S#MouseSelect)				or (Screen.Event.Info = S#MouseActivate) then do;					call Select.New.Cur.Obj(Cancel.Button,-1,-1);					call Display.Notice(NT#MustRespondToDialog,ATTR#Normal,NulStr,2,0,0);				end;			end;		end;	end;	call Erase.Object(Format.Label);		/*	Erases message and whole line of text	*/	call Undefine.Object.Range(Panel.Menu.Alloc+500,Panel.Menu.Alloc+510);	call Select.New.Cur.Obj(Corner.Label,-1,-1);	call POP.GET.ENABLE.WORDS;	return (exit=1);end OPEN.DDT.FORMAT.DIALOG.PANEL;Handle.Dig.Xfer.Label: proc swapable;	/*	User has clicked in Digital Transfer label	*/	if Screen.Event.Info = S#MouseSelect	then do;		call Highlight.Graphics.Button.Table(Dig.Xfer.Label, 1, 2, 0);		if lod.running = 0		then call no.direct.to.disk;		else if (DDT.Config & "H0003") = 0		then call Display.Notice(NT#NoDDTHardware,ATTR#Reverse,NulStr,0,0,0);		else if (DDT.Config & "H00F0") = 0		then call Display.Notice(NT#MitsuOnlyHardware,ATTR#Reverse,NulStr,0,0,0);		else call OPEN.DDT.FORMAT.DIALOG.PANEL;		call Highlight.Graphics.Button.Table(Dig.Xfer.Label, 0, 2, 0);	end;end Handle.Dig.Xfer.Label;Handle.Off.In.Out.Bounce: proc swapable;	dcl tmp(1)	fixed;	if Screen.Event.Info = S#MouseSelect	then if Lod.Running <> 0 then do;		call Map.Graphics.Button.Table.Mouse.Press(Dig.On.Off.Table, tmp);		write(mam) = Scsi.Ptr;		/*	send new xfer code to LOD.  It	*/		write(mdi) = 40;				/*	will generate an error message	*/		write(md ) = tmp(0);			/*	and send us an init record			*/		call Send.To.Lod(144,4);	/*	if hardware is not available		*/		call Highlight.Graphics.Button.Table(Dig.On.Off.Table, DTD.Xfer.Mode, 2, 0);	end;end Handle.Off.In.Out.Bounce;Handle.Defaults.Table: proc swapable;	dcl tmp(1)	fixed;	/*	col,row of mouse press			*/	if Screen.Event.Info = S#MouseSelect then do;		/*	Check to see if default file is proper version (32 secs or bigger)	*/		if Defs.There = 0 then do;			call Display.Notice(NT#WrongDefVersion,ATTR#Reverse,NulStr,6,0,0);			return;		end;		call Map.Graphics.Button.Table.Mouse.Press(Defaults.Table, tmp);		call Highlight.Graphics.Button.Table(Defaults.Table, bits(tmp(0)), 2, 0);	/*	respond to user snappily here	*/		call Open.Defaults.Dialog.Panel(tmp(0));		call Highlight.Graphics.Button.Table(Defaults.Table, 0, 2, 0);	end;end Handle.Defaults.Table;GET.PANEL.MENU.EVENT: proc (event) returns (fixed) public swapable;	dcl event					fixed;	dcl Panel.Cell				fixed;	dcl (Quit,I)				fixed;	dcl ColInfo		(1)		fixed;	dcl Defined.Panel.Bits	lit '"001777"';	/*	bits for menu cells which map to defined panels	*/	dcl Requires.DTD			lit '"000637"';	/*	bits for panels which need DTD to work				*/	dcl Cell.To.Panel.Map	data (0,1,2,3,9,5,4,6,8,10,-1,-1,-1,-1,-1,-1);	do while Quit=0;		if event <> Get.Null.Event then do;			if Screen.Event.Group <> Panel.Menu.Group then return event;			if event = Get.Screen.Event then do;				if Screen.Event.Id = Raw.Screen.Id then do;					if Screen.Event.Info = S#MouseSelect then do;						/*	remap event to Group 0 event where the	*/						/*	mouse press is actually processed		*/						Screen.Event.Group=0;						Screen.Event.Code=Get.Screen.Event;						event=Screen.Event.Code;						Quit=1;						/*	Screen.Event.Info & Screen.Event.Id	*/						/*	are already set correctly.				*/					end;				end;				else if Screen.Event.Id = Panel.Menu.Mouse.Hole then do;					if Screen.Event.Info = S#MouseSelect then do;						/*	remap event to Group 0 event where the		*/						/*	screen exit command is actually processed	*/						Screen.Event.Group=0;						Screen.Event.Code=Get.Screen.Event;						event=Screen.Event.Code;						Quit=1;						/*	Screen.Event.Info & Screen.Event.Id	*/						/*	are already set correctly.				*/					end;				end;				else if Screen.Event.Id=Panel.Menu.Table then do;					if (Screen.Event.Info = S#MouseSelect)					or (Screen.Event.Info = S#MouseActivate)					then do;						if AEE.Initialized = false then call AEE.Init;						call Map.Graphics.Button.Table.Mouse.Press(Panel.Menu.Table,Colinfo);						Panel.Cell=ColInfo(0)+8*ColInfo(1);						if Panel.Cell<12 then do;							if  ((Defined.Panel.Bits&Bits(Panel.Cell))<>0)							then do;			/*	this represents a real panel	*/								if ((DTD.MAX.SECS <> 0) & (LOD.VERSION >= Lod.Version.Needed))								or (simulate_dtd)								or ((Requires.DTD&Bits(Cell.To.Panel.Map(Panel.Cell)))=0)	/*	panel doesn't really need DTD to work	*/								then do;								/*	up and running with right version		*/									if ((Panel.Bits&"170000")<>0) then do;		/*	a user button is lit		*/										Panel.Bits=Panel.Bits&(not "170000");	/*	turn off user buttons	*/										call Highlight.Graphics.Button.Table(Panel.Menu.Table,Panel.Bits,2,0);									end;									call Toggle.Panel.State(Cell.To.Panel.Map(Panel.Cell));	/*	open or close desired panel	*/								end;								else do;	/*	some problem with DTD system	*/									if		  DTD.MAX.SECS = 0 then call No.Direct.To.Disk;									else if LOD.VERSION  < Lod.Version.Needed then call Display.Notice(NT#DTDVersionError,ATTR#Normal,NulStr,0,0,0);								end;							end;							else call Display.Notice(NT#UndefinedMenuBox,ATTR#Normal,NulStr,0,0,0);						end;						else do;	/*	user has selected one of the MACRO buttons	*/							if (Panel.Bits&Bits(Panel.Cell))=0				/*	opening a new set of panels		*/							then Panel.Bits=Panel.Bits&(Not "170000");	/*	turn off any lit user buttons		*/							Panel.Bits=Panel.Bits xor Bits(Panel.Cell);	/*	toggle state of this user button	*/							call Highlight.Graphics.Button.Table(Panel.Menu.Table,Panel.Bits,2,0);							call Set.User.Screen.Layout(Panel.Cell-12);	/*	invoke macro layout command		*/						end;					end;				end;		/*	of screen event on PANEL MENU	*/				else if (Screen.Event.Id>= Panel.Menu.User.Id)				and	  (Screen.Event.Id< (Panel.Menu.User.Id+4))				then do;			/*	user wants to save current screen layout	*/					if (Screen.Event.Info = S#MouseSelect)					or (Screen.Event.Info = S#MouseActivate)					then do;						I=Screen.Event.Id-Panel.Menu.User.Id;						if Open.Layout.Macro.Dialog.Panel(I) then do;							Panel.Bits=(Panel.Bits&(not "170000"))|Bits(12+I);							call Highlight.Graphics.Button.Table(Panel.Menu.Table,Panel.Bits,2,0);						end;					end;				end;				else if Screen.Event.Id=Big.Time.Mode.Table then do;					if (Screen.Event.Info = S#MouseSelect)					or (Screen.Event.Info = S#MouseActivate)					then do;						call Map.Graphics.Button.Table.Mouse.Press(Big.Time.Mode.Table,Colinfo);						if  (Big.Time.Display.Mode=BT#SMPTE)						and (ColInfo(1)<>0)						then call Get_Disable(GET.SMPTE.EVENT);						if  (Big.Time.Display.Mode<>BT#SMPTE)						and (ColInfo(1)=0)						then do;							call Get_Enable(GET.SMPTE.EVENT);						end;						do case ColInfo(1);							Big.Time.Display.Mode=BT#SMPTE;							Big.Time.Display.Mode=BT#SEQ;							Big.Time.Display.Mode=BT#DTD;						end;						call Highlight.Graphics.Button.Table(Big.Time.Mode.Table,Bits(Big.Time.Display.Mode),2,0);						/*	call Update.Play.Scrolling.Boundaries at least	*/						/*	once so that our begin & and times are set		*/						/*	to be something useful.									*/						call UPDATE.PLAY.SCROLLING.BOUNDARIES;						call Refresh.Big.Time.Display;	/*	redraw display in new format	*/					end;				end;				else if Screen.Event.Id=SMPTE.On.Off.Buttons then do;					if (Screen.Event.Info = S#MouseSelect)					or (Screen.Event.Info = S#MouseActivate)					then do;						call Map.Graphics.Button.Table.Mouse.Press(SMPTE.On.Off.Buttons,Colinfo);						if ColInfo(0)=0 then do;	/*	turn SMPTE on	*/							if SMPTE.OnOff=0 then call Toggle.SMPTE;						end;						else do;	/*	turn SMPTE off	*/							if SMPTE.OnOff<>0 then call Toggle.SMPTE;						end;						call Highlight.Graphics.Button.Table(SMPTE.On.Off.Buttons,Bits(SMPTE.OnOff=0),2,0);					end;				end;				else if Screen.Event.Id=SMPTE.Offset.Id then do;					if (Screen.Event.Info = S#MouseSelect)					or (Screen.Event.Info = S#MouseActivate)					then do;						call Highlight.Graphics.Button.Table(SMPTE.Offset.Id,1,2,0);						call Open.SMPTE.Offset.Dialog.Panel;						call Highlight.Graphics.Button.Table(SMPTE.Offset.Id,0,2,0);					end;				end;				else if Screen.Event.Id = Dig.Xfer.Label then do;					call Handle.Dig.Xfer.Label;				end;				else if Screen.Event.Id = Dig.On.Off.Table then do;					call Handle.Off.In.Out.Bounce;				end;				else if Screen.Event.Id = Defaults.Table then do;					call Handle.Defaults.Table;				end;			end;		end;		if Quit=0 then event = Get.Next.Screen.Event;	end;	return event;end GET.PANEL.MENU.EVENT;