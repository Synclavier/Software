/*	:SYNSOU:AUDMOD:AUD-PMG1 - Audio Event Editor Project Manager insert	*//*Modified:1991/12/06 - PF  - Log "refresh" for Quick Updates on track erase1988/01/23 - cj  - changes for multi track DDT user iface1988/08/03 - SGS - added Create.New.Project1988/07/26 - cj  - fixed bug with "erase all" not selecting all projects1988/06/18 - cj  - expanded PMGR to include DDT fields1988/05/02 - SGS - restructured event loops in Process..Event and Get.Next.. procs1988/04/29 - JSS - Process.Onebar.Event now handles Gain vals in decibels*//*	This routine highlights or unhighlights a given project	*//*	on the "show all" display											*/SET.PROJECT.HIGHLIGHT: proc (project,setting) swapable;	dcl project			fixed;	dcl setting			fixed;	dcl bit.bank		fixed;	dcl (y1,y2)			fixed;	dcl start.time		fixed;	dcl end.time		fixed;	dcl pix.per.sec	fixed;	/*	1000 * pixels per second	*/	ALLOC.X: proc (sec,pix.per.sec) returns (fixed);		dcl sec			fixed;		dcl pix.per.sec	fixed;		load	sec;		mul	pix.per.sec;				mwait;		div	1000;		sec = res + (rem > 500);		return sec + gpos.x(300);	end ALLOC.X;	if LOD.Running <> 0 then do;		load	 gpos.x(7900)-gpos.x(300);		mul	 1000;				 mwait;		div	 DTD.MAX.SECS;		pix.per.sec = res + (rem > shr(DTD.MAX.SECS,1));		/*	complement highlighting if setting does not	*/		/*	match current display:							*/		bit.bank = shr(project,4);		if (((allbar.select.bits(bit.bank)&(bits(project&15)))=0)  & (setting<>0))		or (((allbar.select.bits(bit.bank)&(bits(project&15)))<>0) & (setting=0))		then do;			call Fetch.DTD.Song.Directory(project);			write(mam) = SCSI.Ptr;			write(mal) = 13;			start.time = read(mdi);			end.time   = read(mdi);			vector_mode;			call pc(27); call ps('|PI');	/*	Left diag fill	*/			call data_level(2);			call Blockmode_On;			start.time = alloc.x(start.time,pix.per.sec);			end.time   = alloc.x(end.time,  pix.per.sec);			y1 = gpos.y((Project.Manager.Row+1)*100-30);			y2 = gpos.y((Project.Manager.Row+Project.Manager.Size-2)*100-10);			call connect(start.time,y1,end.time,y2);			call Blockmode_Off;			call Data_Level(0);			transparent_mode;			allbar.select.bits(bit.bank) = allbar.select.bits(bit.bank) xor bits(project&15);		end;	end;end SET.PROJECT.HIGHLIGHT;TOGGLE.PROJECT.HIGHLIGHT: proc (project) swapable;	dcl project	fixed;	dcl setting	fixed;	if LOD.Running <> 0 then do;		setting = ((allbar.select.bits(shr(project,4))&(bits(project&15)))=0);		call Set.Project.Highlight(project,setting);	end;end TOGGLE.PROJECT.HIGHLIGHT;MAP.PROJECT.SELECTION: proc (x) swapable;	dcl x				fixed;	/*	X position of click	*/	dcl click.time	fixed;	dcl (i,j)		fixed;	dcl end.time	fixed;	dcl start.time	fixed;	/*	Procedure returns the project the user clicked in	*/	/*	(or at least the first one found in song directory	*/	/*	that contains that coordinate)							*/	if LOD.Running <> 0 then do;		i	 = gpos.x(7900)-gpos.x(300);		/*	# of pixels representing DTD	*/		load	DTD.MAX.SECS;						/*	total seconds on DTD	*/		mul	1000;									/*	scale to milliseconds	*/		mwait;		div	i;										/*	div by total pixels in display	*/		if (shl(rem,1) ige i) load res+1;	/*	round	*/		else						 load res;		//	clear D4 and affect an mwait		mul	x;										/*	mul by x position in display	*/		mwait;		div	1000;									/*	scale back to seconds	*/		if (rem ige 500) load res+1;			/*	round	*/		click.time = res;		do i = 0 to 40 by 10;			call Fetch.DTD.Song.Directory(i);			do j = 0 to 9;				write(mam) = SCSI.Ptr;				write(mal) = j*24 + 13;				start.time = read(mdi);				end.time   = read(mdi);				if ((click.time ige start.time) && (click.time ilt end.time)) return (i+j);			end;		end;	end;	return (-1);	/*	if user clicked on a non-project	*/end MAP.PROJECT.SELECTION;CLEAR.SELECTED.PROJECTS: proc swapable;	dcl (i,j)	fixed;	do i = 0 to 49;		if (allbar.select.bits(shr(i,4))&(bits(i&15)))<>0		then call Set.Project.Highlight(i,0);	end;	do i = 0 to 3;		allbar.select.bits(i) = 0;	end;end CLEAR.SELECTED.PROJECTS;/*	Fetch.Project.Locks returns bits in sel.bits for	*//*	every project that is locked:								*/FETCH.PROJECT.LOCKS: proc (sel.bits) swapable;	dcl sel.bits	array;	dcl (i,j)	fixed;	do i = 0 to 3;		sel.bits(i) = 0;	end;	do i = 0 to 40 by 10;		call Fetch.DTD.Song.Directory(i);		do j = 0 to 9;			write(mam) = SCSI.Ptr;			write(mal) = j*24+17;	/*	Status word	*/			if (read(mdi)&Bit1) <> 0			then sel.bits(shr(i+j,4))=sel.bits(shr(i+j,4))\bits((i+j)&15);		end;	end;end FETCH.PROJECT.LOCKS;HIGHLIGHT.LOCKED.PROJECTS: proc swapable;	dcl (i,j)		fixed;	dcl tmp.bits (3)	fixed;	call Fetch.Project.Locks(tmp.bits);	do i = 0 to 49;		call Set.Project.Highlight(i,(tmp.bits(shr(i,4))&(bits(i&15)))<>0);	end;end HIGHLIGHT.LOCKED.PROJECTS;/*	Select new current project:	*/SELECT.ONE.PROJECT: proc (sel.bits) swapable;	dcl sel.bits	array;	dcl (i,j)		fixed;	dcl (proj)		fixed;	do i = 0 to 3;		if (sel.bits(i) <> 0)		then do j = 0 to 15;			if (sel.bits(i) & bits(j)) <> 0			then do;				proj = i*16 + j;				if proj < 50				then do;					call Select.DTD.Current.Project(proj);					return;				end;			end;		end;	end;end SELECT.ONE.PROJECT;/*	Change locks on passed projects:	*/SET.PROJECT.LOCKS: proc (sel.bits) swapable;	dcl sel.bits		array;	dcl cur.bits (3)	fixed;	dcl ton.bits (3)	fixed;	dcl toff.bits(3)	fixed;	dcl (i,j)			fixed;	/*	see which projects are locked:	*/	call Fetch.Project.Locks(cur.bits);	/*	lock	 selected tracks that are not locked	*/	/*	unlock selected tracks that are		locked	*/	do i = 0 to 3;		ton.bits (i) = (	 (sel.bits(i))) and (not(cur.bits(i)));		toff.bits(i) = (not(sel.bits(i))) and (	(cur.bits(i)));	end;	call Set.DTD.Project.Status(0,toff.bits);	call Set.DTD.Project.Status(1,ton.bits );end SET.PROJECT.LOCKS;/*	Set up dialog box/highlighting for ALLBAR command	*/ALLBAR.COMMAND.ACTIVATE: proc (id) swapable;	dcl id	fixed;	dcl tmp	fixed;	dcl (i,j)	fixed;	dcl (s,e)	fixed;	if Project.Manager.Command <> 0 then do;		call Display.Notice(NT#MustRespondToDialog,ATTR#Reverse,NulStr,0,0,0);		call Select.New.Cur.Obj(Project.Manager.Command,-1,-1);	/*	re-highlight original command	*/		return false;	end;	if LOD.Running <> 0 then do;		call Display.Project.Manager.Prompt(id,1);		Project.Manager.Command = id;		call Set.Object.Attr(id,0,ATTR#Normal\ATTR#Reverse);		call Select.New.Cur.Obj(Corner.Label,-1,-1);		if (id = Project.Allbar.EraseAll.Label) then do;			do i = 0 to 40 by 10;				call Fetch.DTD.Song.Directory(i);				do j = 0 to 9;					write(mam) = SCSI.Ptr;					write(mal) = j*24+13;					s = read(mdi);				/*	Start and end times non-zero means something there	*/					e = read(mdi);					if (s + e) <> 0 then do;						write(mal) = j*24+17;	/*	status word					*/						if (read(mdi)&Bit1) = 0	/*	project is not locked	*/						then do;							call Set.Project.Highlight(i+j,1);							call Fetch.DTD.Song.Directory(i);	/*	re-read song dir	*/						end;					end;				end;			end;		end;		else if id = Project.Allbar.ChangeLock.Label then do;			call Highlight.Locked.Projects;		end;		else if id = Project.Allbar.SwitchProj.Label then do;			call SET.PROJECT.HIGHLIGHT (AEE.Current.Project,1);		end;	end;end ALLBAR.COMMAND.ACTIVATE;dcl SET.PROJECT.MANAGER.COMMAND.HIGHLIGHTS proc recursive;ONEBAR.COMMAND.ACTIVATE: proc (id) swapable;	dcl id	fixed;	dcl tmp	fixed;	dcl i		fixed;	/*	if already processing a one bar command, we will allow	*/	/*	the user to change is mind.  at least un-highlight the	*/	/*	prior command buttons, however									*/	if Project.Manager.Command <> 0 then do;		call Set.Object.Attr(Project.Manager.Command,0,ATTR#Normal\ATTR#AltIntensity);	end;	call Display.Project.Manager.Prompt(id,1);	Project.Manager.Command = id;	call Set.Object.Attr(id,0,ATTR#Reverse\ATTR#Normal);	call Select.New.Cur.Obj(Corner.Label,-1,-1);	if (id = Project.Onebar.AllRepro)	or (id = Project.Onebar.AllInput)	or (id = Project.Onebar.AllAuto)	or (id = Project.Onebar.AllCuePB)	or (id = Project.Onebar.AllSafe)	then do;		/*	This needs to do a track check to make sure that the ALL command can be executed for all tracks	*/		Onebar.Select.Bits = DTD.AVAIL.TRKS;	/*	Set all bits	*/		call SET.PROJECT.MANAGER.COMMAND.HIGHLIGHTS;	end;	else do;		Onebar.Select.Bits = 0;	/*	Clear all bits	*/		call SET.PROJECT.MANAGER.COMMAND.HIGHLIGHTS;	end;	/*	Update because we don't know why things are staying highlighted!	*/	call Update.Object.Range(Project.Onebar.AllRepro,Project.Onebar.EraseDrive);end ONEBAR.COMMAND.ACTIVATE;UPDATE.PROJECT.MANAGER: proc public swapable;	call DISPLAY.PROJECT.LINE;					/*	update top line now				*/	if Project.Manager.Mode = 1 then do;	/*	Only when we are in SHOW ALL	*/		call Display.All.Projects;	end;	else if Project.Manager.Mode = 2 then do;		Display.New.Project.Info = (-1);		/*	update display for all tracks	*/	end;end UPDATE.PROJECT.MANAGER;CANCEL.PENDING.ALLBAR.COMMAND: proc swapable;	call Clear.Selected.Projects;					/*	unhighlight selected projects		*/															/*	also clears Allbar.Select.Bits	*/	call Display.Project.Manager.Prompt(0,0);	/*	erase prompt							*/	Project.Manager.Command = 0;					/*	no command pending anymore			*/end CANCEL.PENDING.ALLBAR.COMMAND;CREATE.NEW.PROJECT: proc swapable;	dcl New.Project	fixed;		/*	the first empty project number	*/	dcl tmp(1)			fixed;	Find.New.DTD.Project: proc;		dcl proj.num		fixed;	/*	number of first empty project				*/		dcl used				fixed;	/*	flag to signal non-empty project			*/		dcl (i,j,k)			fixed;		dcl (s,e)			fixed;		used = 1; proj.num=0;		if LOD.Running <> 0 then do;			proj.num=0; i=0;			do while (i<=40) and (used=1);	/*	loop through non-empty projects	*/				call Fetch.DTD.Song.Directory(i);				j=0;				do while (j<=9) and (used=1);					write(mam)=SCSI.Ptr;					write(mal)=24*j+1;					used=0;					/*	check title ?? (empty proj has space-filled title)	*/					do k = 0 to 11;						if ((read(md) &"377")<>a.sp)						or  (shr(read(mdi),8)<>a.sp) then;	/*	used=1;	*/					end;					/*	non-zero start and end times means project is being used	*/					s = read(mdi); e = read(mdi);					if ((s + e)<>0) then used=1;					if used=0 then proj.num=i+j;					j=j+1;				end;				i=i+10;			end;		end;		if used=0 then	return (proj.num);	/*	found an empty one				*/		else				return (-1);			/*	all projects are being used	*/														/*	or LOD is not running			*/	end Find.New.DTD.Project;	New.Project = Find.New.DTD.Project;	/*	0-49 if found, -1 if not	*/	if New.Project=(-1) then return(0);	/*	no empty projects left		*/	Disable.Deposits = true;	call Deposit.Fixed.Point(Project.Number.Id, New.Project+1);	call Update.Object(Project.Number.Id);	call Deposit.Label(Project.Name.Id,NulStr);	call Update.Object(Project.Name.Id);	Disable.Deposits = false;	call Stop.DTD.Playback;	call Select.DTD.Current.Project(New.Project);	/*	reset some things to default settings	*/	call STR32(DefDev,DefSec,tmp);	call ADD16(Info#AEEDefaults,tmp);	call Read.Defaults(D#In|D#Out|D#Samp|D#SIn|D#SDisp|D#SOffs|							 D#FDisp|D#FOffs|D#RecM|D#DForm,tmp(0),tmp(1));	call Update.AEE.Defaults(D#In|D#Out|D#Samp|D#SIn|D#SDisp|D#SOffs|									 D#FDisp|D#FOffs|D#RecM|D#DForm);end CREATE.NEW.PROJECT;dcl SET.ONEBAR.SBAR proc (fixed) recursive;PROCESS.ALLBAR.EVENT: proc swapable;	dcl waste(20)	fixed;	dcl i			fixed;	dcl SelProj	fixed;	/*	designates which proj user has selected	*/	if Screen.Event.Id = Project.Allbar.ShowProj.Label then do;		if Screen.Event.Info = S#MouseSelect then do;			if Project.Manager.Command <> 0 then				call Cancel.Pending.Allbar.Command;			call Define.Project.Manager.Onebar(Project.Manager.Row,Project.Manager.Size);			/*	limit top drive to valid range when changing	*/			/*	size of pmgr:											*/			if (Project.Onebar.Top.Drive + (Project.Manager.Size-3)) > DTD.Num.Voices			then Project.Onebar.Top.Drive = DTD.Num.Voices - (Project.Manager.Size-3);			if Project.Onebar.Top.Drive <0			then Project.Onebar.Top.Drive = 0;			call SET.ONEBAR.SBAR(Project.Onebar.Top.Drive);			disable.deposits = 1;			call Deposit.Fixed.Point(Project.Onebar.Size, Project.Manager.Size-3);			disable.deposits = 0;			Display.New.Project.Info = (-1);	/*	update display for all tracks	*/		end;	end;	else if (Screen.Event.Id >= Project.Allbar.SwitchProj.Label)	&		  (Screen.Event.Id <= Project.Allbar.EraseAll.Label  )	then do;		if Screen.Event.Info = S#MouseSelect		then do;	/*	ignore if user reselected current command	*/			if Project.Manager.Command<>Screen.Event.Id then do;				/*	cancel pending command, if any	*/				if Project.Manager.Command <>0 then					call Cancel.Pending.Allbar.Command;				/*	then select new command	*/				call Allbar.Command.Activate(Screen.Event.Id);			end;			else call Select.New.Cur.Obj(Corner.Label,-1,-1);		end;	end;	else if Screen.Event.Id = Project.Manager.OK.Button then do;		if Screen.Event.Info = S#MouseSelect then do;			do case Project.Manager.Command - Project.Allbar.SwitchProj.Label;				call Select.One.Project(Allbar.Select.Bits);				call Create.New.Project;				call Set.Project.Locks (Allbar.Select.Bits);				call Erase.DTD.Projects(Allbar.Select.Bits);				call Erase.DTD.Projects(Allbar.Select.Bits);			end;			call Display.Project.Line;		/*	update display quickly	*/			call Cancel.Pending.Allbar.Command;		end;	end;	else if Screen.Event.Id = Project.Manager.Cancel.Button then do;		if Screen.Event.Info = S#MouseSelect then do;			call Cancel.Pending.Allbar.Command;		end;	end;	else if Screen.Event.Id = Project.Allbar.Track.Region then do;		if (Screen.Event.Info = S#MouseSelect  )		or (Screen.Event.Info = S#MouseActivate)		then do;			if Project.Manager.Command <> 0  then do;				if Project.Manager.Command = Project.Allbar.SwitchProj.Label then do;					/*	determine which proj was selected	*/					SelProj = Map.Project.Selection(mouse(press.x)-gpos.x(300));					/*	highlight only that project		*/					if (SelProj <> (-1) )	/*	if on a proj	*/					then do;						call CLEAR.SELECTED.PROJECTS;						call SET.PROJECT.HIGHLIGHT (SelProj,1);					end;				end;				else if Project.Manager.Command = Project.Allbar.EraseAll.Label then do;					SelProj = Map.Project.Selection(mouse(press.x)-gpos.x(300));					if SelProj <> (-1)					then do;						call Fetch.DTD.Song.Directory(SelProj);						write(mam) = SCSI.Ptr;						write(mal) = 17;	/*	Status word	*/						if (read(mdi)&Bit1) <> 0	/*	project is locked	*/						then do;							call COPY.STRING('Project is Locked - Cannot Erase',Misc.Buf);							call set.error(err.lod,Misc.Buf);						end;						else call Toggle.Project.Highlight(SelProj);	/*	Allbar.Select.Bits set here	*/					end;				end;				else do;	/*	allow user to choose as many projects as he wants	*/					SelProj = Map.Project.Selection(mouse(press.x)-gpos.x(300));					if SelProj <> (-1)					then call Toggle.Project.Highlight(SelProj);	/*	Allbar.Select.Bits set here	*/				end;			end;		end;	end;end PROCESS.ALLBAR.EVENT;/*	this routine sets the highlights for all displayed tracks	*//*	based upon the global variable 'Onebar.Select.Bits'		*/SET.PROJECT.MANAGER.COMMAND.HIGHLIGHTS: proc swapable;	dcl i							fixed;	do i = 0 to Project.Manager.Size-4;		if ((Project.Manager.Command									  ) =0)	/*	if no command outstanding	*/		or ((Onebar.Select.Bits&Bits(i+Project.Onebar.Top.Drive)) =0)	/*	or trk not selected			*/		then do;			call Set.Table.Cell.Attr(Project.Onebar.Name.Table,0,i,0,ATTR#Normal);			call Set.Table.Cell.Attr(Project.Onebar.Name.Table,0,i,1,ATTR#Normal\ATTR#Reverse);		end;		else do;			call Set.Table.Cell.Attr(Project.Onebar.Name.Table,0,i,0,ATTR#AltIntensity\ATTR#Reverse);			call Set.Table.Cell.Attr(Project.Onebar.Name.Table,0,i,1,ATTR#AltIntensity\ATTR#Reverse);		end;	end;end SET.PROJECT.MANAGER.COMMAND.HIGHLIGHTS;CHECK.PROJECT.MANAGER.COMMAND.TOGGLE: proc swapable;	dcl Actual.Table.Row		fixed;	if  ((Project.Manager.Command			 <> 0))	and ((Screen.Event.Info = S#MouseSelect  )	or   (Screen.Event.Info = S#MouseActivate)	or   (Screen.Event.Info = S#Deposit		  ))	/*	so the switches work	*/	then do;		Actual.Table.Row = Screen.Event.Table.Row + Project.Onebar.Top.Drive;		Onebar.Select.Bits = Onebar.Select.Bits xor bits(Actual.Table.Row);		call SET.PROJECT.MANAGER.COMMAND.HIGHLIGHTS;		call Select.New.Cur.Obj(Corner.Label,-1,-1);	/*	put cursor at corner during project.manager.comands	*/	end;end CHECK.PROJECT.MANAGER.COMMAND.TOGGLE;/*	$page - swap proc to handle onebar scroll bar							*//*	Computes which drive should be displayed at the top of				*//*	Show Proj panel, given position (in percent) of scroll bar box.	*//*	Used when depositing scroll bar.												*/COMPUTE.TOP.DRIVE: proc (percent) returns (fixed) swapable;	dcl percent				fixed;	dcl Num.Top.Drives	fixed;	/*	Always display from track 0 if project manager is bigger	*/	/*	than number of tracks:												*/	if (Project.Manager.Size-3) >= DTD.Num.Voices	then return 0;	Num.Top.Drives = DTD.Num.Voices - (Project.Manager.Size-3) + 1;	load Num.Top.Drives;	/*	get # of top drive lines	*/	uload 500;				/*	round up by .5%				*/	mul percent;			/*	times %, 0 - 1000				*/	mwait;					/*	wait								*/	div 1000;	if res >= Num.Top.Drives			/*	limit round up to		*/	then return Num.Top.Drives - 1;	/*	largest legit line	*/	else return res;end COMPUTE.TOP.DRIVE;/*	Routine to set position of scroll bar	*//*	to match top drive							*/SET.ONEBAR.SBAR: proc (New.Top.Drive) swapable;	dcl New.Top.Drive	fixed;		/*	pass drive # of top row	*/	dcl Num.Top.Drives	fixed;	dcl sbarpos			fixed;	/*	compute # of top lines possible:	*/	Num.Top.Drives = DTD.Num.Voices - (Project.Manager.Size-3) + 1;	if Num.Top.Drives < 1 then Num.Top.Drives = 1;	if   New.Top.Drive < 0	then New.Top.Drive = 0;	else if New.Top.Drive > (Num.Top.Drives-1)	then	  New.Top.Drive = (Num.Top.Drives-1);	if Num.Top.Drives = 1	then sbarpos = 0;	else do;		load 1000;								/*	get 1000					*/		uload shr(Num.Top.Drives-1,1);	/*	round by 1/2 drive	*/		mul  New.Top.Drive;					/*	times top drive		*/		mwait;		div Num.Top.Drives-1;		sbarpos = res;							/*	0 - 1000					*/	end;	Disable.Deposits = true;	call Deposit.Scroll.Bar(Project.Onebar.Scroll.Bar, sbarpos);	Disable.Deposits = false;end SET.ONEBAR.SBAR;SET.ONEBAR.DISPLAY: proc (New.Top.Drive) swapable;	dcl New.Top.Drive	fixed;		/*	pass drive # of top row	*/	dcl Num.Top.Drives	fixed;	/*	compute # of top lines possible:	*/	Num.Top.Drives = DTD.Num.Voices - (Project.Manager.Size-3) + 1;	if Num.Top.Drives < 1 then Num.Top.Drives = 1;	if   New.Top.Drive < 0	then New.Top.Drive = 0;	else if New.Top.Drive > (Num.Top.Drives-1)	then	  New.Top.Drive = (Num.Top.Drives-1);	call SET.ONEBAR.SBAR (New.Top.Drive);				/*	set scroll bar and	*/	call Update.Object(Project.Onebar.Scroll.Bar);	/*	update SNAPPILY		*/	Project.Onebar.Top.Drive = New.Top.Drive;	Display.New.Project.Info = (-1);	/*	update display for all tracks	*/	call SET.PROJECT.MANAGER.COMMAND.HIGHLIGHTS;	/*	and highlights		*/end SET.ONEBAR.DISPLAY;/*	$page - routine to handle scroll bar events	*/Handle.Onebar.Scroll.Bar:proc swapable;	dcl i						fixed;	dcl New.Top.Drive		fixed;	dcl Num.Top.Drives	fixed;	if (Project.Manager.Size-3) >= DTD.Num.Voices	then Num.Top.Drives = 1;	else Num.Top.Drives = DTD.Num.Voices - (Project.Manager.Size-3) + 1;	if Screen.Event.Info = S#Deposit then do;		i = Fetch.Scroll.Bar(Project.Onebar.Scroll.Bar);	/*	get %		*/		New.Top.Drive = Compute.Top.Drive(i);					/*	drive #	*/		if New.Top.Drive <> Project.Onebar.Top.Drive then do;			/*	One deposit, just scroll display; leave sbar where	*/			/*	the user dropped it:											*/			Project.Onebar.Top.Drive = New.Top.Drive;			Display.New.Project.Info = (-1);	/*	update display for all tracks	*/			call SET.PROJECT.MANAGER.COMMAND.HIGHLIGHTS;		end;	end;	else if Screen.Event.Info = S#SBArrowForward then do;		if (Project.Onebar.Top.Drive+1)+(Project.Manager.Size-3) <= DTD.Num.Voices then do;			call SET.ONEBAR.DISPLAY (Project.Onebar.Top.Drive+1);		end;	end;	else if Screen.Event.Info = S#SBArrowBack then do;		if Project.Onebar.Top.Drive - 1 >= 0 then do;			call SET.ONEBAR.DISPLAY (Project.Onebar.Top.Drive-1);		end;	end;	else if Screen.Event.Info = S#SBPageForward then do;		New.Top.Drive = Project.Onebar.Top.Drive + (Project.Manager.Size-3);		if   New.Top.Drive > (Num.Top.Drives-1)		then New.Top.Drive = (Num.Top.Drives-1);		if (New.Top.Drive <> Project.Onebar.Top.Drive)		then do;			call SET.ONEBAR.DISPLAY (New.Top.Drive);		end;	end;	else if Screen.Event.Info = S#SBPageBack then do;		New.Top.Drive = Project.Onebar.Top.Drive - (Project.Manager.Size-3);		if   New.Top.Drive < (0)		then New.Top.Drive = (0);		if (New.Top.Drive <> Project.Onebar.Top.Drive)		then do;			call SET.ONEBAR.DISPLAY (New.Top.Drive);		end;	end;end Handle.Onebar.Scroll.Bar;/*	$page - handle onebar event	*/dcl CLOSE.PROJECT.MANAGER.PANEL proc			recursive;dcl OPEN.PROJECT.MANAGER.PANEL  proc (fixed)	recursive;PROCESS.ONEBAR.EVENT: proc swapable;	dcl waste(20)	fixed;	dcl i				fixed;	dcl rec(CUE.HIST.REC.LEN - 1)	fixed;	if Screen.Event.Id = Project.Onebar.ShowAll then do;		if Screen.Event.Info = S#MouseSelect then do;			Onebar.Select.Bits = 0;			call Display.Project.Manager.Prompt(0,0);	/*	Clear prompt (if any)	*/			Project.Manager.Command = 0;			call Define.Project.Manager.Allbar(Project.Manager.Row,Project.Manager.Size);			call Display.All.Projects;		end;	end;	/*	Detect click on ok button, or double click on 'ALL' commands:	*/	else if ((Screen.Event.Id	= Project.Manager.OK.Button))	or		  ((Screen.Event.Id	= Project.Manager.Command	)	and		(Screen.Event.Id >= Project.Onebar.AllRepro	)	and		(Screen.Event.Id <= Project.Onebar.AllSafe	))	then do;		if Screen.Event.Info = S#MouseSelect then do;			do case Project.Manager.Command - Project.Onebar.AllRepro;				call Set.DTD.Drive.Mode(0,Onebar.Select.Bits);		/*	All Repro	*/				call Set.DTD.Drive.Mode(1,Onebar.Select.Bits);		/*	All Input	*/				call Set.DTD.Drive.Mode(2,Onebar.Select.Bits);		/*	All Auto		*/				call Set.DTD.Drive.Mode(3,Onebar.Select.Bits);		/*	All Cue PB	*/				call Set.DTD.Drive.Status(0,Onebar.Select.Bits);	/*	All Safe		*/				call Set.DTD.Drive.Status(2,Onebar.Select.Bits);	/*	Lock			*/				call Set.DTD.Drive.Status(3,Onebar.Select.Bits);	/*	Unlock		*/				do;					/*	log refresh to Quick Updates on track erase	*/					call Build.Proj.Hist.Rec (AEE.Current.Project, 3, rec);					call Add.Cue.To.Hist (rec);					call Erase.DTD.Drives(Onebar.Select.Bits);	/*	Erase	*/					call WAIT.FOR.DTD.COMMAND.TO.FINISH;				end;			end;			call Display.Project.Manager.Prompt(0,0);	/*	Erase and undefine prompt line	*/			/*	update tallies and aee screen as appropriate	*/			do case Project.Manager.Command - Project.Onebar.AllRepro;				call Update.AEE.Track.Status.Displays.And.Tallies (Onebar.Select.Bits,0);	/*	All Repro	*/				call Update.AEE.Track.Status.Displays.And.Tallies (Onebar.Select.Bits,0);	/*	All Input	*/				call Update.AEE.Track.Status.Displays.And.Tallies (Onebar.Select.Bits,0);	/*	All Auto		*/				call Update.AEE.Track.Status.Displays.And.Tallies (Onebar.Select.Bits,0);	/*	All Cue PB	*/				call Update.AEE.Track.Status.Displays.And.Tallies (0,Onebar.Select.Bits);	/*	All Safe		*/				do;	/*	update switch contents on lock/unlock	*/					Display.New.Project.Info = Display.New.Project.Info													 \ Onebar.Select.Bits;				end;				do;					Display.New.Project.Info = Display.New.Project.Info													 \ Onebar.Select.Bits;				end;				do;					Display.New.Project.Info = (-1);	/*	update display for all tracks	*/					call UPDATE.ALLOCATE.TIMES;		/*	and allocate times may change	*/				end;			end;			Onebar.Select.Bits		= 0;			Project.Manager.Command	= 0;			/*	No command pending now	*/			call SET.PROJECT.MANAGER.COMMAND.HIGHLIGHTS;		end;	end;	else if Screen.Event.Id = Project.Manager.Cancel.Button then do;		if Screen.Event.Info = S#MouseSelect then do;			call Display.Project.Manager.Prompt(0,0);	/*	Clear prompt	*/			Onebar.Select.Bits		= 0;			Project.Manager.Command	= 0;			call SET.PROJECT.MANAGER.COMMAND.HIGHLIGHTS;		end;	end;	else if Screen.Event.Id = Project.Onebar.Name.Table then do;		if (Screen.Event.Info = S#Deposit)		then do;			call Fetch.Table(Project.Onebar.Name.Table,Screen.Event.Table.Col,Screen.Event.Table.Row);			call Fetch.String(Project.Onebar.Name.Type,waste);			call Set.DTD.Drive.Name(Project.Onebar.Top.Drive+Screen.Event.Table.Row,waste);			Display.New.Project.Info = Display.New.Project.Info											 \ bits(Project.Onebar.Top.Drive+Screen.Event.Table.Row);		end;		call Check.Project.Manager.Command.Toggle;	end;	else if (Screen.Event.Id >= Project.Onebar.AllRepro)	&		  (Screen.Event.Id <= Project.Onebar.EraseDrive)	then do;		if Screen.Event.Info = S#MouseSelect		then do;			/*	cancel pending command, if any	*/			if Project.Manager.Command <>0 then do;				call Display.Project.Manager.Prompt(0,0);	/*	Clear prompt	*/				Onebar.Select.Bits		= 0;				Project.Manager.Command	= 0;				call SET.PROJECT.MANAGER.COMMAND.HIGHLIGHTS;			end;			/*	then select new command	*/			call Onebar.Command.Activate(Screen.Event.Id);		end;	end;	else if Screen.Event.Id = Project.Onebar.Scroll.Bar then do;		call Handle.Onebar.Scroll.Bar;	end;	else if Screen.Event.Id = Project.Onebar.Status.Table then do;		if Screen.Event.Info = S#Deposit then do;			call Fetch.Table(Project.Onebar.Status.Table,Screen.Event.Table.Col,Screen.Event.Table.Row);			waste(0) = Fetch.Switch(Project.Onebar.Status.Type);			if waste(0) ige 2 then waste(0) = 1;	/*	limit this change to safe/ready only - can not go to locked	*/			call Set.DTD.Drive.Status(waste(0),bits(Project.Onebar.Top.Drive+Screen.Event.Table.Row));			call Update.AEE.Track.Status.Displays.And.Tallies (0,bits(Project.Onebar.Top.Drive+Screen.Event.Table.Row));		end;		call Check.Project.Manager.Command.Toggle;	end;	else if Screen.Event.Id = Project.Onebar.Mode.Table then do;		if Screen.Event.Info = S#Deposit then do;			call Fetch.Table(Project.Onebar.Mode.Table,Screen.Event.Table.Col,Screen.Event.Table.Row);			waste(0) = Fetch.Switch(Project.Onebar.Mode.Type);			call Set.DTD.Drive.Mode(waste(0),bits(Project.Onebar.Top.Drive+Screen.Event.Table.Row));			call Update.AEE.Track.Status.Displays.And.Tallies (bits(Project.Onebar.Top.Drive+Screen.Event.Table.Row),0);		end;		call Check.Project.Manager.Command.Toggle;	end;	else if (Screen.Event.Id = Project.Onebar.Source.Table )	or		  (Screen.Event.Id = Project.Onebar.Channel.Table)	then do;		if Screen.Event.Info = S#Deposit then do;			call Fetch.Table(Project.Onebar.Source.Table,Screen.Event.Table.Col,Screen.Event.Table.Row);			call Fetch.Table(Project.Onebar.Channel.Table,Screen.Event.Table.Col,Screen.Event.Table.Row);			waste(0) = shl(Fetch.Switch(Project.Onebar.Source.Type),8)						\		Fetch.Switch(Project.Onebar.Channel.Type);			/*	give error if trying to change DIG input routing if using	*/			/*	multi track DDT hardware.												*/			if  (Screen.Event.Id = Project.Onebar.Channel.Table)	/*	if changing channel #	*/			and ((ddt.config & 15) = 2)									/*	using multi trk hrdware	*/			and (Fetch.Switch(Project.Onebar.Source.Type) = 1)		/*	and source is dig			*/			then call set.error(err.ddt.routs,'');			else call Set.DTD.Drive.Parameter(Project.Onebar.Top.Drive+Screen.Event.Table.Row,0,waste(0));			Display.New.Project.Info = Display.New.Project.Info											 \ bits(Project.Onebar.Top.Drive+Screen.Event.Table.Row);		end;		call Check.Project.Manager.Command.Toggle;	end;	else if Screen.Event.Id = Project.Onebar.Gain.Table then do;		if Screen.Event.Info = S#Deposit then do;			call Fetch.Table(Project.Onebar.Gain.Table,Screen.Event.Table.Col,Screen.Event.Table.Row);			waste(0) = Fetch.Fixed.Point(Project.Onebar.Gain.Type);			if waste(0) > 28 then waste(0) = 28;	/*	Limit gain in decibels	*/			if waste(0) < -3 then waste(0) = -3;			call Set.DTD.Drive.Parameter(Project.Onebar.Top.Drive +												  Screen.Event.Table.Row, 1,												  map_dB_to_times (waste(0)));	/*	Send "times" gain to LOD and ext. mem.	*/			Display.New.Project.Info = Display.New.Project.Info											 \ bits(Project.Onebar.Top.Drive+Screen.Event.Table.Row);		end;		call Check.Project.Manager.Command.Toggle;	end;	else if Screen.Event.Id = Project.Onebar.Out.Table then do;		if Screen.Event.Info = S#Deposit then do;			call Fetch.Table(Project.Onebar.Out.Table,Screen.Event.Table.Col,Screen.Event.Table.Row);			waste(0) = Fetch.Fixed.Point(Project.Onebar.Out.Type);			if  (waste(0) > DTD.Max.Tracks)	/*	limit to voices/tracks	*/			and (waste(0) > DTD.Num.Voices)			then do;				if DTD.Num.Voices = 0				then waste(0) = DTD.Max.Tracks;				else waste(0) = DTD.Num.Voices;			end;			if waste(0) < 0  then waste(0) = 0;			call Set.DTD.Drive.Parameter(Project.Onebar.Top.Drive +												  Screen.Event.Table.Row, 5,												  waste(0));			Display.New.Project.Info = (-1);	/*	must update all rows on OUT change	*/		end;		call Check.Project.Manager.Command.Toggle;	end;	else if Screen.Event.Id = Project.Onebar.Vol.Table then do;		if Screen.Event.Info = S#Deposit then do;			call Fetch.Table(Project.Onebar.Vol.Table,Screen.Event.Table.Col,Screen.Event.Table.Row);			waste(0) = Fetch.Fixed.Point(Project.Onebar.Vol.Type);			if waste(0) > 1000 then waste(0) = 1000;			call Set.DTD.Drive.Parameter(Project.Onebar.Top.Drive+Screen.Event.Table.Row,2,waste(0));			Display.New.Project.Info = Display.New.Project.Info											 \ bits(Project.Onebar.Top.Drive+Screen.Event.Table.Row);		end;		call Check.Project.Manager.Command.Toggle;	end;	else if Screen.Event.Id = Project.Onebar.Pan.Table then do;		if Screen.Event.Info = S#Deposit then do;			call Fetch.Table(Project.Onebar.Pan.Table,Screen.Event.Table.Col,Screen.Event.Table.Row);			waste(0) = Fetch.Fixed.Point(Project.Onebar.Pan.Type);			if		  waste(0) < -50 then waste(0) = -50;			else if waste(0) >  50 then waste(0) =  50;			call Set.DTD.Drive.Parameter(Project.Onebar.Top.Drive+Screen.Event.Table.Row,3,waste(0));			Display.New.Project.Info = Display.New.Project.Info											 \ bits(Project.Onebar.Top.Drive+Screen.Event.Table.Row);		end;		call Check.Project.Manager.Command.Toggle;	end;	else if Screen.Event.Id = Project.Onebar.DDT.Table then do;		if Screen.Event.Info = S#Deposit then do;			call Fetch.Table(Project.Onebar.DDT.Table,Screen.Event.Table.Col,Screen.Event.Table.Row);			waste(0) = Fetch.Fixed.Point(Project.Onebar.DDT.Type);			if waste(0) > 2 then waste(0) = 2;			if waste(0) < 0 then waste(0) = 0;			if ((ddt.config & 15) = 2)	/*	multi track DDT avail	*/			then call set.error(err.ddt.routs,'');			else call Set.DTD.Drive.Parameter(Project.Onebar.Top.Drive+Screen.Event.Table.Row,6,waste(0));			Display.New.Project.Info = (-1);	/*	must update all rows on DDT change	*/		end;		call Check.Project.Manager.Command.Toggle;	end;	else if (Screen.Event.Id = Project.Onebar.Used.Table )		  or (Screen.Event.Id = Project.Onebar.Voice.Table)	then do;		call Check.Project.Manager.Command.Toggle;		call Select.New.Cur.Obj(Corner.Label,-1,-1);	/*	put cursor at corner during project.manager.comands	*/	end;	else if Screen.Event.Id = Project.Onebar.Size then do;		if (Screen.Event.Info = S#Deposit)		then do;			i = Fetch.Fixed.Point(Project.Onebar.Size);			if i < 1 then i = 1;			if i > DTD.Num.Voices then i = DTD.Num.Voices;			if i <> (Project.Manager.Size-3)			then do;				Project.Manager.User.Size = i+4;	/*	set new preferred size	*/				call Close.Project.Manager.Panel;				call Open.Project.Manager.Panel(Project.Manager.User.Size);			end;			else do;	/*	fix up display if incorrect size enterred	*/				disable.deposits = 1;				call Deposit.Fixed.Point(Project.Onebar.Size, Project.Manager.Size-3);				disable.deposits = 0;			end;		end;	end;end PROCESS.ONEBAR.EVENT;GET.PROJECT.MANAGER.EVENT: proc (event) returns (fixed) public swapable;	dcl event		fixed;	dcl waste (20)	fixed;	dcl i				fixed;	do while 1;		if event <> Get.Null.Event then do;			if Screen.Event.Group <> Project.Manager.Group then return event;			if Screen.Event.Code = Get.Screen.Event then do;				if Screen.Event.Id = Project.Switch.Id then do;					if Screen.Event.Info = S#MouseSelect then do;						call Handle.Shuttle.Project.Switch (0,																		0, Project.Name.Id,																		Project.Number.Id, 1000);					end;				end;				else if Screen.Event.Id = Project.Number.Id then do;					if Screen.Event.Info = S#Deposit then do;						call Handle.Shuttle.Project.Switch (0,																		0, Project.Name.Id,																		Project.Number.Id,																		Fetch.Fixed.Point(Project.Number.Id));					end;				end;				else if Screen.Event.Id = Project.Name.Id then do;					if Screen.Event.Info = S#Deposit then do;						call Fetch.String(Project.Name.Id,waste);						call Set.DTD.Project.Name(waste);						call Update.Audio.Event.Editor;					end;				end;				else if Screen.Event.Id = Project.Start.Time then do;					if Screen.Event.Info = S#Deposit then do;						call Fetch.32Bit.MSEC(Project.Start.Time,waste);						load  waste(1);						uload waste(0);						div	1000;						waste(0) = res + (rem > 500);						call Set.DTD.Project.Parameter(0,waste(0));						call Display.Project.Line;					end;				end;				else if Screen.Event.Id = Project.End.Time then do;					if Screen.Event.Info = S#Deposit then do;						call Fetch.32Bit.MSEC(Project.End.Time,waste);						load  waste(1);						uload waste(0);						div	1000;						waste(0) = res + (rem > 500);						call Set.DTD.Project.Parameter(1,waste(0));						call Display.Project.Line;					end;				end;				else if Screen.Event.Id = Project.Rate then do;					if Screen.Event.Info = S#Deposit then do;						waste(0) = Fetch.Fixed.Point(Project.Rate);						call Set.DTD.Project.Parameter(2,waste(0));						call Display.Project.Line;					end;				end;				else if Project.Manager.Mode = 1				then call Process.Allbar.Event;				else if Project.Manager.Mode = 2				then call Process.Onebar.Event;			end;		end;		event = Get.Next.Screen.Event;	end;end GET.PROJECT.MANAGER.EVENT;