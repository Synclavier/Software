/* AUD-CUE1 - more cue/shuttle editor   Modified:   11/14/89 - MWH - Fix occasional cue editor display bug (misc.buf re-used)   06/14/89 - SGS - broke some more things in the optical disk code   05/23/89 - SGS - added call to STUFF.CATEGORY.INTO.TABLE   05/17/89 - SGS - Fixed lots of bugs for alpha release   05/05/89 - cj  - preserve other cue.bits in various routines   05/03/89 - TSS - Merged changes for Optical disk to DTD transfer project   04/20/89 - SGS - Added Optical.Group to update procs   11/30/88 - MWH - Declare network event when reel buttons are changed   10/24/88 - cj  - fixed update/misc.buf/crash problem with TSM                    cue name   10/03/88 - cj  - remapped cue durations upon user input if using                    live click track   09/18/88 - cj  - fixed bytes/words mix up in display cue and shuttle displays   09/07/88 - MWH - Add "real" DSP user interface   08/08/88 - cj  - store absolute # of smpte bits in cue record   06/01/88 - TSS - made even more procs in order to shrink cue module   *//* Forward references for cue editor */dcl Get.Cue.Dialog               proc (fixed, fixed) recursive;dcl Close.Edit.Command.Dialog    proc                recursive;dcl Set.Shuttle.Flags.And.Edits  proc                recursive;dcl Set.Anchor.Time              proc (array, fixed) recursive;dcl Deposit.Shuttle.Time.Display proc (array)        recursive;dcl Select.Time.Field            proc (fixed)        recursive;dcl Handle.AEE.Cue.Place         proc (array, fixed) recursive;/* $page - handle new name, comment *//* store new cue name is passed a newly entered cue name.  *//* it stores that name in the cue record in ext memory,    *//* and also sets up the name displays on the screen        */STORE.NEW.CUE.NAME:proc (name) swapable;   dcl name                 array;   dcl i                    fixed;   /* Store this new name in the current cue:              */   i = Assign.New.DTD.Cue.Name(name);   /* If name was too long to fit,  present error message: */   if i = 0 then do;      call DISPLAY.NOTICE (NT#CueRecordTooLong,ATTR#Reverse,NulStr,0,0,0);      /* set bit to re-deposit correct current name in our panels: */      new.ABLE.dtd.info = new.ABLE.dtd.info \ 256;      return;   end;   /* Quickly update various displays to provide a snappy response: */   disable.deposits = 1;   if Shuttle.Group <> 0 then do;      call Deposit.String(Shuttle.Name.Id,name);      call Update.Object(Shuttle.Name.Id);   end;   if Cue.Group     <> 0 then do;      call Deposit.String(Cue.Name.Id,name);      call Update.Object(Cue.Name.Id);   end;   if Record.Group  <> 0 then do;      call Deposit.Graphics.String(Record.TSM.Name.Id,name);      /* Don't update object here since it's not always active when record panel is up */   end;   if (Optical.Group <> 0) and (GID(AEE.Opt.Width.Mode)<>0) then do;      call Deposit.String(Optical.Cue.Name,name);      call Update.Object(Optical.Cue.Name);   end;   disable.deposits = 0;   if Record.Group <> 0            /* keep record panel up to date          */   then call Set.Record.Cue.Lock.Times;end STORE.NEW.CUE.NAME;/* store a new caption */STORE.NEW.CUE.CAPTION:proc (capt) swapable;   dcl capt				array;   dcl i					fixed;   dcl tmp.buf (14)	fixed;	//	max 63-35 = 28 characters										//	max 63 characters	in capt, 35 characters will go in the row zero of Optical.Capt.Type.Obj()   /* Store the new caption in the current cue: */   i = Assign.New.DTD.Cue.Caption(capt);   /* if out of memory,  present an error message: */   if i = 0 then do;      call DISPLAY.NOTICE (NT#CueRecordTooLong,ATTR#Reverse,NulStr,0,0,0);      /* set bit to re-deposit correct current name in our panels: */      new.ABLE.dtd.info = new.ABLE.dtd.info \ 256;      return;   end;   /* Quickly update various displays: */   disable.deposits = 1;   if Shuttle.Group <> 0 then do;      call Deposit.String(Shuttle.Comment.Id,capt);   end;   if Cue.Group     <> 0 then do;      call Deposit.String(Cue.Comment.Id,capt);   end;   if (Optical.Group <> 0) and (GID(AEE.Opt.Width.Mode)<>0)   then do;      i = Fetch.Object.Info(Optical.Capt.Type.Obj,O#STR.Max.Chars);//		note: everything in the following two lines is handled automatically by Split.String()//		if capt(0) igt i then call Split.String(capt,i,tmp.buf);//		else tmp.buf(0)=0;		Split.String(capt,i,tmp.buf);      call Fetch.Table(Optical.Caption.String,0,0);      call Deposit.String(Optical.Capt.Type.Obj,capt);      call Deposit.Table(Optical.Caption.String,0,0);      call Fetch.Table(Optical.Caption.String,0,1);      call Deposit.String(Optical.Capt.Type.Obj,tmp.buf);      call Deposit.Table(Optical.Caption.String,0,1);      call Update.Object(Optical.Caption.String);   end;   disable.deposits = 0;end STORE.NEW.CUE.CAPTION;/* $page - handy routine to quickly display name of current cue            *//* Note:   here is a trick:  when the user clicks somewhere to change      *//* the current cue (for example scroll forward to the next cue in the      *//* cue directory), quickly update the cue name field.  Let the normal      *//* "event" processing update the rest of the screen when we can.           */Display.AEE.Cue.Names: proc public swapable;   dcl buf(16) fixed;   disable.deposits = 1;   if Cue.Group<>0 then do;      write(mam) = Current.Cue.Ptr;      write(mal) = CUE.NAME;      call COPY.IN(addr(buf(0)),17);      call Deposit.String(Cue.Name.Id,buf);      call Update.Object(Cue.Name.Id);      call Check.Next.Event;      /* keep mouse going for speedy operation */   end;   if Shuttle.Group<>0 then do;      write(mam) = Current.Cue.Ptr;      write(mal) = CUE.NAME;      call COPY.IN(addr(buf(0)),17);      call Deposit.String(Shuttle.Name.Id,buf);      call Update.Object(Shuttle.Name.Id);      call Check.Next.Event;      /* keep mouse going for speedy operation */   end;   if Record.Group<>0 then do;      write(mam) = Current.Cue.Ptr;      write(mal) = CUE.NAME;      call COPY.IN(addr(buf(0)),17);      call Deposit.Graphics.String(Record.TSM.Name.Id,buf);      /* Don't update object here since it's not always active when record panel is up */      call Check.Next.Event;      /* keep mouse going for speedy operation */   end;   if  (Optical.Group<>0) then do;      if (GID(AEE.Opt.Width.Mode)<>0) then do;         write(mam) = Current.Cue.Ptr;         write(mal) = CUE.NAME;         call COPY.IN(addr(buf(0)),17);         call Deposit.String(Optical.Cue.Name,buf);         call Update.Object(Optical.Cue.Name);      end;      call Check.Next.Event;      /* keep mouse going for speedy operation */   end;   disable.deposits = 0;end Display.AEE.Cue.Names;/* $page - deposit cue and shuttle displays                  */Display.Cue.And.Shuttle.Displays:proc public swapable;    dcl cue.record (CUE.NAME-1) fixed;   dcl rlen                    fixed;   dcl nlen                    fixed;   dcl clen                    fixed;   dcl MaxLen                  fixed;   dcl buf        (40)         fixed;   dcl second.buf (40)         fixed; /* holds strings for String objects */   dcl i                       fixed;   call Check.Next.Event;      /* keep mouse going for speedy operation */   /* present name of current cue on all panels: */   call Display.AEE.Cue.Names;   /* look up record length, name length (wrds), comment length (wrds) */   write(mam) = Current.Cue.Ptr;   write(mal) = CUE.RLEN;   rlen       = read(md);   write(mal) = CUE.NAME;   nlen       = shr(read(md)+3,1);   /* # of wrds in cue name  */   if rlen igt CUE.NAME+nlen   then do;      write(mal) = CUE.NAME+nlen;      clen       = read(md);         /* get comment len, bytes */   end;   else clen     = 0;                /* no comment in record   */   /* read in basic cue info up to just */   /* before name:                      */   write(mal) = 0;   call COPY.IN(addr(cue.record(0)),CUE.NAME);   /* Refresh all cue information on all panels: */   Disable.Deposits = true;   if Cue.Group <> 0 then do;      write(mam) = Current.Cue.Ptr;      if clen<>0 then do;         write(mal) = CUE.NAME+nlen;         call COPY.IN(addr(buf(0)),shr(clen+3,1));      end;      else buf(0) = 0;      call Deposit.String(Cue.Comment.Id,buf);      call Deposit.Fixed.Point(Cue.Fade.In.Time.Id,cue.record(CUE.FIN));      call Deposit.Fixed.Point(Cue.Fade.Out.Time.Id,cue.record(CUE.FOUT));      call Deposit.Switch(Cue.Offset.Switch,Current.Cue.Sync.Mode);   end;   if Shuttle.Group <> 0 then do;      write(mam) = Current.Cue.Ptr;      if clen<>0 then do;         write(mal) = CUE.NAME+nlen;         call COPY.IN(addr(buf(0)),shr(clen+3,1));      end;      else buf(0) = 0;      call Deposit.String(Shuttle.Comment.Id,buf);      call Deposit.Switch(Shuttle.Cue.Sync.Switch,Current.Cue.Sync.Mode);   end;   if (Optical.Group <> 0)   and (GID(AEE.Opt.Width.Mode)<>0) then do;      write(mam) = Current.Cue.Ptr;      if clen<>0 then do;         write(mal) = CUE.NAME+nlen;         call COPY.IN(addr(buf(0)),shr(clen+3,1));      end;      else buf(0) = 0;      if Opt.Caption.Locked=0 then do;         MaxLen = Fetch.Object.Info(Optical.Capt.Type.Obj,O#STR.Max.Chars);         if buf(0) igt MaxLen          then call Split.String(buf,MaxLen,second.buf);         else second.buf(0) = 0;         call Fetch.Table(Optical.Caption.String,0,0);         call Deposit.String(Optical.Capt.Type.Obj,buf);         call Deposit.Table(Optical.Caption.String,0,0);         call Fetch.Table(Optical.Caption.String,0,1);         call Deposit.String(Optical.Capt.Type.Obj,second.buf);         call Deposit.Table(Optical.Caption.String,0,1);         call Update.Object(Optical.Caption.String);      end;      if Opt.Category.Locked=0 then do;         buf(0) = 0;                 /* clear out table */         do i = 0 to Fetch.Object.Info(Optical.Category.Table,O#TABL.Down)-1;            call Stuff.Category.Into.Table(buf,i);         end;         call Fetch.String(Optical.Cue.Name,buf);         if buf(0)<>0 then do;       /* only fill in cats if there is a cue showing */            call Get.Default.Category(buf);            call Stuff.Category.Into.Table(buf,0);         end;         call Update.Object(Optical.Category.Table);      end;   end;   Disable.Deposits = false;   call Check.Next.Event;      /* keep mouse going for speedy operation */   call Display.Drive.Select.Bits;      /* display drives               */   call Display.Current.Cue.Protect;    /* display protect bit          */   call Deposit.Cue.Times.Display;      /* set cue trim & edit times    */   if Record.Group <> 0                 /* update record panel          */   then call Set.Record.Cue.Lock.Times;   if Shuttle.Group <> 0 then do;      call Set.Shuttle.Flags.And.Edits;   /* set in/out flags and edits */   end;end Display.Cue.And.Shuttle.Displays;/* $page - handle new cue in time *//* handle a new cue in time from any source */HANDLE.ANY.NEW.CUE.IN.TIME: proc (newintime,code,push) swapable;   dcl newintime array;    /* pass new in time, normally from terminal */   dcl code      fixed;    /* pass this code # to system routine       */   dcl push      fixed;    /* 1 = push old value on exchange stack     */   dcl i         fixed;   /* Use system routine,  then display our error messages:            */   i = ASSIGN.NEW.DTD.CUE.IN(newintime, code, push);   if i = 1   then call DISPLAY.NOTICE (NT#InTimeError,ATTR#Reverse,NulStr,0,0,0);   if i = 2   then call DISPLAY.NOTICE (NT#SyncTimeError,ATTR#Reverse,NulStr,0,0,0);end HANDLE.ANY.NEW.CUE.IN.TIME;/* handle new cue time typed in or taken: */HANDLE.NEW.CUE.IN.TIME: proc (id) swapable;   dcl Id        fixed;   dcl new (1)   fixed;   /* fetch newly typed in value into */   /* handy temp:                     */   call Fetch.32Bit.Msec(Id,new);  /* get new value typed in */   /* call common smart routine:      */   call HANDLE.ANY.NEW.CUE.IN.TIME(new, Current.Cue.Audition, 1);end HANDLE.NEW.CUE.IN.TIME;/* $page - handle a new cue out time */HANDLE.ANY.NEW.CUE.OUT.TIME: proc (newouttime,code,push,dur) swapable;   dcl newouttime  array;    /* pass new out time here                */   dcl code        fixed;    /* pass code to operating system         */   dcl push        fixed;    /* 1 = push on exchange stack            */   dcl dur         fixed;    /* 1 = newouttime is duration            */   dcl status      fixed;   status = ASSIGN.NEW.DTD.CUE.OUT(newouttime, code, push, dur);   if status = 1   then call DISPLAY.NOTICE (NT#InTimeError,ATTR#Reverse,NulStr,0,0,0);end HANDLE.ANY.NEW.CUE.OUT.TIME;HANDLE.NEW.CUE.OUT.TIME: proc (id,switch) swapable;   dcl Id      fixed;    /* Id of object containing new value */   dcl Switch  fixed;    /* Id of out/duration switch         */   dcl new (1) fixed;   /* fetch newly typed out value into */   /* handy temp:                      */   call Fetch.32Bit.Msec(ID,new);  /* get new value typed in */   call Handle.Any.New.Cue.Out.Time(new, Current.Cue.Audition, 1, Fetch.Switch(switch));end HANDLE.NEW.CUE.OUT.TIME;/* $page - handle a new cue sync time */HANDLE.NEW.CUE.SYNC.TIME: proc (Id) public swapable;   dcl Id         fixed;   dcl new    (1) fixed;   /* fetch newly typed in value into */   /* handy temp:                     */   call Fetch.32Bit.Msec(Id,new);  /* get new value typed in */   /* store checked value in */   /* global variable:       */      call COPY32(new,Cue.Sync.Time);      call UPDATE.CURRENT.CUE.RECORD;end HANDLE.NEW.CUE.SYNC.TIME;/* $page - handle change of edit times *//* when changing edit times, smart limits are applied.  We are passed *//* a code that tells us where the new number came from (in other      *//* words what to do with it).                                         *//*                                                                    *//* See the operating system Assign.New.DTD.Edit.In routine for        *//* a description of the codes.                                        *//*                                                                    *//* when entering times from the mouse, it is best to exchange the in  *//* and out times if they are out of order (makes good visual sense)   *//* when typing in values, it is best to change the other value when   *//* they are out of order.                                             */HANDLE.ANY.NEW.EDIT.IN.TIME: proc (newtime, code, push) swapable;   dcl newtime	array;	/* pass new offs time here			*/   dcl code		fixed;	/* pass code to operating system	*/   dcl push		fixed;	/* 1 = push prior value on stack	*/   dcl i			fixed;   i = ASSIGN.NEW.DTD.EDIT.IN(newtime, code, push);   if i = 1   then call DISPLAY.NOTICE (NT#EditTimeError,ATTR#Reverse,NulStr,0,0,0);   if i = 2   then call DISPLAY.NOTICE (NT#BadSlideIn,ATTR#Reverse,NulStr,0,0,0);   if i = 3   then call DISPLAY.NOTICE (NT#EditTimeError,ATTR#Reverse,NulStr,0,0,0);   if i = 4   then call DISPLAY.NOTICE (NT#EditTimeError,ATTR#Reverse,NulStr,0,0,0);   if i = 5   then call DISPLAY.NOTICE (NT#BadSlideOut,ATTR#Reverse,NulStr,0,0,0);end HANDLE.ANY.NEW.EDIT.IN.TIME;HANDLE.NEW.EDIT.IN.TIME: proc (id) swapable;   dcl Id        fixed;   dcl new (1)   fixed;   /* fetch newly typed in value into */   /* handy temp:                     */   call Fetch.32Bit.Msec(Id,new);  /* get new value typed in */   /* call common smart routine:      */   call HANDLE.ANY.NEW.EDIT.IN.TIME(new, Current.Cue.Audition, 1);end HANDLE.NEW.EDIT.IN.TIME;/* $page - handle new edit out time *//* We are also passed the code for the edit out time */HANDLE.ANY.NEW.EDIT.OUT.TIME: proc (newtime,code,push,dur) swapable;   dcl newtime	array;	/* pass new edit out time here	*/   dcl code		fixed;	/* pass code to operating system	*/   dcl push		fixed;	/* 1 = push prior value on stack	*/   dcl dur		fixed;	/* 1 = newtime is a duration		*/   dcl i			fixed;   i = ASSIGN.NEW.DTD.EDIT.OUT(newtime, code, push, dur);   if i = 1   then call DISPLAY.NOTICE (NT#EditTimeError,ATTR#Reverse,NulStr,0,0,0);   if i = 2   then call DISPLAY.NOTICE (NT#EditTimeError,ATTR#Reverse,NulStr,0,0,0);   if i = 3   then call DISPLAY.NOTICE (NT#BadSlideOut,ATTR#Reverse,NulStr,0,0,0);   if i = 4   then call DISPLAY.NOTICE (NT#EditTimeError,ATTR#Reverse,NulStr,0,0,0);   if i = 5   then call DISPLAY.NOTICE (NT#BadSlideIn,ATTR#Reverse,NulStr,0,0,0);end HANDLE.ANY.NEW.EDIT.OUT.TIME;HANDLE.NEW.EDIT.OUT.TIME: proc (id,switch) swapable;   dcl Id      fixed;    /* Id of object containing new value */   dcl Switch  fixed;    /* Id of out/duration switch         */   dcl new (1) fixed;   /* fetch newly typed out value into */   /* handy temp:                      */   call Fetch.32Bit.Msec(ID,new);  /* get new value typed in */   call Handle.Any.New.Edit.Out.Time(new, Current.Cue.Audition, 1, Fetch.Switch(switch));end HANDLE.NEW.EDIT.OUT.TIME;HANDLE.NEW.CUE.OFFS.TIME: proc (id, switch) swapable;   dcl Id      fixed;    /* Id of object containing new value */   dcl Switch  fixed;    /* Id of out/duration switch         */   dcl new (1) fixed;   /* fetch newly typed out value into */   /* handy temp:                      */   call Fetch.32Bit.Msec(ID,new);  /* get new value typed in */   /* If is a duration, compute new end time: */   if Fetch.Switch(switch) = 1   then do;      call ADD32(Cue.In.Time, new, new);   /* get abs offset time */      call HANDLE.ANY.NEW.EDIT.IN.TIME(new, 2, 1);   end;   /* Else assign this time to the edit in time: */   else do;      call HANDLE.ANY.NEW.EDIT.IN.TIME(new, Current.Cue.Audition, 1);   end;end HANDLE.NEW.CUE.OFFS.TIME;/* $page - change cue sync when changing pre/mid/post time */CHANGE.CUE.SYNC.MODE:proc (setting) swapable;   dcl setting fixed;   call ASSIGN.NEW.DTD.SYNC.MODE(setting);   disable.deposits = 1;   if Cue.Group <> 0   then call Deposit.Switch(Cue.Offset.Switch,setting);   if Shuttle.Group <> 0   then call Deposit.Switch(Shuttle.Cue.Sync.Switch,setting);   disable.deposits = 0;end CHANGE.CUE.SYNC.MODE;/* $page - handle exchange functions */EXCHANGE.IN.TIME:proc swapable;   dcl time(1) fixed;   call Pop.DTD.Cue.Time(Saved.AEE.Cue.In.Time,time);   if COM16(zero.time,time) = lw#igt   /* must check un-initialized */   then time(1) = zero.time;           /* data                      */   call HANDLE.ANY.NEW.CUE.IN.TIME(time, 2, 1);   call Set.Anchor.Time(Cue.In.Time,1);end EXCHANGE.IN.TIME;EXCHANGE.OUT.TIME:proc swapable;   dcl time(1) fixed;   call Pop.DTD.Cue.Time(Saved.AEE.Cue.Out.Time,time);   if COM16(zero.time,time) = lw#igt   /* must check un-initialized */   then time(1) = zero.time;           /* data                      */   call HANDLE.ANY.NEW.CUE.OUT.TIME(time, 2, 1, 0);   call Set.Anchor.Time(Cue.Out.Time,1);end EXCHANGE.OUT.TIME;EXCHANGE.EDIT.IN.TIME:proc swapable;   dcl time(1) fixed;   call Pop.DTD.Cue.Time(Saved.AEE.Edit.In.Time,time);   if COM16(zero.time,time) = lw#igt   /* must check un-initialized */   then time(1) = zero.time;           /* data                      */   call HANDLE.ANY.NEW.EDIT.IN.TIME(time, 2, 1);   call Set.Anchor.Time(Cue.Edit.In.Time,1);end EXCHANGE.EDIT.IN.TIME;EXCHANGE.EDIT.OUT.TIME:proc swapable;   dcl time(1) fixed;   call Pop.DTD.Cue.Time(Saved.AEE.Edit.Out.Time,time);   if COM16(zero.time,time) = lw#igt   /* must check un-initialized */   then time(1) = zero.time;           /* data                      */   call HANDLE.ANY.NEW.EDIT.OUT.TIME(time, 2, 1, 0);   call Set.Anchor.Time(Cue.Edit.Out.Time,1);end EXCHANGE.EDIT.OUT.TIME;/* $page - routine to increment cue name *//* increment cue name is called to increment the *//* name of the current cue                       */Increment.Cue.Name:proc swapable;   call INCREMENT.DTD.CURRENT.CUE.NAME;   /* quickly update our name displays for illusions of speed: */   call Display.AEE.Cue.Names;end Increment.Cue.Name;