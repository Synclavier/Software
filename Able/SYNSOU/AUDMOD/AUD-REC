/* AUD-REC  Audio Event Editor Recording Routines   Modified:   01/05/92 - cj  - Added "bounce/move" capability to record panel   11/06/91 - MWH - Change READY and RECORD active indicators   06/26/91 - cj  - moved gpi punch in recording to main loop   06/21/91 - cj  - cleared cue on retake; added audition on/off control   06/20/91 - cj  - allowed ready to preserve triggering cues   09/21/89 - SJS - added support for 'THREE' algorithm   04/14/89 - SJS - changed speech to 'ONE' and music to 'TWO'   12/13/88 - cj  - removed QUICK setting;  changed SMART to SPEECH   10/27/88 - cj  - change default DSP algorithm to SPEECH   10/24/88 - cj  - bug fix/repair in DSP functions   10/03/88 - cj  - Set REMAP bit in time field definition                    for use with live click tracks   09/08/88 - MWH - Add "real" DSP user interface   08/08/88 - cj  - store absolute # of smpte bits in cue record    08/04/88 - MWH - Erase take icons when sequencer trigger is disabled*/dcl Record.Group            fixed public;dcl Record.Row              fixed;dcl Record.Size             fixed;dcl Record.Screen.Space     fixed;dcl Record.Size.Box         fixed;dcl Record.Disk.Start.Label fixed;dcl Record.Disk.Stop.Label  fixed;dcl Record.Trig.Start.Label fixed;dcl Record.Trig.Stop.Label  fixed;dcl Record.Ready.Button     fixed;dcl Record.Record.Button    fixed;dcl Record.Stop.Button      fixed public;dcl Record.Mode.Switch      fixed;dcl Record.Trigger.Switch   fixed;dcl Record.Rec.Switch       fixed;dcl Record.Trig.Start.Time  fixed public;  /* must be kept in order */dcl Record.Trig.Stop.Time   fixed public;  /* must be kept in order */dcl Record.Disk.Start.Time  fixed public;  /* must be kept in order */dcl Record.Disk.Stop.Time   fixed public;  /* must be kept in order */dcl Record.Trig.Start.Take  fixed;dcl Record.Trig.Stop.Take   fixed;dcl Record.TSM.Cue.Arrows   fixed;         /* cue switch icon id    */dcl Record.TSM.Name.Id      fixed public;  /* cue name id           */dcl Record.TSM.Alg.Label    fixed;         /* alg label id          */dcl Record.TSM.Alg.Switch   fixed;         /* alg switch id         */dcl Record.TSM.Toggle       fixed;         /* l/r gr. but. table id */dcl Record.TSM.Length.Label fixed;         /* length label id       */dcl Record.TSM.Length       fixed public;  /* length field id       */dcl Record.TSM.Ratio        fixed;         /* ratio field id        */dcl Record.TSM.Alg          fixed;     /* index of algorithm to use */dcl Record.TSM.Options(TSM.Opt#array.size-1)   fixed; /* holds args */dcl Record.TSM.Len.or.Ratio fixed;     /* 0 = length, 1 = ratio     */dcl Record.TSM.Contents     fixed;     /* 0 = blank                 */                                       /* 1 = drawn                 */dcl Record.Drive.Type       fixed public;dcl Record.Drive.Table      fixed public;dcl Record.Cue.Name.Label   fixed;dcl Record.Cue.Name.Id      fixed;dcl Record.Retake.Id        fixed;dcl Record.Audition.Button  fixed public;dcl Record.Cross.Fade.Id    fixed;dcl Record.TSM.Options.Id   fixed;dcl Rec.Panel.Row           fixed;/* literals for Record.Trigger settings: *//* you can't change these easily         *//* without checking the GPI code:        */dcl RT.MANUAL      lit '0';dcl RT.SEQUENCER   lit '1';dcl RT.POLY.XFER   lit '2';dcl RT.TSM         lit '3';    /* DSP Time Scale Modifcation */dcl RT.BOUNCE      lit '4';    /* bounce                     */dcl RT.MOVE        lit '5';    /* move                       */dcl RT.DEFAULT     lit 'RT.MANUAL'; /* change as needed             */dcl Record.Trigger fixed PUBLIC;  /* Ghosts of switches for real-time access */dcl RM.ALLOCATE    lit '0';dcl RM.PUNCH.IN    lit '1';dcl RM.CUE.LOCK    lit '2';dcl Record.Mode             fixed public;dcl Record.Ready.Bits       fixed public;dcl Record.Recording.State  fixed public;dcl Record.Recording.Bits   fixed public;dcl Record.Disk.Start(1)    fixed;          /* 32 bit msec time with respect to current project */dcl Record.Disk.Stop(1)     fixed;          /* (ie: "zero.time" is start of current project) */dcl Record.Trig.Start(1)    fixed;dcl Record.Trig.Stop(1)     fixed;/* Record.Dependent.Time.Mode holds either 0 (Record.Trig.Stop.Time)  *//* or (1) Record.Disk.Stop.Time.   These are id #'s for the           *//* bottom two fields.   This is the id# of the field that             *//* should be changed whenever one of the other three fields           *//* is changed                                                         */dcl Record.Dependent.Time.Mode fixed;dcl Update.Record.Panel  proc recursive;/* $page - check.record.cue.name *//* check record cue name is used to check a cue name.  it *//* looks up the name from the Record.Cue.Name.Id object,  *//* enters the default name 'Take' if it is a null string, *//* computes the next numerical name if that name is       *//* already a cue, stores the result back in               *//* Record.Cue.Name.Id, and stores the result in the       *//* gid/pid static variable AEE.Record.Cue.Name            */CHECK.RECORD.CUE.NAME: proc swapable;   dcl cname(17-1) fixed;   if Record.Mode <> RM.ALLOCATE         /* if not allocate, then any */   then return;                          /* name can be shown          */   if  (Current.Cue.Ptr <> 0)            /* current cue exists         */   and (Record.Trigger = RT.MOVE)        /* and our plan is to move it */   then do;      write(mam) = Current.Cue.Ptr;      write(mal) = CUE.NAME;               call COPY.IN(addr(cname(0)),17);   end;   else do;      call fetch.string(Record.Cue.Name.Id,cname);   /* get cue name */      call Strip.Leading.Spaces(cname,cname);      do while  (cname(0)<>0)      and (byte(cname,cname(0)-1)=sp);         cname(0)=cname(0)-1;         call pbyte(cname,cname(0),0);      end;   end;   if cname(0)=0 then do;                         /* null string  */      call copy.string('Take',cname);      call Generate.Numerical.Cue.Name(Cname,Cname); /* append correct digits */   end;   if  (Record.Trigger <> RT.MOVE)            /* if something else besides */   and (Locate.DTD.Cue(cname) <> 0)           /* move, no duplicates       */   then do;      call Generate.Numerical.Cue.Name(cname,cname); /* Get next name */   end;   disable.deposits = 1;   call Deposit.String(Record.Cue.Name.Id,cname);   disable.deposits = 0;   call GID(AEE.Record.Cue.Name);   call COPY.OUT(addr(cname(0)),17);end CHECK.RECORD.CUE.NAME;/* $page - Enable and Disable TSM sub-panels */Enable.TSM.Panels: proc swapable;   dcl s1(2)        fixed;   dcl s2(0)        fixed;   call Set.Object.Mouse.Access(Record.TSM.Cue.Arrows, O#ACT.Middle.Press);   call Set.Object.Mouse.Access(Record.TSM.Name.Id,    O#ACT.Middle.Press);   call Set.Object.Mouse.Access(Record.TSM.Alg.Switch, O#ACT.Left.Press \ O#ACT.Middle.Press \ O#ACT.Right.Press);   call Set.Object.Mouse.Access(Record.TSM.Toggle,     O#ACT.Middle.Press);   call Set.Object.Mouse.Access(Record.TSM.Options.Id, O#ACT.Middle.Press);   call Enable.Object(Record.TSM.Cue.Arrows);   call Enable.Object(Record.TSM.Name.Id);   call Enable.Object(Record.TSM.Alg.Label);   call Enable.Object(Record.TSM.Alg.Switch);   call Enable.Object(Record.TSM.Toggle);   call Enable.Object(Record.TSM.Length.Label);   call Enable.Object(Record.TSM.Options.Id);   if Record.TSM.Contents = 0 then do;  /* draw l, r buttons if not there */      call COPY.STRING('L',s1);      call Deposit.Graphics.Button.Table.Label(Record.TSM.Toggle, 0, 0, 1, s1, s2);      call COPY.STRING('R',s1);      call Deposit.Graphics.Button.Table.Label(Record.TSM.Toggle, 1, 0, 1, s1, s2);      Record.TSM.Contents = 1;   end;   if Record.TSM.Len.or.Ratio = 0   then do;/* length is specified */      call Deposit.Graphics.String(Record.TSM.Length.Label,'New cue length:');      call Highlight.Graphics.Button.Table.Entry(Record.TSM.Toggle,0,0,2,0,1);      call Highlight.Graphics.Button.Table.Entry(Record.TSM.Toggle,0,1,0,0,1);      call Set.Object.Mouse.Access(Record.TSM.Length,O#ACT.Left.Press \ O#ACT.Middle.Press \ O#ACT.Right.Press);      call Enable.Object(Record.TSM.Length);      call Set.Object.Mouse.Access(Record.TSM.Ratio,0);      call Erase.Object(Record.TSM.Ratio);      call Disable.Object(Record.TSM.Ratio);      if (Cur.Obj.Id = Record.TSM.Ratio)      then call Select.New.Cur.Obj(Corner.Label,-1,-1);   end;   else do;/* ratio is specified */      call Deposit.Graphics.String(Record.TSM.Length.Label,'Ratio:');      call Highlight.Graphics.Button.Table.Entry(Record.TSM.Toggle,0,1,2,0,1);      call Highlight.Graphics.Button.Table.Entry(Record.TSM.Toggle,0,0,0,0,1);      call Set.Object.Mouse.Access(Record.TSM.Ratio,O#ACT.Left.Press \ O#ACT.Middle.Press \ O#ACT.Right.Press);      call Enable.Object(Record.TSM.Ratio);      call Set.Object.Mouse.Access(Record.TSM.Length,0);      call Erase.Object(Record.TSM.Length);      call Disable.Object(Record.TSM.Length);      if (Cur.Obj.Id = Record.TSM.Length)      then call Select.New.Cur.Obj(Corner.Label,-1,-1);   end;end Enable.TSM.Panels;Disable.TSM.Panels: proc(code) swapable;   dcl code         fixed;  /* 0 = disable all; 1 = leave bounce/move items */   dcl s1(2)        fixed;   dcl s2(0)        fixed;   /* Disable bounce/move items if needed: */   if code = 0 then do;      call Set.Object.Mouse.Access(Record.TSM.Cue.Arrows, 0);      if Locate.Object(Record.TSM.Cue.Arrows) then do;         if ((Read.Object(Object.Ptr + O#Status) and O#STAT.Exhibit) <> 0)  /* erase only if exhibited */         then do;            call Mouse.Switch(0);            call Area.Fill(Read.Object(Object.Ptr+O#ULX)+1, /* leave left vert bar */                           Read.Object(Object.Ptr+O#ULY)-1,                           Read.Object(Object.Ptr+O#LRX),                           Read.Object(Object.Ptr+O#LRY),1,0);            call Mouse.Switch(1);         end;      end;      call Set.Object.Status(Record.TSM.Cue.Arrows,O#STAT.Exhibit,false);      call Disable.Object(Record.TSM.Cue.Arrows);      call Set.Object.Mouse.Access(Record.TSM.Name.Id,    0);      call Erase.Object(Record.TSM.Name.Id);      if (Cur.Obj.Id = Record.TSM.Name.Id)      then call Select.New.Cur.Obj(Corner.Label,-1,-1);      call Disable.Object(Record.TSM.Name.Id);   end;   call Set.Object.Mouse.Access(Record.TSM.Alg.Switch, 0);   call Set.Object.Mouse.Access(Record.TSM.Toggle,     0);   call Set.Object.Mouse.Access(Record.TSM.Length,     0);   call Set.Object.Mouse.Access(Record.TSM.Ratio,      0);   call Set.Object.Mouse.Access(Record.TSM.Options.Id, 0);   /* Erase objects */   call Erase.Object(Record.TSM.Alg.Label);   call Erase.Object(Record.TSM.Alg.Switch);   call Erase.Object(Record.TSM.Length.Label);   call Erase.Object(Record.TSM.Length);   call Erase.Object(Record.TSM.Ratio);   call Erase.Object(Record.TSM.Options.Id);   /* Turn off boxes around selection */   call Highlight.Graphics.Button.Table.Entry(Record.TSM.Toggle,0,0,0,0,1);   call Highlight.Graphics.Button.Table.Entry(Record.TSM.Toggle,0,1,0,0,1);   /* Remove L's, R's */   if Record.TSM.Contents <> 0 then do;  /* erase l, r buttons if there */      call COPY.STRING('L',s1);      call Deposit.Graphics.Button.Table.Label(Record.TSM.Toggle, 0, 0, 1, s1, s2);      call COPY.STRING('R',s1);      call Deposit.Graphics.Button.Table.Label(Record.TSM.Toggle, 1, 0, 1, s1, s2);      Record.TSM.Contents = 0;   end;   /* mark objects as erased: */   call Set.Object.Status(Record.TSM.Toggle,    O#STAT.Exhibit,false);   if (Cur.Obj.Id = Record.TSM.Alg.Switch)   or (Cur.Obj.Id = Record.TSM.Length)   or (Cur.Obj.Id = Record.TSM.Ratio)   then call Select.New.Cur.Obj(Corner.Label,-1,-1);   call Disable.Object(Record.TSM.Alg.Label);   call Disable.Object(Record.TSM.Alg.Switch);   call Disable.Object(Record.TSM.Toggle);   call Disable.Object(Record.TSM.Length.Label);   call Disable.Object(Record.TSM.Length);   call Disable.Object(Record.TSM.Ratio);   call Disable.Object(Record.TSM.Options.Id);end Disable.TSM.Panels;Enable.BOUNCE.MOVE.Panels: proc swapable;   call Set.Object.Mouse.Access(Record.TSM.Cue.Arrows, O#ACT.Middle.Press);   call Set.Object.Mouse.Access(Record.TSM.Name.Id,    O#ACT.Middle.Press);   call Enable.Object(Record.TSM.Cue.Arrows);   call Enable.Object(Record.TSM.Name.Id);   call Disable.TSM.Panels(1);           /* disable other TSM stuff */end Enable.BOUNCE.MOVE.Panels;/* $page - set.record.panel.attributes *//* this routine looks at the states of the following variables:   Record.Mode   Record.Trigger   Record.Dependent.Time.Mode   It sets up the labels and highlights of all the fields on   the record panel to do what is needed */SET.RECORD.PANEL.ATTRIBUTES:proc swapable;   disable.deposits = 1;   /* set mouse access and display attributes for disk start */   /* and disk stop times                                    */   if Record.Mode = RM.PUNCH.IN  /* punch in mode - locked to sequencer. */   then do;                      /* Disable disk start/disk stop fields  */      call Set.Object.Mouse.Access(Record.Disk.Start.Time,0);      call Set.Object.Mouse.Access(Record.Disk.Stop.Time, 0);      call Erase.Object(Record.Disk.Start.Time);      call Erase.Object(Record.Disk.Stop.Time );      if (Cur.Obj.Id = Record.Disk.Start.Time)      or (Cur.Obj.Id = Record.Disk.Stop.Time)      then call Select.New.Cur.Obj(Corner.Label,-1,-1);      call Disable.Object(Record.Disk.Start.Time);      call Disable.Object(Record.Disk.Stop.Time );   end;   else do;  /* otherwise show fields, but limit access */       call Set.Object.Mouse.Access(Record.Disk.Start.Time,0);      call Set.Object.Mouse.Access(Record.Disk.Stop.Time, O#ACT.Middle.Press); /* must allow middle press for select to set dependent time */      call Enable.Object(Record.Disk.Start.Time);      call Enable.Object(Record.Disk.Stop.Time );      if (Cur.Obj.Id = Record.Disk.Start.Time)      or (Cur.Obj.Id = Record.Disk.Stop.Time )      then call Select.New.Cur.Obj(Corner.Label,-1,-1);   end;   /* set up access and highlight of record cue name */   /* and retake buttons                             */   if Record.Mode = RM.ALLOCATE    /* allocate - allow access to cue name */   then do;       call CHECK.RECORD.CUE.NAME;  /* double check cue name here */      call Enable.Object(Record.Cue.Name.Label);      call Enable.Object(Record.Cue.Name.Id);      if  (Record.Trigger = RT.MOVE)      then do;         call Set.Object.Mouse.Access(Record.Cue.Name.Id,0);         if (Cur.Obj.Id = Record.Cue.Name.Label)          or (Cur.Obj.Id = Record.Cue.Name.Id)         then call Select.New.Cur.Obj(Corner.Label,-1,-1);      end;      else do;         call Set.Object.Mouse.Access(Record.Cue.Name.Id,O#ACT.Middle.Press);      end;      call Enable.Object(Record.Retake.Id);   end;   else if Record.Mode = RM.CUE.LOCK /* cue lock - show name, but no access */   then do;      call Enable.Object(Record.Cue.Name.Label);      call Enable.Object(Record.Cue.Name.Id);      call Set.Object.Mouse.Access(Record.Cue.Name.Id,0);      call Erase.Object (Record.Retake.Id);      if (Cur.Obj.Id = Record.Cue.Name.Label)       or (Cur.Obj.Id = Record.Cue.Name.Id)      or (Cur.Obj.Id = Record.Retake.Id)      then call Select.New.Cur.Obj(Corner.Label,-1,-1);      call Disable.Object(Record.Retake.Id);   end;   else do;   /* other modes - remove cue name field */      call Erase.Object(Record.Cue.Name.Label);      call Erase.Object(Record.Cue.Name.Id);      call Set.Object.Mouse.Access(Record.Cue.Name.Id,0);      call Erase.Object(Record.Retake.Id);      if (Cur.Obj.Id = Record.Cue.Name.Label)       or (Cur.Obj.Id = Record.Cue.Name.Id)      or (Cur.Obj.Id = Record.Retake.Id)      then call Select.New.Cur.Obj(Corner.Label,-1,-1);      call Disable.Object(Record.Cue.Name.Label);      call Disable.Object(Record.Cue.Name.Id);      call Disable.Object(Record.Retake.Id);   end;   /* set up labels for Disk/Cue Start + Disk/Cue Stop */   if Record.Mode =  RM.CUE.LOCK then do;      call Deposit.Label(Record.Disk.Start.Label,'Cue Start');      if   ( Record.Trigger = RT.SEQUENCER )   /* if sequencer             */      and  ( Record.Dependent.Time.Mode = 0)   /* and disk stop dependent  */      then do;                                 /* then bring in trig stop  */         call Deposit.Label(Record.Disk.Stop.Label,'');      end;      else do;         call Deposit.Label(Record.Disk.Stop.Label,'Cue Stop');      end;   end;   else if Record.Mode = RM.ALLOCATE then do;      call Deposit.Label(Record.Disk.Start.Label,'Trk Start');      if   ( Record.Trigger = RT.SEQUENCER )   /* if sequencer             */      and  ( Record.Dependent.Time.Mode = 0)   /* and disk stop dependent  */      then do;                                 /* then bring in trig stop  */         call Deposit.Label(Record.Disk.Stop.Label,'');      end;      else do;         call Deposit.Label(Record.Disk.Stop.Label,'Trk Stop');      end;   end;   else do;   /* punch in - no disk times */      call Deposit.Label(Record.Disk.Start.Label,'');      call Deposit.Label(Record.Disk.Stop.Label, '');   end;   /* Set up labels for Trig Start + Trig Stop  */   /* Also trig start/stop times                */   /* Also TSM items                            */   if  (Record.Trigger = RT.SEQUENCER)      /* if sequencer or smpte in */   then do;                                 /* set up trig start label  */      call Disable.TSM.Panels(0);           /* remove tsm stuff (maybe) */      if (Record.Dependent.Time.Mode = 0)   /* and disk stop dependent  */      or (Record.Mode = RM.PUNCH.IN)        /* or punch in              */      then call Deposit.Label(Record.Trig.Stop.Label,'Trig Stop');      else call Deposit.Label(Record.Trig.Stop.Label,'');      call Set.Object.Attr(Record.Trig.Start.Time,0,ATTR#Normal);      call Set.Object.Attr(Record.Trig.Start.Time,1,ATTR#Normal\ATTR#Reverse);      call Set.Object.Attr(Record.Trig.Stop.Time,0,ATTR#Normal);      call Set.Object.Attr(Record.Trig.Stop.Time,1,ATTR#Normal\ATTR#Reverse);      call Enable.Object(Record.Trig.Start.Label);      call Enable.Object(Record.Trig.Stop.Label);      call Enable.Object(Record.Trig.Start.Time);      call Enable.Object(Record.Trig.Stop.Time);      call Enable.Object(Record.Trig.Start.Take);      call Enable.Object(Record.Trig.Stop.Take);   end;   else do;      call Erase.Object(Record.Trig.Start.Label);      call Erase.Object(Record.Trig.Stop.Label);      call Erase.Object(Record.Trig.Start.Time);      call Erase.Object(Record.Trig.Stop.Time);      /* This is a fix for Pericom that won't erase filled objects properly! */      /* Erase take buttons (filled graphics object) */      if Locate.Object(Record.Trig.Start.Take) then do;         if ((Read.Object(Object.Ptr + O#Status) and O#STAT.Exhibit) <> 0)  /* erase only if exhibited */         then do;            call Mouse.Switch(0);            call Area.Fill(Read.Object(Object.Ptr+O#ULX),                           Read.Object(Object.Ptr+O#ULY) - 6,                           Read.Object(Object.Ptr+O#LRX),                           Read.Object(Object.Ptr+O#LRY),1,0);            call Mouse.Switch(1);            call Set.Object.Status(Record.Trig.Start.Take,O#STAT.Exhibit,false);         end;      end;      if Locate.Object(Record.Trig.Stop.Take) then do;         if ((Read.Object(Object.Ptr + O#Status) and O#STAT.Exhibit) <> 0)  /* erase only if exhibited */         then do;            call Mouse.Switch(0);            call Area.Fill(Read.Object(Object.Ptr+O#ULX),                           Read.Object(Object.Ptr+O#ULY),                           Read.Object(Object.Ptr+O#LRX),                           Read.Object(Object.Ptr+O#LRY) + 6,1,0);            call Mouse.Switch(1);            call Set.Object.Status(Record.Trig.Stop.Take,O#STAT.Exhibit,false);         end;      end;         if (Cur.Obj.Id = Record.Trig.Start.Time)      or (Cur.Obj.Id = Record.Trig.Stop.Time)      then call Select.New.Cur.Obj(Corner.Label,-1,-1);      call Disable.Object(Record.Trig.Start.Label);      call Disable.Object(Record.Trig.Stop.Label);      call Disable.Object(Record.Trig.Start.Time);      call Disable.Object(Record.Trig.Stop.Time);      call Disable.Object(Record.Trig.Start.Take);      call Disable.Object(Record.Trig.Stop.Take);      if (Record.Trigger = RT.TSM)          /* bring tsm items in or out */      then call  Enable.TSM.Panels;         /* as needed                 */      else if (Record.Trigger = RT.BOUNCE)      or      (Record.Trigger = RT.MOVE  )      then call  Enable.BOUNCE.MOVE.Panels;      else call  Disable.TSM.Panels(0);   end;   disable.deposits = 0;end SET.RECORD.PANEL.ATTRIBUTES;/* Display.AEE.Record.Ready.Buttons sets that attributes and contents *//* of the READY and RECORD/REHEARSE/BLOCK/PROCESS button on the AEE   *//* record panel.                                                      */Display.AEE.Record.Ready.Buttons: proc public swapable;   dcl state fixed;   dcl star  fixed;  /* Flag whether to add a "*" to Record.Record.Button */   if Record.Group = 0 then return;   /* Set highlighting of READY button: */   if DTD.Ready.Enabled <> 0 then do;      call Set.Object.Attr(Record.Ready.Button,0,ATTR#Normal\ATTR#Blink\ATTR#Reverse\ATTR#AltIntensity);      call Set.Object.Attr(Record.Ready.Button,1,ATTR#Normal\ATTR#Blink\ATTR#Reverse\ATTR#AltIntensity);      call Deposit.Label  (Record.Ready.Button,' READY* ');   end;   else do;      call Set.Object.Attr(Record.Ready.Button,0,ATTR#Normal\ATTR#AltIntensity);      call Set.Object.Attr(Record.Ready.Button,1,ATTR#Normal\ATTR#AltIntensity);      call Deposit.Label  (Record.Ready.Button,' READY  ');   end;   /* Set highlighting of RECORD button: */   if  (Armed.for.Protocol.DTD.Recording <> 0)  /* if armed for protocol recording */   then state = Protocol.Recording.State;       /* then show it's state            */   else if (Lod.Punch.In.Tracks          <> 0)  /* else if doing gpi recording     */   then state = 3;   else state = Record.Recording.State;         /* else show AEE state             */   star = 0;   do case (state);      do;    /* Not armed or recording */         call Set.Object.Attr(Record.Record.Button,0,ATTR#Normal\ATTR#AltIntensity);         call Set.Object.Attr(Record.Record.Button,1,ATTR#Normal\ATTR#AltIntensity);      end;      do;    /* Armed */         call Set.Object.Attr(Record.Record.Button,0,ATTR#Normal\ATTR#Blink\ATTR#Reverse\ATTR#AltIntensity);         call Set.Object.Attr(Record.Record.Button,1,ATTR#Normal\ATTR#Blink\ATTR#Reverse\ATTR#AltIntensity);         star = 1;  /* Add a trailing star if we are "blinking" */      end;      do;    /* Recording but not armed */         call Set.Object.Attr(Record.Record.Button,0,ATTR#Normal\ATTR#Reverse);         call Set.Object.Attr(Record.Record.Button,1,ATTR#Normal\ATTR#Reverse);      end;      do;    /* Recording and armed */         call Set.Object.Attr(Record.Record.Button,0,ATTR#Normal\ATTR#Reverse);         call Set.Object.Attr(Record.Record.Button,1,ATTR#Normal\ATTR#Reverse);      end;   end;   /* Set correct label in the RECORD button */   disable.deposits = 1;   if  ( Record.Trigger = RT.SEQUENCER )    /* if sequencer triggering */   and ( DTD.Ready.Enabled    = 0      )    /* and not ready           */   then do;                                 /* then record is rehearse */      /* There's no room for a star after REHEARSE, but that should be OK */      call Deposit.Label(Record.Record.Button,'REHEARSE');   end;   else if (Record.Mode = RM.ALLOCATE  )    /* else if allocate mode   */   and     (Record.Recording.State >= 2)    /* and AEE recording       */   and     (Record.Trigger <> RT.TSM   )    /* and not TSM mode        */   and     (Record.Trigger <> RT.BOUNCE)    /* and not TSM mode        */   and     (Record.Trigger <> RT.MOVE  )    /* and not TSM mode        */   then do;      if star = 0      then call Deposit.Label(Record.Record.Button,' BLOCK  ');      else call Deposit.Label(Record.Record.Button,' BLOCK* ');   end;   else if (Record.Trigger = RT.TSM  )            /* if armed for TSM  */   and     (Armed.for.Protocol.DTD.Recording = 0) /* no protocol recd  */   then do;      if star = 0      then call Deposit.Label(Record.Record.Button,'PROCESS ');      else call Deposit.Label(Record.Record.Button,'PROCESS*');   end;   else do;                                 /* else record is record   */      if star = 0      then call Deposit.Label(Record.Record.Button,' RECORD ');      else call Deposit.Label(Record.Record.Button,' RECORD*');   end;   disable.deposits = 0;end Display.AEE.Record.Ready.Buttons;DEFINE.RECORD.PANEL: proc (row,size) swapable;   dcl row          fixed;   dcl size         fixed;   dcl lines(20)    fixed;   dcl i            fixed;   dcl MR13i        lit 'write("373")';   init:proc(val,id);   /* init 32-bit msec id to saved */      dcl val array;    /* in-memory value              */      dcl id  fixed;      if  (val(0)=0)    /* init 32 bit msec values to 0.000 */      and (val(1)=0)      then val(1)=zero.time;      call Deposit.32Bit.Msec(id,val,Zero.Zero);   end init;   call Copy.String('RECORD CONTROL',lines);   call Print.Panel.Title(row,lines);   Rec.Panel.Row = row;   write("313") = addr(misc.buf(0));   MR13i = O#Icon.Connect;  /* READY/RECORD/STOP Buttons and Mode/Trig/Act switches */      MR13i =  800;      MR13i =  100;      MR13i =  800;      MR13i = -200;   MR13i = O#Icon.Connect;  /* between Mode & Auto switches and Sync and Start/Stop times */      MR13i = 2400;         /**/      MR13i =  100;      MR13i = 2400;         /**/      MR13i = -200;   MR13i = O#Icon.Connect;  /* between disk times and trig times */      MR13i = 5100;         /**/      MR13i =  100;      MR13i = 5100;         /**/      MR13i = -100;   MR13i = O#Icon.Connect;        MR13i = - 10;      MR13i =    0;      MR13i =  800;      MR13i =    0;   MR13i = O#Icon.Connect;        MR13i = - 10;      MR13i = -100;      MR13i =  800;      MR13i = -100;   MR13i = O#Icon.Connect;     /* long horizontal line above track ready buttons */      MR13i = 2400;      MR13i = -100;      MR13i = 8010;      MR13i = -100;   MR13i = O#Icon.Connect;        MR13i = - 10;      MR13i = -200;      MR13i = 8010;      MR13i = -200;   MR13i = O#Icon.Connect;       /* line after cue name field   */      MR13i = 4100;              /* character position 41 (pre) */      MR13i = -200;      MR13i = 4100;      MR13i = -300;   MR13i = O#Icon.Connect;       /* line after retake           */      MR13i = 4900;                    MR13i = -200;      MR13i = 4900;      MR13i = -300;   MR13i = O#Icon.Connect;       /* line after audition         */      MR13i = 5900;                    MR13i = -200;      MR13i = 5900;      MR13i = -300;   MR13i = O#Icon.Connect;       /* line after crfade           */      MR13i = 7100;                    MR13i = -200;      MR13i = 7100;      MR13i = -300;   MR13i = O#ICON.End;   call Set.Auto.Allocation.Id(Record.Alloc);   call Set.Default.Action(O#ACT.Middle.Press);   call Set.Default.Attr(0,ATTR#Normal\ATTR#AltIntensity);   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse);   /* draw box around all 4 lines */   call                    Define.Graphics.Box(S#AA,gpos.x(-10),gpos.y((row-1)*100),gpos.x(8010),gpos.y((row+size-1)*100),0);   call                    Define.Graphics.Icon(S#AA,0,(row*100),0,misc.buf);   call                    Load.Close.Box.Icon(misc.buf);   Record.Size.Box       = Define.Graphics.Icon(S#AA,0,(row*100),1,misc.buf);   call Activate.Object.Range(Record.Alloc,Record.Size.Box);   do i = Record.Alloc to Record.Size.Box;      call Update.Object(i);   end;   call                    Set.Default.Action(O#ACT.Middle.Press\O#ACT.Prev.Obj\O#ACT.Update.On.Dep\O#ACT.RealTime.Object);   Record.Ready.Button   = Define.Label(S#AA,row,  0,0,' READY  ');   Record.Record.Button  = Define.Label(S#AA,row+1,0,8,''        );   call                    Set.Default.Action(O#ACT.Middle.Press\O#ACT.Prev.Obj);   Record.Stop.Button    = Define.Label(S#AA,row+2,0,0,' STOP   ');   call                     Load.Take.Icon(misc.buf);   Record.Trig.Start.Take = Define.Graphics.Icon(S#AA,5100,row*100,2,misc.buf);   misc.buf(0)            = O#ICON.InsertIcon;   misc.buf(1)            = Record.Trig.Start.Take;   misc.buf(2)            = O#Icon.End;   Record.Trig.Stop.Take  = Define.Graphics.Icon(S#AA,5100,(row+1)*100,2,misc.buf);   call                    Set.Default.Action(0);   call                    Define.Label(S#AA,row  ,9,0,'Mode');   call                    Define.Label(S#AA,row+1,9,0,'Trig');   call                    Define.Label(S#AA,row+2,9,0,'Rec');   Record.Disk.Start.Label=Define.Label(S#AA,row,  25,9,'');   Record.Disk.Stop.Label =Define.Label(S#AA,row+1,25,8,'');   call                    Define.Label(S#AA,row+2,25,0,'Tracks');   Record.Trig.Start.Label=Define.Label(S#AA,row,  54,10,'Trig Start');   Record.Trig.Stop.Label =Define.Label(S#AA,row+1,54,9,'');   Record.Cue.Name.Label  =Define.Label(S#aa,row+3, 3,0,'Cue:');   call                    Define.Label(S#aa,row+3,60,0,'Crfade:');   call                    Set.Default.Action(O#ACT.Middle.Press);   Record.Retake.Id       =Define.Label(S#aa,row+3,42,0,'Retake');   Record.Audition.Button =Define.Label(S#aa,row+3,49,0,' Audition ');   Record.TSM.Options.Id  =Define.Label(S#aa,row+3,72,0,'Options');   call                    Set.Object.Action(Record.TSM.Options.Id,O#ACT.Prev.Obj,1);     call                    Set.Default.Attr(0,ATTR#Normal);   Record.Mode.Switch    = Define.Switch(S#AA,row,  14, 8,0,'Allocate|Punch In|Cue Lock');   Record.Trigger.Switch = Define.Switch(S#AA,row+1,14, 9,0,'Manual|Sequencer|Poly Xfr|TSM|Bounce');   Record.Rec.Switch     = Define.Switch(S#AA,row+2,14, 6,0,'Single|Repeat');   /* Define TSM panel objects */   call                    Set.Default.Action(O#ACT.Middle.Press\O#ACT.Left.Press\O#ACT.Right.Press);   Record.TSM.Alg.Switch = Define.Switch(S#AA,row,  74, 6,0,'THREE|ONE|TWO');   Record.TSM.Length     = Define.32Bit.MSEC(S#AA,row+1,65,14,AEE.Time.Format\O#MSEC.RealTime,cf#dur,cf#default,cf#default);   call                    Set.Default.Action(O#ACT.Jog.Enabled\O#ACT.Middle.Press\O#ACT.Left.Press\O#ACT.Right.Press);   Record.TSM.Ratio      = Define.Fixed.Point(S#AA,row+1,60,6,4,cf#unsigned|cf#left|cf#zerofill);   call                    Set.Default.Action(0);   Record.TSM.Alg.Label  = Define.Label(S#AA,row,  69,0,'Alg:');   Record.TSM.Length.Label=Define.Graphics.String(S#AA,                           gpos.x(5400),                           gpos.y((row+1)*100) + 15 - shr(Ver.Char.Size(1),1),                           15, 1, 0, O#GSTR.General);   call                    Set.Default.Action(O#ACT.Middle.Press);   Record.TSM.Name.Id    = Define.Graphics.String(S#AA,                           gpos.x(5400),                           gpos.y(row*100) + 15 - shr(Ver.Char.Size(1),1),                           22, 1, 0, O#GSTR.General);   call                    Load.UpDown.Icon(Misc.Buf);   Record.TSM.Cue.Arrows = Define.Graphics.Icon(S#AA, 5100, row*100, 1, Misc.Buf);   Record.TSM.Toggle     = Define.Graphics.Button.Table                           (S#AA, 5150, (row-1+1)*100+10, 5250, (row+1)*100-10, 1, 2, 0);   /* define these in order: */   call Set.Default.Action(O#ACT.Middle.Press\O#ACT.Left.Press\O#ACT.Right.Press\O#ACT.Drag.Enabled\O#ACT.Drag.Type.Check);   Record.Disk.Start.Time= Define.32Bit.MSEC(S#AA,row  ,36,14,AEE.Time.Format\O#MSEC.RealTime\O#MSEC.Alt.Offset,cf#time,cf#default,cf#default);   Record.Disk.Stop.Time = Define.32Bit.MSEC(S#AA,row+1,36,14,AEE.Time.Format\O#MSEC.RealTime\O#MSEC.Alt.Offset,cf#time,cf#default,cf#default);   Record.Trig.Start.Time= Define.32Bit.MSEC(S#AA,row  ,65,14,AEE.Time.Format\O#MSEC.RealTime,cf#time,cf#default,cf#default);   Record.Trig.Stop.Time = Define.32Bit.MSEC(S#AA,row+1,65,14,AEE.Time.Format\O#MSEC.RealTime,cf#time,cf#default,cf#default);   call Set.Object.Attr(Record.Disk.Start.Time, 0, ATTR#Normal\ATTR#AltIntensity);   call Set.Object.Attr(Record.Disk.Start.Time, 1, ATTR#Normal\ATTR#AltIntensity);   call Set.Object.Attr(Record.Disk.Stop.Time,  0, ATTR#Normal\ATTR#AltIntensity);   call Set.Object.Attr(Record.Disk.Stop.Time,  1, ATTR#Normal\ATTR#AltIntensity);   if   record.tsm.alg = 0     /* initialize algorithm to ONE  */   then record.tsm.alg = 2;    /* (holds x + 1)                   */   disable.deposits = true;   call init(Record.Disk.Start,Record.Disk.Start.Time);   call init(Record.Disk.Stop ,Record.Disk.Stop.Time );   call init(Record.Trig.Start,Record.Trig.Start.Time);   call init(Record.Trig.Stop ,Record.Trig.Stop.Time );   call Deposit.Switch(Record.TSM.Alg.Switch,Record.Tsm.Alg-1);   Record.TSM.Contents = 0;   disable.deposits = false;   call                    Set.Default.Action(O#ACT.Middle.Press);   call                    Set.Default.Attr(0,ATTR#Normal\ATTR#AltIntensity);   Record.Drive.Type     = Define.Label(S#AA,row+2,32,3,'');   call                    Set.Object.Action(Record.Drive.Type,O#ACT.Prev.Obj,true);   Record.Drive.Table    = Define.Table(S#AA,16,1,Record.Drive.Type);   call                    Copy.String(' 01| 02| 03| 04| 05| 06| 07| 08| 09| 10| 11| 12| 13| 14| 15| 16',misc.buf);   call                    Fill.String.Table(Record.Drive.Table,0,0,1,misc.buf);   call                    Set.Object.Action(Record.Drive.Table,O#ACT.Update.On.Dep,true);   call                    Set.Default.Attr(0,ATTR#Normal);   Record.Cue.Name.Id    = Define.String(S#AA,row+3,8,32,O#STR.General);  /* initialized momentarily */   Record.Cross.Fade.Id  = Define.Fixed.Point(S#AA,row+3,67,3,0,CF#Right);   Record.Trigger        = GID(Record.Trigger.Switch.Setting)+RT.DEFAULT;   Record.Mode           = GID(Record.Mode.Switch.Setting);   call                    Deposit.Switch(Record.Mode.Switch,Record.Mode); /* use deposit reporting here */   call                    Deposit.Switch(Record.Trigger.Switch,Record.Trigger);   call                    Deposit.Switch(Record.Rec.Switch,GID(Record.Rec.Switch.Setting));   Record.Group          = Group.Objects(Record.Group.Id,Record.Alloc,Record.Alloc+999,get#Screen.Event);   call Activate.Object.Range(Record.Alloc,Record.Alloc+999);   /* Must do this after Record.Group is defined */   call Display.Cue.And.Shuttle.Displays; /* Puts current cue name in Record.TSM.Name.Id */   /* read in Record.Cue.Name.Id from GID/PID */   call GID(AEE.Record.Cue.Name);      /* get saved name from static */   call COPY.IN(addr(misc.buf(0)),17); /* area                       */   disable.deposits = true;   call Deposit.String(Record.Cue.Name.Id,misc.buf);   disable.deposits = false;   /* check record cue name is called from set.record.panel.attributes */   call SET.RECORD.PANEL.ATTRIBUTES;   call Set.Auto.Arrow.Link.Range(Record.Disk.Start.Time,Record.Trig.Stop.Time);   call Set.Object.Arrow.Links   (Record.Cue.Name.Id,   ARR#Auto,ARR#Auto,ARR#Auto,ARR#Auto);   call Set.Object.Arrow.Links   (Record.Cross.Fade.Id, ARR#Auto,ARR#Auto,ARR#Auto,ARR#Auto);   call Set.Object.Arrow.Links   (Record.TSM.Name.Id,   ARR#Auto,ARR#Auto,ARR#Auto,ARR#Auto);   call Set.Object.Arrow.Links   (Record.TSM.Length,    ARR#Auto,ARR#Auto,ARR#Auto,ARR#Auto);   call Set.Object.Arrow.Links   (Record.TSM.Ratio,     ARR#Auto,ARR#Auto,ARR#Auto,ARR#Auto);   call DEPOSIT.AUDITION.BUTTON.DISPLAY;end DEFINE.RECORD.PANEL;OPEN.RECORD.PANEL: proc public swapable;   dcl (sid,row,size) fixed;  /*** Declare in Order ***/   if Record.Group <> 0 then return;   if Allocate.Screen.Space(5,5,loc(addr(sid))) then do;      call Set.Panel.Menu.Highlight(4,1);      call Set.AEE.Panel.Info(4,row,size); /* find and set entry for panel */      call Define.Record.Panel(row+1,size-1);      Record.Screen.Space = sid;      Record.Size = size-1;      Record.Row = row+1;            if (!simulate_dtd)      {	      call Update.AEE.Track.Status.Displays.And.Tallies (0,-1); /* set record ready displays, allocate times */			call Update.Record.Panel; /* so cross fade gets set */		}   end;   else call Display.Notice(NT#NoMoreRoomOnScreen,ATTR#Normal,NulStr,0,0,0);end OPEN.RECORD.PANEL;dcl STOP.RECORD.RECORDING proc recursive;CLOSE.RECORD.PANEL: proc public swapable;   if Record.Group <> 0 then do;   /* Group is defined     */      call Set.Panel.Menu.Highlight(4,0);      call Set.AEE.Panel.Info(4,0,0); /* mark entry as unused */      if Record.Recording.State <> 0       then call STOP.RECORD.RECORDING;  /* force stop recording */      Record.Screen.Space = Erase.Screen.Space(Record.Screen.Space);      Record.Group = Ungroup.Objects(Record.Group);      call Undefine.Object.Range(Record.Alloc,Record.Alloc+999);      call Select.New.Cur.Obj(Corner.Label,-1,-1);      call Update.AEE.Track.Status.Displays.And.Tallies (0,0);   end;end CLOSE.RECORD.PANEL;SET.RECORD.DEPENDENT.TIME: proc (Mode) swapable;   dcl Mode   fixed;   if  (Record.Trigger = RT.MANUAL)       /* manual      */   or  (Record.Trigger = RT.POLY.XFER)    /* poly xfer   */   or  (Record.Trigger = RT.TSM)          /* dsp op      */   or  (Record.Trigger = RT.BOUNCE)       /* bounce      */   or  (Record.Trigger = RT.MOVE  )       /* move        */   then Mode = 0;                         /* leave       */   if Mode <> Record.Dependent.Time.Mode  /* update screen on changes */   then do;      Record.Dependent.Time.Mode = Mode;      call SET.RECORD.PANEL.ATTRIBUTES;   end;end SET.RECORD.DEPENDENT.TIME;UPDATE.ALLOCATE.TIMES: proc PUBLIC swapable;   dcl (stmp     ) (1)        fixed;   dcl (etmp     ) (1)        fixed;   dcl (temptime ) (1)        fixed;   if Record.Group = 0              /* no record group - quit */   then return;   if Record.Mode <> RM.ALLOCATE    /* only when in                 */   then return;                     /* alloc mode                   */   Disable.Deposits = true;   call Fetch.DTD.Auto.Allocate.Time(0, stmp, etmp); /* get auto allocate start and end times */   Record.Disk.Start(0) = stmp(0);     /* Use allocate time as start time */   Record.Disk.Start(1) = stmp(1);     /* always                          */   call Deposit.32Bit.MSEC(Record.Disk.Start.Time,Record.Disk.Start,Zero.Zero);   /* if doing sequencer triggering,  or smpte triggering,   and  */   /* the disk stop time is the dependent time,  then compute     */   /* the auto allocate end time based upon the trigger times     */   if  (Record.Trigger = RT.SEQUENCER)   then do;      if (Record.Dependent.Time.Mode = 0) /* if disk stop time is dependent then compute it */      then do;           call SUB32(Record.Trig.Stop,Record.Trig.Start,temptime);  /* compute trigger duration */         call ADD32(Record.Disk.Start,temptime,Record.Disk.Stop);  /* compute disk end time */      end;      else do;                            /* else compute trigger end time */         Record.Disk.Stop(0) = etmp(0);   /* else use end of song time returned from dtd */         Record.Disk.Stop(1) = etmp(1);         call SUB32(Record.Disk.Stop,Record.Disk.Start,temptime);  /* compute trigger duration */         call ADD32(Record.Trig.Start,temptime,Record.Trig.Stop);  /* compute disk end time */         call Deposit.32Bit.MSEC(Record.Trig.Stop.Time,Record.Trig.Stop,Zero.Zero);      end;   end;   else do;                  /* other modes - use end of song always and do not update trig stop time */      Record.Disk.Stop(0) = etmp(0);      Record.Disk.Stop(1) = etmp(1);   end;   call Deposit.32Bit.MSEC(Record.Disk.Stop.Time,Record.Disk.Stop,Zero.Zero);   Disable.Deposits = false;end UPDATE.ALLOCATE.TIMES;TOGGLE.RECORD.DRIVE.TABLE: proc (col) swapable;   dcl col    fixed;   if (Record.Ready.Bits&bits(col)) = 0 then do;      call SET.DTD.DRIVE.STATUS(1,bits(col));   end;   else do;      call SET.DTD.DRIVE.STATUS(0,bits(col));   end;   call Update.AEE.Track.Status.Displays.And.Tallies (0,bits(col));end TOGGLE.RECORD.DRIVE.TABLE;SET.RECORD.READY: proc(state) swapable;   dcl state fixed;   call Set.DTD.Ready.Light(state&1);   call Display.AEE.Record.Ready.Buttons;   call Update.Object(Record.Ready.Button );   call Update.Object(Record.Record.Button);   call Update.AEE.Track.Status.Displays.And.Tallies (0, Record.Ready.Bits); /* toggle blinking state on record panel */   if DTD.Ready.Enabled <> 0 then do;      call CHECK.RECORD.CUE.NAME;  /* double check cue name here */   end;end SET.RECORD.READY;TOGGLE.RECORD.READY: proc PUBLIC swapable;   call Set.Record.Ready(DTD.Ready.Enabled xor 1);   if  (DTD.Ready.Enabled = 0)               /* not ready now                  */   then do;      if (GID(Any.Recording.Happened)<>0)    /* but some recording had occurred */      then do;                               /* then update pmgr               */         call PID(Any.Recording.Happened,0);         call UPDATE.PROJECT.MANAGER;        /* update used display or allocate display */      end;   end;end TOGGLE.RECORD.READY;/* routine looks at current cue.   sets up record in/out/trigger times *//* to punch over that cue                                              *//* currently,  the cue must be in the current project and it           *//* can not be a reel                                                   */SET.RECORD.CUE.LOCK.TIMES: proc public swapable;   dcl start	(1)		fixed;   dcl stop		(1)		fixed;   dcl sync		(1)		fixed;   dcl time		(1)		fixed;   dcl a			(1)		fixed;   dcl mode					fixed;   dcl name		(17-1)	fixed;   dcl temp		(4)	  	fixed;   dcl cuebits				fixed;   round32:proc(num);      /* routine to round up by 128 samples */      dcl num array;      call ADD16(128,num);      num(lw#lsb) = num(lw#lsb) & "177400";   end round32;   if Record.Group=0 then Return;          /* no record group */   if Record.Mode = RM.CUE.LOCK then do;   /* Cue Lock mode   */      call STR32(0,zero.time,start);       /* set up for    */      call STR32(0,zero.time,stop );       /* possible      */      call STR32(0,zero.time,sync );       /* failure       */      call COPY.STRING('** Cue is not in Current Project', name);      if Current.Cue.Ptr <> 0 then do;     /* make sure shuttle is open */         call COMPUTE.ACTUAL.DTD.IN.SAMPLE.#(Current.Cue.Ptr);         write(mam) = Current.Cue.Ptr;     /* look up info from current cue */         write(mal) = CUE.S.MSB;        /* get info about current cue */         call COPY.IN(addr(start(0)), 2);         write(mal) = CUE.E.MSB;         call COPY.IN(addr(stop (0)), 2);         write(mal) = CUE.SMPT.MSB;         call COPY.IN(addr(sync (0)), 2);         write(mal) = CUE.SMPT.MODE;         mode       = read(md);         write(mal) = CUE.BITS;         cuebits    = read(md);         /* sync time is easy: */         if (cuebits & bit3) = 0      /* cue.smpt.msb is relative to smpte offset */         then call SBITS.TO.MSEC(sync ,cf#time, SAMP.SPEED, mode, sync);         else do;            call SBITS.TO.SMPTE(sync, mode, temp);            call SMPTE.TO.MSEC(temp, cf#time, SAMP.SPEED, SM.MODE, loc(addr(SM.HRS)), sync);            if sync(0) < 0           /* but might be before start of sequence */            then call STR32(0, zero.time, sync);         end;         /* compute in/out times with respect to current proj */         call SUB32(stop, start, time);     /* get cue length, samples */         write(mam) = Current.Cue.Ptr;      /* and get in.s#           */         write(mal) = CUE.IN.S#.MSB;         call COPY.IN(addr(start(0)), 2);   /* actual in sample #      */         call ADD32(start, time, stop);     /* and abs out time        */         /* make sure cue is in current project: */         call COPY32(start, a); call ROUND32(a);         if  (COM32(a, AEE.Current.Project.Base) >= lw#ieq)         and (COM32(a, AEE.Current.Project.End )  = lw#ilt)         then do;            if COM32(stop, AEE.Current.Project.End) = lw#igt            then call COPY32(AEE.Current.Project.End, stop);            call DTD.Sample.#.To.Msecs(Start, CF#Time, S$Speed, AEE.Current.Project.Rate, AEE.Current.Project.Base, Start);            call DTD.Sample.#.To.Msecs(Stop,  CF#Time, S$Speed, AEE.Current.Project.Rate, AEE.Current.Project.Base, Stop );            write(mam) = Current.Cue.Ptr;  /* look up cue name for display */            write(mal) = CUE.NAME;                     call COPY.IN(addr(name(0)),17);          end;         /* if cue is not in current project, just set record */         /* times to 0                                        */         else do;            call STR32(0,zero.time,start);            call STR32(0,zero.time,stop );         end;      end;      /* use deposit reporting to get start time */      call Deposit.32Bit.MSEC(Record.Disk.Start.Time,Start,Zero.Zero);      call COPY32(Start,Record.Disk.Start);      /* set stop times here so consistency checking works */      disable.deposits = 1;      call Deposit.32Bit.MSEC(Record.Disk.Stop.Time,stop,Zero.Zero);      call COPY32(Stop,Record.Disk.Stop);      call Deposit.32Bit.MSEC(Record.Trig.Start.Time,sync,Zero.Zero);      call COPY32(Sync,Record.Trig.Start);      call SUB32(Record.Disk.Stop,Record.Disk.Start,time);      call ADD32(Record.Trig.Start,time,Record.Trig.Stop);      call Deposit.32Bit.Msec(Record.Trig.Stop.Time,Record.Trig.Stop,Zero.Zero);      call deposit.string(Record.Cue.Name.Id,name);      disable.deposits = 0;   end;   /* Set TSM Ratio and New Length when calling up a cue */   write(mam) = Current.Cue.Ptr;     /* look up info from current cue */   write(mal) = CUE.S.MSB;           /* get info about current cue */   call COPY.IN(addr(start(0)), 2);   write(mal) = CUE.E.MSB;   call COPY.IN(addr(stop (0)), 2);   call SUB32(stop, start, time);     /* get cue length, samples */   call DTD.Sample.#.To.Msecs(time, CF#Dur, S$Speed, AEE.Current.Project.Rate, Zero.Zero, Time);   write(mam) = Current.Cue.Ptr;      /* get name handy in case move */   write(mal) = CUE.NAME;             /* or bounce                   */   call COPY.IN(addr(name(0)),17);    disable.deposits = 1;      call Deposit.Fixed.Point(Record.TSM.Ratio, TSM#Ratio.Default);      call Deposit.32bit.Msec (Record.TSM.Length, Zero.Zerotime, Time);      if  (Record.Trigger = RT.BOUNCE)  /* for bounce & move, fetch   */      or  (Record.Trigger = RT.MOVE  )  /* name on cue recall         */      then call deposit.string(Record.Cue.Name.Id,name);   disable.deposits = 0;   if  (Record.Trigger = RT.BOUNCE)   then call CHECK.RECORD.CUE.NAME;end SET.RECORD.CUE.LOCK.TIMES;