/* AUD-PMGR  DIRECT-TO-DISK PROJECT MANAGER *//*   Modified:      01/23/88 - cj  - changes for multi track DDT user iface      07/29/88 - cj  - changed enables for actually draw one project      07/26/88 - CJ  - changed the way select project works      06/18/88 - CJ  - ADDED fields for DDT/Bouce routings      05/02/88 - SGS - modified Select.Current.Project to accept proj #      04/29/88 - JSS - Project.Onebar.Gain.Type now defined for decibels      04/27/88 - SGS - modified Map.Project.Selection to return project #*/dcl Project.Manager.Group           fixed public;dcl Project.Manager.Screen.Space    fixed;dcl Project.Manager.Mode            fixed public;  /* 0 - Undefined      */                                                   /* 1 - Show all       */                                                   /* 2 - Show Project   */                                                   /* negative means "last display was..." */dcl Project.Manager.Row             fixed;dcl Project.Manager.Size            fixed public;dcl Project.Manager.User.Size       fixed public;dcl Project.Manager.Command         fixed;dcl Project.Manager.Prompt          fixed;dcl Project.Manager.OK.Button       fixed;dcl Project.Manager.Cancel.Button   fixed;dcl Project.Mod.Label               fixed;dcl Project.Switch.Id               fixed;dcl Project.Number.Id               fixed;dcl Project.Name.Id                 fixed;dcl Project.Start.Time              fixed;dcl Project.End.Time                fixed;dcl Project.Status.Switch           fixed;dcl Project.Rate                    fixed;dcl Allbar.Select.Bits(3)           fixed;   /* 50 bits for selecting projects on SHOW ALL displaty */dcl Project.Allbar.Track.Region     fixed;dcl Project.Allbar.Dividers         fixed;dcl Project.Allbar.ShowProj.Label   fixed;dcl Project.Allbar.SwitchProj.Label fixed;dcl Project.Allbar.NewProj.Label    fixed;dcl Project.Allbar.ChangeLock.Label fixed;dcl Project.Allbar.Erase.Label      fixed;dcl Project.Allbar.EraseAll.Label   fixed;dcl Project.Onebar.Top.Drive        fixed public;dcl Onebar.Select.Bits              fixed;  /* 16 bits used for selecting drives for erase, lock, etc. */dcl Project.Onebar.EraseDrive       fixed;dcl Project.Onebar.Lock             fixed;dcl Project.Onebar.Unlock           fixed;dcl Project.Onebar.AllRepro         fixed;dcl Project.Onebar.AllInput         fixed;dcl Project.Onebar.AllAuto          fixed;dcl Project.Onebar.AllCuePB         fixed;dcl Project.Onebar.AllSafe          fixed;dcl Project.Onebar.ShowAll          fixed;dcl Project.Onebar.Size             fixed;dcl Project.Onebar.Drive.Type       fixed;dcl Project.Onebar.Drive.Table      fixed;dcl Project.Onebar.Name.Type        fixed;dcl Project.Onebar.Name.Table       fixed;dcl Project.Onebar.Status.Type      fixed public;dcl Project.Onebar.Status.Table     fixed public;dcl Project.Onebar.Mode.Type        fixed public;dcl Project.Onebar.Mode.Table       fixed public;dcl Project.Onebar.Used.Type        fixed;dcl Project.Onebar.Used.Table       fixed;dcl Project.Onebar.Source.Type      fixed;dcl Project.Onebar.Source.Table     fixed;dcl Project.Onebar.Channel.Type     fixed;dcl Project.Onebar.Channel.Table    fixed;dcl Project.Onebar.Gain.Type        fixed;dcl Project.Onebar.Gain.Table       fixed;dcl Project.Onebar.Out.Type         fixed;dcl Project.Onebar.Out.Table        fixed;dcl Project.Onebar.Voice.Type       fixed;dcl Project.Onebar.Voice.Table      fixed;dcl Project.Onebar.Vol.Type         fixed;dcl Project.Onebar.Vol.Table        fixed;dcl Project.Onebar.Pan.Type         fixed;dcl Project.Onebar.Pan.Table        fixed;dcl Project.Onebar.DDT.Type         fixed;dcl Project.Onebar.DDT.Table        fixed;dcl Project.Onebar.Scroll.Bar       fixed;dcl Update.Project.Manager          proc recursive;/* $page - Display Project Line *//* This routine gets information for the current project from the *//* DTD system.   It fills in the top line of the PMGR panel       */DISPLAY.PROJECT.LINE: proc swapable;   dcl proj.start(1)  fixed;   dcl proj.end(1)    fixed;   dcl proj.mod       fixed;   dcl proj.status    fixed;   dcl proj.rate      fixed;   dcl proj.title(12) fixed;   dcl i              fixed;   if LOD.Running <> 0 then do;      call Fetch.DTD.Song.Directory(AEE.Current.Project);      write(mam) = SCSI.Ptr;      write(mal) = 1;      do i = 1 to 12;         proj.title(i) = read(mdi);      end;      proj.start(0) = read(mdi);      proj.end(0)   = read(mdi);      proj.rate     = read(mdi);      write("324")  = read(mdi);      proj.status   = read(mdi);      proj.mod      = read(mdi);      /* convert project start/end times to 32-bit milliseconds */      /* for display purposes                                   */      load proj.start(0); mul  1000; proj.start(0) = ures; proj.start(1) = res;      load proj.end(0);   mul  1000; proj.end(0)   = ures; proj.end(1)   = res;      proj.title(0)=23;      Disable.Deposits = true;      call Deposit.Fixed.Point(Project.Number.Id, AEE.Current.Project+1);      call Deposit.String(Project.Name.Id,proj.title);      call Deposit.32Bit.MSEC(Project.Start.Time,Zero.Zerotime,proj.start);      call Deposit.32Bit.MSEC(Project.End.Time,Zero.Zerotime,proj.end);      call Deposit.Fixed.Point(Project.Rate,proj.rate);      if      (proj.status&1)=0 then i = 0;        /* empty    */      else if (proj.status&2)=0 then i = 1;        /* unlocked */      else                           i = 2;        /* locked   */      call Deposit.Switch(Project.Status.Switch,i);      if proj.mod = 0 then call Set.Object.Attr(Project.Mod.Label,0,ATTR#Normal);      else                 call Set.Object.Attr(Project.Mod.Label,0,ATTR#Reverse);      Disable.Deposits = false;   end;end DISPLAY.PROJECT.LINE;/* $page - display all projects *//* This routine gets the allocation directory from the DTD.   it *//* indicates which areas have been recorded on.   A visual       *//* display of this information is presented                      */DISPLAY.ALL.PROJECTS: proc swapable;   dcl row            lit 'Project.Manager.Row';   dcl size           lit 'Project.Manager.Size';   dcl top.drive      fixed;   dcl drives         fixed;   dcl time           fixed;   dcl Alloc.Y        fixed;   dcl (i,j,k)        fixed;   dcl Alloc.End      fixed;   dcl Alloc.Start    fixed;   dcl Alloc.Status   fixed;   dcl Alloc.Rate     fixed;   dcl Alloc.Mod      fixed;   dcl Alloc.Title (12) fixed;   dcl (x1,x2,y1,y2)  fixed;   dcl last.end       fixed;   dcl last.start     fixed;   dcl pix.per.sec    fixed;  /* 1000 * pixels per second of dtd time */   /* Recompute pix.per.sec every time display is done */   ALLOC.X: proc (sec,pix.per.sec) returns (fixed);      dcl sec         fixed;      dcl pix.per.sec fixed;      load  sec;      mul   pix.per.sec;            mwait;      div   1000;      sec = res + (rem > 500);      return sec + gpos.x(300);   end ALLOC.X;   /* compute 1000 * pixels per second of audio */   load   gpos.x(7900)-gpos.x(300);   mul    1000;          mwait;   div    DTD.MAX.SECS;   pix.per.sec = res + (rem > shr(DTD.MAX.SECS,1));   call Mouse.Switch(0);   do k = 0 to 40 by 10;           /* Display all titles and draw project borders */      call Fetch.DTD.Song.Directory(k);      call COPY.EXT.MEM.SEC(SCSI.Ptr,TRD.Ptr,1);  /* SECTOR BOUNDARIES & LENGTH   */      i = 0;      do while (i < 10);         write(mam) = TRD.Ptr;         write(mal) = i*24+13;    /* Get to start time */         alloc.start = read(mdi);         alloc.end   = read(mdi);         if alloc.start + alloc.end > 0 then do;            alloc.start = alloc.x(alloc.start,pix.per.sec);  /* Convert to avoid compiler bug */            alloc.end   = alloc.x(alloc.end,  pix.per.sec);            vector_mode;            call Data_Level(1);            call pc(27); call ps('|P_');            call Blockmode_On;            y1 = gpos.y((row+1)*100-50);            call connect(alloc.start+1,y1+13,alloc.end-1,y1-4); /* Erase previous title */            call Blockmode_Off;            call Data_Level(0);            write(mam) = TRD.Ptr;            write(mal) = i*24+1;            j = 1;            do while j <= 12;               alloc.title(j) = read(mdi);               j = j + 1;            end;            alloc.title(0) = 24;            call move_to(alloc.start+3,y1);            alpha_mode;            x1 = ((alloc.end-alloc.start)/7);            if x1 < alloc.title(0) then alloc.title(0) = x1;            call pc(27); call ps(';');            call ps(alloc.title);            vector_mode;            y1 = gpos.y(row*100+20);            y2 = gpos.y((row+size-2)*100-10);            call line_type(1);            call connect(alloc.start,y1,alloc.start,y2);            call connect(alloc.end,  y1,alloc.end,  y2);            call line_type(0);         end;         i = i + 1;      end;   end;   /* now fill in drive items */   /* Compute how many lines of drive allocation display will fit */   /* on the screen:                                              */   drives = 2*(Project.Manager.Size-3);  /* # of drives we can show here */   if drives >= DTD.MAX.TRACKS           /* start drawing from drive 0   */   then top.drive = 0;                   /* if all drives will fit       */   /* if all drives won't fit, then start with project.onebar.top.drive  */   /* or lower drive if we can get all after project.onebar.top.drive:   */   else if (DTD.MAX.TRACKS-drives) < Project.Onebar.Top.Drive   then top.drive = DTD.MAX.TRACKS-drives;   else top.drive = Project.Onebar.Top.Drive;   i = top.drive;                       /* start with this drive */   do while (i < (top.drive+drives))   and      (i < DTD.MAX.TRACKS    );      alloc.y = gpos.y(row*100+100)-((i-top.drive+1)*13)+6;      call move_to(gpos.x(100),alloc.y-4);      alpha_mode;      call pc(27); call ps(':');      call pnum(i+1,0);      vector_mode;      call Send.To.Lod(13,0);        /* Select track info */      write(mam) = SCSI.Ptr;      write(mdi) = i;      call Send.To.Lod(143,2);      call Send.To.Lod(18,0);      call COPY.EXT.MEM.SEC(SCSI.Ptr,TRD.Ptr,1);  /* SECTOR BOUNDARIES & LENGTH  */      write(mam) = TRD.Ptr;      k = 0;      do j = 0 to 63;         k = k + read(mdi) + read(mdi);  /* compute checksum */      end;      if k <> GID(Checksum.Drive.Allocation+i) then do;         call PID(CheckSum.Drive.Allocation+i,k);         call Data_Level(1);           /* erase */         call pc(27); call ps('|P_');  /* Solid fill */         call Blockmode_On;         /* erase from start of disk out to */         /* first recorded segment          */         write(mam)  = TRD.Ptr;    /* check first allocation element */         if read(md)<>0 then do;   /* if nonzero, then first recorded section of the disk is not at 0.000 */            alloc.end   = 0;            alloc.start = read(md);            alloc.end   = alloc.x(alloc.end,pix.per.sec);            alloc.start = alloc.x(alloc.start,pix.per.sec);            call connect(alloc.end,alloc.y+4,alloc.start,alloc.y-4);         end;         last.end = 0;         do j = 0 to 63;    /* Scan alloc table */            write(mam)  = TRD.Ptr;            write(mal)  = shl(j,1)+1;            alloc.end   = read(mdi);            alloc.start = read(mdi);            if alloc.end <> 0 then last.end = alloc.end;            if (alloc.start-alloc.end) > 0 then do;               alloc.end   = alloc.x(alloc.end,pix.per.sec);               alloc.start = alloc.x(alloc.start,pix.per.sec);               call connect(alloc.end,alloc.y+4,alloc.start,alloc.y-4);            end;         end;         if alloc.x(last.end,pix.per.sec) <> alloc.x(dtd.max.secs,pix.per.sec)  /* erase from last recorded area to end of disk */         then call connect(alloc.x(last.end,pix.per.sec),alloc.y+4,alloc.x(dtd.max.secs,pix.per.sec),alloc.y-4);         call Data_Level(0);         do j = 0 to 63;            write(mam)  = TRD.Ptr;            write(mal)  = shl(j,1);            alloc.start = read(mdi);            alloc.end   = read(mdi);            if (alloc.end + alloc.start > 0)   /* at least one non-zero */            & ((alloc.end-alloc.start) >= 0)            then do;                alloc.start = alloc.x(alloc.start,pix.per.sec);  /* Convert to avoid compiler bug */               alloc.end   = alloc.x(alloc.end,pix.per.sec);               call connect(alloc.start,alloc.y+4,alloc.end,alloc.y-4);            end;         end;         call Blockmode_Off;         x1 = alloc.x(0,pix.per.sec);         x2 = alloc.x(DTD.MAX.SECS,pix.per.sec);         call connect(x1,alloc.y,x2,alloc.y);      end;      i = i + 1;   end;   call Mouse.Switch(1);   transparent_mode;end DISPLAY.ALL.PROJECTS;/* $PAGE - Actually display one project *//* This routine is called whenever Display.New.Project.Info is <> 0. *//* It gets the project information from the Direct-To-Disk and       *//* presents it on the screen.                                        *//* We check for mouse presses and input character while we are       *//* doing this so that system response is speedy                      */dcl Events.Pending proc external; /* must know if smger has something for us */ACTUALLY.DISPLAY.ONE.PROJECT: proc PUBLIC swapable;   dcl row           lit 'Project.Manager.Row';   dcl size          lit 'Project.Manager.Size';   dcl top.drive     lit 'Project.Onebar.Top.Drive';   /* The following variables hold a temp copy */   /* of the track info:                       */   dcl task          fixed;  /* so far not used               */   dcl track.title(8) fixed; /* look up info for this track   */   dcl status        fixed;  /* into these global variables   */   dcl mode          fixed;  /* first                         */   dcl used(1)       fixed;   dcl source        fixed;   dcl channel       fixed;   dcl gain          fixed;   dcl output        fixed;   dcl volume        fixed;   dcl pan           fixed;   dcl ddt           fixed;   dcl (i,j,k)       fixed;   dcl tstr   (8)    fixed;   if DTD.Max.Secs = 0 then do;       /* if DTD is not finished initializing */      Display.New.Project.Info = 0;   /* then quit                           */      return;   end;   if Send.For.Track.Directory = 0    /* Send for track directory.  if it    */   then do;                           /* is not available,  then quit also   */      Display.New.Project.Info = 0;      return;   end;   if  (Check.Next.Event   <> 0)  /* if system event pending   */   or  (new.in.char        <> 0)  /* or inchar pending         */   or  (new.mouse.button   <  0)  /* or mouse press pending    */   or  (m$Presses          <> 0)  /* or stacked                */   or  (Events.Pending     <> 0)  /* or screen events          */   then do;                       /* then quit here.           */      return;                     /* return back here when     */   end;                           /* we have free time         */   do i = 0 to 15;                /* check all bits            */      /* See if this track needs to be updated: */      if (Display.New.Project.Info & bits(i)) <> 0      then do;         if  (i < (top.drive       ))     /* if this track is not  */         or  (i > (top.drive+size-4))     /* being displayed, then */         then do;                         /* no update required    */            Display.New.Project.Info = Display.New.Project.Info                                     xor bits(i);         end;         else do;                         /* else update it        */            write(mam) = TRD.Ptr + shr(24+16*i,8);            write(mal) = 24+16*i;            do j = 1 to 8;               track.title(j) = read(mdi);            end;            track.title(0) = 16;            status    = read(md)&7;            mode      = shr(read(mdi),8);            used(0)   = read(mdi);            source    = shr(read(md),8);            channel   = read(mdi) & 255;            gain      = read(mdi);            volume    = read(mdi);            pan       = read(mdi);            task      = read(mdi);            output    = read(md) & 255;            ddt       = shr(read(mdi),8);            bitlsb = used(0);     /* Compute used scaled by sample rate */            bitmsb = 0;           /* to get used in real time           */            call ratio_multiply(500,Fetch.Fixed.Point(Project.Rate));            load  bitlsb;            mul   1000;            used(0) = ures;            used(1) = res;            Disable.Deposits = true;            call Fetch.Table(Project.Onebar.Drive.Table,0,i-top.drive);            call Deposit.Fixed.Point(Project.Onebar.Drive.Type,i+1);            call Deposit.Table(Project.Onebar.Drive.Table,0,i-top.drive);            call Fetch.Table(Project.Onebar.Name.Table,0,i-top.drive);            call Deposit.String(Project.Onebar.Name.Type,track.title);            call Deposit.Table(Project.Onebar.Name.Table,0,i-top.drive);            /* Make sure status switch contains the correct string: */            call Fetch.Table(Project.Onebar.Status.Table,0,i-top.drive);            if (Dtd.Avail.Trks&bits(i)) = 0     /* if unavail,  then use    */            then j = 3;                         /* unavail;unavail;         */            else if status >=2                  /* else if locked, then     */            then j = 2;                         /* use locked;locked        */            else j = 1;                         /* else use safe/ready      */            if j <> GID(Pmgr.Status.Contents+i-top.drive) /* change switch contents   */            then do;                                      /* if it is not right       */               call PID(Pmgr.Status.Contents+i-top.drive,j);               do case (j-1);                   /* set switch contents      */                  do;                     call copy.string('Safe   ',tstr);                     call Deposit.Switch.Field(Project.Onebar.Status.Type,0,tstr);                     call copy.string('*READY*',tstr);                     call Deposit.Switch.Field(Project.Onebar.Status.Type,1,tstr);                  end;                  do;                     call copy.string('Locked ',tstr);                     call Deposit.Switch.Field(Project.Onebar.Status.Type,0,tstr);                     call copy.string('Locked ',tstr);                     call Deposit.Switch.Field(Project.Onebar.Status.Type,1,tstr);                  end;                  do;                     call copy.string('Unavail',tstr);                     call Deposit.Switch.Field(Project.Onebar.Status.Type,0,tstr);                     call copy.string('Unavail',tstr);                     call Deposit.Switch.Field(Project.Onebar.Status.Type,1,tstr);                  end;               end;            end;            call Deposit.Switch(Project.Onebar.Status.Type,status);            call Deposit.Table(Project.Onebar.Status.Table,0,i-top.drive);            call Fetch.Table(Project.Onebar.Mode.Table,0,i-top.drive);            call Deposit.Switch(Project.Onebar.Mode.Type,mode);            call Deposit.Table(Project.Onebar.Mode.Table,0,i-top.drive);            call Fetch.Table(Project.Onebar.Used.Table,0,i-top.drive);            call Deposit.32Bit.MSEC(Project.Onebar.Used.Type,Zero.Zerotime,used);            call Deposit.Table(Project.Onebar.Used.Table,0,i-top.drive);            call Fetch.Table(Project.Onebar.Source.Table,0,i-top.drive);            call Deposit.Switch(Project.Onebar.Source.Type,source);            call Deposit.Table(Project.Onebar.Source.Table,0,i-top.drive);            /* Make sure input channel switch contains correct contents: */            call Fetch.Table(Project.Onebar.Channel.Table,0,i-top.drive);            /* See what string should be stored in the channel switch: */            if  (Source =  1)             /* of source is DIG          */            and ((ddt.config & 15) = 2)   /* and multi track DDT avail */            then j = 2+i;                 /* construct switch          */            else if (Source <> 0)  /* if dig, out, trk, then use 1 - 16 */            then j = 1;            else j = 0;            /* else use 1A - 4D                  */            if j <> GID(Pmgr.Channel.Contents+i-top.drive) /* change switch contents   */            then do;                                       /* if it is not right       */               call PID(Pmgr.Channel.Contents+i-top.drive,j);               if j = 0               then do k = 0 to 16;                /* STM switch string        */                  do case(k);                     call copy.string('  ',tstr);                     call copy.string('1A',tstr);                     call copy.string('1B',tstr);                     call copy.string('1C',tstr);                     call copy.string('1D',tstr);                     call copy.string('2A',tstr);                     call copy.string('2B',tstr);                     call copy.string('2C',tstr);                     call copy.string('2D',tstr);                     call copy.string('3A',tstr);                     call copy.string('3B',tstr);                     call copy.string('3C',tstr);                     call copy.string('3D',tstr);                     call copy.string('4A',tstr);                     call copy.string('4B',tstr);                     call copy.string('4C',tstr);                     call copy.string('4D',tstr);                  end;                  call Deposit.Switch.Field(Project.Onebar.Channel.Type,k,tstr);               end;               else if j = 1               then do k = 0 to 16;  /* DIG, OUT, TRK switch string */                  do case(k);                     call copy.string('  ',tstr);                     call copy.string(' 1',tstr);                     call copy.string(' 2',tstr);                     call copy.string(' 3',tstr);                     call copy.string(' 4',tstr);                     call copy.string(' 5',tstr);                     call copy.string(' 6',tstr);                     call copy.string(' 7',tstr);                     call copy.string(' 8',tstr);                     call copy.string(' 9',tstr);                     call copy.string('10',tstr);                     call copy.string('11',tstr);                     call copy.string('12',tstr);                     call copy.string('13',tstr);                     call copy.string('14',tstr);                     call copy.string('15',tstr);                     call copy.string('16',tstr);                  end;                  call Deposit.Switch.Field(Project.Onebar.Channel.Type,k,tstr);               end;               /* Special switch string for Multi Track DDT hardware if */               /* source is DIG.   Set up string to be all --'s if      */               /* hardware not avail on this port,  or else set up      */               /* string to be all the correct channel number.          */               else do k = 0 to 16;                  if (ddt.avail.trks & bits(i)) = 0                  then call copy.string('--',tstr);                  else call conv.fixed.to.str(i+1, 0, 2, cf#right\cf#spfill, tstr);                  call Deposit.Switch.Field(Project.Onebar.Channel.Type,k,tstr);               end;            end;            call Deposit.Switch(Project.Onebar.Channel.Type,Channel);            call Deposit.Table(Project.Onebar.Channel.Table,0,i-top.drive);            if source = 0     /* for STM, use actual gain */            then gain = map_times_to_dB (gain); /* Convert stored "times" value to dB for display */            else gain = 0;    /* else use 0 for now       */            call Fetch.Table(Project.Onebar.Gain.Table,0,i-top.drive);            call Deposit.Fixed.Point(Project.Onebar.Gain.Type,gain);            call Deposit.Table(Project.Onebar.Gain.Table,0,i-top.drive);            call Fetch.Table(Project.Onebar.Out.Table,0,i-top.drive);            call Deposit.Fixed.Point(Project.Onebar.Out.Type,output);            call Deposit.Table(Project.Onebar.Out.Table,0,i-top.drive);            /* Now update voice information: */            call Fetch.Table(Project.Onebar.Voice.Table,0,i-top.drive);            call Deposit.Fixed.Point(Project.Onebar.Voice.Type,i+1);            call Deposit.Table(Project.Onebar.Voice.Table,0,i-top.drive);            call Fetch.Table(Project.Onebar.Vol.Table,0,i-top.drive);            call Deposit.Fixed.Point(Project.Onebar.Vol.Type,volume);            call Deposit.Table(Project.Onebar.Vol.Table,0,i-top.drive);            call Fetch.Table(Project.Onebar.Pan.Table,0,i-top.drive);            call Deposit.Fixed.Point(Project.Onebar.Pan.Type,pan);            call Deposit.Table(Project.Onebar.Pan.Table,0,i-top.drive);            call Fetch.Table(Project.Onebar.DDT.Table,0,i-top.drive);            if ((ddt.config & 15) = 2)   /* if multi track DDT avail */            then do;               if (ddt.avail.trks & bits(i)) = 0               then call Deposit.Fixed.Point(Project.Onebar.DDT.Type, 0);               else call Deposit.Fixed.Point(Project.Onebar.DDT.Type, i+1);            end;            else call Deposit.Fixed.Point(Project.Onebar.DDT.Type,ddt);            call Deposit.Table(Project.Onebar.DDT.Table,0,i-top.drive);            Disable.Deposits = false;            Display.New.Project.Info = Display.New.Project.Info                                     xor bits(i);            if  (Check.Next.Event   <> 0)  /* if system event pending   */            or  (new.in.char        <> 0)  /* or inchar pending         */            or  (new.mouse.button   <  0)  /* or mouse press pending    */            or  (m$Presses          <> 0)  /* or stacked                */            or  (Events.Pending     <> 0)  /* or screen events          */            then do;                       /* then quit here.           */               return;                     /* return back here when     */            end;                           /* we have free time         */         end;      end;   end;end ACTUALLY.DISPLAY.ONE.PROJECT;/* load divider icon for "show project" display: */LOAD.ONEBAR.ICON: proc (icon,size) swapable;   dcl icon          array;   dcl size          fixed;   dcl (i,j)         fixed;   i = -((size-1)*100);   j = i-96;   write("313") = addr(icon(0));      MR13i = O#ICON.Connect;     /* horiz bar above fields */                MR13i = -10;                MR13i = i;                MR13i = 8010;                MR13i = i;   MR13i = O#ICON.Connect;     /* after "show all"       */                MR13i = 1000;                MR13i = i;                MR13i = 1000;                MR13i = j;   MR13i = O#ICON.LineType;    /* set dashed line        */                MR13i = 1;   MR13i = O#ICON.Connect;                MR13i = 2200;  /* after repro            */                MR13i = i-27;                MR13i = 2200;                MR13i = j+27;   MR13i = O#ICON.Connect;     /* after input            */                MR13i = 2900;                MR13i = i-27;                MR13i = 2900;                MR13i = j+27;   MR13i = O#ICON.Connect;     /* after auto             */                MR13i = 3500;                MR13i = i-27;                MR13i = 3500;                MR13i = j+27;   MR13i = O#ICON.Connect;     /* after cue pb           */                MR13i = 4300;                MR13i = i-27;                MR13i = 4300;                  MR13i = j+27;   MR13i = O#ICON.LineType;                MR13i = 0;   MR13i = O#ICON.Connect;     /* after safe             */                MR13i = 4900;                MR13i = i;                MR13i = 4900;                MR13i = j;   MR13i = O#ICON.Connect;     /* after "LOCK"           */                MR13i = 5500;                MR13i = i;                MR13i = 5500;                MR13i = j;   MR13i = O#ICON.Connect;     /* after "UNLOCK"         */                MR13i = 6300;                MR13i = i;                MR13i = 6300;                MR13i = j;   MR13i = O#ICON.Connect;     /* after "ERASE"         */                MR13i = 7000;                MR13i = i;                MR13i = 7000;                MR13i = j;   /* solid area between tracks & outputs: */   MR13i = O#Icon.BlockModeOn;   MR13I     = O#ICON.Connect;       MR13I = 5740;       MR13I = -104;       MR13I = 5790;       MR13I =    i;   MR13i = O#Icon.BlockModeOff;   MR13i = O#ICON.End;end LOAD.ONEBAR.ICON;/* Define project manager "show project" items */DEFINE.PROJECT.MANAGER.ONEBAR: proc(row,size) swapable;   dcl size          fixed;   dcl row           fixed;   dcl (x1,x2,y1,y2) fixed;   dcl (i,j)         fixed;   dcl Project.Onebar.Dividers  fixed;   dcl Project.Onebar.Label     fixed;   if (Project.Manager.Mode = 1) then do;  /* Must erase Show All display */      call Erase.Object.Range(Project.Manager.Alloc+100,Project.Allbar.EraseAll.Label);      call Undefine.Object.Range(Project.Manager.Alloc+100,Project.Allbar.EraseAll.Label);      call Mouse.Switch(0);      vector_mode;      call pc(27); call ps('|P_');      call Data_Level(1);      call Blockmode_On;                  /* This code does a blockmode */      x1 = gpos.x(10);                    /* graphics erase of the      */      x2 = gpos.x(8000);                  /* Show All display           */      y1 = gpos.y(row*100+10);      y2 = gpos.y((row+size-2)*100-10);      call connect(x1,y1,x2,y2);             call Blockmode_Off;      call Data_Level(0);      transparent_mode;      call mouse.switch(1);      do i = 0 to 15;         call PID(Checksum.Drive.Allocation+i,-1);      end;      call Select.New.Cur.Obj(Corner.Label,-1,-1);   end;   Project.Allbar.ShowProj.Label   = 0; /* zero out all show all variables */   Project.Allbar.SwitchProj.Label = 0; /* both when re-opening pmgr, as   */   Project.Allbar.NewProj.Label    = 0; /* well as when returning to       */   Project.Allbar.ChangeLock.Label = 0; /* screen                          */   Project.Allbar.Erase.Label      = 0;    Project.Allbar.EraseAll.Label   = 0;   call Set.Auto.Allocation.Id(Project.Manager.Alloc+100);   call Set.Default.Action(O#ACT.Middle.Press \ O#ACT.Update.On.Dep);   call Set.Default.Attr(0,ATTR#Normal\ATTR#AltIntensity);   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);   call LOAD.ONEBAR.ICON (misc.buf, size);   Project.Onebar.Dividers         = Define.Graphics.Icon(S#AA,0,(row*100)-100,0,misc.buf);   Project.Onebar.ShowAll          = Define.Label(S#AA,row+size-1, 0,0,' Show All ');   i                               = Define.Label(S#AA,row+size-1,11,0,'ALL:');   call                              Set.Object.Mouse.Access(i,0);   Project.Onebar.AllRepro         = Define.Label(S#AA,row+size-1,15,0,' Repro ');   Project.Onebar.AllInput         = Define.Label(S#AA,row+size-1,22,0,' Input ');   Project.Onebar.AllAuto          = Define.Label(S#AA,row+size-1,29,0,' Auto ');   Project.Onebar.AllCuePB         = Define.Label(S#AA,row+size-1,35,0,' Cue PB ');   Project.Onebar.AllSafe          = Define.Label(S#AA,row+size-1,43,0,' Safe ');   Project.Onebar.Lock             = Define.Label(S#AA,row+size-1,49,0,' Lock ');   Project.Onebar.Unlock           = Define.Label(S#AA,row+size-1,55,0,' Unlock ');   Project.Onebar.EraseDrive       = Define.Label(S#AA,row+size-1,63,0,' Erase ');   i                               = Define.Label(S#AA,row+size-1,71,0,'Size:');   call                              Set.Object.Mouse.Access(i,0);   Project.Onebar.Label            = Define.Label(S#AA,row+1,0,0,   'No. Track Title      Status  Mode    Used  Input   dB Out No.  Vol  Pan DDT');   call                              Set.Object.Mouse.Access(Project.Onebar.Label,0);   call Set.Default.Attr(0,ATTR#Normal);   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse);   Project.Onebar.Drive.Type       = Define.Fixed.Point(S#AA,row+2,0,3,0,cf#right\cf#forcedp);   Project.Onebar.Drive.Table      = Define.Table(S#AA,1,size-3,Project.Onebar.Drive.Type);   call                              Set.Object.Mouse.Access(Project.Onebar.Drive.Table,0);   Project.Onebar.Voice.Type       = Define.Fixed.Point(S#AA,row+2,58,3,0,cf#right\cf#forcedp);   Project.Onebar.Voice.Table      = Define.Table(S#AA,1,size-3,Project.Onebar.Voice.Type);   /* define objects user can type info into in order to simplify */   /* auto arrow link set below:                                  */   Project.Onebar.Name.Type        = Define.String(S#AA,row+2, 4,16,O#STR.General);   Project.Onebar.Name.Table       = Define.Table(S#AA,1,size-3,Project.Onebar.Name.Type);   call Set.Default.Action(O#ACT.Left.Press|O#ACT.Middle.Press|O#ACT.Right.Press|O#ACT.Update.On.Dep);   Project.Onebar.Size             = Define.Fixed.Point(S#AA,row+size-1,77,2,0,cf#right);   Project.Onebar.Gain.Type        = Define.Fixed.Point(S#AA,row+2,50,3,0,cf#right\cf#signed\cf#subspace);   Project.Onebar.Gain.Table       = Define.Table(S#AA,1,size-3,Project.Onebar.Gain.Type);   Project.Onebar.Out.Type         = Define.Fixed.Point(S#AA,row+2,54,2,0,cf#right\cf#subspace);   Project.Onebar.Out.Table        = Define.Table(S#AA,1,size-3,Project.Onebar.Out.Type);   Project.Onebar.Vol.Type         = Define.Fixed.Point(S#AA,row+2,62,5,1,cf#right);   Project.Onebar.Vol.Table        = Define.Table(S#AA,1,size-3,Project.Onebar.Vol.Type);   Project.Onebar.Pan.Type         = Define.Fixed.Point(S#AA,row+2,68,3,0,cf#right\cf#signed);   Project.Onebar.Pan.Table        = Define.Table(S#AA,1,size-3,Project.Onebar.Pan.Type);   Project.Onebar.DDT.Type         = Define.Fixed.Point(S#AA,row+2,72,2,0,cf#right\cf#subspace);   Project.Onebar.DDT.Table        = Define.Table(S#AA,1,size-3,Project.Onebar.DDT.Type);   call Set.Default.Action(O#ACT.Middle.Press|O#ACT.Update.On.Dep);   Project.Onebar.Used.Type        = Define.32Bit.MSEC(S#AA,row+2,36,6,O#MSEC.Minutes.Seconds\O#MSEC.RealTime,cf#dur,3,cf#suppress);   Project.Onebar.Used.Table       = Define.Table(S#AA,1,size-3,Project.Onebar.Used.Type);   /* Note: leave room for 'UNAVAIL;UNAVAIL' in switch: */   Project.Onebar.Status.Type      = Define.Switch(S#AA,row+2,21,7,0,'       |       ');   /* set status and mode tables to update on deposit */   /* to provide for real time updates of terminal    */   /* displays from button panel                      */   Project.Onebar.Status.Table     = Define.Table(S#AA,1,size-3,Project.Onebar.Status.Type);   call                              Set.Object.Action(Project.Onebar.Status.Table,O#ACT.Update.On.Dep, true);   do i = 0 to 15;                         /* indicate each status switch */      call PID(Pmgr.Status.Contents+i, 0); /* contains the basic safe/    */   end;                                    /* ready string                */   Project.Onebar.Mode.Type        = Define.Switch(S#AA,row+2,29,5,0,'Repro|Input|Auto|CuePB');   Project.Onebar.Mode.Table       = Define.Table(S#AA,1,size-3,Project.Onebar.Mode.Type);   call                              Set.Object.Action(Project.Onebar.Mode.Table,O#ACT.Update.On.Dep, true);   Project.Onebar.Source.Type      = Define.Switch(S#AA,row+2,43,3,0,'STM|DIG|OUT|TRK');   Project.Onebar.Source.Table     = Define.Table(S#AA,1,size-3,Project.Onebar.Source.Type);   Project.Onebar.Channel.Type     = Define.Switch(S#AA,row+2,47,2,0,'  |1A|1B|1C|1D|2A|2B|2C|2D|3A|3B|3C|3D|4A|4B|4C|4D');   Project.Onebar.Channel.Table    = Define.Table(S#AA,1,size-3,Project.Onebar.Channel.Type);   do i = 0 to 15;                           /* indicate each channel swch  */      call PID(Pmgr.Channel.Contents+i, 0);  /* contains the basic 1A - 4D  */   end;                                      /* string                      */   call Set.Default.Action(O#ACT.Middle.Press);   Project.Onebar.Scroll.Bar       = Define.Scroll.Bar(S#AA,O#SBAR.Orient.Ver,O#SBAR.Just.Left,gpos.x(8014),gpos.y((row-1)*100),gpos.y((row+size-1)*100));   disable.deposits = 1;           /* because activate.scroll.bar does a deposit */   call                            Activate.Scroll.Bar(Project.Onebar.Scroll.Bar, 0);   disable.deposits = 0;   call                            Set.Scroll.Bar.Bits(Project.Onebar.Scroll.Bar,O#SBAR.Bits.Real.Time,true);   call Activate.Object.Range(Project.Manager.Alloc+100,Project.Onebar.Scroll.Bar);   call Set.Auto.Arrow.Link.Range(Project.Onebar.Name.Type,Project.Onebar.DDT.Table);   Project.Manager.Mode = 2;end DEFINE.PROJECT.MANAGER.ONEBAR;/* Define items for "Show All" display */DEFINE.PROJECT.MANAGER.ALLBAR: proc(row,size) swapable;   dcl size          fixed;   dcl row           fixed;   dcl lines (42)    fixed;   dcl (i,j)         fixed;   dcl (x1,x2,y1,y2) fixed;   dcl MR13i         lit 'write("373")';   i = -((size-1)*100);   j = i-96;   write("313") = addr(lines(0));   MR13i = O#ICON.Connect;                MR13i = -10;                MR13i = i;                MR13i = 8010;                MR13i = i;   MR13i = O#ICON.Connect;                MR13i = 1100;                MR13i = i;                MR13i = 1100;                MR13i = j;   MR13i = O#ICON.Connect;                MR13i = 2400;                MR13i = i;                MR13i = 2400;                MR13i = j;   MR13i = O#ICON.Connect;                MR13i = 3400;                MR13i = i;                MR13i = 3400;                MR13i = j;   MR13i = O#ICON.Connect;                MR13i = 4700;                MR13i = i;                MR13i = 4700;                MR13i = j;   MR13i = O#ICON.Connect;                MR13i = 5700;                MR13i = i;                MR13i = 5700;                MR13i = j;   MR13i = O#ICON.Connect;                MR13i = 6900;                MR13i = i;                MR13i = 6900;                MR13i = j;   MR13i = O#ICON.Connect;                MR13i = 8010;                MR13i = 0;                MR13i = 8010;                MR13i = j;   MR13i = O#ICON.End;   if Project.Manager.Mode = 2 then do;      call Erase.Object.Range(Project.Manager.Alloc+100,Project.Onebar.Scroll.Bar);      call Undefine.Object.Range(Project.Manager.Alloc+100,Project.Onebar.Scroll.Bar);      call Select.New.Cur.Obj(Corner.Label,-1,-1);   end;   Project.Onebar.ShowAll     = 0;   /* force all the one bar variables */   Project.Onebar.AllRepro    = 0;   /* to zero when opening the show   */   Project.Onebar.AllInput    = 0;   /* all panel (ie when returning    */   Project.Onebar.AllAuto     = 0;   /* to aee screen)                  */   Project.Onebar.AllCuePB    = 0;   Project.Onebar.AllSafe     = 0;   Project.Onebar.Lock        = 0;   Project.Onebar.Unlock      = 0;   Project.Onebar.EraseDrive  = 0;   Project.Onebar.Size        = 0;   call Set.Auto.Allocation.Id(Project.Manager.Alloc+100);   call Set.Default.Action(O#ACT.Middle.Press);   call Set.Default.Attr(0,ATTR#Normal\ATTR#AltIntensity);   call Set.Default.Attr(1,ATTR#Normal\ATTR#AltIntensity\ATTR#Reverse);   x1 = gpos.x(0);   y1 = gpos.y(row*100);   x2 = gpos.x(8000);   y2 = gpos.y((row+size-2)*100);   Project.Allbar.Track.Region     = Define.Graphics.Region(S#AA,x1,y1,x2,y2);   Project.Allbar.Dividers         = Define.Graphics.Icon(S#AA,0,(row*100)-100,0,lines);   /* These definitions must not change order */   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse); /* to be consistent with Allbar.Command.Activate() */   Project.Allbar.ShowProj.Label   = Define.Label(S#AA,row+size-1, 0,0,' Show Proj ');   Project.Allbar.SwitchProj.Label = Define.Label(S#AA,row+size-1,11,0,' Select Proj ');   Project.Allbar.NewProj.Label    = Define.Label(S#AA,row+size-1,24,0,' New Proj ');   Project.Allbar.ChangeLock.Label = Define.Label(S#AA,row+size-1,34,0,' Change Lock ');   Project.Allbar.Erase.Label      = Define.Label(S#AA,row+size-1,57,0,' Erase Proj ');   Project.Allbar.EraseAll.Label   = Define.Label(S#AA,row+size-1,69,0,' Erase All ');   call Set.Default.Attr(1,ATTR#Normal\ATTR#AltIntensity\ATTR#Reverse);   call Activate.Object.Range(Project.Manager.Alloc+100,Project.Allbar.EraseAll.Label);   do j = Project.Manager.Alloc+100 to Project.Allbar.EraseAll.Label;      call Update.Object(j);   end;   Project.Manager.Mode = 1;end DEFINE.PROJECT.MANAGER.ALLBAR;/* Define complete project manager panel */DEFINE.PROJECT.MANAGER.PANEL: proc(row,size) swapable;   dcl row         fixed;   dcl size        fixed;   dcl i           fixed;   dcl lines (30)  fixed;   dcl MR13i       lit 'write("373")';   dcl Project.Manager.Size.Box fixed;   dcl Project.Label            fixed;   dcl Project.Start.Label      fixed;   dcl Project.End.Label        fixed;   dcl Project.Rate.Label       fixed;   call Copy.String('PROJECT MANAGER',lines);   call Print.Panel.Title(row,lines);   write("313") = addr(lines(0));   MR13i = O#Icon.Connect;    /* horizontal line under project name, */      MR13i = - 10;           /* start, end, sample rate             */      MR13i = -100;      MR13i = 8010;      MR13i = -100;   MR13i = O#Icon.Connect;    /* vert line between name & start      */      MR13i = 3600;      MR13i =    0;      MR13i = 3600;      MR13i = -100;   MR13i = O#Icon.Connect;    /* vert line between start & end       */      MR13i = 4800;      MR13i =    0;      MR13i = 4800;      MR13i = -100;   MR13i = O#Icon.Connect;    /* vert line between end & rate        */      MR13i = 5800;      MR13i =    0;      MR13i = 5800;      MR13i = -100;   MR13i = O#Icon.Connect;    /* vert line between rate & locked     */      MR13i = 6800;      MR13i =    0;      MR13i = 6800;      MR13i = -100;   MR13i = O#Icon.Connect;    /* vert line between locked & modified */      MR13i = 7700;      MR13i =    0;      MR13i = 7700;      MR13i = -100;   MR13i = O#ICON.End;   call Set.Auto.Allocation.Id(Project.Manager.Alloc);   call Set.Default.Action(O#ACT.Middle.Press);   call Set.Default.Attr(0,ATTR#Normal\ATTR#AltIntensity);   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);   call                   Define.Graphics.Box(S#AA,gpos.x(-10),gpos.y((row-1)*100),gpos.x(8010),gpos.y((row+size-1)*100),0);   call                   Define.Graphics.Icon(S#AA,0,(row*100)-100,0,lines);   call                   Load.Close.Box.Icon(misc.buf);   Project.Manager.Size.Box = Define.Graphics.Icon(S#AA,0,(row*100),1,misc.buf);   call Activate.Object.Range(Project.Manager.Alloc,Project.Manager.Size.Box);   do i = Project.Manager.Alloc to Project.Manager.Size.Box;      call Update.Object(i);   end;   call                   Set.Default.Action(0);   Project.Label        = Define.Label(S#AA, row,    3, 0, 'Proj');     Project.Start.Label  = Define.Label(S#AA, row,   37, 0, 'Start');   Project.End.Label    = Define.Label(S#AA, row,   49, 0, 'End');   Project.Rate.Label   = Define.Label(S#AA, row,   59, 0, 'Rate');   Project.Mod.Label    = Define.Label(S#AA, row,   77, 0, ' M ');   call Set.Default.Attr(0,ATTR#Normal);   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse);   call Set.Default.Action(O#ACT.Middle.Press\O#ACT.Prev.Obj);   call                    Load.UpDown.Icon(Misc.Buf);   Project.Switch.Id     = Define.Graphics.Icon(S#AA, -10, row*100, 1, Misc.Buf);   /* Define name, start time, end time and rate in order for arrow keys */   call Set.Default.Action(O#ACT.Left.Press|O#ACT.Middle.Press|O#ACT.Right.Press|O#ACT.Update.On.Dep);   Project.Number.Id     = Define.Fixed.Point(S#AA,row,8,3,0,cf#right\cf#forcedp);   call Set.Default.Action(O#ACT.Middle.Press \ O#ACT.Update.On.Dep);   Project.Name.Id       = Define.String(S#AA,row,12,24,O#STR.General);   call Set.Default.Action(O#ACT.Left.Press|O#ACT.Middle.Press|O#ACT.Right.Press|O#ACT.Update.On.Dep);   Project.Start.Time    = Define.32Bit.MSEC(S#AA,row,42,6,O#MSEC.Minutes.Seconds\O#MSEC.RealTime,cf#dur,3,cf#suppress);   Project.End.Time      = Define.32Bit.MSEC(S#AA,row,52,6,O#MSEC.Minutes.Seconds\O#MSEC.RealTime,cf#dur,3,cf#suppress);   Project.Rate          = Define.Fixed.Point(S#AA,row,63,5,1,cf#right);   call Set.Default.Action(O#ACT.Middle.Press);   Project.Status.Switch = Define.Switch(S#AA,row,69,8,0,'Empty|Unlocked|Locked');   call                    Set.Object.Mouse.Access(Project.Status.Switch,0);   call Activate.Object.Range(Project.Manager.Alloc,Project.Manager.Alloc+999);   call Set.Auto.Arrow.Link.Range(Project.Number.Id,Project.Rate);   /* fill project info before updating object: */   call DISPLAY.PROJECT.LINE;   do i = Project.Number.Id to Project.Status.Switch; /* show cur name */      call Update.Object(i);                          /* and info      */   end;                                               /* quickly       */   if  (Project.Manager.Mode = -2) /* if re-opening proj manager panel,  and last time it showed one project only */   then do;         call Define.Project.Manager.Onebar(row,size);   end;   else do;      call Define.Project.Manager.Allbar(row,size);   end;   Project.Manager.Group = Group.Objects(Project.Manager.Group.Id,Project.Manager.Alloc,Project.Manager.Alloc+999,Get#Screen.Event);   Project.Manager.Command = 0;end DEFINE.PROJECT.MANAGER.PANEL;/* Compute desired size of project manager panel: */LINES.IN.PROJECT.MANAGER.PANEL: proc fixed public swapable;   dcl (size) fixed;   size = shr(DTD.Num.Voices,1) + 4;   if size < 5 then size = 5; /* 5 lines if no drives? */   return size;end LINES.IN.PROJECT.MANAGER.PANEL;/* Display project manager prompt (dialog box) for assorted commands: */DISPLAY.PROJECT.MANAGER.PROMPT: proc (id,buttons) swapable;  /* Displays a prompt by id */   dcl id      fixed; /* screen.event.id of command button                */   dcl buttons fixed; /* 1=draw OK and CANCEL buttons; 0=don't draw them  */   dcl PMP     lit 'Project.Manager.Prompt';   dcl i       fixed;   dcl FirstId fixed;   dcl LastId  fixed;   if (id > 0) then do;      if (Project.Manager.Prompt = 0) then do;         call Set.Auto.Allocation.Id(Project.Manager.Alloc+200);         call Set.Default.Action(O#ACT.Middle.Press);         call Set.Default.Attr(0,ATTR#Normal\ATTR#AltIntensity\ATTR#Reverse);         call Set.Default.Attr(1,ATTR#Normal\ATTR#AltIntensity\ATTR#Reverse);         FirstId = Define.Label(S#AA,Project.Manager.Row+Project.Manager.Size,0,60,'');         Project.Manager.Prompt = FirstId;         LastId = FirstId;         Disable.Deposits = true;         if (id >= Project.Onebar.AllRepro)         &  (id <= Project.Onebar.EraseDrive)         then do;            do case id-Project.Onebar.AllRepro;               call Deposit.Label(PMP,'Click again or OK to set all tracks to REPRO');               call Deposit.Label(PMP,'Click again or OK to set all tracks to INPUT');               call Deposit.Label(PMP,'Click again or OK to set all tracks to AUTO');               call Deposit.Label(PMP,'Click again or OK to set all tracks to CUE PLAYBACK');               call Deposit.Label(PMP,'Click again or OK to set all tracks to SAFE');               call Deposit.Label(PMP,'Select track(s) to LOCK with mouse');               call Deposit.Label(PMP,'Select track(s) to UNLOCK with mouse');               call Deposit.Label(PMP,'Select track(s) to ERASE with mouse');            end;         end;         else if (id >= Project.Allbar.SwitchProj.Label)         &       (id <= Project.Allbar.EraseAll.Label)         then do;            do case id-Project.Allbar.SwitchProj.Label;               call Deposit.Label(PMP,'Select project with mouse, then click OK');               call Deposit.Label(PMP,'Create new project');               call Deposit.Label(PMP,'Click Project then OK to Lock/Unlock Project');               call Deposit.Label(PMP,'Select project(s) to ERASE with mouse');               call Deposit.Label(PMP,'All projects will be ERASED');            end;         end;         Disable.Deposits = false;         call Set.Default.Attr(0,ATTR#Normal\ATTR#Reverse);         call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse);         if buttons <> 0 then do;            Project.Manager.OK.Button     = Define.Label (S#AA,Project.Manager.Row+Project.Manager.Size,65,0,'[OK]');            Project.Manager.Cancel.Button = Define.Label (S#AA,Project.Manager.Row+Project.Manager.Size,71,0,'[Cancel]');            LastId = Project.Manager.Cancel.Button;         end;         call Activate.Object.Range(FirstId,LastId);         call Update.Object.Range  (FirstId,LastId);         call Set.Default.Attr(0,ATTR#Normal);      end;   end;   else if (id = 0) then do;      if (Project.Manager.Prompt <> 0) then do;  /* Erase prompt line */         call Erase.Object.Range(Project.Manager.Prompt,Project.manager.Cancel.Button);         call Undefine.Object.Range(Project.Manager.Prompt,Project.Manager.Cancel.Button);         Project.Manager.Prompt = 0;         Project.Manager.OK.Button = 0;         Project.Manager.Cancel.Button = 0;         call Set.Object.Attr(Project.Manager.Command,0,ATTR#Normal\ATTR#AltIntensity); /* un-highlight button */         call Select.New.Cur.Obj(Corner.Label,-1,-1);      end;   end;end DISPLAY.PROJECT.MANAGER.PROMPT;insert ':synsou:audmod:aud-pmg1';OPEN.PROJECT.MANAGER.PANEL: proc (MaxSize) public swapable;   dcl (MaxSize     ) fixed;   dcl (sid,row,size) fixed;  /*** Declare in Order ***/   dcl num.tracks     fixed;   dcl (i,j)          fixed;   if Project.Manager.Group <> 0 then return;   size=LINES.IN.PROJECT.MANAGER.PANEL; /* get recommended size */   if (MaxSize <= 0)                  then MaxSize = size;   if (MaxSize >  (DTD.Num.Voices+4)) then MaxSize = (DTD.Num.Voices+4);   if (MaxSize <  5)                  then MaxSize = 5;   if Allocate.Screen.Space(5,MaxSize,loc(addr(sid))) then do;      call Set.Panel.Menu.Highlight(0,1);      call Set.AEE.Panel.Info(0,row,size); /* find and set entry for panel */      do i = 0 to 15;         call PID(Checksum.Drive.Allocation+i,-1);      end;      Project.Manager.Command       = 0; /* initialize to no dialog */      Project.Manager.Prompt        = 0; /* box items defined       */      Project.Manager.OK.Button     = 0;      Project.Manager.Cancel.Button = 0;      Onebar.Select.Bits            = 0;      do i = 0 to 3;         allbar.select.bits(i) = 0;      end;      /* when re-drawing entre aee screen, Project.Manager.Mode will */      /* still have its old value from when the panel was last open  */      /* since we do not actually close the panel before leaving     */      /* the screen.  Make Project.Manager.Mode negative here to     */      /* indicate panel is not really open,  even tho we did not     */      /* close it before leaving the screen                          */      if Project.Manager.Mode >0       then Project.Manager.Mode = -Project.Manager.Mode;      call Define.Project.Manager.Panel(row+1,size-1);      Project.Manager.Size = size-1;      Project.Manager.Row  = row+1;      Project.Manager.Screen.Space = sid;      /* Fill in initial display settings (show proj or show all) */      if (Project.Manager.Mode = 2) /* if showing project, set scroll bar position */      then do;         /* limit top drive to valid range when changing */         /* size of pmgr:                                */         if (Project.Onebar.Top.Drive + (Project.Manager.Size-3)) > DTD.Num.Voices         then Project.Onebar.Top.Drive = DTD.Num.Voices - (Project.Manager.Size-3);         if Project.Onebar.Top.Drive <0         then Project.Onebar.Top.Drive = 0;         call SET.ONEBAR.SBAR(Project.Onebar.Top.Drive);         disable.deposits = 1;         call Deposit.Fixed.Point(Project.Onebar.Size, Project.Manager.Size-3);         disable.deposits = 0;         Display.New.Project.Info = (-1);      end;      else do;         call Display.All.Projects;      end;   end;   else call Display.Notice(NT#NoMoreRoomOnScreen,ATTR#Normal,NulStr,0,0,0);end OPEN.PROJECT.MANAGER.PANEL;CLOSE.PROJECT.MANAGER.PANEL: proc public swapable;   dcl i    fixed;   if Project.Manager.Group <> 0 then do;   /* Group is defined */      call Set.Panel.Menu.Highlight(0,0);      call Set.AEE.Panel.Info(0,0,0); /* mark entry as unused */      Project.Manager.Mode = -(Project.Manager.Mode);   /* No display any more */      Project.Manager.Screen.Space = Erase.Screen.Space(Project.Manager.Screen.Space);      Project.Manager.Group = Ungroup.Objects(Project.Manager.Group);      call cpos(Project.Manager.Row+Project.Manager.Size,0); /* Erase prompt line */      call pc(27); call ps('[K');      call Undefine.Object.Range(Project.Manager.Alloc,Project.Manager.Alloc+999);      call Select.New.Cur.Obj(Corner.Label,-1,-1);   end;end CLOSE.PROJECT.MANAGER.PANEL;