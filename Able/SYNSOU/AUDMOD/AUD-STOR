/* AUD-STOR   $TITLE  Synclavier-side Cue Storage routines   Modified:   05/01/89 - cj  - update event.in.s#.msb when loading and backing                    up cues.  Clarify adjustment if in & out times                    to handle weird situations better.   10/31/88 - cj  - fixed bug if cues will not fit in file   05/27/88 - KJO/MWH - Only write cue backup file if type is text or data   */dcl Storage.Group           fixed public;dcl Storage.Row             fixed;dcl Storage.Size            fixed;dcl Storage.Switch.Button   fixed;dcl Storage.File.Name.Id    fixed;dcl Storage.Project.Name    fixed;dcl Storage.Recall.Button   fixed;dcl Storage.Save.Button     fixed;dcl Storage.Screen.Space    fixed;dcl Storage.Mode.Switch     fixed;dcl Storage.Size.Box        fixed;dcl Storage.Project.Name.Field.Width lit '20';dcl Storage.Magic.#1        lit   '9876';dcl Storage.Magic.#2        lit   '5432';dcl Cache.Cat.If.Possible          proc (fixed, array, fixed) external;dcl Cat.Cache.File.Type            fixed                      external;dcl Handle.Cat.Cache.Switch.Button proc (array, fixed)        external;dcl UPDATE.STORAGE.PANEL    proc recursive;DEFINE.STORAGE.PANEL: proc(row,size) swapable;   dcl row       fixed;   dcl size      fixed;   dcl lines(20) fixed;   dcl i         fixed;   dcl Storage.Filename(AEE.Sequence.Name.Wlen) fixed;   call Copy.String('CUE STORE/RECALL',lines);   call Print.Panel.Title(row,lines);   call Set.Auto.Allocation.Id(Storage.Alloc);   call Set.Default.Action(O#ACT.Middle.Press);   call Set.Default.Attr(0,ATTR#Normal\ATTR#AltIntensity);   call Set.Default.Attr(1,ATTR#Normal\ATTR#AltIntensity);   call                   Define.Graphics.Box(S#AA,gpos.x(-10),gpos.y((row-1)*100),gpos.x(8010),gpos.y((row+size-1)*100),0);   call                   Load.Close.Box.Icon(misc.buf);   Storage.Size.Box     = Define.Graphics.Icon(S#AA,0,(row*100),1,misc.buf);   call                   Set.Default.Action(0);   call                   Define.Label(S#AA,row,0,0,'Cues for Proj:');   call                   Define.Label(S#AA,row,39,0,'File:');   Storage.Project.Name = Define.Label(S#AA,row,15,Storage.Project.Name.Field.Width,'');   call                   Set.Default.Action(O#ACT.Middle.Press\O#ACT.Prev.Obj);   call                    Load.UpDown.Icon(Misc.Buf);   Storage.Switch.Button = Define.Graphics.Icon(S#AA, 3600, row*100, 1, Misc.Buf);   Storage.Save.Button   = Define.Label(S#AA,row  ,67,0,'[DTD-To-File]');   Storage.Recall.Button = Define.Label(S#AA,row+1,67,0,'[File-To-DTD]');   call                   Set.Default.Action(O#ACT.Middle.Press);   call Set.Default.Attr(0,ATTR#Normal);   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse);   Storage.File.Name.Id = Define.String(S#AA,row,45,21,0);   /* set up initial name: */   call GID(AEE.Cue.File.Name);   call COPY.IN(addr(Storage.Filename(0)), AEE.Sequence.Name.Wlen);   disable.deposits = 1;   call Deposit.String(Storage.File.Name.Id,Storage.Filename);   disable.deposits = 0;   call Cache.Cat.If.Possible(AEE.Seq.Cat, Storage.Filename, T#Data);   Storage.Group        = Group.Objects(Storage.Group.Id,Storage.Alloc,Storage.Alloc+999,Get#Screen.Event);   call                   Update.Storage.Panel;   call                   Activate.Object.Range(Storage.Alloc,Storage.Alloc+999);   call Set.Object.Arrow.Links(Storage.File.Name.Id  ,ARR#Auto, ARR#Auto, ARR#Auto, ARR#Auto);end DEFINE.STORAGE.PANEL;OPEN.STORAGE.PANEL: proc public swapable;   dcl (sid,row,size) fixed;  /*** Declare in Order ***/   if Storage.Group <> 0 then return;   if Allocate.Screen.Space(4,4,loc(addr(sid))) then do;      call Set.Panel.Menu.Highlight(8,1);      call Set.AEE.Panel.Info(8,row,size); /* find and set entry for panel */      call Define.Storage.Panel(row+1,size-1);      Storage.Screen.Space = sid;      Storage.Row  = row+1;      Storage.Size = size-1;   end;   else call Display.Notice(NT#NoMoreRoomOnScreen,ATTR#Normal,NulStr,0,0,0);end OPEN.STORAGE.PANEL;CLOSE.STORAGE.PANEL: proc public swapable;   if Storage.Group <> 0 then do;   /* Group is defined */      call Set.Panel.Menu.Highlight(8,0);      call Set.AEE.Panel.Info(8,0,0); /* mark entry as unused */      Storage.Screen.Space = Erase.Screen.Space(Storage.Screen.Space);      Storage.Group = Ungroup.Objects(Storage.Group);      call Undefine.Object.Range(Storage.Alloc,Storage.Alloc+999);      call Select.New.Cur.Obj(Corner.Label,-1,-1);   end;end CLOSE.STORAGE.PANEL;UPDATE.STORAGE.PANEL: proc public swapable;   if Storage.Group = 0 then return;   call COPY.STRING(AEE.Current.Project.Name, Misc.Buf);   if misc.buf(0) igt Storage.Project.Name.Field.Width   then misc.buf(0) = Storage.Project.Name.Field.Width;   Disable.Deposits = true;   call Deposit.Label(Storage.Project.Name,Misc.Buf);   Disable.Deposits = false;end UPDATE.STORAGE.PANEL;GET.STORE.DIALOG: proc (row,message)  returns (fixed) PUBLIC swapable;   dcl row                      fixed;   dcl message                  fixed;   dcl (i,j)                    fixed;   dcl Message.Label            fixed;   dcl OK.Button                fixed;   dcl Cancel.Button            fixed;   dcl exit                     fixed;   dcl saved                    fixed;   dcl Storage.Filename(AEE.Sequence.Name.Wlen) fixed;   /* Message:  0 - store DTD cues to file                1 - read file and  store cues on DTD   */   call Set.Auto.Allocation.Id(Storage.Alloc+500);   call Set.Default.Action(O#ACT.Middle.Press);   call Set.Default.Attr(0,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse);   call GID(AEE.Cue.File.Name);   call COPY.IN(addr(Storage.Filename(0)), AEE.Sequence.Name.Wlen);   saved = Locate(Storage.Filename,1);   Disable.Deposits = true;   Message.Label = Define.Label(S#AA,Row,0,66,'');   OK.Button     = Define.Label(S#AA,Row,67,0,'[OK]');   Cancel.Button = Define.Label(S#AA,Row,72,0,'[CANCEL]');   do case (message);      do;         if saved         then call COPY.STRING('Copy and REPLACE cues FROM Direct-To-Disk TO file "',misc.buf);         else call COPY.STRING('Copy and SAVE cues FROM Direct-To-Disk TO file "',misc.buf);         call APPEND.TO.STR(Misc.Buf,Storage.Filename);         call APPEND.TO.STR(Misc.Buf,'"');      end;      do;         call COPY.STRING('Copy cues FROM file "',misc.buf);         call APPEND.TO.STR(Misc.Buf,Storage.Filename);         call APPEND.TO.STR(Misc.Buf,'" TO Direct-to-Disk');      end;   end;   if misc.buf(0) > 67 then misc.buf(0) = 67;   call Deposit.Label(Message.Label,Misc.Buf);   call Deposit.Object.Info(Message.Label,O#EraseMethod,O#ERAS.Whole.Line);   Disable.Deposits = false;   call Set.Default.Attr(0,ATTR#Normal);   call Set.Default.Attr(1,ATTR#AltIntensity\ATTR#Reverse);   /* 10 Objects MAX in Dialog Bar for now */   call Activate.Object.Range(Storage.Alloc+500,Storage.Alloc+510);   call Update.Object(Message.Label);   call Update.Object(OK.Button    );    call Update.Object(Cancel.Button);    call Select.New.Cur.Obj(Corner.Label,-1,-1);   do while exit = 0;      i = Get.Next.Screen.Event;      if (Screen.Event.Group = Storage.Group)      then do;         if i = Get.Screen.Event then do;            if  (Screen.Event.Id = OK.Button)            or  ((Screen.Event.Id = Storage.Save.Button  )            and  (message         = 0                    ))            or  ((Screen.Event.Id = Storage.Recall.Button)            and  (message         = 1                    ))            then do;               if (Screen.Event.Info = S#MouseSelect  )               or (Screen.Event.Info = S#MouseActivate)               then do;                  exit = 1;               end;            end;            else if (Screen.Event.Id = Cancel.Button) then do;               if Screen.Event.Info = S#MouseSelect               then exit = -1;            end;            else if (Screen.Event.Info = S#MouseSelect)            or      (Screen.Event.Info = S#MouseActivate)            then do;               call Display.Notice(NT#MustRespondToDialog,ATTR#Reverse,NulStr,1,0,0);               call Select.New.Cur.Obj(Corner.Label,-1,-1);            end;         end;      end;      else do;  /* Outside group; <> Cue.Group */         if  (i = Get.Screen.Event) then do;            if ((Screen.Event.Info = S#MouseSelect)            or  (Screen.Event.Info = S#MouseActivate))            then do;               call Display.Notice(NT#MustRespondToDialog,ATTR#Reverse,NulStr,2,0,0);               call Select.New.Cur.Obj(Corner.Label,-1,-1);            end;         end;      end;   end;   call Erase.Object(Message.Label);  /* Erases message and whole line */   call Undefine.Object.Range(Storage.Alloc+500,Storage.Alloc+599);   call Select.New.Cur.Obj(Corner.Label,-1,-1);   call DISPLAY.NOTICE (NT#EraseNotice,ATTR#Normal,NulStr,0,0,0);   call REMOVE.ERR;      return (exit > 0);   /* if exit < 0 then return false; else true */end GET.STORE.DIALOG;SAVE.DISK.CUES: proc (fname) swapable;  /* Saves cues dynamically */   dcl fname                 array;   dcl buf (256)             fixed;   dcl cues                  fixed;   dcl cue#                  fixed;   dcl cue.len               fixed;   dcl buf.ptr               fixed;   dcl sector.length         fixed;   dcl (write.msw,write.lsw) fixed;   dcl (base.msw,base.lsw)   fixed;   dcl (base.len)            fixed;   dcl (i,j,k)               fixed;   dcl filename(AEE.Sequence.Name.Wlen) fixed;   dcl (ptr,len)             fixed;     /* declare in order */   dcl flen(1)               fixed;   Replace.Cue.File: proc(filename, size);      dcl filename array;      dcl size     fixed; /* sectors */      if not(replace(filename,t#data,0,size,size*256,1))      then do;         call handle.cat.error(1);         return 0;      end;      return 1;   end Replace.Cue.File;   READ32:proc(base,ptr,tmp);      dcl base fixed;      dcl ptr  fixed;      dcl tmp  array;      write(mam) = base + shr(ptr,8);      write(mal) = ptr;      tmp(0) = read(mdi);      tmp(1) = read(mdi);   end READ32;   WRITE32:proc(base,ptr,tmp);      dcl base fixed;      dcl ptr  fixed;      dcl tmp  array;      write(mam) = base + shr(ptr,8);      write(mal) = ptr;      write(mdi) = tmp(0);      write(mdi) = tmp(1);   end WRITE32;   local.fix1:proc(x);      /* fix1: adjust pointer always to point */      dcl x    fixed;       /* relative to start of project         */      dcl a(1) fixed;      call READ32(Scsi.Ptr,x,a);      call SUB32(a,AEE.Current.Project.Base,a);      call WRITE32(Scsi.Ptr,x,a);   end;   local.fix2:proc(x);      /* fix2: only adjust pointers that      */      dcl x    fixed;       /* do not point to infinity             */      dcl a(1) fixed;      call READ32(Scsi.Ptr,x,a);      if a(0) <> (-1) then do;          /* leave -1, -1 intact */         /* generate some negative numbers here for material that */         /* is before the start of the current project.  this     */         /* will be detected when the cue is reloaded             */         call SUB32(a,AEE.Current.Project.Base,a);      end;      call WRITE32(Scsi.Ptr,x,a);   end;   call copy.string(fname,filename);       /* get file name into local array */   if DTD.MAX.SECS = 0                     /* no DTD */   then do;      call Display.Notice(NT#SystemError,ATTR#Reverse,Nulstr,0,0,0);      return;   end;   push.system.pdl;                        /* free up system stack           */   if Cat.Cache.File.Type = T#DATA         /* force re-update of scroll      */   then Cat.Cache.File.Type = 0;           /* listing if showing T#Data      */   i = Locate(filename,1);                 /* find the desired file (maybe)  */   /* Convert a TEXT file to a DATA file ONLY IF it already  */   /* contains cue data:                                     */   if (i) & (F#Type = T#Text) & (F#LS_length<>0)  /* if text - set to data if it    */   then do;                                 /* already contains cues         */      call Readdata(F#MS_Sector, F#LS_Sector,misc.buf,3);   /* Get total cues    */      if  (misc.buf(1) = Storage.Magic.#1)  /* check for correct */      and (misc.buf(2) = Storage.Magic.#2)  /* data file info    */      then do;         if not(DELETE(filename,1))         /* delete file so we */         then do;                           /* save it with the  */            call handle.cat.error(1);       /* correct type      */            pop.system.pdl;            return;         end;         i = 0;                            /* no longer saved    */      end;   end;   if (i) then do;                         /* file is found                  */      if F#Type <> T#Data      then do;         call Display.Notice(NT#MustSetFileType,ATTR#Reverse,Nulstr,0,0,0);         pop.system.pdl;         return;      end;   end;   /* Read through cue directory to get size of file needed: */   call Set.DTD.Scroll.Range(1);  /* Current song only */   cue# = 0;                      /* start with cue 0  */   call STR32(0, 0, flen);        /* total cue lengths */   do while (Fetch.Nth.Alpha.DTD.Cue(cue#)<>0);      /* fetch cue into scsi.ptr for speed */      call Fetch.Entire.DTD.Cue(DTD.Cue#, Scsi.Ptr);      write(mam) = SCSI.Ptr;      cue.len    = read(mdi);      call ADD16(cue.len, flen);    /* add up length of cues */      cue# = cue# + 1;   /* Step to the next cue */   end;   call ADD16(768, flen);           /* add in 1 sector for header sector, */                                    /* plus round up,  plus make file     */                                    /* at least three sectors long,       */                                    /* plus round up for funny comparison */                                    /* (sector.length) below.             */   call shr32(flen,8);              /* get sectors             */   if not(Replace.Cue.File(filename, flen(lw#lsb)))   then do;      pop.system.pdl;      return;   end;   base.msw  = F#MS_Sector;   base.lsw  = F#LS_Sector;   base.len  = F#LS_Length;   do i = 0 to 255;          /* zero out header sector at start of       */      misc.buf(i) = 0;       /* saving cues in case we crash             */   end;   call WriteData(base.msw,base.lsw,misc.buf,256);   write.msw = base.msw;   write.lsw = base.lsw;   call ADD16(1,loc(addr(write.msw)));   sector.length = 1;   buf.ptr = 0;   cues    = 0;   cue#    = 0;   call Set.DTD.Scroll.Range(1);  /* Current song only */   do while (Fetch.Nth.Alpha.DTD.Cue(cue#)<>0);      /* fetch cue into scsi.ptr */      call Fetch.Entire.DTD.Cue(DTD.Cue#, Scsi.Ptr);      /* adjust in/out times relative to this song to make */      /* for more useful store/recall                      */      /* see if is a reel */      write(mam) = Scsi.Ptr;      write(mal) = Cue.List.Ptr;      ptr = read(mdi);      len = read(mdi);      /* always adjust cue.in.s#.msb since it is in */      /* the current project                        */      call local.fix1(cue.in.s#.msb);      /* if not a reel, then adjust in times relative */      /* to current project                           */      if ptr = 0 then do;         call local.fix1(cue.s.msb);        /* store data addresses */         call local.fix1(cue.e.msb);        /* relative to start    */         call local.fix1(cue.edit.in.msb);  /* of song.             */         call local.fix1(cue.edit.out.msb);         call local.fix1(cue.off.msb);         call local.fix1(event.in.s#.msb);      end;      /* if a reel - just adjust mapping */      else do;         do k = ptr to ptr + len - 1  by Cue.Seg.Stride;            call local.fix1(k + S#In.Msb  );            call local.fix2(k + S#Out.Msb );         end;      end;      write(mam) = SCSI.Ptr;      cue.len    = read(mdi);      if (sector.length + shr(cue.len+255,8)) ile base.len      then do;          /* write out if it will fit */         do i = 0 to cue.len-1;            write(mam) = scsi.ptr + shr(i,8);            write(mal) = i;            buf(buf.ptr) = read(md);            buf.ptr = buf.ptr + 1;            if buf.ptr = 256 then do;               call WriteData(write.msw,write.lsw,buf,256);               call ADD16(1,loc(addr(write.msw)));               sector.length = sector.length + 1;               buf.ptr = 0;            end;         end;         cues = cues + 1;      end;      cue# = cue# + 1;   /* Step to the next cue */   end;   if buf.ptr > 0 then do;  /* Some last things in the buffer */      call WriteData(write.msw,write.lsw,buf,buf.ptr);   end;   if base.len IGE 2 then do;    /* If file is at least 2 sectors: 1 for header, 1 for data */      buf(0) = cues;      buf(1) = Storage.Magic.#1;      buf(2) = Storage.Magic.#2;      do i = 3 to 255;         buf(i) = 0;      end;      call WriteData(base.msw,base.lsw,buf,256);   end;   if cues = cue#   then call Display.Notice(NT#CuesSavedToDisk,ATTR#Normal,filename,cues,0,0);   else call Display.Notice(NT#SystemError,ATTR#Reverse,Nulstr,cues,cue#,0);   pop.system.pdl;end SAVE.DISK.CUES;RECALL.DISK.CUES: proc (fname) swapable;   dcl fname               array;   dcl buf(256)            fixed;   dcl cue#                fixed;   dcl count               fixed;   dcl total.cues          fixed;   dcl buf.ptr             fixed;   dcl (read.msw,read.lsw) fixed;   dcl read.secs           fixed;   dcl (i, j, k)             fixed;   dcl filename(8)         fixed;   dcl (ptr,len)           fixed; /* declare in order */   dcl a(1)                fixed;   dcl b(1)                fixed;   dcl c(1)                fixed;   dcl sector.length       fixed;   dcl cue.len             fixed;   dcl id                  fixed;   dcl tmp(17-1)				fixed;   READ32:proc(base,ptr,tmp);      dcl base fixed;      dcl ptr  fixed;      dcl tmp  array;      write(mam) = base + shr(ptr,8);      write(mal) = ptr;      tmp(0) = read(mdi);      tmp(1) = read(mdi);   end READ32;   WRITE32:proc(base,ptr,tmp);      dcl base fixed;      dcl ptr  fixed;      dcl tmp  array;      write(mam) = base + shr(ptr,8);      write(mal) = ptr;      write(mdi) = tmp(0);      write(mdi) = tmp(1);   end WRITE32;   local.fix1:proc(x);      /* fix1 - always adjust pointer */      dcl x    fixed;      dcl a(1) fixed;      call READ32(Cue.Build.Ptr,x,a);      call ADD32(a,AEE.Current.Project.Base,a);      call WRITE32(Cue.Build.Ptr,x,a);   end;   call copy.string(fname,filename);    /* get into local array */   push.system.pdl;                     /* get storage          */   if Lod.Running <> 0 then do;     if Locate(filename,1) then do;        read.msw      = F#MS_Sector;        read.lsw      = F#LS_Sector;        read.secs     = F#LS_Length;        sector.length = 0;        if (F#LS_Length <> 0)        then call Readdata(read.msw,read.lsw,buf,3);   /* Get total cues    */        if (buf(1) <> Storage.Magic.#1)           /* check for correct */        or (buf(2) <> Storage.Magic.#2)           /* data file info    */        or (F#LS_Length = 0)        then do;           call Display.Notice(NT#ErrorWithCueFile,ATTR#Reverse,NulStr,0,0,0);           pop.system.pdl;           return;        end;        total.cues = buf(0);        buf.ptr = 256;        i = 0;        do while i ilt total.cues;           if buf.ptr = 256 then do;              call ADD16(1,loc(addr(read.msw)));              call Readdata(read.msw,read.lsw,buf,256);   /* Get total cues */              buf.ptr = 0;              sector.length = sector.length + 1;           end;           cue.len = buf(buf.ptr);                 /* get length of cue   */           if (sector.length + shr(buf.ptr + cue.len + 255,8)) ile read.secs           then do;                                /* copy file if good   */              do j = 0 to cue.len-1;                  /* copy entire cue     */                 if buf.ptr = 256 then do;                    call ADD16(1,loc(addr(read.msw)));                    call Readdata(read.msw,read.lsw,buf,256);                     buf.ptr = 0;                    sector.length = sector.length + 1;                 end;                 write(mam) = Cue.Build.Ptr + shr(j,8);                 write(mal) = j;                 write(md ) = buf(buf.ptr);                 buf.ptr = buf.ptr + 1;              end;              /* adjust cue pointers for new position of current song */              /* check for un-initialized cue area (old format) */              write(mam) = Cue.Build.Ptr;              write(mal) = Cue.List.Ptr;              ptr = read(mdi);              len = read(mdi);              /* if not a reel, update all pointers to current */              /* song position                                 */              if ptr = 0 then do;                 call local.fix1(cue.s.msb);                 call local.fix1(cue.e.msb);                 call local.fix1(cue.edit.in.msb);                 call local.fix1(cue.edit.out.msb);                 call local.fix1(cue.off.msb);                 /* assign to cue.in.s#.msb to handle old cues */                 call READ32 (Cue.Build.Ptr,cue.s.msb,a);                 call WRITE32(Cue.Build.Ptr,cue.in.s#.msb,a);                 call local.fix1(event.in.s#.msb);              end;              /* else if reel, just adjust mapping */              else do;                           /* handle reel */                 call local.fix1(cue.in.s#.msb);                 do k = ptr to ptr + len - 1  by Cue.Seg.Stride;                    call READ32(Cue.Build.Ptr,k + S#In.Msb, a);      /* in  time rel to project */                    call READ32(Cue.Build.Ptr,k + S#Out.Msb,b);      /* out time rel to project */                    call ADD32(a,AEE.Current.Project.Base,a);   /* add project start      */                    if b(0) <> (-1)                    then call ADD32(b,AEE.Current.Project.Base,c);   /* add project start      */                    else call COPY32(b,c);                    if  (a(0) < 0)               /* segment started before proj */                    then do;                       if (b(0) =  (-1))         /* if segment went to end */                       or (c(0) >= ( 0))         /* or is audible          */                       then do;                  /* correct sync           */                          call READ32(Cue.Build.Ptr,k + S#Sync.Msb,b);                          call SUB32 (b,a,b);    /* a is negative now      */                          call STR32 (0,0,a);    /* new in time of 0,0     */                          call WRITE32(Cue.Build.Ptr,k + S#In.Msb,   a);                          call WRITE32(Cue.Build.Ptr,k + S#Out.Msb,  c);                          call WRITE32(Cue.Build.Ptr,k + S#Sync.Msb, b);                       end;                       else do;                  /* else zap segment       */                          call WRITE32(Cue.Build.Ptr,k + S#In.Msb,  Zero.Zero);                          call WRITE32(Cue.Build.Ptr,k + S#Out.Msb, Zero.Zero);                       end;                    end;                    else do;                     /* get all of it          */                       call WRITE32(Cue.Build.Ptr,k + S#In.Msb, a);                       call WRITE32(Cue.Build.Ptr,k + S#Out.Msb,c);                    end;                 end;              end;              write(mam) = Cue.Build.Ptr;              write(mal) = Cue.Name;              call COPY.IN(addr(tmp(0)),17);              Id = Locate.DTD.Cue(tmp);   /* see if saved - look in cur project first */              if Id <> 0 then do;         /* replace model - in current proj first, or anywhere on disk */                 Id = REPLACE.ENTIRE.DTD.CUE(Id, Cue.Build.Ptr);              end;              else do;                 Id = DEFINE.ENTIRE.DTD.CUE.WITH.ERROR.MESSAGES(Cue.Build.Ptr);              end;              if Id > 0 then count = count + 1;              i = i + 1;           end;           else do;               /* must be file format error */              total.cues = i;     /* so stop here              */           end;        end;        call Update.Cue.Menu.Table(0,-1);        if count=Total.Cues        then call Display.Notice(NT#CuesRecalledFromDisk,ATTR#Normal,filename,count,0,0);     end;     else call Display.Notice(NT#FileNotFound,ATTR#Normal,filename,0,0,0);   end;   pop.system.pdl;end RECALL.DISK.CUES;GET.STORAGE.EVENT: proc (event) returns (fixed) public swapable;   dcl event                       fixed;   dcl tmp(AEE.Sequence.Name.Wlen) fixed;   do while 1;      if event <> Get.Null.Event then do;         if Screen.Event.Group <> Storage.Group then return event;         if event = Get.Screen.Event then do;            if Screen.Event.Id = Storage.Recall.Button then do;               if Screen.Event.Info = S#MouseSelect then do;                  /* Highlight Store/Recall Button: */                  call Set.Object.Attr(Storage.Recall.Button,0,ATTR#Normal\ATTR#Reverse);                  call Set.Object.Attr(Storage.Recall.Button,1,ATTR#Normal\ATTR#Reverse);                  call Update.Object(Storage.Recall.Button);                  call Fetch.String(Storage.File.Name.Id, tmp);                  if  (tmp(0) <> 0)                  and (GET.STORE.DIALOG (Storage.Row+Storage.Size, 1) <> 0)                  then call Recall.Disk.Cues(tmp);                  call Set.Object.Attr(Storage.Recall.Button,0,ATTR#Normal\ATTR#AltIntensity);                  call Set.Object.Attr(Storage.Recall.Button,1,ATTR#Normal\ATTR#AltIntensity);                  call Update.Object(Storage.Recall.Button);               end;            end;            else if Screen.Event.Id = Storage.Save.Button then do;               if Screen.Event.Info = S#MouseSelect then do;                  call Set.Object.Attr(Storage.Save.Button,0,ATTR#Normal\ATTR#Reverse);                  call Set.Object.Attr(Storage.Save.Button,1,ATTR#Normal\ATTR#Reverse);                  call Update.Object(Storage.Save.Button);                  call Fetch.String(Storage.File.Name.Id, tmp);                  if  (tmp(0) <> 0)                  and (GET.STORE.DIALOG (Storage.Row+Storage.Size, 0) <> 0)                  then call Save.Disk.Cues(tmp);                  call Set.Object.Attr(Storage.Save.Button,0,ATTR#Normal\ATTR#AltIntensity);                  call Set.Object.Attr(Storage.Save.Button,1,ATTR#Normal\ATTR#AltIntensity);                  call Update.Object(Storage.Save.Button);               end;            end;            else if Screen.Event.Id = Storage.File.Name.Id then do;               if Screen.Event.Info = S#Deposit then do;                  call Fetch.String(Storage.File.Name.Id,tmp);                  /* save in ext memory for startup */                  call GID(AEE.Cue.File.Name);                  call COPY.OUT(addr(tmp(0)), AEE.Sequence.Name.Wlen);                  /* read and cache catalog for scrolling.  Append : to file name */                  /* if it is really the name of a catalog                        */                  if Cache.Cat.If.Possible(AEE.Seq.Cat, tmp, T#Data) then do;                     call APPENDC(tmp, colon);                     call GID(AEE.Cue.File.Name);                     call COPY.OUT(addr(tmp(0)), AEE.Sequence.Name.Wlen);                     disable.deposits = 1;                     call Deposit.String (Storage.File.Name.Id, tmp);                     disable.deposits = 0;                     call Update.Object(Storage.File.Name.Id);                  end;               end;            end;            else if Screen.Event.Id = Storage.Switch.Button then do;               /* get current user string */               if Screen.Event.Info = S#MouseSelect               then do;                  call Fetch.String(Storage.File.Name.Id, tmp);                  retry:;                  if Handle.Cat.Cache.Switch.Button (tmp, T#Data)                  then do;                     /* if data file,  make sure file contains */                     /* cue data,  otherwise do not allow      */                     /* scrolling through it                   */                     if  (Locate(tmp,1))                     and (F#Type = T#Data)                     and (F#LS_Length <> 0)                     then do;                        call Readdata(F#MS_Sector, F#LS_Sector,misc.buf,3);   /* Get total cues    */                        if (misc.buf(1) <> Storage.Magic.#1)  /* check for correct */                        or (misc.buf(2) <> Storage.Magic.#2)  /* data file info    */                        then goto retry;                     end;                     call GID(AEE.Cue.File.Name);                     call COPY.OUT(addr(tmp(0)), AEE.Sequence.Name.Wlen);                     disable.deposits = 1;                     if tmp(0) > 25 then tmp(0) = 25;                     call Deposit.String (Storage.File.Name.Id, tmp);                     disable.deposits = 0;                     call Update.Object(Storage.File.Name.Id);                  end;               end;            end;         end;      end;      event = Get.Next.Screen.Event;   end;end GET.STORAGE.EVENT;