/* AUD-SYN1 - routines to process sync panel events *//* MODIFIED:   02/15/91 - CJ  - Combined new & old functionality of BPM   02/07/91 - pf  - updated click rate and bpm displays for tempo/meter maps   05/02/90 - cj  - added "pull-down" smpte code   10/10/89 - cj  - create system wide event when time format changes   05/02/89 - TSS - Merged changes for Optical disk to DTD transfer project   10/03/88 - cj - checked for live click track in time displays*/Handle.Sync.Display.Switch: proc swapable;   dcl map data (O#MSEC.Sec.Msec,O#MSEC.Minutes.Seconds,  /* map switch setting */                 O#MSEC.Beats,   O#MSEC.Measures.Beats,   /* to aee time format */                 O#MSEC.SMPTE,   O#MSEC.Feet.Frames);   dcl x fixed;   if Screen.Event.Info = S#Deposit   then do;      call Set.AEE.Time.Format(map(Fetch.Switch(Sync.Display.Switch)));      /* Create a system event when the AEE time format changes */      new.seq.info = new.seq.info \ 8;      call Update.Sync.Panel(true);   /* update dialog, if any */      call Update.Optical.Panel;      /* update place-in-seqeunce time */   end;end Handle.Sync.Display.Switch;Handle.SMPTE.Label:proc swapable;   /* User clicks here to enable/disable SMPTE DISPLAY OFFSET */   if Screen.Event.Info = S#MouseSelect then do;      write(mam) = BAS.PTR;      write(mal) = SEQ.DOFFDIS;      write(md ) = read(md) xor 1;      call Sample.Syncl.Smgr.Globals;     /* get info into smgr immediately */                                            call Update.Sync.Panel(false);   /* call update immediately to highlight/box (but no need to update dialog) */      /* Set bit to cause update of all time fields,  big time display, */      /* and Sequence Panel Refresh.   This event sould go out to all   */      /* devices since other people may care whether the display        */      /* offset is turned on or not:                                    */      new.seq.info = new.seq.info \ 8;   end;end Handle.SMPTE.Label;Handle.Sync.Smpte.Offset: proc swapable;   dcl msec  (1) fixed;   dcl Offset(4) fixed;   dcl sbits (1) fixed;   dcl doff  (1) fixed;   if Screen.Event.Info = S#Deposit then do;      call Fetch.32Bit.Msec(Sync.SMPTE.Offset, Msec);      call MSEC.TO.SBITS(Msec, cf#dur, S$Speed, S$Smode, Sbits);      write(mam) = BAS.PTR;      /* look up display offset stored with seq */      write(mal) = SEQ.DOFFSET;  /* get smpte display offset               */      doff(0)    = read(mdi);      doff(1)    = read(mdi);      if read(mdi) = 0                      /* if SEQ.DOFFDIS = 0,  then display      */      then call SUB32(sbits, doff, sbits);  /* offset is enabled.   subtract it out   */      call SBITS.TO.SMPTE(sbits, S$Smode, offset);      call Set.Synclav.SMPTE.Offset(Offset); /* store in sequence */      sm.hrs = offset(0); /* update internal memory variables     */      sm.min = offset(1); /* right here, in case speed.comp       */      sm.sec = offset(2); /* did not get called                   */      sm.fra = offset(3);       sm.bit = offset(4);      call Sample.Syncl.Smgr.Globals; /* get info into smgr immediately */   end;   else if Screen.Event.Info = S#ObjectDrag then do;      call Perform.AEE.Drag.Function(Screen.Event.Id,Screen.Event.Obj.Info);      call Select.New.Cur.Obj(Corner.Label,-1,-1);   end;end Handle.Sync.Smpte.Offset;Handle.SMPTE.In.Mode.Table: proc (id) swapable;   dcl id     fixed;   dcl tmp(1) fixed;   dcl map.to.mode data (1,4,0,2,3);     /* map switch  to sm.mode        */   dcl map.mode    data (2,0,3,4,1);     /* map sm.mode to switch         */   if Screen.Event.Info = S#MouseSelect   then do;      call Map.Graphics.Button.Table.Mouse.Press(id, tmp);      call Highlight.Graphics.Button.Table(Sync.SMPTE.In.Mode.Table, bits(tmp(0)), 2, 0);      if  (Sync.Dialog.Mode = 1)      and (Sync.Dialog.Disp.Contents = O#MSEC.SMPTE)      then call Highlight.Graphics.Button.Table(Sync.Dialog.Disp.Mode.Table, bits(tmp(0)), 2, 0);      call SET.SYNCLAV.SMPTE.MODE (map.to.mode(tmp(0)));      call Sample.Syncl.Smgr.Globals; /* get info into smgr immediately */   end;end Handle.SMPTE.In.Mode.Table;Handle.Send.Oms.Table: proc (id) swapable;   dcl id     fixed;   dcl tmp(1) fixed;	dcl i      fixed;	if (interp_is_running == 0)					// Not interpreter - ignore		return;   if Screen.Event.Info = S#MouseSelect   then do;		dcl (is_sending_clk, is_sending_mtc, is_sending_either) fixed;		dcl (start_clk, start_mtc, stop_both, toggle_mode     ) fixed;				is_sending_either = (midi.sync.out < 0);		is_sending_clk    = (is_sending_either && (midi.sync.is.tc == 0));		is_sending_mtc    = (is_sending_either && (midi.sync.is.tc != 0));				start_clk   = false;		start_mtc   = false;		stop_both   = false;		toggle_mode = false;		      call Map.Graphics.Button.Table.Mouse.Press(id, tmp);		// Handle click in Send CLK button		if (tmp(0) == 0)									{			if      (is_sending_clk == true) stop_both   = true;		// If sending clks, turn it off			else if (is_sending_mtc == true) toggle_mode = true;		// If sending mtc, toggle			else                             start_clk   = true;		// else start sending clocks		}				// Handle click in Send MTC button		else if (tmp(0) == 1)		{			if      (is_sending_mtc == true) stop_both   = true;		// If sending mtc, turn it off			else if (is_sending_clk == true) toggle_mode = true;		// If sending clk, toggle			else                             start_mtc   = true;		// else start sending clocks		}		// Turn off OMS MIDI Sync		if (stop_both == true)		{			call stop.recd.move.play;			midi.sync.out = (midi.sync.out & 0x7FFF);		// MSB indicates send of OMS midi clock or tc						new.seq.info = new.seq.info \ 512;			call display.sequencer.status;						if (midi.sync.out == 0)								// Not sending anywhere			{				if (DISPLAY.MTC != 0)					CLEAR.LOWER();									DISPLAY.MTC = 0;			}		}				// Turn on clock		if (start_clk == true)		{			call stop.recd.move.play;			midi.sync.out   = midi.sync.out | 0x8000;		// Set MSB to send OMS midi clocks			midi.sync.is.tc = 0;									// Clock						new.seq.info = new.seq.info \ 512;			call display.sequencer.status;		}				// Turn on MTC		if (start_mtc == true)		{			call stop.recd.move.play;			midi.sync.out   = midi.sync.out | 0x8000;		// Set MSB to send OMS midi clocks			midi.sync.is.tc = true;								// MTC						MIDI.FULL.FRAME(play.time.msb, play.time.lsb);			NEW.MTC.VAL = 0;										//	but don't display time here...				new.seq.info = new.seq.info \ 512;			call display.sequencer.status;		}				// Toggle mode		if (toggle_mode == true)		{			call stop.recd.move.play;			MIDI.SYNC.IS.TC = MIDI.SYNC.IS.TC XOR 1;					if (midi.sync.is.tc == 0)			/*	clear mtc display when disabling mtc	*/				DISPLAY.MTC = 0;					else if (midi.sync.out != 0)		/*	send out full frame when changing	*/			{											/*	sync to midi tc							*/				MIDI.FULL.FRAME(play.time.msb, play.time.lsb);				NEW.MTC.VAL = 0;			}					/*	Create a system event when changing the	*/			/*	output sync:									*/					new.seq.info = new.seq.info \ 512;			call display.sequencer.status;		}		// Present VK display		if ((start_clk | start_mtc | toggle_mode) == true)		{			if ((upper.disp = (midi.l-par.l)) && (MIDI.PARAM.ID == 1))		// Update display if showing midi clock/midi tc output				call display.par();			CLEAR.LOWER();				if (MIDI.SYNC.IS.TC != 0)			{				DO CASE (SM.MODE);                      	   /* PRESENT MTC MODE */					CALL EMIT.STRING(16,'Drop Frame MTC');					CALL EMIT.STRING(16,'Non Drop   MTC');					CALL EMIT.STRING(16,'25 Frame   MTC');					CALL EMIT.STRING(16,'24 Frame   MTC');					CALL EMIT.STRING(16,'NTSC 30 Fr MTC');				END;								SUPRESS.BEAT.DISPLAY=1;                   	/* STOP BEAT DISPLAYS MOMENTARILY */				BEAT.DISPLAY.TIME=REAL.MILLISECONDS;      	/* HOLD DISPLAY FOR 5 SECONDS */				LOWER.DISP=SMODE.DISP;                    	/* INDICATE SMODE DISPLAYED   */			}		}				else if (stop_both == true)		{			if ((upper.disp = (midi.l-par.l)) && (MIDI.PARAM.ID == 1))		// Update display if showing midi clock/midi tc output				call display.par();			if (LOWER.DISP==SMODE.DISP)				CLEAR.LOWER();		}				else if (LOWER.DISP==SMODE.DISP)			CLEAR.LOWER();				// Update button display		i = 0;							// Assume no highliting		if (midi.sync.out < 0)		// MIDI Sync output going to OMS		{			if (MIDI.SYNC.IS.TC == 0) i = 1;			// Midi Clocks			else							  i = 2;			// MIDI Time Code		}			call Highlight.Graphics.Button.Table(Sync.Send.OMS.Table, i, 2, 0);   end;end Handle.Send.Oms.Table;Handle.Enable.Oms.Table: proc (id) swapable;   dcl id     fixed;   dcl tmp(1) fixed;	if (interp_is_running == 0)						// Not interpreter - ignore		return;   if Screen.Event.Info = S#MouseSelect   then do;		// Handle click in Send CLK button      call Map.Graphics.Button.Table.Mouse.Press(id, tmp);		if (tmp(0) == 0)		{			if (OMS.MIDI.ENABLED == false)			{				OMS.MIDI.ENABLED = true;				interp_init_oms_midi_bulk(addr(ANY.OMS.MIDI.BULK.BYTES), OMSMIDI.PTR);			}						else			{				OMS.MIDI.ENABLED = false;				interp_init_oms_midi_bulk(0, 0);			}			if ((POLY.TIMBRE.MIDI.CONTROL | OMS.MIDI.ENABLED | MAX.MIDINET.CHAN) != 0)				MIDI.INPUT.ENABLED = true;			else				MIDI.INPUT.ENABLED = false;			call Highlight.Graphics.Button.Table(Sync.Enable.OMS.Table, OMS.MIDI.ENABLED, 2, 0);		}   end;end Handle.Enable.Oms.Table;Handle.Sync.Command.Table:proc swapable;   dcl tmp(1) fixed;   if Screen.Event.Info = S#MouseSelect   then do;      call Map.Graphics.Button.Table.Mouse.Press(Sync.Command.Table, tmp);      call Highlight.Graphics.Button.Table       /* highlight       */      (Sync.Command.Table, bits(tmp(0)),  2, 0); /* lights quickly  */      if Sync.Dialog.Mode <> 0               /* erase prior display */      then call Define.Sync.Dialog(Sync.Row+3,0);      if tmp(0) = 3                          /* smpte generator     */      then do;         /* smpte generate */         call Draw.Message('                                Press SPACE bar on terminal to stop');         call cpos(23,0);         call TTY_WAIT;         call SMPTE.GENERATOR(1);         call Erase.Message;         call Highlight.Graphics.Button.Table  /* un-highlight      */         (Sync.Command.Table, 0, 2, 0);        /* lights quickly    */      end;      else call Define.Sync.Dialog(Sync.Row+3, tmp(0)+1);   end;end Handle.Sync.Command.Table;/* $page - handle events for sync panel dialog lines *//* Procedure to take current time (either sequence or smpte) and *//* store in 32-bit millisecond format for smpte displays:        */TAKE.SYSTEM.SEQUENCE.DURATION: proc (time) swapable;   dcl time    array;   dcl tbuf(4) fixed;   if (SMPTE.ONOFF    = 0)    /* if SMPTE is not being used   */   or (TIME.BASE.MODE = 4)    /* or we are locked to smpte    */   then do;                   /* then use sequence time       */      disable;         time(0) = Play.Time.Msb;         time(1) = Play.Time.Lsb;      enable;      call SUB16(Zero.Time, time);    /* get in duration format */      if time(0) < 0                  /* so we can store as     */      then call STR32(0, 0, time);    /* 32-bit msec smpte disp */      call SMPTE.To.Msec(loc(addr(SM.HRS)), cf#dur, SAMP.SPEED, SM.MODE, zero.zero, Tbuf);      call ADD32(Time, Tbuf, Time);   end;   else do;                   /* else use most recent smpte   */      tbuf(0) = cur.hrs;      /* get most recently scanned    */      tbuf(1) = cur.min;      /* smtpe time                   */      tbuf(2) = cur.sec;      tbuf(3) = cur.fra;      tbuf(4) = 0;      call SMPTE.To.Msec(tbuf, cf#dur, SAMP.SPEED, SM.MODE, zero.zero, Time);   end;end TAKE.SYSTEM.SEQUENCE.DURATION;Handle.Dialog.Mode.1.Events: proc swapable;   dcl tmp(1) fixed;   dcl width  fixed;   dcl fps    fixed;   dcl a(1)   fixed;   dcl b(1)   fixed;   dcl c(1)   fixed;   dcl str(4) fixed;   Take.Duration:proc (tmp);      dcl tmp      array;      dcl a(1)     fixed;      /* Get current synclavier time,  cf#time format,  may be */      /* plus or minus:                                        */      call TAKE.SYSTEM.SEQUENCE.TIME(tmp);      /* remove zero.time offset to get a duration equivalent. */      /* This will yield how many milliseconds (plus or minus) */      /* we are from the start of the sequence:                */      if tmp(0) < 0 then do;         call ADD16(Zero.Time, tmp);         if tmp(0) >= 0         then call STR32(0, Zero.Time, tmp);      end;      else do;         call SUB16(Zero.Time, tmp);         if tmp(0) < 0         then call STR32(0, Zero.Time, tmp);      end;      /* add in footage offset so time matches footage display */      call FEET.TO.MSEC (S$Foffset, cf#dur, S$Speed, S$Fmode, zero.zero, A);      call ADD32(A, tmp, tmp);   end Take.Duration;   if Screen.Event.Id = Sync.Dialog.Take1   then do;      if Screen.Event.Info = S#MouseSelect      then do;         call TAKE.SYSTEM.SEQUENCE.DURATION (tmp);         /* let deposit reporting do its job: */         call Deposit.32Bit.Msec(Sync.Dialog.Time1, Zero.Zerotime, tmp);         call Update.Object(Sync.Dialog.Time1);      end;   end;   else if Screen.Event.Id = Sync.Dialog.Time1   then do;      if Screen.Event.Info = S#ObjectDrag then do;         call Perform.AEE.Drag.Function(Screen.Event.Id,Screen.Event.Obj.Info);         call Select.New.Cur.Obj(Corner.Label,-1,-1);      end;      else if Screen.Event.Info = S#Deposit then do;         /* store value away in Sync.Compute.Event.Time so same */         /* value is restored when we open up the panel         */         /* again:                                              */         call SMPTE.TO.MSEC(loc(addr(SM.HRS)), cf#dur, SAMP.SPEED, SM.MODE, zero.zero, A);         call Fetch.32Bit.Msec(Sync.Dialog.Time1, B);         call SUB32(B, A, B);   /* get how far into sequence time1 is, + or - */         if b(0) < 0                     /* convert to cf#time for storage */         then call SUB16(zero.time, B);  /* in Sync.Compute.Event.Time     */         else call ADD16(zero.time, B);         call PID(Sync.Compute.Event.Time  , b(0));         call PID(Sync.Compute.Event.Time+1, b(1));      end;   end;   else if Screen.Event.Id = Sync.Dialog.Take2   then do;      if Screen.Event.Info = S#MouseSelect      then do;         if Sync.Dialog.Disp.Contents = O#MSEC.SMPTE         then do;            call TAKE.SYSTEM.SEQUENCE.DURATION (tmp);         end;         else do;            call Take.Duration (tmp);         end;         /* let deposit reporting do its job: */         call Deposit.32Bit.Msec(Sync.Dialog.Time2, Zero.Zerotime, tmp);         call Update.Object(Sync.Dialog.Time2);      end;   end;   else if Screen.Event.Id = Sync.Dialog.Time2   then do;      if Screen.Event.Info = S#ObjectDrag then do;         call Perform.AEE.Drag.Function(Screen.Event.Id,Screen.Event.Obj.Info);         call Select.New.Cur.Obj(Corner.Label,-1,-1);      end;      else if Screen.Event.Info = S#Deposit      then do;         /* compute new smpte display offset when display	*/         /* value is entered											*/         if Sync.Dialog.Disp.Contents = O#MSEC.SMPTE         then do;            /* compute Smpte Display Offset						*/            /* Time1 = duration      (+ or minus)				*/            /* Time2 = duration      (+ or minus)				*/            call Fetch.32Bit.Msec(Sync.Dialog.Time1, A);            call Fetch.32Bit.Msec(Sync.Dialog.Time2, B);            call SUB32(B, A, C);   /* get display offset, msecs, + or - *//*				//	At this point C can hold any value from XXX to XXX inclusive.				//	This corresponds to the range (-24 hours <= C <= +24 hours) in any SMPTE mode.				//	To avoid multiple representations of the same offset, we should reduce this to the range -12 hours < C <= +12 hours.				if			((C == 86400000) || (C == -86400000))	C = 0;			//	-24 hours or + 24 hours becomes zero offset				else if	(C > 86400000/2)								C -= 86400000;	//	if greater than +12 hours then subtract 24 hours				else if	(C <= -86400000/2)							C += 86400000;	//	if less than or equal to -12 hours then add 24 hours	//	Get 24 hours of milliseconds in the current mode	//	The smpte mode is actually irrelevant since 24 hours in any mode will yield	//	the same number of milliseconds.  Only SAMP.SPEED has an effect.  -TY 2001/02/12	//	compute round(24*60*60*1000 * 1000/SAMP.SPEED)	bitmsb =  1318;	bitlsb = 23552;	ratio_multiply(1000,SAMP.SPEED);*/            call MSEC.TO.SBITS (C, cf#dur, SAMP.SPEED, SM.MODE, C);            write(mam) = BAS.PTR;                  write(mal) = SEQ.DOFFSET;              write(mdi) = C(0);            write(mdi) = C(1);            write(mdi) = 0;        /* SEQ.DOFFDIS = 0 when setting      */            call Sample.Syncl.Smgr.Globals; /* get info into smgr immediately */            /* Create a system event whenever the smpte display	*/            /* offset changes, or is turned on or off:				*/            new.seq.info = new.seq.info \ 8;         end;         else do;            /* compute Footage display offset					*/            /* Time1 = SMPTE	 duration		(+ or minus)	*/            /* Time2 = FOOTAGE duration		(+ or minus)	*/            call Fetch.32Bit.Msec(Sync.Dialog.Time1, A);            call Fetch.32Bit.Msec(Sync.Dialog.Time2, B);            call SMPTE.TO.MSEC(loc(addr(SM.HRS)), cf#dur, SAMP.SPEED, SM.MODE, zero.zero, C);            call SUB32(A, C, C);  /* get how far into sequence time1 is   */            call SUB32(B, C, C);  /* get footage display at start of seq  */            call MSEC.TO.FEET(C, cf#dur, S$Speed, S$Fmode, zero.zero, Str);            write(mam) = BAS.PTR;            write(mal) = SEQ.FOFFSET;            write(mdi) = Str(0);            write(mdi) = Str(1);            write(mdi) = Str(2);            call Sample.Syncl.Smgr.Globals; /* get info into smgr immediately */            /* Create a system event whenever the footage	*/            /* display offset changes:								*/            new.seq.info = new.seq.info \ 8;         end;      end;   end;   else if Screen.Event.Id = Sync.Dialog.Disp.Mode.Table   then do;      if Screen.Event.Info = S#MouseSelect      then do;         if Sync.Dialog.Disp.Contents = O#MSEC.SMPTE         then do;            call Handle.SMPTE.In.Mode.Table(Sync.Dialog.Disp.Mode.Table);         end;         else do;            call Map.Graphics.Button.Table.Mouse.Press(Sync.Dialog.Disp.Mode.Table, tmp);            /* detect change of film width: */            if tmp(0) < 2 then do;                                          call Set.Synclav.Feet.Mode(tmp(0), -1);                   end;                                                                                                                      else do;                                                        call Set.Synclav.Feet.Mode(-1, tmp(0)-2);                 end;                                                                                                                      call Sample.Syncl.Smgr.Globals; /* get info into smgr immediately */            /* Highlight our button table to reflect the */            /* new mode:                                 */            if S$Fmode >= 3 then do;               width = 1;               fps   = S$Fmode - 3;            end;            else do;               width = 0;               fps   = S$Fmode;            end;            call Highlight.Graphics.Button.Table            (Sync.Dialog.Disp.Mode.Table, bits(width) \ bits(fps + 2), 2, 0);         end;      end;   end;   else if Screen.Event.Id = Sync.Dialog.Cancel.Button   then do;      if Screen.Event.Info = S#MouseSelect      then do;         call Highlight.Graphics.Button.Table   /* turn off        */         (Sync.Command.Table, 0,  2, 0);        /* lights quickly  */         call Define.Sync.Dialog(Sync.Row+3, 0);      end;   end;end Handle.Dialog.Mode.1.Events;Handle.Dialog.Mode.2.Events: proc swapable;   dcl tmp(1) fixed;   dcl a  (1) fixed;   dcl b  (1) fixed;   dcl c  (1) fixed;   dcl d  (1) fixed;   if Screen.Event.Id = Sync.Dialog.Take1   then do;      if Screen.Event.Info = S#MouseSelect      then do;         call TAKE.SYSTEM.REAL.TIME(tmp);         /* let deposit reporting do its job: */         call Deposit.32Bit.Msec(Sync.Dialog.Time1, tmp, Zero.Zero);         call Update.Object(Sync.Dialog.Time1);      end;   end;   else if Screen.Event.Id = Sync.Dialog.Time1   then do;      if Screen.Event.Info = S#ObjectDrag then do;         call Perform.AEE.Drag.Function(Screen.Event.Id,Screen.Event.Obj.Info);         call Select.New.Cur.Obj(Corner.Label,-1,-1);      end;      else if Screen.Event.Info = S#Deposit            /* new time: save */      then do;                                         /* for next time  */         call Fetch.32Bit.Msec(Sync.Dialog.Time1,tmp); /* panel is       */         call PID(Sync.Compute.Event.Time  , tmp(0));  /* opened.        */         call PID(Sync.Compute.Event.Time+1, tmp(1));      end;   end;   else if Screen.Event.Id = Sync.Dialog.Take2   then do;      if Screen.Event.Info = S#MouseSelect      then do;         call TAKE.SYSTEM.REAL.TIME(tmp);         /* let deposit reporting do its job: */         call Deposit.32Bit.Msec(Sync.Dialog.Time2, tmp, Zero.Zero);         call Update.Object(Sync.Dialog.Time2);      end;   end;   else if Screen.Event.Id = Sync.Dialog.Time2   then do;      if Screen.Event.Info = S#ObjectDrag then do;         call Perform.AEE.Drag.Function(Screen.Event.Id,Screen.Event.Obj.Info);         call Select.New.Cur.Obj(Corner.Label,-1,-1);      end;      else if Screen.Event.Info = S#Deposit then do;         /* highlight the 'Compute Start Time' button when */         /* the smpte value is entered to remind the user  */         /* to click it:                                   */         call Highlight.Graphics.Button.Table         (Sync.Dialog.Ok.Button, 1, 2, 0);      end;   end;   else if Screen.Event.Id = Sync.Dialog.OK.Button   then do;      if Screen.Event.Info = S#MouseSelect      then do;         call Highlight.Graphics.Button.Table         (Sync.Dialog.Ok.Button, 1, 2, 0);         /* compute Smpte Offset                           */         /* Time1 = sequence time (+ or minus)             */         /* Time2 = sequence time (+ or minus)             */         call Fetch.32Bit.Msec(Sync.Dialog.Time1, A);         call Fetch.32Bit.Msec(Sync.Dialog.Time2, B);         call Fetch.32Bit.Msec(Sync.Smpte.Offset, C);         call SUB32(B, A, D);             /* get difference between   */                                          /* the two times displayed. */         if (a(0) xor b(0)) < 0           /* If of different sign,    */         then do;                         /* then difference is off   */            if d(0) < 0                   /* by two zero.times.       */            then call ADD16(2*Zero.Time, D);            else call SUB16(2*Zero.Time, D);         end;         call ADD32(D, C, D);             /* Now compute new offset.  */         /* let deposit reporting do its job */         call Deposit.32Bit.Msec(Sync.SMPTE.Offset, Zero.Zerotime, D);         call Update.Object(Sync.SMPTE.Offset);  /* Draw promptly */         /* Setting time2 will show correct smpte time once the */         /* new offset has been computed:                       */         disable.deposits = 1;         call Deposit.32Bit.Msec(Sync.Dialog.Time2, A, Zero.Zero);         disable.deposits = 0;         call Highlight.Graphics.Button.Table         (Sync.Dialog.Ok.Button, 0, 2, 0);      end;   end;   else if Screen.Event.Id = Sync.Dialog.Cancel.Button   then do;      if Screen.Event.Info = S#MouseSelect      then do;         call Highlight.Graphics.Button.Table   /* turn off        */         (Sync.Command.Table, 0,  2, 0);        /* lights quickly  */         call Define.Sync.Dialog(Sync.Row+3, 0);      end;   end;end Handle.Dialog.Mode.2.Events;Handle.Dialog.Mode.3.Events: proc swapable;   dcl map data (O#MSEC.Sec.Msec,O#MSEC.Minutes.Seconds,  /* map switch setting */                 O#MSEC.Beats,   O#MSEC.Measures.Beats,   /* to aee time format */                 O#MSEC.SMPTE,   O#MSEC.Feet.Frames);   dcl tmp(1) fixed;   if (Screen.Event.Id = Sync.Dialog.Switch1)   then do;      if Screen.Event.Info = S#Deposit      then do;         call Set.32Bit.MSEC.Display.Format(Sync.Dialog.Time1,               map(Fetch.Switch(Sync.Dialog.Switch1))                   \ O#MSEC.Allow.Minus \ O#MSEC.RealTime,              cf#time, cf#default, cf#default);         Sync.Dialog.Switch.Settings =             shl(map(Fetch.Switch(Sync.Dialog.Switch1))                - Sync.Dialog.Switch1.Default,8)               \ ((map(Fetch.Switch(Sync.Dialog.Switch2))               - Sync.Dialog.Switch2.Default) & 255);      end;   end;   else if Screen.Event.Id = Sync.Dialog.Take1   then do;      if Screen.Event.Info = S#MouseSelect      then do;         call TAKE.SYSTEM.REAL.TIME(tmp); /* get synclav time */         /* let deposit reporting do its job: */         call Deposit.32Bit.Msec(Sync.Dialog.Time1, tmp, Zero.Zero);         call Update.Object(Sync.Dialog.Time1);      end;   end;   else if Screen.Event.Id = Sync.Dialog.Time1   then do;      if Screen.Event.Info = S#Deposit      then do;         call Fetch.32Bit.Msec(Sync.Dialog.Time1,tmp);         disable.deposits = 1;         call Deposit.32Bit.Msec(Sync.Dialog.Time2,tmp,Zero.Zero);         disable.deposits = 0;         call Update.Object(Sync.Dialog.Time2);         call PID(Sync.Compute.Event.Time  , tmp(0));         call PID(Sync.Compute.Event.Time+1, tmp(1));      end;      else if Screen.Event.Info = S#ObjectDrag then do;         call Perform.AEE.Drag.Function(Screen.Event.Id,Screen.Event.Obj.Info);         call Select.New.Cur.Obj(Corner.Label,-1,-1);      end;      /* else nothing to do on deposit - wait for 'ok' */   end;   else if (Screen.Event.Id = Sync.Dialog.Switch2)   then do;      if Screen.Event.Info = S#Deposit      then do;         call Set.32Bit.MSEC.Display.Format(Sync.Dialog.Time2,               map(Fetch.Switch(Sync.Dialog.Switch2))               \ O#MSEC.Allow.Minus \ O#MSEC.RealTime,               cf#time, cf#default, cf#default);         Sync.Dialog.Switch.Settings =             shl(map(Fetch.Switch(Sync.Dialog.Switch1))                - Sync.Dialog.Switch1.Default,8)               \ ((map(Fetch.Switch(Sync.Dialog.Switch2))               - Sync.Dialog.Switch2.Default) & 255);      end;   end;   else if Screen.Event.Id = Sync.Dialog.Take2   then do;      if Screen.Event.Info = S#MouseSelect      then do;         call TAKE.SYSTEM.REAL.TIME(tmp); /* get synclav time */         /* let deposit reporting do its job: */         call Deposit.32Bit.Msec(Sync.Dialog.Time2, tmp, Zero.Zero);         call Update.Object(Sync.Dialog.Time2);      end;   end;   else if Screen.Event.Id = Sync.Dialog.Time2   then do;      if Screen.Event.Info = S#Deposit      then do;         call Fetch.32Bit.Msec(Sync.Dialog.Time2,tmp);         disable.deposits = 1;         call Deposit.32Bit.Msec(Sync.Dialog.Time1,tmp,Zero.Zero);         disable.deposits = 0;         call Update.Object(Sync.Dialog.Time1);         call PID(Sync.Compute.Event.Time  , tmp(0));         call PID(Sync.Compute.Event.Time+1, tmp(1));      end;      else if Screen.Event.Info = S#ObjectDrag then do;         call Perform.AEE.Drag.Function(Screen.Event.Id,Screen.Event.Obj.Info);         call Select.New.Cur.Obj(Corner.Label,-1,-1);      end;      /* else nothing to do on deposit - wait for 'ok' */   end;   else if Screen.Event.Id = Sync.Dialog.OK.Button   then do;      if Screen.Event.Info = S#MouseSelect      then do;         call Highlight.Graphics.Button.Table   /* turn off        */         (Sync.Command.Table, 0,  2, 0);        /* lights quickly  */         call Define.Sync.Dialog(Sync.Row+3, 0);      end;   end;   else if Screen.Event.Id = Sync.Dialog.Cancel.Button   then do;      if Screen.Event.Info = S#MouseSelect      then do;         call Highlight.Graphics.Button.Table   /* turn off        */         (Sync.Command.Table, 0,  2, 0);        /* lights quickly  */         call Define.Sync.Dialog(Sync.Row+3, 0);      end;   end;end Handle.Dialog.Mode.3.Events;/* $page - Get.Sync.Event */DCL DISPLAY.METER PROC EXTERNAL;   /* VK METER DISPLAY ROUTINE */GET.SYNC.EVENT: proc (event) returns (fixed) public swapable;   dcl event         fixed;   dcl str  (8)      fixed;   dcl time (2)      fixed;   dcl doffs(1)      fixed;   do while 1;      if event <> Get.Null.Event then do;         if Screen.Event.Group <> Sync.Group then return event;         if event = Get.Screen.Event then do;            /* Top Row,  left to right: */            if Screen.Event.Id = Sync.Display.Switch then do;               call Handle.Sync.Display.Switch;            end;            else if Screen.Event.Id = Sync.SMPTE.Label then do;               call Handle.SMPTE.Label;            end;            else if (Screen.Event.Id = Sync.SMPTE.Take)            AND     (Screen.Event.Info = S#MouseSelect)            then do;               call TAKE.SYSTEM.SMPTE.TIME(str);  /* get hours-mins-secs-frames-bits of current sequencer time or smpte time */               call Set.Synclav.SMPTE.Offset(str); /* store in sequence */               call Sample.Syncl.Smgr.Globals; /* get info into smgr immediately */               /* Quickly refresh start time display to show correct */               /* value:                                             */               call SMPTE.To.Msec(S$Soffset, cf#dur, S$Speed, S$Smode, Zero.Zero, Time);               disable.deposits = 1;               call Deposit.32Bit.Msec(Sync.SMPTE.Offset, Zero.Zerotime, Time);               disable.deposits = 0;               call Update.Object(Sync.SMPTE.Offset);  /* Draw promptly */            end;            else if (Screen.Event.Id = Sync.SMPTE.Offset) then do;               call Handle.Sync.Smpte.Offset;            end;            else if (Screen.Event.Id = Sync.SMPTE.In.Mode.Table) then do;               call Handle.SMPTE.In.Mode.Table(Sync.SMPTE.In.Mode.Table);            end;            else if ((interp_is_running != 0) && (Screen.Event.Id = Sync.Send.OMS.Table)) then do;               call Handle.Send.OMS.Table(Sync.Send.OMS.Table);            end;            else if ((interp_is_running != 0) && (Screen.Event.Id = Sync.Enable.OMS.Table)) then do;               call Handle.Enable.OMS.Table(Sync.Enable.OMS.Table);            end;            /* Second row,  left to right: */            else if Screen.Event.Id = Sync.Sync.Mode then do;               if Screen.Event.Info = S#Deposit then do;                  call Set.Synclav.Sync.Mode(Fetch.Switch(Sync.Sync.Mode));                  call Update.Sync.Panel(false);   /* in case something went wrong */               end;            end;            else if Screen.Event.Id = Sync.Click.On.Off.Switch then do;               if Screen.Event.Info = S#Deposit then do;                  call Set.Synclav.Click.Sound(Fetch.Switch(Sync.Click.On.Off.Switch));                  call Update.Sync.Panel(false);   /* in case something went wrong */               end;            end;            else if Screen.Event.Id = Sync.Click.Rate then do;               if Screen.Event.Info = S#Deposit then do;                  call Fetch.Sound.File.Time(Sync.Click.Rate, time);                  call Set.Synclav.Click.Rate(time, Fetch.Switch(Sync.Click.Mode.Switch));                  call Sample.Syncl.Smgr.Globals;  /* set s$Click correctly */                  call Update.Sync.Panel(false);   /* in case something went wrong */               end;            end;            else if Screen.Event.Id = Sync.Click.Mode.Switch then do;               if Screen.Event.Info = S#Deposit then do;                  call Handle.Click.Mode.Switch(Fetch.Switch(Sync.Click.Mode.Switch));  /* update click state vars based on switch pos */                  call Update.Click.Field(Sync.Click.Rate, Fetch.Switch(Sync.Click.Mode.Switch));                  call Update.Sync.Panel(false);   /* in case something went wrong */               end;            end;            else if Screen.Event.Id = Sync.Speed then do;               if Screen.Event.Info = S#Deposit then do;                  call Store.Syncl.Param(3, 0, speed.l, Fetch.Fixed.Point(Sync.Speed));                  call Sample.Syncl.Smgr.Globals;  /* set s$speed correctly */                  call Update.Sync.Panel(false);   /* in case something went wrong */               end;            end;            else if Screen.Event.Id = Sync.BeatsPerMeas then do;               if Screen.Event.Info = S#Deposit then do;                  if (meter.map.ptr == 0)						{							Store.Syncl.Param(3, 0, bpm.l, Fetch.Fixed.Point(Sync.BeatsPerMeas));						}                  else						{                     Set.Beats.Per.Measure(loc(addr(sampled.actual.sequence.time.msb)), Fetch.Fixed.Point(Sync.BeatsPerMeas));                     if (upper.disp == bpm.l-par.l)	call display.meter;                  }                  call Sample.Syncl.Smgr.Globals;  /* set s$BPM correctly */                  call Update.Sync.Panel(false);   /* in case something went wrong */               end;            end;            /* Third row,  left to right: */            else if Screen.Event.Id = Sync.Command.Table            then call Handle.Sync.Command.Table;            /* Check for dialog line items: */            else if (Sync.Dialog.Mode = 1)            then call Handle.Dialog.Mode.1.Events;            else if (Sync.Dialog.Mode = 2)            then call Handle.Dialog.Mode.2.Events;            else if (Sync.Dialog.Mode = 3)            then call Handle.Dialog.Mode.3.Events;         end;      end;      event = Get.Next.Screen.Event;   end;end GET.SYNC.EVENT;