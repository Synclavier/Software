/* AUD-CU10   $TITLE  Routines to animate flag area   Modified:   02/06/92 - cj  - Activated DSP scrubbing from q-page   01/11/90 - MWH - Fixed link fine bar to recenter if wave display not up   04/10/89 - cj  - fixed do while loop in animate.flag.region   03/14/89 - PF  - changed RS422.packet.there to Protocol.packet.there   07/29/88 - cj  - fixed coarse bar/fine bar mixup in zoom button code   07/29/88 - cj  - argument change to link fine bar if applicable   05/28/88 - TSS - Added PLAY FROM, PAUSE, PLAY TO while animating   05/25/88 - TSS - Enhanced ANIMATE.FLAG.REGION to support new features   05/20/88 - TSS - Split file into two pieces (AUD-SH4, AUD-SH5)*//* routine to play dtd from local position */Trigger.Dtd.From.Pix:proc(mx,mins,pixels,origpos,origtime,code) swapable;   dcl mx       fixed;    /* pass mouse current x position   */   dcl mins     fixed;    /* pass x position of 0 %          */   dcl pixels   fixed;    /* pixels to reach 1000 %          */   dcl origpos  fixed;    /* pass original pixel position    */   dcl origtime array;    /* and time thereof, for precision */   dcl code     fixed;    /* pass playback code              */   dcl i        fixed;   if  (mx < mins)        /* before left edge = 0.000 %      */   then i = 0;   else if  (mx > mins+pixels)   /* after right edge         */   then i = 1000;   /*  compute percentage from pixel position */   else do;      load  (mx-mins);    /* get # of pixels from start to us */      uload shr(pixels,1);/* perform rounding                 */      mul   1000;         /* copmpute percent, 0 - 1000%      */      mwait;      div   pixels;      i = res;            /* result is 0-1000 percent */   end;   if mx = origpos        /* if pixel is back at original, play from original point, since it is likely to be more accurate than the corresponding pixel */   then call COPY32(origtime,AEE.Shuttle.Anchor.Time);   else call Compute.Time.From.Percent   /* else compute pixel time */   (i,AEE.Shuttle.In.Time,AEE.Shuttle.Out.Time,AEE.Shuttle.Anchor.Time);            if  (mx < mins       )           /* skip audio portion if */   or  (mx > mins+pixels)           /* mouse is outside      */   or  (code = (-2)     )           /* forced stop           */   then do;                         /* the play region       */      call Stop.DTD.Playback;        return;   end;   else do;                  /* else play from anchor point         */      if  (code = 0)         /* if animating cue in time            */      and (COM32(AEE.Shuttle.Anchor.Time, Cue.Out.Time) = lw#ilt)      then call Play.Current.Cue(4,0,0,Shuttle.Drive.Bits,1); /* play from new anchor point to end of cue  */      else if code = (-1)      then call Play.Current.Cue(4,1,6,Shuttle.Drive.Bits,1); /* play to anchor time while animating */      else call Play.Current.Cue(4,0,2,Shuttle.Drive.Bits,1); /* play from new anchor point to end of sbar */   end;   call DEPOSIT.SHUTTLE.TIME.DISPLAY(AEE.Shuttle.Anchor.Time);   if  (DTD.Play.State = 2)    /* if we did successfully trigger the cue */   then DTD.Play.State = 3;    /* then set to state where we do not want */end Trigger.Dtd.From.Pix;      /* to see time display.                   *//* all times are with respect to the current cue */Start.Point.Playback:proc (time,mt) swapable;   dcl time   array;         /* time to start */   dcl mt     fixed;         /* mouse time    */   dcl dsp.running fixed external;   //dcl send.to.dsp.subroutine proc(fixed,fixed,fixed) external;   call Set.DTD.Play.Tracks(Current.Cue.Drive.Bits);   call Send.To.Lod        (DTD.Scrolling.Off, 0  );   call Play.DTD.At.Point  (time,Fine.Bar.Play.Code,mt,1);   //if dsp.running <> 0   //then call send.to.dsp.subroutine(70,0,Scsi.Ptr);end Start.Point.Playback;Init.For.Point:proc (time,fpixels,fmins,fminy,fmaxy,force) swapable;   dcl time    array;   /* time to play from   */   dcl fpixels fixed;   /* pixels in fine bar  */   dcl fmins   fixed;   /* left start pixel    */   dcl fminy   fixed;   /* fine min y          */   dcl fmaxy   fixed;   /* fine max y          */   dcl fdisp   fixed;   /* disp pixel returned */   dcl force   fixed;   /* force re-allign     */                        /* of fine sbar when   */                        /* running into edge   */   call Link.Fine.Bar.If.Applicable(time,force);  /* Link fine bar up */   load Times.To.Percent(AEE.Fine.In.Time,time,AEE.Fine.Out.Time);  /* get % (should be 500) in fine bar */   uload 500;              /* round up by .5 pixel */   mul   fpixels;          /* times pixels         */   mwait;   div   1000;             /* over 1000 = yields pixel offset */   fdisp = fmins + res;   return fdisp;end Init.For.Point;Compute.New.Disp:proc (time,pixels,mins) swapable;   dcl time   array;    /* pass time computed from fine bar */   dcl pixels fixed;    /* pixels in coarse bar             */   dcl mins   fixed;    /* min pixels of coarse bar         */   load Times.To.Percent(AEE.Shuttle.In.Time,time,AEE.Shuttle.Out.Time);   uload 500;              /* round up by .5 pixel */   mul   pixels;           /* times pixels         */   mwait;   div   1000;             /* over 1000 = yields pixel offset */   return mins + res;end Compute.New.Disp;/* $page - update flag position after drag *//* The drag flag has been dragged to the position 'DISP'.  *//* If this position is not the original position, then     *//* we must remove the original flag                        *//* We can leave the drag flag in position, since it will   *//* function as the new flag (most likely)                  */Update.Flag.Position:proc (code,disp,miny,origpos) swapable;   dcl Code     Fixed;   /* flag code, 0 - 10                      */   dcl Disp     fixed;   /* disp position where drag flag ended up */   dcl Miny     fixed;   /* miny of flag region                    */   dcl Origpos  fixed;   /* original flag pixel position           */   /* we just have some accounting to do since the drag flag */   /* sitting at DISP can act as the new flag                */   /* we must erase the original flag, however               */   do case (code);      /* after most drags,  the desired flag is in the new */      /* position.  just erase the old flag and account    */      do;         call Plot.Flag(Coarse.Bar.In.Flag,miny,0,0,0);  /* remove original flag */         Coarse.Bar.In.Flag = disp;      end;      do;         call Plot.Flag(Coarse.Bar.Out.Flag,miny,1,0,0); /* remove original flag */         Coarse.Bar.Out.Flag = disp;      end;      do;         call Plot.Flag(Coarse.Bar.EIn.Flag,miny,2,0,0); /* remove original flag */         Coarse.Bar.EIn.Flag = disp;      end;      do;         call Plot.Flag(Coarse.Bar.EOut.Flag,miny,3,0,0);/* remove original flag */         Coarse.Bar.EOut.Flag = disp;      end;      /*  E flags are a little more complicated since several */      /* edit points could actually share the same E flag     */      do;  /* handle drag of an E flag */         write(mam) = Cue.Flag.Ptr;         load origpos; div 16;         write(mal) = shl(res,1)+1;         if (read(md)&bits(rem))<>0 then do;     /* if flag exists at orig */            write(md) = read(md) xor bits(rem);  /* pos, then remove it    */            call Plot.Flag(origpos,miny,4,0,0);  /* marking place as blank */         end;         write(mam) = Cue.Flag.Ptr;              /* new draw edit flag in  */         load disp; div 16;                      /* the new position       */         write(mal) = shl(res,1)+1;         if (read(md)&bits(rem))=0 then do;      /* if no flag there, then */            write(md) = read(md) xor bits(rem);  /* drag flag is now there */         end;         else call Plot.Flag(disp,miny,4,0,0);   /* else replace edit flag */      end;                                       /* that was erased by the drag flag */      do;    /* code 5 - not used for dragging */      end;      do;    /* code 6 - edit line             */         /* must do more drawing for edit line since */         /* we used a shadow box                     */         call Plot.Flag(Edit.Line.Center.Pix,miny,5,0,0); /* remove old line */         call Plot.Flag(disp,miny,5,0,0);                 /* draw   new line */         call Plot.Flag(disp,miny,6,0,0);                 /* erase animate   */         Edit.Line.Center.Pix = disp;      end;      /* after drag of while cue, respective flag is in */      /* the correct position                           */      do;         call Plot.Flag(Coarse.Bar.In.Flag,miny,0,0,0);  /* remove original flag */         Coarse.Bar.In.Flag = disp;               end;      do;         call Plot.Flag(Coarse.Bar.Out.Flag,miny,1,0,0); /* remove original flag */         Coarse.Bar.Out.Flag = disp;      end;      do;         call Plot.Flag(Coarse.Bar.EIn.Flag,miny,2,0,0); /* remove original flag */         Coarse.Bar.EIn.Flag = disp;      end;      do;         call Plot.Flag(Coarse.Bar.EOut.Flag,miny,3,0,0); /* remove original flag */         Coarse.Bar.EOut.Flag = disp;      end;      /* for magnifiers - remove the drag icon */      /* since the actual icon never leaves    */      /* its resting place                     */      do;                     /* left magnifier */         call Plot.Flag(disp,miny,11,0,origpos);       end;      do;                    /* right magnifier */         call Plot.Flag(disp,miny,12,0,origpos);        end;      do;                     /* left magnifier */         /* just remove magnifier only - extension has already  */         /* been removed, leaving just the magnifier            */         call Plot.Flag(disp,miny,11,0,origpos);       end;      do;                    /* right magnifier */         call Plot.Flag(disp,miny,12,0,origpos);        end;      do;                    /* nothing to do for coarse bar drag */      end;                   /* shadow has been removed; box will be positioned later */   end;end Update.Flag.Position;/* $page - subroutine to change values after drop */Process.Drag.Drop: proc(code,time,info,disp,origtime) swapable;   dcl code     fixed;       /* pass drag code          */   dcl time     array;       /* pass new time to assign */   dcl info     fixed;       /* drag info for E flag    */   dcl disp     fixed;       /* new display position    */   dcl origtime array;       /* original time as well   */   /* Handy routine to change coarse bar in/out times such as happens  */   /* when dragging magnifiers                                         */   Handle.Shuttle.Move:proc;      /* Re-link fine bar:                                             */      call Set.DTD.Fine.Scrub.Bar(AEE.Shuttle.Anchor.Time, 0);      /* Create a system event when the region of audio covered by the */      /* coarse scroll bar changes:                                    */      new.dtd.info = new.dtd.info \ 2048;   end Handle.Shuttle.Move;   backup: proc(starting,delta,output);   /* back up time with zero check */      dcl starting     array;             /* starting time                */      dcl delta        array;             /* amount to back up by         */      dcl output       array;             /* output data array            */      if COM32(starting,delta) = lw#ilt      then call STR32(0,0,output);      else call SUB32(starting,delta,output);      if COM16(zero.time,output) = lw#igt      then output(1) = zero.time;   end backup;   /* process slide of region    */   /* must do a little carefully */   Slide.Area: proc(time,origtime,regioncode);      dcl time       array;    /* new time    */      dcl origtime   array;    /* orig time   */      dcl regioncode fixed;    /* 0 = cue; 1 = edit; 2 = shuttle */      dcl temp(1)    fixed;    /* 0 = slde cue + edit area       */      dcl temp1(1)   fixed;      dcl in   (1)   fixed;      dcl out  (1)   fixed;      if COM32(time,origtime) = lw#ilt    /* new time is earlier */      then do;         call SUB32(origtime,time,temp);  /* how much earlier    */         do case (regioncode);            do;                         /* move entire cue     */               call backup(Cue.Edit.In.Time, temp,Cue.Edit.In.Time);               call backup(Cue.Edit.Out.Time,temp,Cue.Edit.Out.Time);               call backup(Cue.Out.Time,     temp,Cue.Out.time     );               call backup(Cue.Offs.Time,    temp,Cue.Offs.Time    );               call backup(Cue.In.Time,      temp,temp1            );               call HANDLE.ANY.NEW.CUE.IN.TIME (temp1, 4, 1);            end;            do;                           /* only edit area      */               call backup(Cue.Edit.In.Time,temp,temp1);               call HANDLE.ANY.NEW.EDIT.IN.TIME (temp1, 3, 1);               call backup(Cue.Edit.Out.Time,temp,temp1);               call HANDLE.ANY.NEW.EDIT.OUT.TIME (temp1, 3, 1, 0);            end;            do;                           /* shuttle              */               call COPY32(AEE.Shuttle.In.Time,in);    /* Save range of coarse bar  */               call COPY32(AEE.Shuttle.Out.Time,out);               call backup(AEE.Shuttle.In.Time,  temp, AEE.Shuttle.In.Time);               call backup(AEE.Shuttle.Out.Time, temp, AEE.Shuttle.Out.Time);               if Coarse.Shuttle.Wave = 1                      /* Wave display is up */               AND (COM32(AEE.Shuttle.In.Time,in)   <> lw#ieq  /* A time has changed */               OR   COM32(AEE.Shuttle.Out.Time,out) <> lw#ieq)               then call Invalidate.Wave.Display(1);   /* Redraw coarse wave display */               call Handle.Shuttle.Move;            end;         end;      end;      else do;                            /* new time later      */         call SUB32(time,origtime,temp);  /* get how much        */         do case (regioncode);            do;                            /* entire cue          */               call ADD32(Cue.Edit.In.Time, temp,Cue.Edit.In.Time);               call ADD32(Cue.Edit.Out.Time,temp,Cue.Edit.Out.Time);               call ADD32(Cue.Out.Time,     temp,Cue.Out.time     );               call ADD32(Cue.Offs.Time,    temp,Cue.Offs.Time    );               call ADD32(Cue.In.Time,      temp,temp1            );               call HANDLE.ANY.NEW.CUE.IN.TIME (temp1, 4 ,true);            end;            do;                            /* only edit area      */               call ADD32(Cue.Edit.Out.time,temp,temp1);               call HANDLE.ANY.NEW.EDIT.OUT.TIME (temp1, 3, 1, 0);               call ADD32(Cue.Edit.In.time,temp,temp1);               call HANDLE.ANY.NEW.EDIT.IN.TIME (temp1, 3, 1);            end;            do;                            /* shuttle             */               call ADD32(AEE.Shuttle.In.Time,  temp, AEE.Shuttle.In.Time);               call ADD32(AEE.Shuttle.Out.Time, temp, AEE.Shuttle.Out.Time);               if Coarse.Shuttle.Wave = 1           /* Wave display is up */               AND COM16(0,temp) <> lw#ieq          /* Times have changed */               then call Invalidate.Wave.Display(1);   /* Redraw coarse wave display */               call Handle.Shuttle.Move;            end;         end;      end;   end Slide.Area;   do case (code);      call HANDLE.ANY.NEW.CUE.IN.TIME  (time, 3, 1);      call HANDLE.ANY.NEW.CUE.OUT.TIME (time, 3, 1, 0);      call HANDLE.ANY.NEW.EDIT.IN.TIME (time, 3, 1);      call HANDLE.ANY.NEW.EDIT.OUT.TIME(time, 3, 1, 0);      call SLIDE.SEGMENT.SYNC.TIME (time, origtime, info, disp);      do;     /* code 5 is not used */      end;      do;     /* new edit in time and out time from drag of edit line */         call Slide.Area(time,origtime,1);      end;      do;     /* slide of entire cue from cue in */         call Slide.Area(time,origtime,0);      end;      do;     /* slide of entire cue from cue out */         call Slide.Area(time,origtime,0);      end;      do;     /* slide of edit region from edit in */         call Slide.Area(time,origtime,1);      end;      do;     /* slide of edit region from edit out */         call Slide.Area(time,origtime,1);      end;      /* handle drag of magnifer glasses */      do;     /* left magnifier - set shuttle in */         if Coarse.Shuttle.Wave = 1                      /* Wave display is up */         AND COM32(AEE.Shuttle.In.Time,time) <> lw#ieq   /* Time is changing   */         then call Invalidate.Wave.Display(1);   /* Redraw coarse wave display */         call COPY32(time, AEE.Shuttle.In.Time);         call Handle.Shuttle.Move;      end;      do;     /* right magnifier - set shuttle out */         if Coarse.Shuttle.Wave = 1                      /* Wave display is up */         AND COM32(AEE.Shuttle.Out.Time,time) <> lw#ieq  /* Time is changing   */         then call Invalidate.Wave.Display(1);   /* Redraw coarse wave display */         call COPY32(time, AEE.Shuttle.Out.Time);         call Handle.Shuttle.Move;      end;      do;     /* slide of entire shuttle from shuttle in */         call Slide.Area(time,origtime,2);      end;      do;     /* slide of shuttle from shuttle out */         call Slide.Area(time,origtime,2);      end;      do;     /* nothing to do for coarse bar drag */      end;    /* anchor time is set elsewhere      */   end;end Process.Drag.Drop;/* $page - routine to clean up after flag animation *//* if user just clicks mouse quickly,  then return without *//* moving icon or changing time                            */dcl Locked.Item fixed public;  /* Object id of item we are locked to */                               /* Zero if not locked to anything     */                               /* When set, most screen functions    */                               /* are disabled.                      */Stop.Flag.Animation: proc(Mode,Fdisp,Fmaxy,Fminy,Disp,                          Code,mins,maxs,miny,mt,                          origpos,origtime,oanch) swapable;   dcl (Mode,Fdisp,Fmaxy,Fminy,Disp)  fixed;   dcl (Code,Mins,Maxs,Miny,Mt)       fixed;   dcl (origpos)                      fixed;   dcl (origtime,oanch)               array;   dcl (force)                        fixed;   dcl dsp.running fixed external;   //dcl send.to.dsp.subroutine proc(fixed,fixed,fixed) external;   if Mode = 0 then do;             call connect(fdisp,fmaxy-1,fdisp,fminy+1);  /* remove bar  */   end;   call Plot.Flag(disp,miny,code,1,origpos);      /* remove shadow/extension */   call Restore.Edit.Line.If.Possible(mins,maxs,miny);   CALL DATA_LEVEL(0);                        /* back to transp mode */   TRANSPARENT_MODE;   if Mode <> 0 then do;                      /* check seg plback    */      if ((Mouse(Release.Time) - mt) igt 200) /* button held longer than .2 seconds */      or (Locked.Item <> (-1))          /* or mouse not locked to an icon */      then do;                          /* stop playback        */         call Stop.DTD.Playback;        /* box positions below  */         call COPY32(AEE.Shuttle.Anchor.Time,loc(addr(Cur.DTD.MS.Msb))); /* store for take buttons */      end;      else if (DTD.Play.State = 3)      /* else allow time display now */      then     DTD.Play.State = 2;      /* that mouse is released      */   end;   else do;                             /* stop point playback */      Call Send.To.Lod(69,0);           /* stop it             */      DTD.Play.State = 0;      //if dsp.running <> 0      //then call send.to.dsp.subroutine(69,0,Scsi.Ptr);      /* start triggered playback if quick mouse press so      */      /* user hear the audio from that point                   */      if ((Mouse(Release.Time) - mt) ilt 200) /* button held less than .2 seconds */      and (Locked.Item = (-1))          /* and not locked to icon */      then do;                          /* stop playback          */         call Trigger.Dtd.From.Pix(origpos,mins,maxs-mins,origpos,origtime,code);         if  (DTD.Play.State = 3)       /* but allow time display since */         then DTD.Play.State = 2;       /* we have already released     */      end;                              /* the mouse.                   */   end;   if  ((Code = 2)                                  /* see if edit in flag was dragged to */   and  (Disp < (Mins - shr(SB.Hwidth,1))))         /* the retirement home                */   or  ((Code = 3)                                  /* also see if edit out flag was dragged */   and  (Disp > (Maxs + shr(SB.Hwidth,1))))         /* to the chicken ranch                  */   then call COPY32(Oanch,AEE.Shuttle.Anchor.Time); /* keep original anchor time if so       */   /* Reposition fine bar around anchor point (since we lost track of  */   /* where it was for a while) and create a system event to update    */   /* various displays:                                                */   /* Fine wave display is not up; force re-centering of the fine bar   */   if Fine.Shuttle.Wave <> 1   then force = 1;   else force = 0;   call Set.DTD.Fine.Scrub.Bar(AEE.Shuttle.Anchor.Time, force);   new.dtd.info = new.dtd.info \ 512;       /* force a new anchor position event */   if Locked.Item = (-1)                    /* normal operation    */   then call Mouse.Switch(1);               /* turn mouse back on  */end Stop.Flag.Animation;/* $page - routine to finish flag animation */Finish.Flag.Animation :proc(Mode,Fdisp,Fmaxy,Fminy,Disp,                            Code,Miny,Origpos,Origtime,                            Mins,Maxs,Xoffs,My,Stk,Info,Oanch) swapable;    dcl (Mode,Fdisp,Fmaxy,Fminy,Disp)     fixed;    dcl (Code,Miny,Origpos)               fixed;    dcl (Origtime,Stk,Oanch)              array;    dcl (Mins,Maxs,Xoffs,My,Info)         fixed;    dcl (force)                           fixed;    dcl (i)                               fixed;   dcl dsp.running fixed external;   //dcl send.to.dsp.subroutine proc(fixed,fixed,fixed) external;   /* done with animate on button release: */   /* remove shadow flag                   */   if Mode = 0 then do;             call connect(fdisp,fmaxy-1,fdisp,fminy+1);       /* remove bar  */   end;   call Plot.Flag(disp,miny,code,1,origpos);           /* and shadow  */   if disp <> origpos    /* if position has changed,  leave drag flag */   then do;              /* in place and account for change           */      call Update.Flag.Position(code,disp,miny,origpos);      call Set.Shuttle.Flags.And.Edits; /* set flag to recheck flags even if time did not change */   end;   if  ((Code = 2) or (Code = 3))     /* if animating edit in or out flag */   then do;                           /* then restore edit line if poss   */      call Restore.Edit.Line.If.Possible(mins,maxs,miny);   end;   /* clean up */   CALL DATA_LEVEL(0);                        /* back to transp mode */   TRANSPARENT_MODE;   /* position mouse at same x position with respect to icon */   /* that it was at                                         */   disable;   Mouse.X = disp - xoffs;   Mouse.Y = my;   enable;   /* re-enable for events */   do i=1 to num.of.get.events;      get.item.enabled(i)=stk(i);   end;   if Mode <> 0 then do;      call Stop.DTD.Playback;        /* box positions below  */   end;   else do;                          /* stop point plabk     */      Call Send.To.Lod(69,0);                 DTD.Play.State = 0;      //if dsp.running <> 0      //then call send.to.dsp.subroutine(69,0,Scsi.Ptr);   end;   call COPY32(AEE.Shuttle.Anchor.Time,loc(addr(Cur.DTD.MS.Msb))); /* store for take buttons */   if  ((Code = 2)                                  /* see if edit in flag was dragged to */   and  (Disp < (Mins - shr(SB.Hwidth,1))))         /* the retirement home                */   or  ((Code = 3)                                  /* also see if edit out flag was dragged */   and  (Disp > (Maxs + shr(SB.Hwidth,1))))         /* to the chicken ranch                  */   then call COPY32(Oanch,AEE.Shuttle.Anchor.Time); /* keep original anchor time if so       */   /* Reposition fine bar around anchor point (since we lost track of  */   /* where it was for a while) and create a system event to update    */   /* various displays:                                                */   /* Fine wave display is not up; force re-centering of the fine bar   */   if Fine.Shuttle.Wave <> 1   then force = 1;   else force = 0;   call Set.DTD.Fine.Scrub.Bar(AEE.Shuttle.Anchor.Time, force);   new.dtd.info = new.dtd.info \ 512;       /* force a new anchor position event */   if Locked.Item = (-1)                    /* normal operation    */   then call Mouse.Switch(1);               /* turn mouse back on  */   /* see if flag was moved   */   /* deposit new value if so */   if  (Code = 2)                         /* see if edit in flag was dragged to */   and (Disp < (Mins - shr(SB.Hwidth,1))) /* the retirement home                */   then call HANDLE.ANY.NEW.EDIT.IN.TIME(Cue.In.Time, 2, 1);   else if  (Code = 3)                        /* also see if edit out flag was dragged */   and      (Disp > (Maxs + shr(SB.Hwidth,1))) /* to the chicken ranch                  */   then call HANDLE.ANY.NEW.EDIT.OUT.TIME(Cue.Out.Time, 2, 1, 0);   else if COM32(AEE.Shuttle.Anchor.Time,Origtime) <> lw#ieq   then call Process.Drag.Drop(code,AEE.Shuttle.Anchor.Time,info,disp,origtime);end Finish.Flag.Animation;/* $SUBTITLE Routines to toggle between SCAN & SCRUB modes during animate */Force.Animate.To.Point.Mode: proc (fminy,fmaxy,fdisp,fmins,fpixels,origfdisp) fixed swapable;   dcl fminy     fixed;   /* fine bar miny                            */   dcl fmaxy     fixed;   /* fine bar max y                           */   dcl fdisp     fixed;   /* fine bar position of fine line           */   dcl fmins     fixed;   /* mins of fine bar (same as mins?)         */   dcl fpixels   fixed;   /* # of pixels in fine bar                  */   dcl origfdisp fixed;   /* starting fine bar position               */   if Scrub.Scan.Mode <> 0 then do;    /* seg - switch to point    */      call Flag.Coarse.Scroll.Bar(Zero.Zero); /* remove flag       */      Vector_mode;      call Data_Level(2);              call Start.Point.Playback (AEE.Shuttle.Anchor.Time,Mouse(Press.Time));      fdisp = Init.For.Point(AEE.Shuttle.Anchor.Time,fpixels,fmins,fminy,fmaxy,0);      call connect(fdisp,fmaxy-1,fdisp,fminy+1);      Mouse.X = Fdisp;          /* mouse is now at fine bar   */      Scrub.Scan.Mode = 0;   end;   return fdisp;end Force.Animate.To.Point.Mode;Force.Animate.To.Segment.Mode: proc (fminy,fmaxy,fdisp,disp,mins,pixels,origpos,origtime,code) swapable;   dcl fminy     fixed;   /* fine bar miny                            */   dcl fmaxy     fixed;   /* fine bar max y                           */   dcl fdisp     fixed;   /* fine bar position of fine line           */   dcl disp     fixed;    /* holds x pixel position of displayed flag */   dcl mins     fixed;    /* x pixel position of scroll bar 0 %       */   dcl pixels   fixed;    /* # of pixels in bar                       */   dcl origpos  fixed;    /* x pixel position flag itself is at       */   dcl origtime array;    /* precise time that went with flag         */   dcl code     fixed;   dcl dsp.running fixed external;   //dcl send.to.dsp.subroutine proc(fixed,fixed,fixed) external;   if Scrub.Scan.Mode=0 then do; /* point - switch to seg    */      Call Send.To.Lod(69,0);   /* stop point playback      */      DTD.Play.State = 0;       /* state is free            */      //if dsp.running <> 0      //then call send.to.dsp.subroutine(69,0,Scsi.Ptr);      call connect(fdisp,fmaxy-1,fdisp,fminy+1);  /* remove bar   */      Transparent_mode;               call Trigger.Dtd.From.Pix(disp,mins,pixels,origpos,origtime,code);      Vector_mode;              /* for flag    */      Mouse.X = Disp;           /* position mouse at shadow */      Scrub.Scan.Mode = 1;      /* now we are in seg mode   */   end;end Force.Animate.To.Segment.Mode;Handle.FKey.During.Animate: proc (fminy,fmaxy,fdisp,disp,mins,pixels,origpos,origtime,code) fixed swapable;   dcl fminy    fixed;    /* fine bar miny                            */   dcl fmaxy    fixed;    /* fine bar max y                           */   dcl fdisp    fixed;    /* fine bar position of fine line           */   dcl disp     fixed;    /* holds x pixel position of displayed flag */   dcl mins     fixed;    /* x pixel position of scroll bar 0 %       */   dcl pixels   fixed;    /* # of pixels in bar                       */   dcl origpos  fixed;    /* x pixel position flag itself is at       */   dcl origtime array;    /* precise time that went with flag         */   dcl code     fixed;   dcl mode.toggled fixed; /* set if we have to change from point mode to segment mode */   if      next.event.info = ASC.FKEY5 then code = ( 0); /* play from */   else if next.event.info = ASC.FKEY6 then code = (-2); /* stop      */   else if next.event.info = ASC.FKEY7 then code = (-1); /* play to   */   if Scrub.Scan.Mode = 0 then do; /* currently in point mode */      mode.toggled=1;      call Force.Animate.To.Segment.Mode(fminy,fmaxy,                                         fdisp,disp,                                         mins,pixels,                                         origpos,origtime,                                         code);   end;   else do;      Transparent_mode;               call Trigger.Dtd.From.Pix(disp,mins,pixels,origpos,origtime,code);      Vector_mode;      call Data_Level(2);           end;   return mode.toggled;end Handle.FKey.During.Animate;Handle.Arrow.Key.During.Animate: proc swapable; /* simulate x-coordinate movement */   dcl amount fixed;   if next.event.info = R.ARR then do; /* right arrow */      amount = (+1);   end;   else if next.event.info = L.ARR then do; /* left arrow */      amount = (-1);   end;   else if next.event.info = U.ARR then do; /* up arrow */      amount = (+10);   end;   else if next.event.info = D.ARR then do; /* down arrow */      amount = (-10);   end;   disable;      Mouse.X = Mouse.X + amount;      if Mouse.X < 0 then Mouse.X = 0; /* limit range */      Mouse.Real.Milliseconds = Real.Milliseconds;   enable;end Handle.Arrow.Key.During.Animate;/* $page - handle mouse activity in flag area *//* Animate Flag Region is called to animate one of the flag markers *//* in the flag region.  It is passed a long list of arguments (see  *//* below                                                            */Animate.Flag.Region:proc (llim,rlim,mins,maxs,origpos,origtime,miny,maxy,code,info) swapable;   dcl llim     fixed;    /* left pixel limit for animation           */   dcl rlim     fixed;    /* right pixel limit for animation (incl)   */   dcl mins     fixed;    /* x pixel position of scroll bar 0 %       */   dcl maxs     fixed;    /* x pixel position of scroll bar 1000 %    */   dcl origpos  fixed;    /* x pixel position flag itself is at       */   dcl origtime array;    /* precise time that went with flag         */   dcl miny     fixed;    /* miny pos of region (ie top of coarse bar)*/   dcl maxy     fixed;    /* y position of line above flag region     */   dcl code     fixed;    /* 0  = animate cue in  flag                */                          /* 1  = animate cue out flag                */                          /* 2  = animate edit in  flag               */                          /* 3  = animate edit out flag               */                          /* 4  = animate E flag                      */                          /* 5  = not used for dragging               */                          /* 6  = animate edit line (edit in and out) */                          /* 7  = animate cue from cue in             */                          /* 8  = animate cue from cue out            */                          /* 9  = animate edit from edit in           */                          /* 10 = animate edit from edit out          */                          /* 11 = magnifier left                      */                          /* 12 = magnifier right                     */                          /* 13 = magnifer shuttle drag (in)          */                          /* 14 = magnifier shuttle drag (out)        */                          /* 15 = animate coarse bar box              */   dcl info     fixed;    /* segment pointer for E flag animate       */   dcl pixels   fixed;    /* # of pixels in bar                       */   dcl mx       fixed;    /* holds mouse x                            */   dcl my       fixed;    /* holds mouse x                            */   dcl mt       fixed;    /* holds mouse time                         */   dcl (i,j,k,t)fixed;   dcl disp     fixed;    /* holds x pixel position of displayed flag */   dcl (stk) (num.of.get.events) fixed;   dcl (exit)   fixed;   dcl (evt)    fixed;   dcl (xoffs)  fixed;    /* mouse x offset to restore mouse          */   dcl (oanch)(1) fixed;  /* original anchor position                 */   dcl (temp) (1) fixed;   dcl toggled    fixed; /* 1 = mode was toggled by software, should be restored when done */   /* info for fine scroll bar */   dcl fminy     fixed;   /* fine bar miny                            */   dcl fmaxy     fixed;   /* fine bar max y                           */   dcl fminp     fixed;   /* fine bar min x (left of arrow)           */   dcl fmaxp     fixed;   /* fine bar max x (right of arrow)          */   dcl fdisp     fixed;   /* fine bar position of fine line           */   dcl fmins     fixed;   /* mins of fine bar (same as mins?)         */   dcl fmaxs     fixed;   dcl fpixels   fixed;   /* # of pixels in fine bar                  */   dcl prior.mx  fixed;   /* prior location of fine mx                */   dcl origfdisp fixed;   /* starting fine bar position               */   dcl forced.scan.mode fixed; /* 1 if toggled animate mode to do fkey playback */   Mouse.Has.Moved:proc(mx);    /* handy routine to see if mouse has  */      dcl mx fixed;             /* moved from where we think it is    */                                /* Used to speed up audio updates     */      /* process 'mouse' movements from the remote box quickly:       */      do while Protocol.Packet.There <> 0;  /* messages in rotary buffer */         call process.protocol.message;      end;      if  (mx <> Mouse.X)       /* to direct to disk                  */      and (M$Releases = 0)      /* if new pos and no releases         */      then return 1;            /* then can try quick update          */      else return 0;            /* else can not or need not           */   end Mouse.Has.Moved;   /* disallow flag movement when previewing an edit */   /* (but allow coarse bar scrubbing)               */   if (Previewing.Edit<>0) and (code <> 15) then do;      call DISPLAY.NOTICE (NT#TurnOffPreview,ATTR#Normal,NulStr,0,0,0);      return;     end;   /* Start of Flag Region Animation */   if termulator then call Termulator.Relative.Mouse.Report.Format;   if (code >= 0) and (code <=3)   then call Select.Time.Field(code); /* select corresponding time field */   /* compute info to have handy:    */   call COPY32(AEE.Shuttle.Anchor.Time, Oanch); /* save original anchor time            */   pixels = maxs-mins;       /* # of pixels box can traverse           */   mx = Mouse(Press.X);      /* get mouse press x                      */   my = Mouse(Press.Y);      /* get mouse press y                      */   mt = Mouse(Press.Time);   /* time of mouse button press             */   xoffs = Origpos - mx;     /* save original icon x offset to mouse   */   /* look up info for fine bar as well */   call FETCH.OBJECT.INFO(Shuttle.Fine.bar,O#ULX);   fminp = read(mdi);        /* read quickly: O#ULX */   fmaxy = read(mdi);        /*               O#ULY */   fmaxp = read(mdi);        /*               O#LRX */   fminy = read(mdi);        /*               O#LRY */   fmins = fminp + SB.HArrowpix + shr(SB.HWidth,1);   fmaxs = fmaxp - SB.HArrowpix - shr(SB.HWidth,1);   fpixels = fmaxs-fmins;   /* start audio from flag point so user has */   /* a reference.  Start Audio Immediately   */   if (origpos < mins)       /* when picking up scissors from the park   */   or (origpos > maxs)       /* bench,  animate in trigger playback      */   then do;                  /* mode so the user can get where he wants  */      if Scrub.Scan.Mode = 0 then do;   /* if doing point mode, then do             */         Scrub.Scan.Mode    = 1;        /* trigger mode                             */         toggled = 1;      end;   end;   call Load.DTD.Temp.Cue(Current.Cue.Ptr);   if Scrub.Scan.Mode <> 0 then do;     /* trigger segment playback                 */      call Trigger.Dtd.From.Pix(origpos,mins,pixels,origpos,origtime,code);      /* note: above call stored origtime in "anchor" */   end;   else do;                  /* start point playback                     */      call Start.Point.Playback(origtime,mt);      call COPY32(origtime,AEE.Shuttle.Anchor.Time);  /* save in anchor ourselves */      call DEPOSIT.SHUTTLE.TIME.DISPLAY(AEE.Shuttle.Anchor.Time);   end;   /* turn off cross hairs. replace with shadow box */   if Locked.Item = (-1)      /* normal operation          */   then call Mouse.Switch(0); /* Turn off crosshairs       */   VECTOR_MODE;               /* vector                    */   CALL DATA_LEVEL(2);        /* compl                     */   alpha_mode;                /* Set char siz              */   call pc(ESC);    call pc(SCOLON);   disp = origpos;            /* use original flag as first drag flag     */                              /* would need shadow flag here              */   if Scrub.Scan.Mode = 0 then do;       /* draw bar in corresponding position of fine bar */      fdisp     = Init.For.Point(Origtime,fpixels,fmins,fminy,fmaxy,0);      prior.mx  = fdisp;      call connect(fdisp,fmaxy-1,fdisp,fminy+1);      origfdisp = fdisp;      /* save for compare               */   end;   if  ((Code = 2) or (Code = 3))     /* if animating edit in or out flag */   and (Edit.Line.Center.Pix <> 0)    /* and edit line is there           */   then do;                           /* then remove it                   */      call Plot.Flag(Edit.Line.Center.Pix,miny,5,0,0);      Edit.Line.Center.Pix = 0;      Edit.Line.Radius     = 0;   end;   call Plot.Flag(origpos,miny,code,1,origpos); /* add shadow or extension */   /* wait for .1 second here to start animating - be sure the */   /* user wants to move the flag.  do this to avoid losing    */   /* fine edit points.  Just return with new anchor point     */   /* if user is in a hurry                                    */   call Check.Next.Event;   do while  ((Real.Milliseconds - mt) ilt 150)   and       (New.Mouse.Button          =  0  );   	  chill.out.and.run.syn();      Check.Next.Event();   end;   if New.Mouse.Button <> 0 then do;    /* just quit before animating */      call Stop.Flag.Animation(Scrub.Scan.Mode,Fdisp,Fmaxy,Fminy,Disp,                               Code,mins,maxs,miny,mt,                               origpos,origtime,oanch);      if toggled then Scrub.Scan.Mode = Scrub.Scan.Mode xor 1; /* restore original mode on quick click */      if (code >= 0) and (code <=3)      /* make sure time field is     */      then call Select.Time.Field(code); /* still selected when we quit */      if termulator then call Termulator.Absolute.Mouse.Report.Format;      return;   end;   /* User has held the mouse down for .1 second - he must want */   /* to drag the flag somewhere (or else he is bored).         */   /* begin the normal animate process                          */   do i=1 to num.of.get.events;      stk(i) = get.item.enabled(i);      get.item.enabled(i)=0;   end;   call Get_enable(Get.Mouse.Movement);   call Get_enable(Get.Mouse.Button);   call Get_enable(Get.DTD.Info);   call Get_enable(Get.DTD.Scrolling);   call Get_enable(Get.Program.Exit);  /* for PF keys & Function Keys */   call Get_enable(Get.Arrow.Key);   exit = 0;   if Scrub.Scan.Mode <> 0 then do;      disable;                   /* slide mouse x to pixel of flag x to  */      Mouse.X = Mouse.X + xoffs; /* simplify math below.  this basically */      enable;                    /* moves mouse.x to origpos             */   end;   else do;                      /* position mouse over bar we drew      */      disable;                   /* above in fine bar                    */      Mouse.X = Mouse.X + fdisp - mx;      enable;   end;   /* wait right here for either mouse movements or */   /* mouse buttons.   stop animation on button     */   /* activity                                      */   do while exit = 0;         evt = Get.Next.Event;      /* get mouse movement or button */      if evt = Get.DTD.Info      /* dtd info - presumably scroll */      then do;         if Scrub.Scan.Mode = 1 then do;    /* only in trigger mode         */            call Flag.Coarse.Scroll.Bar(loc(addr(cur.DTD.MS.Msb)));            VECTOR_MODE;               /* vector                    */            CALL DATA_LEVEL(2);        /* compl                     */         end;      end;      else if evt = Get.Program.Exit      then do;         if  (Next.Event.Info >= ASC.FKEY5)  /* Play From, Pause */         and (Next.Event.Info <= ASC.FKEY7)  /* or Play To       */         then do;            forced.scan.mode=forced.scan.mode |                             Handle.FKey.During.Animate                                        (fminy,fmaxy,fdisp,disp,mins,                                         pixels,origpos,origtime,code);         end;         else if Next.Event.Info = ASC.FKEY8 then do; /* toggle Scrub/Scan mode */            Next.Event.Info = (-1);     /* simulate press of right button */            call Flush.FKeys.From.D50.Buf; /* get rid of extras */            GOTO NEW.BUTTON;            /* jump to button processing code */         end;         call Flush.FKeys.From.D50.Buf; /* get rid of extras */      end;      else if evt = Get.Mouse.Button  /* mouse button - return it to   */      then do;                        /* get event so we return to     */         NEW.BUTTON:         if Next.Event.Info = 2  /* release of middle button      */         then do;                /* stop animating                */            exit = 1;                           new.mouse.button = next.event.info;         end;         else if (Next.Event.Info = (-1)) /* press of right button    */         or      (Next.Event.Info = (-3)) /* press of left  button    */         then do;                         /* switch playback modes    */            if Scrub.Scan.Mode <> 0 then do;    /* seg - switch to point    */               fdisp = Force.Animate.To.Point.Mode(fminy,fmaxy,                                                   fdisp,fmins,                                                   fpixels,origfdisp);               prior.mx  = fdisp;               if origfdisp = 0 then do; /* save first one for compare */                  origfdisp = fdisp;               end;            end;            else do;                     /* point - switch to seg    */               call Force.Animate.To.Segment.Mode(fminy,fmaxy,                                                  fdisp,disp,                                                  mins,pixels,                                                  origpos,origtime,                                                  code);            end;            toggled = 0;                 /* user set mode            */            forced.scan.mode = 0;        /* override special mode    */         end;      end;      else if evt = Get.Arrow.Key     /* arrow keys - map to mouse movements */      then do;         call Handle.Arrow.Key.During.Animate; /* simulate mouse movement */         call Flush.Arrow.Keys.From.D50.Buf;   /* get rid of extras */         GOTO NEW.MOVEMENT;      /* jump into mouse movement code below */      end;      else if evt = Get.Mouse.Movement then do; /* process movements */         NEW.MOVEMENT:         if  (forced.scan.mode <> 0)         and (disp <> mouse.x)         then do;            forced.scan.mode = 0; /* reset flag */            fdisp = Force.Animate.To.Point.Mode(fminy,fmaxy,                                                fdisp,fmins,                                                fpixels,origfdisp);            prior.mx  = fdisp;            if origfdisp = 0 then do; /* save first one for compare */               origfdisp = fdisp;            end;         end;         if Scrub.Scan.Mode <> 0 then do;   /* segment playback movement     */            disable;            mx = Mouse.X;                 /* get current mouse x   */            if mx < llim then mx = llim;  /* note: could be moving */            if mx > rlim then mx = rlim;  /* out of sbar region    */            Mouse.X = mx;                 /* limit mouse to region */            enable;               if mx <> disp then do;        /* change in position    */               call Plot.Flag(disp,miny,code,0,origpos);               disp = mx;               call Plot.Flag(disp,miny,code,0,origpos);               Transparent_mode;                        call TAKE.CURRENT.SHUTTLE.TIME (temp);               call Trigger.Dtd.From.Pix(mx,mins,pixels,origpos,origtime,code);               call Flag.Coarse.Scroll.Bar(temp);/* show where audio actually is */               Vector_mode;               call Data_Level(2);                    end;                                               /* flag        */         end;         else do;                         /* point mode           */            get.next.movement:;           /* re-enter from below  */            disable;            mx = Mouse.X;                 /* get current mouse x  */            t  = Mouse.Real.Milliseconds; /* and time of that pos */            enable;            /* provide smart limits on */            /* fine bar scrolling in   */            /* this mode               */            do while mx > fmaxs;               call Play.Point.From.Percent(1000,Fine.Bar.Play.code,t,AEE.Shuttle.Anchor.Time);               prior.mx = fmaxs;               mx = Init.For.Point(AEE.Shuttle.Anchor.Time,fpixels,fmins,fminy,fmaxy,1)                    + (mx - prior.mx);               Mouse.X  = mx;             /* move mouse there        */            end;            /* detect infinite loop here trying to scroll to         */            /* before time 0.000 of direct-to-disk.   Make sure      */            /* init.for.point actually moves the fine scroll bar     */            do while mx < fmins;               call Play.Point.From.Percent(0,Fine.Bar.Play.code,t,AEE.Shuttle.Anchor.Time);               prior.mx = fmins;               call COPY32(AEE.Fine.In.Time,temp);  /* save current fine bar in time */               mx = Init.For.Point(AEE.Shuttle.Anchor.Time,fpixels,fmins,fminy,fmaxy,1)                    + (mx - prior.mx);               if  (mx < fmins)                             /* if mx is still to left */               and (COM32(AEE.Fine.In.Time, temp) = lw#ieq) /* because fine bar could not move ...*/               then mx = fmins;                             /* then limit mouse to 0.000  */               Mouse.X  = mx;             /* move mouse there        */            end;            load  (mx-fmins);             /* get new pix position  */            uload shr(fpixels,1);         /* round up              */            mul   1000;                   /* compute percentage    */            mwait;                        /* that goes with this   */            div   fpixels;            i = res;  /* result is 0-1000 percent */            call Play.Point.From.Percent(i,Fine.Bar.Play.code,t,AEE.Shuttle.Anchor.Time);            prior.mx  = mx;            /* wait for d50 output buffer to empty before doing */            /* any plotting                                     */            do while num.of.d50.out.chars <> 0;               if Mouse.Has.Moved(mx) then goto Get.Next.Movement;			   chill.out.and.run.syn();            end;            if mx <> fdisp then do;       /* change in position    */               if fdisp <> 0 then do;                  run.syn = 0;               /* provide speedy ness   */                  call connect(fdisp,fmaxy-1,fdisp,fminy+1);  /* remove bar   */                  run.syn = 1;                  fdisp = 0;                  /* wait for above connect characters to go out */                  do while num.of.d50.out.chars <> 0;                     if Mouse.Has.Moved(mx) then goto Get.Next.Movement;			   		 chill.out.and.run.syn();                  end;               end;               fdisp = mx;               run.syn = 0;               /* provide speedy ness   */               call connect(fdisp,fmaxy-1,fdisp,fminy+1);  /* draw new one */               run.syn = 1;            end;            i = Compute.New.Disp(AEE.Shuttle.Anchor.Time,pixels,mins);            if i <> disp then do;     /* move shadow box          */               if Disp <> 0 then do;                  run.syn = 0;                  call Plot.Flag(disp,miny,code,0,origpos);                  run.syn = 1;                  Disp = 0;                  /* wait for above connect characters to go out */                  do while num.of.d50.out.chars <> 0;                     if Mouse.Has.Moved(mx) then goto Get.Next.Movement;					 chill.out.and.run.syn();                  end;               end;               disp = i;               run.syn = 0;               call Plot.Flag(disp,miny,code,0,origpos);               run.syn = 1;            end;         end;                          /* of scrub mode */      end;                             /* process mouse movement */      else if 0 then do;  /* some other event?? */         Transparent_mode;                  call cpos(23,0); call erase.to.end.of.line;         call ps('Evt: '); call pnum(evt,0);         call ps('   Info: '); call pnum(next.event.info,0);         call pc(7);         Vector_mode;         call Data_Level(2);              end;   end;                                /* of do while exit=0     */   call Finish.Flag.Animation (Scrub.Scan.Mode,Fdisp,Fmaxy,Fminy,Disp,                               Code,Miny,Origpos,Origtime,                               Mins,Maxs,Xoffs,My,Stk,Info,Oanch);   if (toggled) or (forced.scan.mode)   then Scrub.Scan.Mode = Scrub.Scan.Mode xor 1; /* restore original mode */   if (code >= 0) and (code <=3)      /* make sure time field is     */   then call Select.Time.Field(code); /* still selected when we quit */   if termulator then call Termulator.Absolute.Mouse.Report.Format;end Animate.Flag.Region;