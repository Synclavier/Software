/* AUD-CU11 $title  routines to animate flag area *//* Modifications:   05/31/88 - TSS - Broke up HANDLE.FLAG.AREA.MOUSE.SELECT to shrink swap area   05/20/88 - TSS - Added argument to Handle.Flag.Area.Mouse.Select routine   05/20/88 - TSS - Split AUD-SH4 file into two pieces (AUD-SH4, AUD-SH5)*//* Trigger audio from flag region if not animating *//* Play.Flag.Region is called when the user clicks the mouse in the *//* flag region,  but did not click on an existing flag.             *//* The audio is triggered as follows                                *//*        if Click is to left of cue  in  flag - play entire cue      *//*   else if Click is to left of edit in  flag - play cue in to ed in *//*   else if Click is to left of edit out flag - play edit region     *//*   else if Click is to left of cue  out flag - play from edit out   *//*   else play from cue out                                           */Play.Flag.Region:proc (mx) swapable;   dcl mx      fixed;      /* pass mouse x position */   /* unknown results if flags are missing */   call Load.DTD.Temp.Cue(Current.Cue.Ptr);   if      mx < Coarse.Bar.In.Flag   then call Play.Current.Cue(1,0,0,Shuttle.Drive.Bits,1); /* play cue in to cue out */   else if (Coarse.Bar.Ein.Flag > Coarse.Bar.In.Flag )   and     (mx                  < Coarse.Bar.Ein.Flag)   then call Play.Current.Cue(1,0,5,Shuttle.Drive.Bits,1); /* play cue in to edit in */   else if ((Coarse.Bar.Eout.Flag < Coarse.Bar.Out.Flag )   /* if eout flag exists         */   and      (mx                   < Coarse.Bar.Eout.Flag))  /* and we clicked before it    */   or      ((Coarse.Bar.Eout.Flag > Coarse.Bar.Out.Flag )   /* or edit out flag is parked  */   and      (mx                   < Coarse.Bar.Out.Flag ))  /* and we clicked before the cue out flag */   then call Play.Current.Cue(2,0,1,Shuttle.Drive.Bits,1); /* play edit in to edit out       */   else if mx < Coarse.Bar.Out.Flag   then call Play.Current.Cue(8,0,0,Shuttle.Drive.Bits,1); /* play edit out to cue out */   else call Play.Current.Cue(7,0,2,Shuttle.Drive.Bits,1); /* play cue out to end of sbar */   call Set.Group.Get(Shuttle.Group,Get.Mouse.Button,true);end Play.Flag.Region;/* $subtitle */Handle.Left.Magnifier.Mouse.Select: proc(code,mx,my,miny,maxy,mins,maxs,minfx) fixed swapable;   dcl code        fixed;   dcl (mx,my)     fixed;   dcl (miny,maxy) fixed;   dcl (mins,maxs) fixed;   dcl minfx       fixed;   /* see if in drag entire shuttle box */   if  (code = 13)   or  ((code = (-1))   and  (my >= (miny + Magnifier.Box.Min.Y))   and  (my <= (miny + Magnifier.Box.Max.Y))   and  (mx >= (minfx + Magnifier.Park.X - Magnifier.Box.Min.X))   and  (mx <= (minfx + Magnifier.Park.X + Magnifier.Box.Max.X)))   then do;      call Animate.Flag.Region(minfx+Magnifier.Park.X, /* animate magnifer all the way */                               maxs,                               mins,maxs,                                        minfx+Magnifier.Park.X,                               AEE.Shuttle.In.Time,                               miny,maxy,13,0);      return 1;   end;   if  (code = 11)   or  ((code = (-1))   and  (my >= (miny + Magnifier.Min.Y))   and  (my <= (miny + Magnifier.Max.Y)))   then do;      call Animate.Flag.Region(minfx+Magnifier.Park.X, /* animate magnifer all the way */                               maxs,                               mins,maxs,                                        minfx+Magnifier.Park.X,                               AEE.Shuttle.In.Time,                               miny,maxy,11,0);      return 1;   end;   return 0;end Handle.Left.Magnifier.Mouse.Select;Handle.Right.Magnifier.Mouse.Select: proc(code,mx,my,miny,maxy,mins,maxs,maxfx) fixed swapable;   dcl code        fixed;   dcl (mx,my)     fixed;   dcl (miny,maxy) fixed;   dcl (mins,maxs) fixed;   dcl maxfx       fixed;   /* see if in drag entire shuttle box */   if  (code = 14)   or  ((code = (-1))   and  (my >= (miny + Magnifier.Box.Min.Y))   and  (my <= (miny + Magnifier.Box.Max.Y))   and  (mx >= (maxfx - Magnifier.Park.X - Magnifier.Box.Max.X))   and  (mx <= (maxfx - Magnifier.Park.X + Magnifier.Box.Min.X)))   then do;      call Animate.Flag.Region(mins,                               maxfx-Magnifier.Park.X,                               mins,maxs,                                        maxfx-Magnifier.Park.X,                               AEE.Shuttle.Out.Time,                               miny,maxy,14,0);      return 1;   end;   if  (code = 12)   or  ((code = (-1))   and  (my >= (miny + Magnifier.Min.Y))   and  (my <= (miny + Magnifier.Max.Y)))   then do;      call Animate.Flag.Region(mins,                               maxfx-Magnifier.Park.X,                               mins,maxs,                                        maxfx-Magnifier.Park.X,                               AEE.Shuttle.Out.Time,                               miny,maxy,12,0);      return 1;   end;   return 0;end Handle.Right.Magnifier.Mouse.Select;/* $page - process mouse clicks in flag area *//* this routine is called when the mouse is pressed within the *//* flag area                                                   *//* We first see if the mouse was clicked on one of the drawn   *//* flags (Cue In, Cue Out, Edit In, Edit Out, an E flag)       *//* If so, then that flag is animated,  with accompanying audio *//* If the mouse was not clicked on a flag,  then a general     *//* segment play routine is called to play the appropriate      *//* segment of the cue                                          */Handle.Flag.Area.Mouse.Select:proc (code) swapable;   dcl (code)           fixed; /* -1 means do nothing, otherwise codes     */                               /* match argument to Animate.Flag.Region:   */                               /* 0  = animate cue in  flag                */                               /* 1  = animate cue out flag                */                               /* 2  = animate edit in  flag               */                               /* 3  = animate edit out flag               */                               /* 4  = animate E flag (not supported)      */                               /* 5  = not used                            */                               /* 6  = animate edit line (edit in and out) (not supported) */                               /* 7  = animate cue from cue in             */                               /* 8  = animate cue from cue out            */                               /* 9  = animate edit from edit in           */                               /* 10 = animate edit from edit out          */                               /* 11 = magnifier left                      */                               /* 12 = magnifier right                     */                               /* 13 = magnifer shuttle drag (in)          */                               /* 14 = magnifier shuttle drag (out)        */                               /* 15 = animate coarse bar box              */   dcl (mx,my)          fixed; /* x & y coordinates where select occurred */   dcl (i,j,k,l,m)      fixed;   dcl (miny,maxy)      fixed;   dcl (minp,maxp)      fixed;   dcl (mins,maxs)      fixed;   dcl (minfx,maxfx)    fixed;   dcl (temp)  (1)      fixed;   dcl (itemp) (1)      fixed;   dcl (otemp) (1)      fixed;   dcl (base)           fixed;   dcl (len)            fixed;   if code = (-1) then do;     /* if not simulating press */      mx = Mouse(Press.X);     /* get actual press coords */      my = Mouse(Press.Y);   end;   /* note: miny for flag region is presumably equal to maxy */   /* of shuttle.   In other words, y position miny + 1 is   */   /* the first pixel above the coarse bar                   */   call FETCH.OBJECT.INFO(Shuttle.Flag.Region,O#ULX);   minfx = read(mdi);    /* read quickly: O#ULX */   maxy  = read(mdi);    /*               O#ULY */   maxfx = read(mdi);    /*               O#LRX */   miny  = read(mdi);    /*               O#LRY */   /* Use coarse bar x and y positions for animating */   minp = FETCH.OBJECT.INFO(Shuttle.Coarse.Bar, O#ULX);   maxp = FETCH.OBJECT.INFO(Shuttle.Coarse.Bar, O#LRX);   mins = minp + SB.HArrowpix + shr(SB.HWidth,1);  /* min/max position for */   maxs = maxp - SB.HArrowpix - shr(SB.HWidth,1);  /* center of sbar box   */   /* See if user clicked on a flag */   /* When checking the flags,  check for the smallest flag first.  That */   /* way user can drag things better when they are all on top of one    */   /* another                                                            */   /* Check for drag of entire cue with small box */   if ((code = 7)   or  (code = 8)   or  ((code = (-1))   and  (my >= (miny + In.Out.Box.Min.Y))   and  (my <= (miny + In.Out.Box.Max.Y))))   and (Coarse.Bar.In.Flag  <> 0)     /* must have both flags for */   and (Coarse.Bar.Out.Flag <> 0)     /* length measurement       */   then do;      if  (code = 7)      or  ((code = (-1))      and  (mx >= ( Coarse.Bar.In.Flag  - In.Out.Box.Min.X))      and  (mx <= ( Coarse.Bar.In.Flag  + In.Out.Box.Max.X))      and ((mx >  (Coarse.Bar.Out.Flag + In.Out.Box.Min.X))      or   (mx <  (Coarse.Bar.Out.Flag - In.Out.Box.Max.X))))      then do;         call Animate.Flag.Region(mins,       /* animate in/out flags */                                  maxs,       /* over allowable sbox  */                                  mins,maxs,  /* ranges only          */                                  Coarse.Bar.In.Flag,                                  Cue.In.Time,                                  miny,maxy,7,0);         return;      end;      else if (code = 8)      or  ((code = (-1))      and  (mx >= (Coarse.Bar.Out.Flag  - In.Out.Box.Max.X))      and  (mx <= (Coarse.Bar.Out.Flag  + In.Out.Box.Min.X))      and  ((mx >  (Coarse.Bar.In.Flag  + In.Out.Box.Max.X))      or    (mx <  (Coarse.Bar.In.Flag  - In.Out.Box.Min.X))))      then do;         call Animate.Flag.Region(mins,   /* animate over valid sbox */                                  maxs,   /* region only             */                                  mins,maxs,                                  Coarse.Bar.Out.Flag,                                  Cue.Out.Time,                                  miny,maxy,8,0);         return;      end;   end;   /* check drag of edit region with small box below scisors */   if ((code = 9)   or  (code = 10)   or  ((code = (-1))   and  (my >= (miny + Edit.Box.Min.Y))   and  (my <= (miny + Edit.Box.Max.Y))))   and (Coarse.Bar.EIn.Flag  >=mins  ) /* must have both flags for */   and (Coarse.Bar.EOut.Flag <> 0    ) /* length measurement       */   and (Coarse.Bar.EOut.Flag <=maxs  ) /* and can not be parked    */   then do;      if  (code = 9)      or  ((code = (-1))      and  (mx >= (Coarse.Bar.Ein.Flag  - Edit.Box.Min.X))      and  (mx <= (Coarse.Bar.Ein.Flag  + Edit.Box.Max.X))      and  ((mx < (Coarse.Bar.Eout.Flag - Edit.Box.Max.X))      or    (mx > (Coarse.Bar.Eout.Flag + Edit.Box.Min.X))))      then do;         call Animate.Flag.Region(minp+Edit.In.Out.Idle, /* animate scissors all the way */                                  maxp-Edit.In.Out.Idle, /* to the parking garage        */                                  mins,maxs,                                           Coarse.Bar.Ein.Flag,                                  Cue.Edit.In.Time,                                  miny,maxy,9,0);         return;      end;      else if (code = 10)      or  ((code = (-1))      and  ( mx >= (Coarse.Bar.Eout.Flag - Edit.Box.Max.X ))      and  ( mx <= (Coarse.Bar.Eout.Flag + Edit.Box.Min.X ))      and  ((mx >  (Coarse.Bar.Ein.Flag  + Edit.Box.Max.X))      or    (mx <  (Coarse.Bar.Ein.Flag  - Edit.Box.Min.X))))      then do;         call Animate.Flag.Region(minp+Edit.In.Out.Idle, /* animate scissors all the way */                                  maxp-Edit.In.Out.Idle, /* to the unemployment office   */                                  mins,maxs,                                  Coarse.Bar.Eout.Flag,                                  Cue.Edit.Out.Time,                                  miny,maxy,10,0);         return;      end;   end;   /* Check for drag of edit line */   if  (code = (-1))   and (my >= (miny + Edit.Line.Min.Y))   and (my <= (miny + Edit.Line.Max.Y))   then do;      if  (mx >= (Edit.Line.Center.Pix  - Edit.Line.Min.X))      and (mx <= (Edit.Line.Center.Pix  + Edit.Line.Max.X))      then do;         /* Compute time of center pix */         /* must be done accurately to */         /* avoid rounding problems    */         load  (Edit.Line.Center.Pix-mins);    /* get # of pixels from start to us */         uload shr(maxs-mins,1); /* perform rounding                 */         mul   1000;             /* compute percent, 0 - 1000%       */         mwait;         div   (maxs-mins);         call Compute.Time.From.Percent         (res,AEE.Shuttle.In.Time,AEE.Shuttle.Out.Time,temp);         call Animate.Flag.Region(mins,         /* animate edit line    */                                  maxs,         /* over allowable sbox  */                                  mins,maxs,    /* ranges only          */                                  Edit.Line.Center.Pix,                                  temp,                                  miny,maxy,6,0);         return;      end;   end;   /* check E flag region: */   if  (code = (-1))   and (my >= (miny + Edit.Min.Y))   and (my <= (miny + Edit.Max.Y))   then do;      i = mx;                 /* get pixel # with respect to bit map */      if i ILT (#bmwrds*16)   /* if desired position is in bit map   */      then do;                /* then see if there is a flag there   */         /* search backwards for an 'E' flag that extends on */         /* to this pixel.   The first one we fine (scanning */         /* backwards) is the one we should animate          */         /* compute limit of how far we should scan to:      */         j = i - (Edit.Max.X-1);         if j<0 then j = 0;         load i; div 16;             /* compute word, bit         */         write(mam) = Cue.Flag.Ptr;  /* and then index to word    */         write(mal) = shl(res,1)+1;  /* check old word            */         do while (i >= j)         and      ((read(md)&bits(rem))=0);            i = i - 1;                /* back up 1 pixel if bit   */            load i; div 16;           /* is not set.  compute new */            write(mam) = Cue.Flag.Ptr;/* word and bit position.   */            write(mal) = shl(res,1)+1;         end;         if i >= j then do;         /* edit flag was found to animate */            /* look through current cue to find segment that goes */            /* with this flag.  we may not find once since the    */            /* edit flags on the screen may not be up to date yet */            write(mam) = Current.Cue.Ptr;            write(mal) = Cue.List.Ptr;            base       = read(md);            write(mal) = Cue.List.Len;            len        = read(md);            if base <> 0 then do;         /* check for empty cue now */               k = base;                  /* search for pixel match  */               write(mam) = Current.Cue.Ptr + shr(k+S#SPixelPointer,8);               write(mal) = (k+S#SPixelPointer);               l = read(mdi);               /* S#SpixelPointer */               m = read(mdi);               /* S#EpixelPointer */               do while  (k ilt base+len-1)  /* search segment list  */               and       (l <> i)            /* for spixel match     */               and       (m <> i);           /* for epixel match     */                  k = k + Cue.Seg.Stride;                  write(mam) = Current.Cue.Ptr + shr(k+S#SPixelPointer,8);                  write(mal) = (k+S#SPixelPointer);                  l = read(mdi);               /* S#SpixelPointer */                  m = read(mdi);               /* S#EpixelPointer */               end;               if k ilt (base+len-1)         /* if we found a match  */               then do;                      /* then animate it      */                  write(mam) = Current.Cue.Ptr + shr(k+S#Sync.Msb,8);                  write(mal) = (k+S#Sync.Msb);                  temp(0) = read(mdi);          /* get sync time of segment */                  temp(1) = read(mdi);                  if l <> i then do;            /* if e flag was not for seg start, then compute seg end */                     itemp(0) = read(mdi);      /* S#In.Msb */                     itemp(1) = read(mdi);      /* S#In.Lsb */                     otemp(0) = read(mdi);      /* S#Out.Msb */                     otemp(1) = read(mdi);      /* S#Out.Lsb */                     call SUB32(Otemp, Itemp, Itemp);                     call ADD32(Temp,  Itemp, Temp );                  end;                  call DTD.Sample.#.To.Msecs(Temp, CF#Time, S$Speed, AEE.Current.Project.Rate, Zero.Zero, Temp);                  /* time would be within shuttle if flag is shown (unless we are */                  /* in the middle of a flag update).  Time is presumabely within */                  /* scroll bar area                                              */                  call Animate.Flag.Region(mins,       /* animate from min sbar */                                           maxs,       /* box pos to max pos    */                                           mins,maxs,  /* pass sbar range       */                                           i,          /* starting pixel #      */                                           temp,       /* time                  */                                           miny,maxy,4,i); /* other info        */                  return;               end;            end;         end;      end;   end;   /* check In.Out flag region: */   if  (code = 0)   or  (code = 1)   or  ((code = (-1))   and  (my >= (miny + In.Out.Min.Y))   and  (my <= (miny + In.Out.Max.Y)))   then do;      if  (code = 0)      or  ((code = (-1))      and (mx >= ( Coarse.Bar.In.Flag  - In.Out.Min.X))      and (mx <= ( Coarse.Bar.In.Flag  + In.Out.Max.X))      and ((Coarse.Bar.Out.Flag = 0)      or   (mx >  (Coarse.Bar.Out.Flag + In.Out.Min.X))      or   (mx <  (Coarse.Bar.Out.Flag - In.Out.Max.X))))      then do;         call Animate.Flag.Region(mins,       /* animate in/out flags */                                  maxs,       /* over allowable sbox  */                                  mins,maxs,  /* ranges only          */                                  Coarse.Bar.In.Flag,                                  Cue.In.Time,                                  miny,maxy,0,0);         return;      end;      else if (code = 1)      or      ((code = (-1))      and      (mx >= (Coarse.Bar.Out.Flag  - In.Out.Max.X))      and      (mx <= (Coarse.Bar.Out.Flag  + In.Out.Min.X))      and      ((mx >  (Coarse.Bar.In.Flag  + In.Out.Max.X))      or        (mx <  (Coarse.Bar.In.Flag  - In.Out.Min.X))))      then do;         call Animate.Flag.Region(mins,   /* animate over valid sbox */                                  maxs,   /* region only             */                                  mins,maxs,                                  Coarse.Bar.Out.Flag,                                  Cue.Out.Time,                                  miny,maxy,1,0);         return;      end;   end;   /* check for press on Edit.In.Flag or Edit.Out.Flag */   if  (code = 2)   or  (code = 3)   or  ((code = (-1))   and  (my >= (miny + Edit.In.Out.Min.Y))   and  (my <= (miny + Edit.In.Out.Max.Y)))   then do;      if  (code = 2)      or  ((code = (-1))      and  (mx >= (Coarse.Bar.Ein.Flag  - Edit.In.Out.Min.X))      and  (mx <= (Coarse.Bar.Ein.Flag  + Edit.In.Out.Max.X))      and  ((Coarse.Bar.Eout.Flag = 0)      or    (mx < (Coarse.Bar.Eout.Flag - Edit.In.Out.Max.X))      or    (mx > (Coarse.Bar.Eout.Flag + Edit.In.Out.Min.X))))      then do;         if code = (-1) then do;            /* if in the middle of a SLIDE edit,          */            /* treat scissors as small box below scissors */            if Pending.Edit = 10 then code = 9;            else                      code = 2;         end;         call Animate.Flag.Region(minp+Edit.In.Out.Idle, /* animate scissors all the way */                                  maxp-Edit.In.Out.Idle, /* to the parking garage        */                                  mins,maxs,                                           Coarse.Bar.Ein.Flag,                                  Cue.Edit.In.Time,                                  miny,maxy,code,0);         return;      end;      else if (code = 3)      or      ((code = (-1))      and      ( mx >= (Coarse.Bar.Eout.Flag - Edit.In.Out.Max.X ))      and      ( mx <= (Coarse.Bar.Eout.Flag + Edit.In.Out.Min.X ))      and      ((mx >  (Coarse.Bar.Ein.Flag  + Edit.In.Out.Max.X))      or        (mx <  (Coarse.Bar.Ein.Flag  - Edit.In.Out.Min.X))))      then do;         if code = (-1) then do;            /* if in the middle of a SLIDE edit,          */            /* treat scissors as small box below scissors */            if Pending.Edit = 10 then code = 10;            else                      code = 3;         end;         call Animate.Flag.Region(minp+Edit.In.Out.Idle, /* animate scissors all the way */                                  maxp-Edit.In.Out.Idle, /* to the unemployment office   */                                  mins,maxs,                                  Coarse.Bar.Eout.Flag,                                  Cue.Edit.Out.Time,                                  miny,maxy,code,0);         return;      end;   end;   /* Check for mouse activity in magnifier area */   if  (code = 13)   or  (code = 11)   or  ((code = (-1)) and (mx < minp))  /* then is in left magnifier */   then do;      if Handle.Left.Magnifier.Mouse.Select             (code,mx,my,miny,maxy,mins,maxs,minfx)<>0 then return;   end;   if  (code = 12)   or  (code = 14)   or  (code = (-1) and (mx > maxp)) /* if to right of shuttle max x */   then do;                          /* then must be rite magnifier  */      if Handle.Right.Magnifier.Mouse.Select             (code,mx,my,miny,maxy,mins,maxs,maxfx)<>0 then return;   end;   if code = (-1) then do;      /* user did not click on a flag */      /* perform the playback         */      call Play.Flag.Region(mx);   end;end Handle.Flag.Area.Mouse.Select;/* $page - handle coarse bar animation *//* this routine is called when the mouse is pressed in the *//* coarse bar.  it performs the animation of the coarse    *//* bar                                                     */Animate.Coarse.Bar:proc (percentage) swapable;   dcl percentage       fixed;  /* pass percentage (0-1000) where mouse was clicked */   dcl (miny,maxy)      fixed;   dcl (minp,maxp)      fixed;   dcl (mins,maxs)      fixed;   dcl (pos)            fixed;   dcl (i)              fixed;   dcl (time)      (1)  fixed;   pos = Fetch.Scroll.Bar(Shuttle.Coarse.Bar);   miny = FETCH.OBJECT.INFO(Shuttle.Flag.Region,O#LRY);   maxy = FETCH.OBJECT.INFO(Shuttle.Flag.Region,O#ULY);   /* Use coarse bar x and y positions for animating */   minp = FETCH.OBJECT.INFO(Shuttle.Coarse.Bar, O#ULX);   maxp = FETCH.OBJECT.INFO(Shuttle.Coarse.Bar, O#LRX);   mins = minp + SB.HArrowpix + shr(SB.HWidth,1);  /* min/max position for */   maxs = maxp - SB.HArrowpix - shr(SB.HWidth,1);  /* center of sbar box   */   i = Mouse(Press.X);         /* presumably pixel position i */                               /* matches passed percentage   */   if i<mins then i = mins;   if i>maxs then i = maxs;   call Compute.Time.From.Percent        (Percentage, AEE.Shuttle.In.Time, AEE.Shuttle.Out.Time, time);   call Animate.Flag.Region(mins,       /* animate box          */                            maxs,       /* over allowable sbox  */                            mins,maxs,  /* ranges only          */                            i,                            time,                            miny,maxy,15,0);end Animate.Coarse.Bar;/* $page - handle select of scisors park area */Handle.Left.Scsisors.Park.Select:proc swapable;   dcl (miny,maxy)      fixed;   dcl (minp,maxp)      fixed;   dcl (mins,maxs)      fixed;   miny = FETCH.OBJECT.INFO(Shuttle.Flag.Region,O#LRY);   maxy = FETCH.OBJECT.INFO(Shuttle.Flag.Region,O#ULY);   /* Use coarse bar x and y positions for animating */   minp = FETCH.OBJECT.INFO(Shuttle.Coarse.Bar, O#ULX);   maxp = FETCH.OBJECT.INFO(Shuttle.Coarse.Bar, O#LRX);   mins = minp + SB.HArrowpix + shr(SB.HWidth,1);  /* min/max position for */   maxs = maxp - SB.HArrowpix - shr(SB.HWidth,1);  /* center of sbar box   */      /* if scisors are not in the box, bring them there */   if Coarse.Bar.Ein.Flag <> (minp + Edit.In.Out.Idle)   then do;      if (abs(Mouse(Button.Result)) = 2)  /* middle button */      or (abs(Mouse(Button.Result)) = 3)  /* left   button */      then do;         /* set edit in time to cue in time */         call HANDLE.ANY.NEW.EDIT.IN.TIME(Cue.In.Time, 3, 1);         VECTOR_MODE;               /* vector                    */         CALL DATA_LEVEL(2);        /* compl                     */         if Coarse.Bar.EIn.Flag <> 0    /* erase old flag if there    */         then do;                       /* was one                    */            call Plot.Flag(Coarse.Bar.EIn.Flag,miny,2,0,0);         end;         Coarse.Bar.EIn.Flag = minp + Edit.In.Out.Idle;  /* draw the new edit in flag  */         call Plot.Flag(Coarse.Bar.EIn.Flag,miny,2,0,0);         CALL DATA_LEVEL(0);           /* back to transp mode */         TRANSPARENT_MODE;         /* and drop into animate routine below */      end;   end;   /* if scisors are in the box, send them out */   if Coarse.Bar.Ein.Flag = minp + Edit.In.Out.Idle   then do;      if abs(Mouse(Button.Result)) = 1  /* rite button   */      then do;                          /* copy anchor   */         call HANDLE.ANY.NEW.EDIT.IN.TIME(AEE.Shuttle.Anchor.Time, 3 , 1);      end;      else if abs(Mouse(Button.Result)) = 2  /* middle button */      then do;         call Animate.Flag.Region(minp+Edit.In.Out.Idle, /* animate scissors all the way */                                  maxp-Edit.In.Out.Idle, /* to the parking garage        */                                  mins,maxs,                                           Coarse.Bar.Ein.Flag,                                  Cue.Edit.In.Time,                                  miny,maxy,2,0);      end;   end;   call Select.New.Cur.Obj(Corner.Label,-1,-1);end Handle.Left.Scsisors.Park.Select;Handle.Right.Scsisors.Park.Select:proc swapable;   dcl (miny,maxy)      fixed;   dcl (minp,maxp)      fixed;   dcl (mins,maxs)      fixed;   miny = FETCH.OBJECT.INFO(Shuttle.Flag.Region,O#LRY);   maxy = FETCH.OBJECT.INFO(Shuttle.Flag.Region,O#ULY);   /* Use coarse bar x and y positions for animating */   minp = FETCH.OBJECT.INFO(Shuttle.Coarse.Bar, O#ULX);   maxp = FETCH.OBJECT.INFO(Shuttle.Coarse.Bar, O#LRX);   mins = minp + SB.HArrowpix + shr(SB.HWidth,1);  /* min/max position for */   maxs = maxp - SB.HArrowpix - shr(SB.HWidth,1);  /* center of sbar box   */   /* if scisors are not in the box, bring them there */   if Coarse.Bar.Eout.Flag <> (maxp - Edit.In.Out.Idle)   then do;      if (abs(Mouse(Button.Result)) = 1)  /* right  button */      or (abs(Mouse(Button.Result)) = 2)  /* middle button */      then do;         /* move flag to box, then animate */         call HANDLE.ANY.NEW.EDIT.OUT.TIME(Cue.Out.Time, 3, 1, 0);         VECTOR_MODE;               /* vector                    */         CALL DATA_LEVEL(2);        /* compl                     */         if Coarse.Bar.EOut.Flag <> 0 /* erase the old flag if there      */         then do;                     /* was one                          */            call Plot.Flag(Coarse.Bar.EOut.Flag,miny,3,0,0);         end;         Coarse.Bar.EOut.Flag = maxp - Edit.In.Out.Idle;         call Plot.Flag(Coarse.Bar.EOut.Flag,miny,3,0,0);         CALL DATA_LEVEL(0);           /* back to transp mode */         TRANSPARENT_MODE;         /* fall into animate procedure call below */      end;   end;   /* if scisors are in the box, send them out */   if Coarse.Bar.Eout.Flag = maxp - Edit.In.Out.Idle   then do;      if abs(Mouse(Button.Result)) = 3  /* left button   */      then do;                          /* copy anchor   */         call HANDLE.ANY.NEW.EDIT.OUT.TIME(AEE.Shuttle.Anchor.Time, 3, 1, 0);      end;      else if abs(Mouse(Button.Result)) = 2  /* middle button */      then do;         call Animate.Flag.Region(minp+Edit.In.Out.Idle, /* animate scissors all the way */                                  maxp-Edit.In.Out.Idle, /* to the unemployment office   */                                  mins,maxs,                                  Coarse.Bar.Eout.Flag,                                  Cue.Edit.Out.Time,                                  miny,maxy,3,0);      end;   end;   call Select.New.Cur.Obj(Corner.Label,-1,-1);end Handle.Right.Scsisors.Park.Select;