/*	:SYNSOU:AUDMOD:AUD-SEQ1 - Define, Open & close panel, update panel	*//*Modified:1998/05/16 - TY  - Substituted calls to SCALE.RTE.VAL passing 0, to calls to SCALE.RTE.TO.PERCENT.1998/04/21 - TY  - Rewrote the scaling algorithm in the pitchbend block of GET.RTE.INFO						 to have the following rounding characteristics:						 1) a value at the halfway point will round up.						 2) for negative values, "rounding up" means more negative.					  - Removed imbedded SCALE RTE.VAL from ENABLE.AND.DEPOSIT.ALL.CELLS and						 GET.RTE.INFO so that the improved version in SEQSOU will be used						 (also to eliminate unnecessary duplication).1991/05/17 - PF  - changed MIDI program numbers from 1-128 to 0-1271990/11/06 - PF  - Added screen support for new sustain update record1990/11/06 - PF  - Split this file in half - AUDSEQ1A1990/08/27 - PF  - Support all MIDI controllers1989/10/02 - cj  - mapped to sequence time for Seq.Refresh.Time1989/06/14 - cj  - changed 'Evt' to 'Cue'1989/05/31 - sgs - diddled an error message1989/05/03 - cj  - convert sample # to sequence time for event duration and mark point.1989/04/24 - cj  - show basic event info on sequence panel1989/04/18 - cj  - moved get.sf.name to seqmods1988/10/22 - cj  - updated big time display while refreshing sequence panel1988/10/03 - cj  - set remap bit for correct time display with live click track.						 Also performed remap here when showing cue and note durations*/DEFINE.SEQUENCER.TEMPLATE: proc (row,col,size,tracks,resize) swapable;	dcl (row,col)	fixed;	/*	y & x transparent coords of upper left corner of track region	*/	dcl size			fixed;	dcl tracks		fixed;	/*	number of track columns to define/display	*/	dcl resize		fixed;	/*	0 = defining template for first time		*/									/*	1 = undefine & redefine top line and note	*/									/*		 area												*/									/*	2 = undefine & redefine note area only		*/									/*	3 = undefine & redefine event time table	*/									/*		 and note area									*/	/*	if re-sizing # of columns, then must erase & undefine	*/	/*	earlier information:												*/	if resize = 1												/*	undefine top line if	*/	then call UNDEFINE.SEQUENCER.TOP.LINE(row,col);	/*	changing # of trks	*/	if resize >= 1																	/*	undefine note area if	*/	then call UNDEFINE.SEQUENCER.NOTE.AREA(row,col,size,resize);	/*	new tracks OR info		*/	if tracks > 16 then tracks = 16;	/*	limit to valid range	*/	if tracks < 01 then tracks = 01;	/*	define new top line if not just changing display contents	*/	call Set.Default.Action(O#ACT.Middle.Press			);	call Set.Default.Attr  (0,ATTR#Normal					);	call Set.Default.Attr  (1,ATTR#Normal\ATTR#Reverse	);	if resize < 2	then call DEFINE.SEQUENCER.TEMPLATE.TOP.LINE (row,col,tracks);	call BEGIN.NOTE.AREA.DEFINE				 (row,col,size,tracks,resize);	call DEFINE.SEQUENCER.TEMPLATE.NOTE.AREA(row,col,size,tracks);	if Highlighted.Length = 0 then Highlighted.Length = 1;	/*	force update of start time for any left over unverified start times	*/	call Clean.Out.Verify.Tracks;	if (Seq.Dialog.Mode = SEQ#RippleVerifyDialog)	then call CLOSE.SEQ.DIALOG;	call Set.Default.Attr(0,ATTR#Normal);end DEFINE.SEQUENCER.TEMPLATE;/*	Routines to open & close sequence panel:	*/dcl Take.New.AEE.Snapshot proc recursive;OPEN.SEQUENCER.PANEL: proc (MaxSize) public swapable;	dcl MaxSize				fixed;	dcl MinSize				fixed;	dcl (sid,row,size)	fixed;	/*** Declare in Order ***/	dcl (I			  )	fixed;	if Seq.Group <> 0 then return;	/*	limit to 20 rows because we can only have 15 rows of	*/	/*	note data															*/	MinSize=6;	if (MaxSize<=0) or (MaxSize>20) then MaxSize=20;	if MaxSize<MinSize then MaxSize=MinSize;	if (MaxSize = 20) and (Motion.Group <> 0)	/*	get 1 smaller since we may abut under	*/	then do;												/*	the motion panel	*/		MaxSize = MaxSize - 1;	end;	if Allocate.Screen.Space(MinSize,MaxSize,loc(addr(sid))) then do;		call Set.Panel.Menu.Highlight(5,1);		call Set.AEE.Panel.Info(5,row,size);		if Seq.Tracks = 0 then do;			Seq.Tracks = 4;	/*	default to show 4 track columns	*/			do i = 0 to 15;	/*	thru										*/				TRKINDEX(I) = Num.Kbd.Tracks + i;			end;		end;		if  (Motion.Group <> 0)						/*	if motion panel is open	*/		and (row = (Motion.Row + Motion.Size))	/*	and right above us		*/		then do;			Seq.Row	= row;												/*	then put seq edit		*/			Seq.Size	= size;												/*	right up next to		*/			call Define.Sequencer.Panel(Seq.Row,Seq.Size,0);	/*	it without a title	*/		end;		else do;						/*	draw sequencer panel title	*/			Seq.Row	= row  + 1;	/*	reserve 1 line for the panel title	*/			Seq.Size	= size - 1;			call Define.Sequencer.Panel(Seq.Row,Seq.Size,1);		end;		/*	Define top line and note area:	*/		call Define.Sequencer.Template(Seq.Row,Seq.Event.Display.Left.X,Seq.Size,Seq.Tracks,0);		/*	Re-open prior permanent dialog row line:	*/		if Perm.Dialog.Mode <> 0		then call Highlight.Graphics.Button.Table			  (Seq.Settings.Command.Table, bits(Perm.Dialog.Mode-1), 2, 0);		call Define.Seq.Permanent.Dialog(Seq.Perm.Dialog.Row, Perm.Dialog.Mode);		Seq.Screen.Space = sid;		Seq.Dialog.Mode=SEQ#NoDialogOpen;		call Erase.Snapshot.Area(AEE.Old.Seq.Snap,16);	/*	Erase snapshot so old snapshot does not become random garbage	*/		call SET.CUE.MENU.PLACE.MODE (GID(Cue.Place.Mode));		/*	Set bits for: Scroll to current time			*/		/*					  Take snapshot of sequencer		*/		/*					  Display new note information	*/		/*					  New track titles					*/		/*					  New track routings					*/		/*					  New track solos						*/		/*	Provide a fresh snapshot right away so that scroll bar items		*/		/*	work immediately.  Also this will set up seq.screen.begin, etc.	*/		/*	Take the snapshot at the last time, so things work better			*/		/*	when returning to the screen.													*/		call Take.New.AEE.Snapshot;	/*	take a sequence snapshot	*/		Seq.Refresh = Seq.Refresh \ (8\16\32\64\128);		Seq.Panel.Started.Play = 0;	end;	else call Display.Notice(NT#NoMoreRoomOnScreen,ATTR#Normal,NulStr,0,0,0);end OPEN.SEQUENCER.PANEL;CLOSE.SEQUENCER.PANEL: proc public swapable;	if Seq.Group <> 0 then do;	/*	Group is defined	*/		call Set.Panel.Menu.Highlight(5,0);		call Set.AEE.Panel.Info(5,0,0);		if Seq.Dialog.Mode <> SEQ#NoDialogOpen		then call Close.Seq.Dialog;		Seq.Screen.Space = Erase.Screen.Space(Seq.Screen.Space);		Seq.Group = Ungroup.Objects(Seq.Group);		call Undefine.Object.Range(Seq.Alloc,Seq.Alloc+499);		call Select.New.Cur.Obj(Corner.Label,-1,-1);		call SET.CUE.MENU.PLACE.MODE (GID(Cue.Place.Mode));		call Set.Up.AEE.Play.Scroll.Points;	/*	disable for play scrolling if not showing big time display	*/		if Seq.Info.Track <> 0		then do;			call Stop.Info.Note(Seq.Info.Track);			Seq.Info.Track = 0;		end;	end;end CLOSE.SEQUENCER.PANEL;/*	$page - routines to update the sequence panel	*//*	Update routines - set up correct track solo displays	*/REFRESH.SEQ.TRACK.SOLO.DISPLAY: proc swapable;	dcl i		fixed;	dcl solo	fixed;	/*	higlight track solo buttons on permanent dialog line	*/	Set.Solo.Highlights:proc (id, trkbase);		dcl id		fixed;		dcl trkbase	fixed;		dcl i			fixed;		dcl j			fixed;		if id = 0 then return;			/*	solo dialog line not up			*/		j = 0;		do i = 0 to 15;					/*	higlight 16 tracks				*/			write(mam)=TBut.Ptr;			write(mal)=trkbase+i;			if (read(md)&b.soloed.trk) <> 0	/*	if track is soloed		*/			then j = j \ bits(i);		end;		call Highlight.Graphics.Button.Table		(id, j, 2, 0);		/*	put a box around the record track	*/		j = 0;		if  (Recd.Trk >= (trkbase	 ))		and (Recd.Trk <  (trkbase+16))		then j = bits(Recd.Trk - trkbase);		call Highlight.Graphics.Button.Table		(id, j, 2, 1);	end Set.Solo.Highlights;	if Seq.Track.Solo.Buttons <> 0	/*	highlight solo buttons in note	*/	then do;									/*	area if needed							*/		do i=0 to Seq.Tracks-1;		/*	loop over columns of event display	*/			write(mam)=TBut.Ptr;			write(mal)=TrkIndex(i);			if (read(md)&b.soloed.trk)=0	/*	track is not soloed	*/			then solo=0;			else solo=1;			call Highlight.Graphics.Button.Table.Entry(Seq.Track.Solo.Buttons+I,0,0,Solo,2,0);		end;	end;	call Set.Solo.Highlights (Display.Solo.Tracks.#1, Display.Solo.Tracks.Base + Num.KBD.Tracks		);	call Set.Solo.Highlights (Display.Solo.Tracks.#2, Display.Solo.Tracks.Base + Num.KBD.Tracks + 16);	call Set.Solo.Highlights (Display.DTD.Tracks		, First.LOD.Track											);	call Draw.Seq.Record.Track.Display(1);	/*	put an 'R' in the correct solo button (if one)	*/end REFRESH.SEQ.TRACK.SOLO.DISPLAY;/*	$page - routine to display track numbers and titles in sequence panel	*/UPDATE.SEQ.TRACK.LABELS: proc (tracks,row) swapable;	dcl tracks				fixed;	/*	number of columns in display	*/	dcl row					fixed;	dcl (i,j,k)				fixed;	dcl tmp(32)				fixed;	dcl Max.STR.Length	fixed;	/*	compute t char width of timbre name field	*/	Max.STR.Length   = (spacing - 8) * Tchar.Width / (Hor.Char.Field(1)*10);	Disable.Deposits = true;	do i = 0 to tracks-1;		if Seq.Track.Number <> 0		then do;			if TRKINDEX(i) > 0 then do;			/*	already assigned a track	*/				call CONV.FIXED.TO.STR(TRKINDEX(i)-1,0,3,cf#right,tmp);			end;			else do;										/*	no track assigned	*/				call COPY.STRING('---', tmp);			end;			call Deposit.String(Seq.Track.Number + i, tmp);		end;		/*	display track/timbre title if one:	*/		if (Seq.Track.Name.Gstring <> 0)		then do;			if (trkindex(i) <> 0)			then do;				J = TRK.HEAD.LOOKUP(trkindex(i), THD.TRACK.TITLE);				if j <> 0 then do;					/*	get track name	*/					if j IGT 32 then j = 32;					call COPY.IN(addr(tmp(0)), shr(j+3,1));				end;				else do;									/*	get timbre name	*/					call LOOKUP.TRACK.TIMBRE.NAME(TRKINDEX(i),tmp);				end;			end;			else tmp(0) = 0;			if tmp(0) IGT Max.STR.Length then tmp(0) = Max.STR.Length;			call Deposit.Graphics.String(Seq.Track.Name.Gstring+i, tmp);		end;	end;	Disable.Deposits = false;end UPDATE.SEQ.TRACK.LABELS;/*	$PAGE - Update Output Routing and Track Volume for cue tracks	*//*	Update seq track values updates the Output Routing and Track	*//*	Volume fields of the Sequence Panel										*/UPDATE.SEQ.TRACK.VALUES: proc swapable;	dcl (i)		fixed;	dcl (j)		fixed;	dcl (k)		fixed;	dcl tmp(16)	fixed;	Disable.Deposits = true;	do i = 0 to Seq.Tracks-1;		if Seq.Track.Out.Gstring <> 0			/*	if output routings are	*/		then do;										/*	shown, then update		*/			k = -1;									/*	no track assigned: print blanks	*/			if TRKINDEX(i) > 0 then do;		/*	if track assigned, look	*/				j = TRKINDEX(i);					/*	get abs trk #				*/				k = 0;								/*	assume no routing			*/				if TRK.HEAD.LOOKUP(j,THD.CUE.TRACK)<>0			/*	cue track			*/				then k=TRK.HEAD.LOOKUP(j,THD.CUE.OUT);			/*	get dtd output #	*/				else if (TRK.HEAD.LOOKUP(j,THD.NN.MSB)<>0)	/*	non-empty, non-Q	*/					  or (TRK.HEAD.LOOKUP(j,THD.NN.LSB)<>0)	/*	track: get mc #	*/				then k=TRK.HEAD.LOOKUP(j,THD.TROU);				if k = 0 then k = (-3);			/*	no routing, show **		*/				else k = (k&63)+1;				/*	else 1 - x					*/			end;			if k <> GID(Seq.Panel.Output.Values+i)			then do;				if		  k = (-3) then call COPY.STRING('**',tmp);				else if k = (-1) then call COPY.STRING('  ',tmp);				else call CONV.FIXED.TO.STR(k, 0, 2, cf#right, tmp);				call Deposit.Graphics.String(Seq.Track.Out.Gstring + i, tmp);				call PID(Seq.Panel.Output.Values+i, k);			end;		end;		if Seq.Track.Vol.Gstring <> 0			/*	if track volumes are		*/		then do;										/*	shown, then update		*/			k = -1;									/*	assume no trk vol to show	*/			if TRKINDEX(i) > 0 then do;		/*	if track assigned, look	*/				j = TRKINDEX(i);					/*	get abs trk #				*/				k = 1000;							/*	default is 100.0			*/				write(mam) = TRK.HEAD;			/*	see if trk head exists	*/				write(mal) = j;				if read(md) <> 0					/*	look up trk volume if	*/				then do;								/*	thd exists					*/					k=TRK.HEAD.LOOKUP(j,THD.TVOL);				end;			end;			if k <> GID(Seq.Panel.Tvol.Values+i)			then do;				if k = (-1) then call COPY.STRING('     ',tmp);				else call CONV.FIXED.TO.STR(k, 1, 5, cf#right, tmp);				call Deposit.Graphics.String(Seq.Track.Vol.Gstring + i, tmp);				call PID(Seq.Panel.Tvol.Values+i, k);			end;		end;	end;	Disable.Deposits = false;end UPDATE.SEQ.TRACK.VALUES;/*	$page - routine to update sequence panel time formats	*/UPDATE.SEQ.TIME.FORMATS:proc PUBLIC swapable;	dcl i	fixed;	dcl l	fixed;	dcl r	fixed;	dcl k	fixed;	dcl map.disp data (0,2,3,4,5,1);	/*	map aee time format to switch setting	*/	l = Seq.Format.Left;	r = Seq.Format.Right;	if AEE.Time.Format = O#MSEC.Smpte	/*	suppress bits display on end time	*/	then k = 0;									/*	string for better jogging				*/	else k = cf#default;	call Set.32Bit.MSEC.Display.Format(Seq.Drag.Time,AEE.Time.Format,cf#time,cf#default,cf#default);	call Set.32Bit.MSEC.Display.Format(Seq.Event.Time.Table,AEE.Time.Format,cf#time,cf#default,cf#default);	if Seq.Duration.Table <> 0	then do i = 0 to Seq.Tracks-1;		call Set.32Bit.MSEC.Display.Format(Seq.Duration.Table+i,AEE.Time.Format,cf#dur,l,r);	end;	if Seq.End.Time.Table <> 0	then do i = 0 to Seq.Tracks-1;		call Set.32Bit.MSEC.Display.Format(Seq.End.Time.Table+i,AEE.Time.Format,cf#time,cf#default,k);	end;	if Display.Format.Table <> 0	then call Highlight.Graphics.Button.Table		  (Display.Format.Table, bits(map.disp(AEE.Time.Format)), 2, 0);end UPDATE.SEQ.TIME.FORMATS;/*	$page - draw sequence panel time cursor, and set up information for scroll	*//*	NOTE:		Seq.Refresh.Time, Seq.Screen.Begin & end, Seq.Cursor.Begin & End				are in SEQUENCER Units (same as Screen.Begin & end and				Cursor.Begin & end).				Cursor.Scroll.Begin & end, Screen.Scroll.Begin & end,				and the Big.Time.Begin & end are in REAL TIME Units		*/Update.Seq.Time.Cursor: proc PUBLIC swapable;	/*	set time cursor	*/	dcl row			fixed;	dcl trk			fixed;	dcl i				fixed;	dcl j				fixed;	dcl k				fixed;	dcl OurTime(1)	fixed;	dcl Time   (1)	fixed;	/*	Algorithm: First set cursor scroll to match screen begin & end	*/	/*				  Then look backwards through screen display				*/	/*				  To find first note that is at or before the current	*/	/*				  Play time.  Draw the cursor under that note.			*/	/*				  Continue backing up to the prior note, find			*/	/*				  its time.  Set cursor begin to that time.				*/	Draw.Time.Cursor: proc(row);		dcl row	fixed;		vector_mode;		call Data_level(2);		call BLOCKMODE_ON;		call connect(gpos.x(Seq.Event.Display.Left.X*100-50)+1,						 gpos.y(row*100)+2,						 gpos.x(8000)-1,						 gpos.y(row*100)+3);		call BLOCKMODE_OFF;		call Data_Level(0);		transparent_mode;		call Check.Next.Event;	end Draw.Time.Cursor;	call COPY32(Seq.Screen.Begin,	Seq.Cursor.Begin);	call COPY32(Seq.Screen.End,	Seq.Cursor.End  );	call Map.Real.Time.To.Sequence.Time(loc(addr(Sampled.Actual.Play.Time.Msb)),Time);	/*	start with last row.  look backwards to find information.	*/	row = Seq.Event.Display.Size-1;	do while row >= 0;		/*	Look up the starting time for this line of notes:	*/		i = 0;		j = false;		do while (i < Seq.Tracks) & (j = false);	/*	Loop over all tracks until one with a time in it occurs	*/			write(mam) = AEE.Cur.Seq.Snap+i;			/*	track sector	*/			write(mal) = INDEX.START+row;				/*	row index		*/			if read(md) <> 0 then j = true;			/*	index <> 0 means a note is there	*/			else i = i + 1;								/*	index = 0 means must continue to search	*/		end;		/*	if this line has a starting time, get it and look at it.	*/		if j <> false then do;			/*	get info about this note for its starting time:	*/			call Get.Snapshot.Info(AEE.Cur.Seq.Snap,i,TRKINDEX,row);			/*	if this sequencer is sitting BEFORE this note, then	*/			/*	set cursor.end and keep backing up.							*/			if COM32(Time, loc(addr(#NMSB))) = lw#ILT			then do;				call COPY32(loc(addr(#NMSB)), Seq.Cursor.End);			end;			/*	else this must be the line with the cursor!!	*/			else do;				/*	move time cursor if we need to	*/				call COPY32(loc(addr(#NMSB)), OurTime);				if Time.Cursor.Row <> Seq.Event.Display.Row + row				then do;					/*	draw new cursor quickly:	*/					call Draw.Time.Cursor(Seq.Event.Display.Row + row);					if Time.Cursor.Row >= 0					then do;						call Draw.Time.Cursor(Time.Cursor.Row);					end;					Time.Cursor.Row = Seq.Event.Display.Row + row;				end;				/*	now keep backing up to find cursor.begin	*/				Next.Row:;				row = row - 1;				if row >= 0 then do;					/*	Look up the starting time for this line of notes:	*/					i = 0;					j = false;					do while (i < Seq.Tracks) & (j = false);	/*	Loop over all tracks until one with a time in it occurs	*/						write(mam) = AEE.Cur.Seq.Snap+i;			/*	track sector	*/						write(mal) = INDEX.START+row;				/*	row index		*/						if read(md) <> 0 then j = true;			/*	index <> 0 means a note is there	*/						else i = i + 1;								/*	index = 0 means must continue to search	*/					end;					call Get.Snapshot.Info(AEE.Cur.Seq.Snap,i,TRKINDEX,row);					/*	if prior row is at same time, keep going back:	*/					if COM32(loc(addr(#NMSB)), OurTime) = lw#ieq					then goto next.row;					call COPY32(loc(addr(#NMSB)), Seq.Cursor.Begin);				end;				/*	set up cursor.begin, cursor.end as needed:	*/				call Set.Up.AEE.Play.Scroll.Points;				return;			end;		end;		row = row - 1;	/*	try next row	*/	end;	/*	oops: cursor is not on the screen anywhere	*/	if Time.Cursor.Row >= 0	then do;		call Draw.Time.Cursor(Time.Cursor.Row);		Time.Cursor.Row = (-1);	end;	call Set.Up.AEE.Play.Scroll.Points;	call Check.Next.Event;end Update.Seq.Time.Cursor;/*	$page - disable all table cells	*//*	This routine is passed a row and column (track).  It disables all	*//*	items for that track on the specified row.  The actual				*//*	screen area for this row & track must be erased before we are		*//*	called.																				*/Disable.All.Table.Cells: proc(row,trk) swapable;	dcl row	fixed;	dcl trk	fixed;	call Check.Next.Event;	if Seq.Pitch.Name.Table <> 0	then call Disable.And.Disexhibit.Table.Cell(Seq.Pitch.Name.Table+trk, 0, row);	if Seq.Key.Number.Table <> 0	then call Disable.And.Disexhibit.Table.Cell(Seq.Key.Number.Table+trk, 0, row);	if Seq.Event.Name.Table <> 0	then call Disable.And.Disexhibit.Table.Cell(Seq.Event.Name.Table+trk, 0, row);	if Seq.Duration.Table <> 0	then call Disable.And.Disexhibit.Table.Cell(Seq.Duration.Table+trk, 0, row);	if Seq.End.Time.Table <> 0	then call Disable.And.Disexhibit.Table.Cell(Seq.End.Time.Table+trk, 0, row);	if Seq.Velocity.Table <> 0	then call Disable.And.Disexhibit.Table.Cell(Seq.Velocity.Table+trk, 0, row);	if Seq.Caption.Table <> 0	then call Disable.And.Disexhibit.Table.Cell(Seq.Caption.Table+trk, 0, row);end Disable.All.Table.Cells;/*	$page - construct real time effects display information	*//*	This routine examines a real time effects record and constructs	*//*	three strings - a short string for the pitch name field,				*//*	a longer string for the event name field, and a numeric				*//*	string for the velocity field.												*/Get.RTE.Info: proc(Pitch.Name, Event.Name, Velocity) swapable;	dcl Event.Name			array;	dcl Pitch.Name			array;	dcl Velocity			array;	dcl I						fixed;	dcl val					fixed;	dcl t						fixed;	dcl ptr					fixed;	dcl pitch.bend.range	fixed;	val = #w3 & 255;							/*	get basic rte information	*/	if (#w3 & shl(b.gui,8)) <> 0			/*	guitar update record	*/	then do;		call Copy.String('Gui',					Pitch.Name);		call Copy.String('Guitar Update 1',	Event.Name);		call pbyte(Event.Name, Event.Name(0) - 1, ASC.1 + shr(#w3,8) & 7);	/*	get string #	*/		val = SCALE.RTE.TO.PERCENT(val);		call CONV.FIXED.TO.STR(val,1,5,cf#right\cf#unsigned\cf#erase\cf#spfill,Velocity);	end;	else do case (shr(#w2,6)&3);	/*	else loook at type of update record	*/		do;										/*	0 => normal update	*/			i = shr(#w2,8);					/*	get rte code handy	*/			if ((i & "200")<>0) then do;	/*	midi controller update	*/				call CONV.FIXED.TO.STR(i&"177",0,3,cf#right\cf#unsigned\cf#erase\cf#zerofill,Pitch.Name);			end;			else if (i = r.pedal1) then call Copy.String('Pd1',Pitch.Name);			else if (i = r.pedal2) then call Copy.String('Pd2',Pitch.Name);			else if (i = r.mwheel) then call Copy.String('Mod',Pitch.Name);			else if (i = r.pwheel) then call Copy.String('Ptc',Pitch.Name);			else if (i = r.ribbon) then call Copy.String('Rib',Pitch.Name);			else if (i = r.breath) then call Copy.String('Brt',Pitch.Name);			else								 call Copy.String('???',Pitch.Name);			if ((i & "200")<>0) then do;	/*	midi controller update	*/				call Copy.String('Midi Cntrl',Event.Name);			end;			else if (i = r.pedal1) then call Copy.String('Pedal 1',	 Event.Name);			else if (i = r.pedal2) then call Copy.String('Pedal 2',	 Event.Name);			else if (i = r.mwheel) then call Copy.String('Mod Wheel', Event.Name);			else if (i = r.pwheel) then call Copy.String('Pitch Bend',Event.Name);			else if (i = r.ribbon) then call Copy.String('Ribbon',	 Event.Name);			else if (i = r.breath) then call Copy.String('Breath',	 Event.Name);			else								 call Copy.String('???',		 Event.Name);			if ((i & "200")<>0) then do;							/*	midi controller update	*/				call CONV.FIXED.TO.STR(val,0,5,cf#right\cf#unsigned\cf#erase\cf#spfill,Velocity);			end;			else if (i = r.ribbon) then do;				if val >= 128 then val=val\"177400";			/*	should be negative, so sign extend	*/				call CONV.FIXED.TO.STR(val,0,5,cf#right\cf#signed\cf#erase\cf#spfill,Velocity);			end;			else if (i = r.pwheel) then do;				t	 = TRK.HEAD.LOOKUP(#trk, thd.ctimb);		/*	get timbre # for this track	*/				ptr = TIM.HEAD.LOOKUP(t,tim.tinfo.pointer);				if ptr=0				then pitch.bend.range=200;							/*	default: units are cents (semitones*100)	*/				else pitch.bend.range=P.LOOKUP(ptr+ti.tbd);	/*	look it up	*/				if val >= 128 then val=val\"177400";			/*	if negative, sign extend	*/				/*	SINCE SPEED IS CRITICAL HERE, USE THE FOLLOWING IN LIEU OF "val=srscale(val,pitch.bend.range,100);"	*/				val = val * pitch.bend.range / 100;				if (val < 0) {if (rem igt 50) val = val+1;}				else			 {if (rem ige 50) val = val+1;}				call CONV.FIXED.TO.STR(val,2,5,cf#right\cf#signed\cf#erase\cf#spfill,Velocity);			end;			else do;	/*	print normal parameter value	*/				val = SCALE.RTE.TO.PERCENT(val);				call CONV.FIXED.TO.STR(val,1,5,cf#right\cf#unsigned\cf#erase\cf#spfill,Velocity);			end;		end;		do;										/*	1 => toggle bits		*/			call Copy.String('Tog',			Pitch.Name);			call Copy.String('Rep/Arpeg',	Event.Name);			call Copy.String('',				Velocity  );		end;		do;										/*	2 => pressure update	*/			call Copy.String('Pre',			Pitch.Name);			call CONV.KEY#.TO.STR(EXTRACT.KEY(loc(addr(#W1))), Event.Name);			call Append.To.Str(Event.Name, ' Pressure');			val = SCALE.RTE.TO.PERCENT(val);			call CONV.FIXED.TO.STR(val,1,5,cf#right\cf#unsigned\cf#erase\cf#spfill,Velocity);		end;		do;												/*	3 => midi update		*/			do case shr(#w2,8);						/*	branch on type code	*/				do;										/*	midi program change	*/					call Copy.String('Mpg',					Pitch.Name);					call Copy.String('MIDI Pgm Change',	Event.Name);					call CONV.FIXED.TO.STR( (val&127), 0 ,5, cf#right\cf#unsigned\cf#erase\cf#spfill,Velocity);				end;				do;										/*	sysex data record	*/					call Copy.String('Sys',					Pitch.Name);					call Copy.String('MIDI Sys Ex',		Event.Name);					call CONV.FIXED.TO.HEXSTR(val,		Velocity  );				end;				do;										/*	sustain switch record	*/					call Copy.String('Sus',					Pitch.Name);					call Copy.String('Sustain Switch',	Event.Name);					if (val <> 0) then val = 1;					call CONV.FIXED.TO.STR(val, 0 ,5, cf#right\cf#unsigned\cf#erase\cf#spfill,Velocity);				end;			end;		end;	end;end Get.RTE.Info;/*	$page - enable and deposit all table cells	*//*	This routine is called to enable all the table cells for a particular	*//*	row and column, and to put all the note information into the				*//*	table cells.																				*//*	It is called with the global note information in the # variables.	*/Enable.And.Deposit.All.Cells: proc(row,trk) swapable;	dcl row			fixed;	dcl trk			fixed;	dcl etime(1)	fixed;	dcl kname(4)	fixed;	dcl vname(4)	fixed;	dcl val			fixed;	dcl (rlen)		fixed;	dcl (nlen)		fixed;	dcl (clen)		fixed;	dcl event (event.record.size-1)	fixed;	/*	expand note information into useful format:	*/	call Expand.Event.Note (Event, 1);		/*	get all info including caption	*/	/*	If ILP or RTE, then expand information appropriately:	*/	if event(event.type) = event.type.ilp then do;		if (#w1&"174001")="104001" then do;	/*	ILP START	*/			call Copy.String('LpS',			kname);			call Copy.String('Loop Start',loc(addr(event(event.cue.name))));			call Copy.String('',				vname);		end;		else do;										/*	ILP END	*/			call Copy.String('LpE',			kname);			call Copy.String('Loop End',	loc(addr(event(event.cue.name))));			call Copy.String('',				vname);		end;		call ADD32 (loc(addr(#NMSB)), loc(addr(event(event.duration.msb))), etime);		call Check.Next.Event;	end;	else if event(event.type) = event.type.rte then do;		call Get.RTE.Info(kname, loc(addr(event(event.cue.name))), vname);		call Check.Next.Event;	end;	/*	If is a cue track and showing duration or end time,	*/	/*	must fetch actual cue to get the information:		*/	else if event(event.type) = event.type.cue then do;		if Seq.Event.Name.Table <> 0			/*	if showing name, put 'Q'	*/		then call COPY.STRING('Q', kname);	/*	in pitch field				*/		else do;										/*	else show first 3 chars	*/			kname(0) = event(event.cue.name+0);			kname(1) = event(event.cue.name+1);			kname(2) = event(event.cue.name+2);			if kname(0) > 3 then kname(0) = 3;		end;		/*	Fetch cue to get cue length if needed:	*/		if (Seq.Duration.Table\Seq.End.Time.Table) <> 0		then do;			if Fetch.DTD.Cue(event(event.cue.id), misc.buf) <> 0			then do;				call Map.Real.Duration.To.Sequence.Duration								  (loc(addr(#NMSB)),									loc(addr(misc.buf(CUE.LEN.MSB))),									loc(addr(event(event.duration.msb))));				if Show.Offsets = 0				then call ADD32(loc(addr(#NMSB)),									 loc(addr(event(event.duration.msb))), etime);				/*	if showing offsets, then suppress display if offset	*/				/*	time is 0:															*/				else do;					call SUB32 (loc(addr(misc.buf(CUE.OFF.MSB))),									loc(addr(misc.buf(CUE.S.MSB  ))),									etime);					call Map.Real.Duration.To.Sequence.Duration								  (loc(addr(#NMSB)),									etime, etime);					if COM16(0, etime) = lw#ieq					then etime(0) = (-1);					else call ADD32 (loc(addr(#NMSB)), etime, etime);				end;			end;			else etime(0) = (-1);		end;		/*	Only show velocity for cues if 'show velocity' is shown	*/		if (Display.Note.Contents & Display.Velocity) <> 0		then do;			call CONV.FIXED.TO.STR(event(event.volume),1,5,cf#right\cf#unsigned\cf#erase\cf#spfill,vname);		end;		if Seq.Caption.Table <> 0 then do;			/*	must fetch entire cue to get caption	*/			if FETCH.ENTIRE.DTD.CUE (event(event.cue.id), Scsi.ptr) <> 0			then do;				write(mam) = Scsi.Ptr;				write(mal) = CUE.RLEN;				rlen		  = read(md);				write(mal) = CUE.NAME;				nlen		  = shr(read(md)+3,1);	/*	# of wrds in cue name	*/				if rlen igt CUE.NAME+nlen				then do;					write(mal) = CUE.NAME+nlen;					clen	  = read(md);				/*	caption len, bytes		*/				end;				else clen  = 0;						/*	no comment in record		*/				if (clen<>0) & (clen ILE 64) then do;					write(mal) = CUE.NAME+nlen;					call COPY.IN(addr(event(event.caption)),shr(clen+3,1));				end;			end;		end;		call Check.Next.Event;	end;	/*	For events, info is readily available:	*/	else if event(event.type) = event.type.event then do;		if Seq.Event.Name.Table <> 0				/*	if showing name, put		*/		then call COPY.STRING('Cue', kname);	/*	Cue in pitch field		*/		else do;											/*	else show first 3 chars	*/			kname(0) = event(event.cue.name+0);			kname(1) = event(event.cue.name+1);			kname(2) = event(event.cue.name+2);			if kname(0) > 3 then kname(0) = 3;		end;		/*	if showing duration or end time, compute duration in msecs	*/		if (Seq.Duration.Table\Seq.End.Time.Table) <> 0		then do;			call DTD.Sample.#.To.Msecs (loc(addr(event(event.duration.msb))),												 CF#Dur,												 S$Speed,												 AEE.Current.Project.Rate, Zero.Zero,												 loc(addr(event(event.duration.msb))));			if Show.Offsets = 0			then do;				call Map.Real.Duration.To.Sequence.Duration							  (loc(addr(#NMSB)),								loc(addr(event(event.duration.msb))),								loc(addr(event(event.duration.msb))));				call ADD32(loc(addr(#NMSB)),							  loc(addr(event(event.duration.msb))), etime);			end;			/*	if showing offsets, then suppress display if offset	*/			/*	time is 0:														*/			else do;				if COM32(loc(addr(event(event.mark.msb))),			/*	if mark is	*/							loc(addr(event(event.in.msb)))) <= lw#ieq	/*	before in	*/				then etime(0) = (-1);										/*	time ...		*/				else do;					call SUB32(loc(addr(event(event.mark.msb))),								  loc(addr(event(event.in.msb))), etime);					call DTD.Sample.#.To.Msecs (etime,														 CF#Dur,														 S$Speed,														 AEE.Current.Project.Rate, Zero.Zero,														 etime);					call Map.Real.Duration.To.Sequence.Duration								  (loc(addr(#NMSB)),									etime, etime);					call ADD32 (loc(addr(#NMSB)), etime, etime);				end;			end;		end;		/*	Only show velocity for cues if 'show velocity' is shown	*/		if (Display.Note.Contents & Display.Velocity) <> 0		then do;			call CONV.FIXED.TO.STR(event(event.volume),1,5,cf#right\cf#unsigned\cf#erase\cf#spfill,vname);		end;		call Check.Next.Event;	end;	/*	Else if a music track, look up sound file info if needed:	*/	else do;		if (Seq.Pitch.Name.Table <> 0)		then do;			call CONV.KEY#.TO.STR(event(event.key#), kname);		end;		if Seq.Event.Name.Table <> 0		then do;			call Get.SF.Name(trkindex(trk), event(event.key#), loc(addr(event(event.cue.name))));		end;		if (Display.Note.Contents & Display.Velocity) <> 0		then do;			call CONV.FIXED.TO.STR(event(event.volume),1,5,cf#right\cf#unsigned\cf#erase\cf#spfill,vname);		end;		if (Seq.End.Time.Table <> 0)		or (Seq.Duration.Table <> 0)		then do;			if Show.Offsets = 0			then call ADD32 (loc(addr(#NMSB)),								  loc(addr(event(event.duration.msb))), etime);			else do;				call COMPUTE.SOUND.FILE.OFFSET.TIME(trkindex(trk),																event(event.key#), etime, 0);				call Map.Real.Duration.To.Sequence.Duration							  (loc(addr(#NMSB)),								etime, etime);				/*	if showing offsets, and no offset time avail, then suppress display:	*/				if COM16(0, etime) = lw#IEQ				then etime(0) = (-1);				else call ADD32 (loc(addr(#NMSB)), etime, etime);			end;		end;		if Seq.Caption.Table <> 0 then do;				call LOOK.UP.SOUND.FILE.CAPTION(trkindex(trk),event(event.key#),														  loc(addr(event(event.caption))), 0);		end;		call Check.Next.Event;	end;	/*	now deposit the note information:	*/	disable.deposits = 1;	if Seq.Pitch.Name.Table <> 0	then do;		call Enable.Table.Cell (Seq.Pitch.Name.Table+trk, 0, row);		call Fetch.Table		  (Seq.Pitch.Name.Table+trk, 0, row);		call Deposit.String	  (Seq.Pitch.Name.Type +trk,	kname);		call Deposit.Table	  (Seq.Pitch.Name.Table+trk, 0, row);		call Check.Next.Event;	end;	if Seq.Key.Number.Table <> 0	then do;		call Enable.Table.Cell	 (Seq.Key.Number.Table+trk, 0, row);		call Fetch.Table			 (Seq.Key.Number.Table+trk, 0, row);		call Deposit.Fixed.Point (Seq.Key.Number.Type +trk, event(event.key#)+24);		call Deposit.Table		 (Seq.Key.Number.Table+trk, 0, row);		call Check.Next.Event;	end;	if Seq.Event.Name.Table <> 0	then do;		call Enable.Table.Cell (Seq.Event.Name.Table+trk, 0, row);		call Fetch.Table		  (Seq.Event.Name.Table+trk, 0, row);		call Deposit.Label	  (Seq.Event.Name.Type +trk, loc(addr(event(event.cue.name))));		call Deposit.Table	  (Seq.Event.Name.Table+trk, 0, row);		call Check.Next.Event;	end;	if Seq.Duration.Table <> 0	then do;		/*	disable duration display for rte notes, ile notes	*/		if (isa.rte.note)		or ((isa.ilp.note) & ((#w1&"174001")<>"104001"))		then do;			call Fetch.Table			(Seq.Duration.Table+trk, 0, row);			call DEPOSIT.OBJECT.INFO(Seq.Duration.Type +trk, O#Trans.Row, Seq.Event.Display.Row + row);	/*	can you believe fetch.table does not set this information?	*/			call ERASE.OBJECT			(Seq.Duration.Type +trk);			call Disable.And.Disexhibit.Table.Cell(Seq.Duration.Table+trk, 0, row);		end;		else do;			call Enable.Table.Cell (Seq.Duration.Table+trk, 0, row);			call Fetch.Table		  (Seq.Duration.Table+trk, 0, row);			call Deposit.32bit.Msec(Seq.Duration.Type +trk, loc(addr(#NMSB)), loc(addr(event(event.duration.msb))));			call Deposit.Table	  (Seq.Duration.Table+trk, 0,row);		end;		call Check.Next.Event;	end;	if Seq.End.Time.Table <> 0	then do;		if (isa.rte.note)		or ((isa.ilp.note) & ((#w1&"174001")<>"104001"))		or (etime(0) = (-1))		then do;			call Fetch.Table			(Seq.End.Time.Table+trk, 0, row);			call DEPOSIT.OBJECT.INFO(Seq.End.Time.Type+trk, O#Trans.Row, Seq.Event.Display.Row + row);	/*	can you believe fetch.table does not set this information?	*/			call ERASE.OBJECT			(Seq.End.Time.Type + trk);			call Disable.And.Disexhibit.Table.Cell(Seq.End.Time.Table+trk, 0, row);		end;		else do;			call Enable.Table.Cell (Seq.End.Time.Table+trk, 0, row);			call Fetch.Table		  (Seq.End.Time.Table+trk, 0, row);			call Deposit.32bit.Msec(Seq.End.Time.Type +trk, etime, Zero.Zero);			call Deposit.Table	  (Seq.End.Time.Table+trk, 0, row);		end;		call Check.Next.Event;	end;	if Seq.Velocity.Table <> 0	then do;		call Enable.Table.Cell	(Seq.Velocity.Table+trk, 0, row);		call Fetch.Table			(Seq.Velocity.Table+trk, 0, row);		call Deposit.String		(Seq.Velocity.Type +trk, vname);		call Deposit.Table		(Seq.Velocity.Table+trk, 0, row);		call Check.Next.Event;	end;	if Seq.Caption.Table <> 0	then do;		call Enable.Table.Cell	(Seq.Caption.Table+trk, 0, row);		call Fetch.Table			(Seq.Caption.Table+trk, 0, row);		call Deposit.String		(Seq.Caption.Type +trk, loc(addr(event(event.caption))));		call Deposit.Table		(Seq.Caption.Table+trk, 0, row);		call Check.Next.Event;	end;	disable.deposits = 0;end Enable.And.Deposit.All.Cells;INSERT ':SYNSOU:AUDMOD:AUDSEQ1A';