/* EDT-SCRN  Screen Routines */dcl Scrn.Ptr lit 'Trd.Ptr+30';dcl Event.Cue.Info      fixed;dcl Scroll.Base         fixed;dcl Num.Tracks          fixed;dcl Track.Width         fixed;dcl Track.Display.Xmin  fixed;   Track.Display.Xmin = 17;dcl Track.Display.Xmax  fixed;   Track.Display.Xmax = 64;dcl Window.Info (8)     fixed public;dcl Cur.Window.Base     fixed; /* Window Info record = 3 words: */   dcl Win.Type            lit '0';   dcl Win.Top             lit '1';   dcl Win.Bot             lit '2';Scroll.Base = 11;Select.Window: proc (window) swapable;   dcl window fixed;   Cur.Window.Base = window * 3;end Select.Window;Set.Window: proc(window,type,top,bot) swapable;   dcl (window,type,top,bot) fixed;   window = window * 3;   Window.Info(window+win.type) = type;   Window.Info(window+win.top)  = top;   Window.Info(window+win.bot)  = bot;end Set.Window;Draw.Track.Template: proc(number,track.list) swapable;   dcl number     fixed;   dcl track.list fixed array;   dcl (i,j) fixed;   Num.Tracks = number;   Track.Width = (Track.Display.Xmax-Track.Display.Xmin)/number;   call Set.Term.Attr(ATTR#Normal\ATTR#AltIntensity\ATTR#Reverse);   j = 0;   do i = Track.Display.Xmin to Track.Display.Xmax by Track.Width+1;      call cpos(Window.Info(Cur.Window.Base+Win.Top),i);      if track.list(j) < 10 then call ps('0');      call pnum(track.list(j),0);      j = j + 1;   end;   vector_mode;   call line_type(1);   do i = Track.Display.Xmin*100 to Track.Display.Xmax*100 by (Track.Width+1)*100;      call connect(gpos.x(i)+5,gpos.y((Window.Info(Cur.Window.Base+Win.Top))*100),gpos.x(i)+5,gpos.y(Window.Info(Cur.Window.Base+Win.Bot)*100));   end;   call line_type(0);   transparent_mode;   call pc(27); call ps('(B');end Draw.Track.Template;UnDraw.Track.Template: proc swapable;   dcl (i,j) fixed;   do i = Window.Info(Cur.Window.Base+Win.Top) to Window.Info(Cur.Window.Base+Win.Bot);      call cpos(i,Track.Display.Xmax);      call pc(27); call ps('[1K');   end;   Track.Width = (Track.Display.Xmax-Track.Display.Xmin)/Num.Tracks;   vector_mode;   call data_level(1);   call line_type(1);   do i = Track.Display.Xmin*100 to Track.Display.Xmax*100 by (Track.Width+1)*100;      call connect(gpos.x(i)+5,gpos.y((Window.Info(Cur.Window.Base+Win.Top))*100),gpos.x(i)+5,gpos.y(Window.Info(Cur.Window.Base+Win.Bot)*100));   end;   call line_type(0);   call data_level(0);   transparent_mode;end UnDraw.Track.Template;Display.Label: proc(field.size) swapable;   dcl field.size  fixed;   dcl i           fixed;   dcl label.len   fixed;   dcl (smsw,slsw) fixed;   save.mammal;   label.len = read(mdi);   do i = 0 to field.size-1;      if i < label.len then do;         if (i&1)=0 then call pc(read(md)&255);         else            call pc(shr(read(mdi),8));      end;      else call pc(a.space);   end;   restore.mammal;end Display.Label;Display.Time: proc swapable;end; Display.Event.Label: proc(Event) swapable;   dcl Event  fixed;   write(mam) = scrn.ptr;   write(mal) = Event;   if read(md) <> NUL$Event   then write(mam) = read(mdi);   write(mal) = Event.Cue.Info;   write(mal) = read(md)*4+3;   call cpos(Scroll.Base+Event,0);   call Display.Label(14);end Display.Event.Label;Display.Event.Time: proc(Event) swapable;   dcl Event fixed;   dcl (msw,lsw) fixed;   write(mam) = scrn.ptr;   write(mal) = Event;   if read(md) <> NUL$Event   then do;      write(mam) = read(mdi);      msw = read(mdi);      lsw = read(mdi);      call cpos(Scroll.Base+Event,0);      call Display.Time;   end;end Display.Event.Time;Track.Xpos: proc(i) swapable;   dcl i fixed;   return Track.Display.Xmin + i * (Track.Width+1);end Track.Xpos;Display.Event.Cue: proc(Event,Track) swapable;   dcl Event                       fixed;   /* Physical event */   dcl Track                       fixed;   /* Logical track  */   dcl (End.Time.Msw,End.Time.Lsw) fixed;   dcl End.Event                   fixed;   dcl Event.Ptr                   fixed;   dcl Cue.Label.Ptr               fixed;   dcl Cue.Info                    fixed;   dcl (i,j)                       fixed;   dcl done                        fixed;   write(mam) = scrn.ptr;   write(mal) = Event;   if read(md) <> NUL$Event then do;      Event.Ptr  = read(md);      write(mam) = Event.Ptr;      write(mal) = 2;      cue.info   = read(mdi);      write(mal) = 3 + cue.info * 4;      Cue.Label.Ptr = read(mal) + shr(read(md)+1,1) + 1;      write(mal) = 3;       i = 0;      do while (i < cue.info) & (read(mdi) <> Track);  /* Search for track # */         write(R13)    = skip;         write(R13)    = skip;         Cue.Label.Ptr = read(mdi);         i = i + 1;      end;         if i = cue.info then return;   /* no cue for track specified */      end.time.msw = read(mdi);      end.time.lsw = read(mdi);      i = event;      done = false;      do while (i+Scroll.Base < Window.Info(Cur.Window.Base+Win.Bot)) & (not done);         write(mam) = scrn.ptr;         write(mal) = i;         if read(md) <> Nul$Event then do;            write(mam) = read(mdi);            if end.time.msw ilt read(md)             then done = true;            else if (end.time.msw = read(mdi))             &       (end.time.lsw ile read(mdi))            then done = true;            else i = i + 1;         end;         else done = true;      end;      End.Event = i;      write(mam) = Event.Ptr;      write(mal) = Cue.Label.Ptr;      call set.term.attr(ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);      j = 0;      do while (j < Num.Tracks) & (Track.Master(j) <> Track);         j = j + 1;      end;      if j < Num.Tracks then do;         call cpos(Scroll.Base+Event,Track.Xpos(j));         call Display.Label(Track.Width);         do i = scroll.base+event+1 to scroll.base+End.Event;            call cpos(i,track.xpos(j));            call pc(a.space);         end;      end;      call set.term.attr(attr#normal);   end;end Display.Event.Cue;Update.Track.Display: proc(mode,top.event,bot.event) swapable;   dcl mode           fixed;   dcl top.event      fixed;   dcl bot.event      fixed;   dcl (i,j)          fixed;   do i = top.event to bot.event;      if mode = 0 then call Display.Event.Time(i);      else             call Display.Event.Label(i);      do j = 0 to Num.Tracks-1;         call Display.Event.Cue(i,track.master(j));      end;   end;end Update.Track.Display;Fill.Trd.Area: proc(maxtrack) swapable;   dcl maxtrack fixed;   dcl (i,j,k) fixed;   dcl s  data ('Label');   /* Set Up Event Ptr Block */   write(mam) = scrn.ptr;   do i = 0 to 11;      write(mdi) = Event.Base + i;   end;   /* Set Up Event Sectors */   j =0;   do i = 0 to 11;      write(mam) = scrn.ptr;      write(mal) = i;      write(mam) = read(mdi);  /* get to real sector */      write(mdi) = 0;       /* Time */      write(mdi) = i;       /* Time */      write(mdi) = 1;       /* # cues */      if j = maxtrack then j = 0;      j = j + 1;      write(mdi) = j;       /* Track # */      write(mdi) = 0;       /* End time */      write(mdi) = i + 2;   /* End time */      write(mdi) = read(mal)+5; /* Label Ptr */      write(mdi) = s(0);    /* Event Label */      write(mdi) = s(1);      write(mdi) = s(2);      write(mdi) = s(3);      write(mdi) = 7;    /* Cue Label */      write(mdi) = s(1);      write(mdi) = s(2);      write(mdi) = s(3)\shl(a.space,8);      write(mdi) = a.a+i;   end;end Fill.Trd.Area;