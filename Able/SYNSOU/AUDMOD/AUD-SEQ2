/* AUD-SEQ2 - Routines to open & close basic dialog lines: *//* 11/01/90 - cj - added move/copy features. Added stuff to find.note *//* routines to open & close sequence dialog line           */CLOSE.SEQ.DIALOG: proc PUBLIC swapable;   dcl i   fixed;   if Seq.Dialog.Mode=SEQ#NoDialogOpen then return; /* no seq dialog panel currently open */   call cpos(Seq.Dialog.Row,0);  /* erase the entire dialog panel */   call Erase.To.End.Of.Line;   /* un-highlight existing items: */   call Highlight.Graphics.Button.Table(Seq.Delete.Move.Play.From,  0, 2, 0);   call Highlight.Graphics.Button.Table(Seq.Move.Copy,              0, 2, 0);   call Highlight.Graphics.Button.Table(Seq.Add.Commands,           0, 2, 0);   if Display.Erase.Bounce.Clear <> 0 then   call Highlight.Graphics.Button.Table(Display.Erase.Bounce.Clear, 0, 2, 0);   /* clean out ripple verify tracks if closing ripple verify line */   call Clean.Out.Verify.Tracks;   call Undefine.Object.Range(Seq.Dialog.First.Id,Seq.Dialog.Last.Id);   Seq.Dialog.Mode = SEQ#NoDialogOpen;   /* leave cursor in event time table in case doing hasty */   /* ripple edits.                                        */   if Cur.Obj.Id <> Seq.Event.Time.Table   then call Select.New.Cur.Obj(Corner.Label,-1,-1);end CLOSE.SEQ.DIALOG;/* $page - routines to define dialog boxes */SET.SEQ.DIALOG.ARROW.LINKS: proc (First.Id,Last.Id) swapable;   dcl (First.Id,Last.Id,I)   fixed;   dcl Leftmost.Mouseable.Id  fixed;   dcl Rightmost.Mouseable.Id fixed;   /* Routine sets arrow links as follows: */   /*    First object can only go LEFT     */   /*    Last  object can only go RIGHT    */   /*    Others go LEFT or RIGHT           */   /*    No objects go UP or DOWN          */   if First.Id<>Last.Id then do; /* only if more than one object */      I=First.Id;      do while I <= Last.Id; /* allow left-most MOUSEABLE object to only go RIGHT */         if Locate.Object(I) then do;            if (Read.Object(Object.Ptr+O#Action)&O#ACT.Middle.Press)<>0            then do;               Leftmost.Mouseable.Id=I;               call Set.Object.Arrow.Links(I,0,0,0,ARR#Auto);               I=Last.Id;         /* quit loop */            end;         end;         I=I+1;      end;      I=Last.Id;      do while I >= First.Id; /* allow right-most MOUSEABLE object to only go LEFT */         if Locate.Object(I) then do;            if (Read.Object(Object.Ptr+O#Action)&O#ACT.Middle.Press)<>0            then do;               Rightmost.Mouseable.Id=I;               if I<>Leftmost.Mouseable.Id               then call Set.Object.Arrow.Links(I,0,0,ARR#Auto,0);               I=1;               /* quit loop */            end;         end;         I=I-1;      end;   end;   if Leftmost.Mouseable.Id=Rightmost.Mouseable.Id                  /* means we only have 1 mouseable object */   then call Set.Object.Arrow.Links(Leftmost.Mouseable.Id,0,0,0,0); /* so no arrow links desired */      do I = Leftmost.Mouseable.Id+1 to Rightmost.Mouseable.Id-1; /* disallow up and down arrows */      call Set.Object.Arrow.Links(i,0,0,ARR#Auto,ARR#Auto);   end;end SET.SEQ.DIALOG.ARROW.LINKS;/* basic dialog routines: */Setup.For.Dialog.Define: proc swapable;   if Seq.Dialog.Mode<>SEQ#NoDialogOpen   then call Close.Seq.Dialog; /* get rid of any other dialog */   call Set.Auto.Allocation.Id(Seq.Dialog.First.Id);   call Set.Default.Action(0);   call Set.Default.Attr(0,ATTR#Normal\ATTR#AltIntensity\ATTR#Reverse);   call Set.Default.Attr(1,ATTR#Normal\ATTR#AltIntensity\ATTR#Reverse);end Setup.For.Dialog.Define;/* $page - define basic dialog lines for sequence panel: */OPEN.SEQ.EVENT.DELETE.DIALOG: proc swapable;   dcl row lit 'Seq.Dialog.Row';   call Setup.For.Dialog.Define;   call Highlight.Graphics.Button.Table(Seq.Delete.Move.Play.From, 1, 2, 0);   Seq.Dialog.Mode = SEQ#EventDeleteDialog;   call Define.Label(S#AA,Row,0,0,'Select events,  then click again to delete them');   call Set.Default.Action(O#ACT.Middle.Press);   call PID(SEQ#Cancel,Define.Label(S#AA,Row,72,0,'[CANCEL]'));   call Select.New.Cur.Obj(GID(SEQ#Cancel),-1,-1);   call Activate.Object.Range(Seq.Dialog.First.Id,GID(SEQ#Cancel));   call Update.Object.Range  (Seq.Dialog.First.Id,GID(SEQ#Cancel));end OPEN.SEQ.EVENT.DELETE.DIALOG;OPEN.SEQ.EVENT.MOVE.DIALOG: proc swapable;   dcl row lit 'Seq.Dialog.Row';   dcl (tcol,trow)   fixed;  /**** Must be declared in order ****/   call Setup.For.Dialog.Define;   call Highlight.Graphics.Button.Table(Seq.Move.Copy, bits(Move.Or.Copy), 2, 0);   Seq.Dialog.Mode = SEQ#EventMoveDialog;   if Move.Or.Copy = 0   then call Define.Label(S#AA,Row,0,0,'MOVE events by dragging or typing');   else call Define.Label(S#AA,Row,0,0,'COPY events by dragging or typing');   call Set.Default.Action(O#ACT.Middle.Press);   call PID(SEQ#Cancel,Define.Label(S#AA,Row,72,0,'[CANCEL]'));   if prev.obj.id = Seq.Event.Time.Table   then do;      call Fetch.Table.Cur.Cell(Seq.Event.Time.Table,loc(addr(tcol)));      call SELECT.NEW.CUR.OBJ(Seq.Event.Time.Table, tcol, trow);   end;   else call Select.New.Cur.Obj(GID(SEQ#Cancel),-1,-1);   call Activate.Object.Range(Seq.Dialog.First.Id,GID(SEQ#Cancel));   call Update.Object.Range  (Seq.Dialog.First.Id,GID(SEQ#Cancel));end OPEN.SEQ.EVENT.MOVE.DIALOG;OPEN.SEQ.TRACK.ERASE.DIALOG: proc swapable;   dcl row lit 'Seq.Dialog.Row';   call Setup.For.Dialog.Define;   call Highlight.Graphics.Button.Table(Display.Erase.Bounce.Clear, 1, 2, 0);   Seq.Dialog.Mode = SEQ#TrackEraseDialog;	/* Use button panel routine to figure out type of erase desired... */	   call CLEAR.ERAS.BUTTON;   call Process.Erase.Button;	do case (erase.style);	   	call Copy.String('Canot erase at this time', Misc.Buf);							/* ERASE.NO.STYLE			*/   			call Copy.String('Click again to ERASE the TEMPO MAP', Misc.Buf);				/* ERASE.TEMPO.MAP  		*/   		call Copy.String('Click again to ERASE the RECORDING TRACK', Misc.Buf);		/* ERASE.RECD.TRACK  	*/				call Copy.String('Click again to ERASE the HELD TRACK BUTTONS', Misc.Buf);	/* ERASE.HELD.TRACKS  	*/   		{																									/* ERASE.SOLOED.TRACKS 	*/			call Copy.String('Click again to ERASE ', Misc.Buf);			call Conv.Fixed.To.Str(Num.Of.Soloed.Tracks,0,cf#default,										  cf#unsigned|cf#append|cf#left|cf#nofill,Misc.Buf);			call Append.To.Str(Misc.Buf,' SOLOED track');			if Num.Of.Soloed.Tracks <> 1			then call Append.To.Str(Misc.Buf,'s');   	}				call Copy.String('Click again to ERASE ALL TRACKS', Misc.Buf);	   			/* ERASE.ALL.TRACKS	 	*/		end;	   call Define.Label(S#AA,Row,0,0,Misc.Buf);   call Set.Default.Action(O#ACT.Middle.Press);   call PID(SEQ#Cancel,Define.Label(S#AA,Row,72,0,'[CANCEL]'));   call Select.New.Cur.Obj(GID(SEQ#Cancel),-1,-1);   call Activate.Object.Range     (Seq.Dialog.First.Id,GID(SEQ#Cancel));   call Set.Seq.Dialog.Arrow.Links(Seq.Dialog.First.Id,GID(SEQ#Cancel));   call Update.Object.Range       (Seq.Dialog.First.Id,GID(SEQ#Cancel));   call Display.Sequencer.Status; /* display if keyboard there */end OPEN.SEQ.TRACK.ERASE.DIALOG;OPEN.SEQ.TRACK.BOUNCE.DIALOG: proc swapable;   dcl row lit 'Seq.Dialog.Row';   call Setup.For.Dialog.Define;   call Highlight.Graphics.Button.Table(Display.Erase.Bounce.Clear, 2, 2, 0);   Seq.Dialog.Mode = SEQ#TrackBounceDialog;   /*           1         2         3         4         5         6         7           */   /* 01234567890123456789012345678901234567890123456789012345678901234567890123456789  */   /* Click again to BOUNCE Sequence track [123] to track [123]. [COPY TRACK] [CANCEL]  */   call Define.Label(S#AA,Row, 0,0,'Click again to BOUNCE Sequence track [');   call Define.Label(S#AA,Row,41,0,'] to track [');   call Define.Label(S#AA,Row,56,0,'].');   call Set.Default.Attr(0,ATTR#Normal\ATTR#AltIntensity\ATTR#Reverse);   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse);   call Set.Default.Action(O#ACT.Left.Press|O#ACT.Middle.Press|O#ACT.Right.Press);   call PID(SEQ#FromTrack,Define.Fixed.Point(s#aa,Row,38,3,0,cf#unsigned|cf#left));   call PID(SEQ#ToTrack  ,Define.Fixed.Point(s#aa,Row,53,3,0,cf#unsigned|cf#left));   call Set.Default.Action(O#ACT.Middle.Press);   call Set.Default.Attr(0,ATTR#Normal\ATTR#AltIntensity);   call Set.Default.Attr(1,ATTR#Normal\ATTR#AltIntensity);   call PID(SEQ#Duplicate,Define.Label(S#AA,Row,59,0,'[COPY TRACK]'));   call PID(SEQ#Bounce   ,0);    /* default to non-replicate bounce */   call Set.Default.Attr(0,ATTR#Normal\ATTR#AltIntensity\ATTR#Reverse);   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse);   call PID(SEQ#Cancel,Define.Label(S#AA,Row,72,0,'[CANCEL]'));   Disable.Deposits=true;      call Deposit.Fixed.Point(GID(SEQ#FromTrack),-1);      call Deposit.Fixed.Point(GID(SEQ#ToTrack)  ,-1);      call PID(SEQ#Toggle,0);             /* first click goes to From Track */   Disable.Deposits=false;   call Select.New.Cur.Obj(GID(SEQ#FromTrack),-1,-1);   call Activate.Object.Range     (Seq.Dialog.First.Id,GID(SEQ#Cancel));   call Set.Seq.Dialog.Arrow.Links(Seq.Dialog.First.Id,GID(SEQ#Cancel));   call Update.Object.Range       (Seq.Dialog.First.Id,GID(SEQ#Cancel));end OPEN.SEQ.TRACK.BOUNCE.DIALOG;OPEN.SEQ.TRACK.CLEAR.SOLOS.DIALOG: proc swapable;   dcl row lit 'Seq.Dialog.Row';   call Setup.For.Dialog.Define;   call Highlight.Graphics.Button.Table(Display.Erase.Bounce.Clear, 4, 2, 0);   Seq.Dialog.Mode = SEQ#TrackClearSolosDialog;   call Define.Label(S#AA,Row,0,0,'Click again to CLEAR SOLOS on all tracks.');   call Set.Default.Action(O#ACT.Middle.Press);   call PID(SEQ#Cancel,Define.Label(S#AA,Row,72,0,'[CANCEL]'));   call Select.New.Cur.Obj(GID(SEQ#Cancel),-1,-1);   call Activate.Object.Range     (Seq.Dialog.First.Id,GID(SEQ#Cancel));   call Set.Seq.Dialog.Arrow.Links(Seq.Dialog.First.Id,GID(SEQ#Cancel));   call Update.Object.Range       (Seq.Dialog.First.Id,GID(SEQ#Cancel));end OPEN.SEQ.TRACK.CLEAR.SOLOS.DIALOG;OPEN.SEQ.RIPPLE.VERIFY.DIALOG: proc swapable;   dcl row lit 'Seq.Dialog.Row';   call Setup.For.Dialog.Define;   Seq.Dialog.Mode = SEQ#RippleVerifyDialog;   call Define.Label(S#AA,Row,0,0,'Click "Verify" to perform ripple edit');   call Set.Default.Action(O#ACT.Middle.Press);   call PID(SEQ#Cancel,Define.Label(S#AA,Row,72,0,'[CANCEL]'));   /* do not select a new object here because the user is probably */   /* trying to type in an end time.                               */   call Activate.Object.Range(Seq.Dialog.First.Id,GID(SEQ#Cancel));   call Update.Object.Range  (Seq.Dialog.First.Id,GID(SEQ#Cancel));end OPEN.SEQ.RIPPLE.VERIFY.DIALOG;/* $page - routine to change track soloing after clicking on top-row boxes: */TOGGLE.SEQ.TRACK.DISPLAY.SOLO: proc (col) swapable;   dcl col fixed; /* which column of display to toggle solo on */   dcl trk fixed;   dcl i   fixed;   trk=TrkIndex(col);           /* abs trk this column maps to */   if trk <= 0                  /* skip toggle if no trk index */   then return;                 /* assigned!!!                 */   if Seq.Track.Solo.Buttons <> 0   then do;      write(mam)=TBut.Ptr;      write(mal)=trk;      if (read(md)&b.soloed.trk)=0 /* track is not soloed */      then i=1;                    /* highlight, since it will become soloed */      else i=0;                    /* about to get un-soloed */      call Highlight.Graphics.Button.Table.Entry(Seq.Track.Solo.Buttons+Col,0,0,I,2,0);   end;   call Toggle.Track.Solo.State(trk);   call REFRESH.SEQ.TRACK.SOLO.DISPLAY;   /* re-open erase dialog as tracks are selected */   if Seq.Dialog.Mode = SEQ#TrackEraseDialog   then call OPEN.SEQ.TRACK.ERASE.DIALOG;end TOGGLE.SEQ.TRACK.DISPLAY.SOLO;/* $page - subroutines for editing sequences              *//* Routine to find the starting time of a display row.    *//* returns track # with the time,  or -1 if no track      */Find.Row.Time: proc(row, time) swapable;   dcl row    fixed;   dcl time   array;   dcl (i,j)  fixed;   if row >= Seq.Event.Display.Size   /* if off end of current snapshot */   then return (-1);                  /* then gonzo                     */   if row < 0                         /* if off end of current snapshot */   then return (-1);                  /* then gonzo                     */   i = 0;   j = false;   do while (i < Seq.Tracks) & (j = false);  /* Loop over all tracks until one with a time in it occurs */      write(mam) = AEE.Cur.Seq.Snap+i;       /* track sector */      write(mal) = INDEX.START+row;          /* row index */      if read(md) <> 0 then j = true;        /* index <> 0 means a note is there */      else i = i + 1;                        /* index = 0 means must continue to search */   end;   if j = false then return -1;            call Get.Snapshot.Info(AEE.Cur.Seq.Snap,i,TRKINDEX,row);   call COPY32(loc(addr(#NMSB)), time);   return i;end Find.Row.Time;/* $page - routines to edit note times *//* find.note - scroll sequence display (etc) to where the new note is: */dcl Advance.AEE.Snapshot.By.1.Line proc recursive;dcl Backup.AEE.Snapshot.By.1.Line  proc recursive;Find.Note: proc(NewTime, w1, w2, w3, w4, trk, orow, code, selected) swapable;   dcl Newtime            array;   dcl (w1, w2, w3, w4)   fixed;   dcl (trk, orow     )   fixed;   dcl (code          )   fixed;   dcl (selected      )   fixed;   dcl (BackedUp      )   fixed;   dcl (Scrolled      )   fixed;   dcl (Origtime)   (1)   fixed;   dcl (OrigSkip      )   fixed;   dcl (AnyMatch      )   fixed;   dcl (i, row)           fixed;   /* See if we will match any note on that track at that time     */   if (w1 = (-1)) & (w2 = (-1)) & (w3 = (-1)) & (w4 = (-1))   then AnyMatch = 1;   /* First see if new note is on same line of screen that it was: */   if  (orow >= 0)     /* if valid orow,  and note is on it,  use it */   and (Get.Snapshot.Info(AEE.Cur.Seq.Snap, trk, TRKINDEX, orow))   then do;      if  (#nmsb = NewTime(0))      and (#nlsb = NewTime(1))      and ((AnyMatch)      or   (((#w1&"174000") = (w1&"174000"))      and   (#w2 = w2)      and   (#w3 = w3)      and   (#w4 = w4)))      then do;         /* Found.  Make sure note(s) is/are selected still.  Will not */         /* be after a move:                                           */         if (Highlighted(orow) & selected) = 0         then do;            call Clear.All.Highlights;            do i = 0 to Seq.Tracks-1;               if (selected & bits(i)) <> 0               then call Set.Highlight(orow, i);            end;         end;         return;      end;   end;   call COPY32(Seq.Refresh.Time, OrigTime);   OrigSkip = Seq.Note.Skip;   /* Else note must have moved.  Try to find it.      */   look.for.note:;   /* Look in this current snapshot area for the note: */   row = 0;   i   = 0;   do while   (row < Seq.Event.Display.Size)   and        (i   = 0                     );      if Get.Snapshot.Info(AEE.Cur.Seq.Snap, trk, TRKINDEX, row)      then do;         if  (#nmsb = NewTime(0))         and (#nlsb = NewTime(1))         and ((AnyMatch)         or   (((#w1&"174000") = (w1&"174000"))         and   (#w2 = w2)         and   (#w3 = w3)         and   (#w4 = w4)))         then do;            i = 1;         end;         else row = row + 1;      end;      else row = row + 1;   end;   /* If note was found,  change highlighting to the new note */   /* if it is different:                                     */   if i <> 0 then do;      /* change highlighting if on different row */      if (row <> orow)      then do;         /* try to scroll the screen to put the new note back in */         /* the correct spot:                                    */         if  (orow     >= 0)   /* if valid orow    */         and (scrolled  = 0)   /* avoid inf. loops */         then do;            do while row < orow;               call Backup.AEE.Snapshot.By.1.Line;               row = row + 1;            end;            do while row > orow;               call Advance.AEE.Snapshot.By.1.Line;               row = row - 1;            end;            scrolled = 1;            goto Look.For.Note;         end;         /* select correct new start time field if desired: */         if code = 0         then call SELECT.NEW.CUR.OBJ(Seq.Event.Time.Table, 0, row);         else call SELECT.NEW.CUR.OBJ(Corner.Label,        -1, -1 );         /* show new time immediately so user does not get confused. */         Disable.Deposits = true;            call Enable.Table.Cell (Seq.Event.Time.Table, 0, row);            call Fetch.Table       (Seq.Event.Time.Table, 0, row);            call Deposit.32Bit.MSEC(Seq.Event.Time.Type, NewTime, Zero.Zero);            call Deposit.Table     (Seq.Event.Time.Table, 0, row);            Event.Time.Enabled = Event.Time.Enabled \ bits(row);            Seq.Refresh = Seq.Refresh \ 8; /* update screen eventually */         Disable.Deposits = false;         call Clear.All.Highlights; /* clear all highlights since we are on a */      end;                          /* different row now                      */      if (Highlighted(row) & selected) = 0      then do;         call Clear.All.Highlights;         do i = 0 to Seq.Tracks-1;            if (selected & bits(i)) <> 0            then call Set.Highlight(row, i);         end;      end;      return;  /* new note was found */   end;   /* If no matching note was find,  see if it is not on this panel: */   if  (COM32(NewTime, Seq.Refresh.Time) <> lw#ieq) /* take snapshot from */   then do;                                         /* new time if we     */      call COPY32(newtime, Seq.Refresh.Time);       /* have not already.  */      Seq.Note.Skip = 0;                            /* Start at the top   */      call Take.New.AEE.Snapshot;                   /* of a possible      */                                                    /* chord.             */      BackedUp    = 1;      goto Look.For.Note;   end;   if  (COM32(NewTime, Seq.Refresh.Time) =  lw#ieq) /* if we are displaying */   and (Seq.Note.Skip                    <> 0     ) /* in the middle of a   */   and (BackedUp                         =  0     ) /* chord, then back     */   then do;                                         /* up to start of       */      Seq.Note.Skip = 0;                            /* the chord.           */      call Take.New.AEE.Snapshot;      BackedUp    = 1;      goto Look.For.Note;   end;   if  (COM32(NewTime, Seq.Refresh.Time) =  lw#ieq) /* if we are displaying */   and (COM32(NewTime, Seq.Screen.End  ) =  lw#ieq) /* a chord that will    */   then do;                                         /* not fit on the       */      Seq.Note.Skip = Seq.Note.Skip                 /* screen, then         */                    + Seq.Event.Display.Size;       /* scroll forward to    */      call Take.New.AEE.Snapshot;                   /* try to find note.    */      BackedUp    = 1;      goto Look.For.Note;   end;   /* Ooops.  Cannot find new note.  Reset snapshot to where it was: */   call Clear.All.Highlights;   call COPY32(OrigTime, Seq.Refresh.Time);   Seq.Note.Skip = OrigSkip;   call Take.New.AEE.Snapshot;   call SELECT.NEW.CUR.OBJ(Corner.Label, -1, -1 );end Find.Note;