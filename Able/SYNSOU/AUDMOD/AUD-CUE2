/*	:SYNSOU:AUDMOD:AUD-CUE2 - More Insert file for AUD-CUEModified:2001/01/29 - TY  - Fixed a yucky bug in the Optical.Group block of SWITCH.CURRENT.CUE().						 Removed lots of unused automatic variables.1989/06/14 - cj  - added "smart" dialog boxes to save.current.cue to						 avoid confusion when changing to events.  Change						 to recall.current.cue.by.id to set recall pointers						 correctly.1989/05/24 - cj  - made play.current.cue smarter to handle fade in/out1989/05/05 - cj  - modified recall.current.cue.by.id to handle events1989/05/03 - TSS - Merged changes for Optical disk to DTD transfer project1989/03/22 - MWH - No error playing between edit points if they are the same1988/10/24 - cj  - Delete incomplete references to TSM Cue Name1988/09/07 - MWH - Add "real" DSP user interface1988/08/08 - cj  - store absolute # of smpte bits with cue sync time1988/05/24 - TSS - added a new stop code to PLAY.CURRENT.CUE*/UPDATE.UNDO.BUFFER: proc swapable;	/*	could copy from current cue ptr	*/	/*	to an undo buffer somewhere		*/end UPDATE.UNDO.BUFFER;CHECK.CURRENT.CUE.PROTECT: proc (group) returns (fixed) swapable;	dcl group	fixed;	if Current.Cue.Protect <> 0	then do;		call Get.Cue.Dialog(group,7);		return false;	end;	else return true;end CHECK.CURRENT.CUE.PROTECT;/*	$page - recall a cue by id	*//*	used by cue directory (etc) to recall a cue	*/RECALL.CURRENT.CUE.BY.ID: proc (id,code,arg1) public swapable;	dcl id					fixed;	dcl code					fixed;	/*	0,1: arg1 is sync time	*/											/*	2  : arg1 is an event	*/	dcl arg1					array;	/*	possible new sync time	*/	dcl our.new.sync(1)	fixed;	dcl temp(4)				fixed;	dcl rlen					fixed;	dcl new.sync	lit 'arg1';	dcl Event		lit 'arg1';	if code = 2										/*	if event pointer is passed,	*/	then do;											/*	then save info away				*/		call blockmove(Event, Recalled.Event.Spointer, spointer.record.size);		call Map.Sequence.Time.To.Real.Time(loc(addr(Event(event.time.msb))), our.new.sync);	end;	else do;		call COPY32(new.sync,our.new.sync);	/*	copy sync time over in case we use push.system.pdl some day	*/	end;	if id <=0 then return;						/*	return if no id					*/	if DTD.Max.Secs <> 0 then do;		if Fetch.Entire.DTD.Cue(id,Cue.Build.Ptr) = 0		then do;			return;		end;		write(mam) = Cue.Build.Ptr;		write(mal) = CUE.RLEN;		rlen		  = read(md);		call Update.Undo.Buffer;			/*	Save current cue for prior undo	*/		if  (COM16(zero.time,our.new.sync)	<= lw#ieq)	/*	if new sync time passed	*/		and (Current.Sync.Locked = 0						)	/*	and sync not locked		*/		then do;			write(mam) = Cue.Build.Ptr;			call COPY.IN(addr(Misc.Buf(0)),CUE.NAME);			/*	set saved switch setting to pre.  Indicate ABSOLUTE smpt.msb	*/			Misc.Buf(CUE.BITS) = Misc.Buf(CUE.BITS) & (not(bit1\bit2)) \ bit3;			call MSEC.TO.SMPTE(Our.New.Sync, cf#time, SAMP.SPEED, SM.MODE, loc(addr(SM.HRS)), temp);			call SMPTE.TO.SBITS (temp, SM.MODE, loc(addr(Misc.Buf(CUE.SMPT.MSB))));			Misc.Buf(CUE.SMPT.MODE) = SM.MODE;			write(mam) = Cue.Build.Ptr;			call COPY.OUT(addr(Misc.Buf(0)),CUE.NAME);		end;		call Set.DTD.Current.Reel(0);	/*	Select "CUE" reel		*/		call Display.Current.Reel;		/*	set display quickly	*/		call COPY.EXT.MEM(Cue.Build.Ptr,0,Current.Cue.Ptr,0,rlen);		/*	Now update cue information for event:	*/		if  (code = 2)	/*	if an event record was passed to us	*/		and (event(event.type) = event.type.event)	/*	that is indeed event	*/		then do;			write(mam) = Current.Cue.Ptr;			call COPY.IN(addr(MISC.BUF(0)), CUE.NAME);			call ADD32(loc(addr(event(event.in.msb))),						  loc(addr(misc.buf(EVENT.IN.S#.MSB))),						  loc(addr(misc.buf(CUE.S.MSB))));			call ADD32(loc(addr(event(event.out.msb))),						  loc(addr(misc.buf(EVENT.IN.S#.MSB))),						  loc(addr(misc.buf(CUE.E.MSB))));			call ADD32(loc(addr(event(event.mark.msb))),						  loc(addr(misc.buf(EVENT.IN.S#.MSB))),						  loc(addr(misc.buf(CUE.OFF.MSB))));			call COPY32(loc(addr(misc.buf(CUE.OFF.MSB))),							loc(addr(misc.buf(CUE.EDIT.IN.MSB))));			misc.buf(CUE.FIN)  = event(event.fade.in);			misc.buf(CUE.FOUT) = event(event.fade.out);			write(mam) = Current.Cue.Ptr;			call COPY.OUT(addr(MISC.BUF(0)), CUE.NAME);			call STORE.NEW.CUE.CAPTION(loc(addr(event(event.caption))));		end;		call Deposit.A.New.Current.Cue(1);		call Display.AEE.Cue.Names;	end;end RECALL.CURRENT.CUE.BY.ID;SWITCH.CURRENT.CUE: proc (group) PUBLIC swapable;	/*	Assumes a mouse click on switch has just occurred	*/	dcl group		fixed;	dcl p.y			fixed;	dcl t.y			fixed;	dcl dir			fixed;	dcl tmp(17-1)	fixed;	if group = Cue.Group then do;		call Fetch.String			  (Cue.Name.Id, tmp);	end;	else if group = Record.Group then do;		call Fetch.Graphics.String(Record.TSM.Name.Id, tmp);	end;	else if group = Optical.Group then do;		//	call Fetch.String		  (Optical.Cue.Name,tmp);	<<==	NO DAMNED GOOD		//	Note: Shuttle.Name.Id is defined only to hold 27 characters instead of the full 32 allocated to other cue name objects.		//	Consequently the call to Fetch String in the line above can yield a truncated cue name.  This causes the call to		//	SCROLL.DTD.CURRENT.CUE() below to fail to advance to the subsequent cue.		//	For now the solution is to get the full cue name from the current cue record rather than from the truncated string object.		write(mam) = Current.Cue.Ptr;		write(mal) = CUE.NAME;		call COPY.IN(addr(tmp(0)), 17);	end;	else do;		call Fetch.String			  (Shuttle.Name.Id, tmp);	end;	/*	Compute direction based upon where the user clicked:	*/	p.y = mouse(press.y);	t.y = tpos.y(p.y);	if p.y > gpos.y(t.y*100-50) then	dir = 0;	else										dir = 1;	if SCROLL.DTD.CURRENT.CUE(tmp, dir) == 1 then do;		if dir = 0 then call Display.Notice(NT#TopOfAlphaList,	ATTR#Reverse,NulStr,0,0,0);		else				 call Display.Notice(NT#BottomOfAlphaList,ATTR#Reverse,NulStr,0,0,0);	end;	else call Display.AEE.Cue.Names;	/*	provide SNAPPY name update	*/end SWITCH.CURRENT.CUE;/*	Called from both shuttle and cue edit panels				*//*	note: all times are in/out times with respect to the	*//*	current cue map (if any)										*/PLAY.CURRENT.CUE: proc(startcode,backup,stopcode,drive.bits,tempcue) public swapable;	dcl startcode	fixed;	/*	See the operating system routine	*/	dcl backup		fixed;	/*	"PLAY.DTD.CURRENT.CUE" for a		*/	dcl stopcode	fixed;	/*	description of these arguments	*/	dcl drive.bits	fixed;	dcl tempcue		fixed;	dcl i				fixed;	i = PLAY.DTD.CURRENT.CUE(startcode,backup,stopcode,drive.bits,tempcue);	if i = 1	then call Display.Notice(NT#NoDrivesSoloed,ATTR#Reverse,NulStr,0,0,0);	if i = 2	then call Display.Notice(NT#InTimeEqualsOutTime,ATTR#Reverse,NulStr,0,0,0);end PLAY.CURRENT.CUE;/*	$page - routine to save current cue to disk		*//*	Save Current Cue takes the current cue pointed	*//*	to by Current.Cue.Ptr and saves it on				*//*	the direct to disk										*//*	First a subroutine to see if the replace			*//*	pointers point to an event that uses a				*//*	particular cue:											*/Investigate.Replace.Pointers: proc (cueid, Replpointer) swapable;	dcl cueid			fixed;	/*	pass id of cue in question	*/	dcl Replpointer	array;	/*	pointer into sequence		*/	dcl event(event.record.size-1)	fixed;	call blockmove(Replpointer, Event, spointer.record.size);	if Get.Sequencer.Event.Information(Event) <> Good.Event.Status	then return 0;								/*	must not if not avail		*/	if  ((event(event.type  ) = event.type.cue  )	or   (event(event.type  ) = event.type.event))	and ( event(event.cue.id) = cueid				)	then return 1;								/*	yes - they use this cue		*/	else return 0;								/*	no  - they do not use it	*/end Investigate.Replace.Pointers;dcl Events.That.Will.Be.Modified	fixed;SAVE.CURRENT.CUE: proc (group) returns (fixed) PUBLIC swapable;	dcl group						fixed;	dcl cue.length					fixed;	dcl (amsb,alsb,bmsb,blsb)	fixed;	dcl tmp(17-1)					fixed;	dcl Current.Cue.Id			fixed;	dcl output(1)					fixed;	dcl replinfo					fixed;	if DTD.Max.Secs <> 0 then do;		/*	disallow save on top of protected cue	*/		if Check.Current.Cue.Protect(group) = 0 then return 0;		write(mam) = Current.Cue.Ptr;		write(mal) = Cue.Name;		if read(md) = 0		then do;			call Increment.Cue.Name;		/*	get default if no string	*/		end;		write(mam) = Current.Cue.Ptr;		write(mal) = Cue.Name;		call COPY.IN(addr(tmp(0)), 17);		if tmp(0) == 0 then return 0;		Current.Cue.Id = Locate.DTD.Cue(tmp);	/*	see if saved - look in cur project first	*/		if Current.Cue.Id = 0 then do;			/*	no cue exists - save it		*/			Current.Cue.Id = DEFINE.ENTIRE.DTD.CUE.WITH.ERROR.MESSAGES(Current.Cue.Ptr);		end;		else do;											/*	cue exists - see if used	*/			call Count.DTD.Cue.Useage(Current.Cue.Id, Output);	/*	output 0 = # of cue triggers.  output(1) = # of event triggers	*/			replinfo = Investigate.Replace.Pointers(Current.Cue.Id, Recalled.Event.Spointer);			if (output(0)\output(1)) = 0			/*	not used in sequence - replace it	*/			then Current.Cue.Id = REPLACE.ENTIRE.DTD.CUE(Current.Cue.Id, Current.Cue.Ptr);			/*	else if cue is already saved and used ONCE in the current	*/			/*	sequence and the replace pointers point to that					*/			/*	usage, then give 'Also replace cue in sequence?' dialog		*/			else if ((output(0) + output(1))	= 1)	/*	if used once			*/			and	  (replinfo						= 1)	/*	and pointers set		*/			then do;				/*	Also save in sequence - yes, no, cancel	*/				replinfo = Get.Cue.Dialog(group,12);	/*	0 = cancel. 1 = no. 2 = yes	*/				if replinfo = 0 then return 0;			/*	cancel	*/				Current.Cue.Id = REPLACE.ENTIRE.DTD.CUE(Current.Cue.Id, Current.Cue.Ptr);				if  (Current.Cue.Id > 0)					/*	if replace was ok					*/				and (replinfo		  = 2)					/*	and replace in seq desired		*/				then do;											/*	then do so							*/					call Handle.AEE.Cue.Place(Recalled.Event.Spointer, 1);					Current.Cue.Id = 0;						/*	to skip 'cue is saved' message below	*/				end;			end;			/*	else of cue is already saved and used more than once in	*/			/*	the current sequence (or used once and the replace			*/			/*	pointers do not point to that usage)							*/			else do;				/*	see if map/tracks has change (for either events or cues),	*/				/*	or see if in/out times have changed (for cues only)			*/				call FETCH.ENTIRE.DTD.CUE (Current.Cue.Id, Scsi.Ptr);	/*	get cue			*/				if  (Compare.DTD.Cue.Tracks(Current.Cue.Ptr, Scsi.Ptr) = 0)	/*	tracks differ	*/				or  (Compare.DTD.Cue.Maps	(Current.Cue.Ptr, Scsi.Ptr) = 0)	/*	maps   differ	*/				or  ((output(0) <> 0)	/*	simple cue trigger used	*/			/*	with new time	*/				and  (Compare.DTD.Cue.Times(Current.Cue.Ptr, Scsi.Ptr) = 0))				then do;					/*	Warning: saving this cue will modify 99 events in your sequence [OK] [CANCEL]	*/					Events.That.Will.Be.Modified = output(0) + output(1);					if Get.Cue.Dialog(group,14) = 0 then return 0;					Current.Cue.Id = REPLACE.ENTIRE.DTD.CUE(Current.Cue.Id, Current.Cue.Ptr);				end;				/*	else saving cue will not affect sequence	*/				else do;					/*	Note: saving this cue will not affect your sequence   [OK]    [CANCEL]	*/					if Get.Cue.Dialog(group,13) = 0 then return 0;					Current.Cue.Id = REPLACE.ENTIRE.DTD.CUE(Current.Cue.Id, Current.Cue.Ptr);				end;			end;		end;		if Current.Cue.Id > 0 then call Display.Notice(NT#CueSaved,ATTR#Normal, tmp, 0, 0, 0);		else Current.Cue.Id = 0;		call UnSet.Cue.Modified;		return Current.Cue.Id;	end;	else return 0;end SAVE.CURRENT.CUE;/*	$page - rename cue	*/RENAME.CURRENT.CUE: proc (group) swapable;	dcl group				fixed;	dcl nam(17-1)			fixed;	dcl Current.Cue.Id	fixed;	if Check.Current.Cue.Protect(group) = 0 then do;		return;	end;	if group = Cue.Group	then call Fetch.String(Cue.Name.Id,nam);	else call Fetch.String(Shuttle.Name.Id,nam);	Current.Cue.Id = Locate.DTD.Cue(nam);	if Current.Cue.Id = 0 then do;		call Display.Notice(NT#MustSaveCueBeforeRename,ATTR#Reverse,NulStr,0,0,0);		return;	end;	if Get.Cue.Dialog(group,2) <> 0 then do;	/*	get new name	*/		write(mam) = SCSI.Ptr;				//	This is where Get.Cue.Dialog() stashed the new cue name		write(mal) = CUE.NAME;		call Copy.In(addr(nam(0)), 17);		do while Locate.DTD.Cue(nam)<>0;	//	keep asking for a different name as long as the one submitted is already in use			if Get.Cue.Dialog(group,3) = 0 then do;				return;			end;			write(mam) = SCSI.Ptr;			write(mal) = CUE.NAME;			call Copy.In(addr(nam(0)), 17);		end;		call Store.New.Cue.Name(nam);		if Current.Cue.Id <> 0 then do;	/*	replace model - in current proj first, or anywhere on disk	*/			Current.Cue.Id = REPLACE.ENTIRE.DTD.CUE(Current.Cue.Id, Current.Cue.Ptr);		end;		else do;			Current.Cue.Id = DEFINE.ENTIRE.DTD.CUE.WITH.ERROR.MESSAGES(Current.Cue.Ptr);		end;		if Current.Cue.Id > 0 then call Display.Notice(NT#CueSaved,ATTR#Normal,nam,0,0,0);		else Current.Cue.Id = 0;		call UnSet.Cue.Modified;	end;end RENAME.CURRENT.CUE;/*	$page - recall cue by name	*/RECALL.CURRENT.CUE: proc (group) swapable;	dcl group					fixed;	dcl tmp(17-1)				fixed;	dcl i							fixed;	dcl Aud.Buf (CUE.NAME)	fixed;	if DTD.Max.Secs <> 0 then do;		if 0 then do;			/*	numerous problems with reels here	*/			if Current.Cue.Mod <> 0 then do;				if Get.Cue.Dialog(group,1) = 0 then do;					return;				end;				Current.Cue.Mod = 0;			end;		end;		/*	get.cue.dialog(6) returns the name	*/		/*	in scsi.ptr									*/		if Get.Cue.Dialog(group,6) <> 0 then do;	/*	Name of cue to recall?	*/			call Update.Undo.Buffer;			/*	Save current cue	*/			write(mam) = SCSI.Ptr;			write(mal) = CUE.NAME;			call Copy.In(addr(tmp(0)), 17);			call Set.DTD.Scroll.Range(Default.CM.Display.Switch + GID(Saved.CM.Display.Switch));			i = Locate.DTD.Cue(tmp);			if i=0 then do;									/*	not found - get	*/				i = Fetch.Next.Alpha.DTD.Cue;				/*	next forward		*/				if i = 0											/*	or backwards		*/				then i = Fetch.Previous.Alpha.DTD.Cue;	/*	cue					*/			end;			if i > 0 then do;				call Fetch.Entire.DTD.Cue(i,Cue.Build.Ptr);	/*	Read in the cue	*/				write(mam) = Cue.Build.Ptr;				call COPY.IN(addr(aud.buf(0)),CUE.NAME);				call Stop.DTD.Playback;				call Set.DTD.Current.Reel(0);	/*	Select "CUE" reel		*/				call Display.Current.Reel;		/*	set display quickly	*/				call COPY.EXT.MEM(Cue.Build.Ptr,0,Current.Cue.Ptr,0,Aud.Buf(CUE.RLEN));				call Deposit.A.New.Current.Cue(1);				call Display.AEE.Cue.Names;				call UnSet.Cue.Modified;			end;			else call Display.Notice(NT#CueDoesNotExist, ATTR#Reverse, tmp, 0, 0, 0);		end;	end;end RECALL.CURRENT.CUE;/*	$page - delete current cue	*//*	used to delete the cue of the current name	*/DELETE.CURRENT.CUE: proc (group) swapable;	dcl group				fixed;	dcl tmp(17-1)			fixed;	dcl Current.Cue.Id	fixed;	if DTD.Max.Secs <> 0 then do;		if Group = Cue.Group		then call Fetch.String(Cue.Name.Id, tmp);		else call Fetch.String(Shuttle.Name.Id, tmp);		Current.Cue.Id = LOCATE.DTD.CUE(tmp);		if Current.Cue.id = 0 then do;			call Display.Notice(NT#CannotDeleteUnsavedCue, ATTR#Reverse, NulStr, 0, 0, 0);			return;		end;		if Check.Current.Cue.Protect(group) = 0 then do;			return;		end;		if Get.Cue.Dialog(group,5) <> 0 then do;			call DELETE.DTD.CUE(Current.Cue.Id);			call Display.Notice(NT#CueDeleted,ATTR#Normal, tmp, 0, 0, 0);			call UnSet.Cue.Modified;		end;	end;end DELETE.CURRENT.CUE;/*	$page - toggle current cue protect				*//*	called to change the protect status of a cue	*//*	cue must be saved to do this						*/TOGGLE.CURRENT.CUE.PROTECT: proc swapable;	dcl Current.Cue.Id	fixed;	dcl tmp(17-1)			fixed;	write(mam) = Current.Cue.Ptr;	write(mal) = CUE.NAME;	call COPY.IN(addr(tmp(0)), 17);	Current.Cue.Id = Locate.DTD.Cue(tmp);	if Current.Cue.Id <> 0 then do;		/*	name exists - toggle & save	*/		Current.Cue.Protect = Current.Cue.Protect xor 1;		call Display.Current.Cue.Protect;		if Cue.Group	  <> 0 then call Update.Object(Cue.Protect.Indicator);		if Shuttle.Group <> 0 then call Update.Object(Shuttle.Protect.Indicator);		call UPDATE.CURRENT.CUE.RECORD;	/*	update ext mem copy for adjusted values	*/		if Current.Cue.Id <> 0 then do;			/*	replace model - in current proj first, or anywhere on disk	*/			Current.Cue.Id = REPLACE.ENTIRE.DTD.CUE(Current.Cue.Id, Current.Cue.Ptr);		end;		else do;			Current.Cue.Id = DEFINE.ENTIRE.DTD.CUE.WITH.ERROR.MESSAGES(Current.Cue.Ptr);		end;		if Current.Cue.Id > 0 then call Display.Notice(NT#CueSaved, ATTR#Normal, tmp, 0, 0, 0);		else Current.Cue.Id = 0;		call UnSet.Cue.Modified;	end;	else do;		if Current.Cue.Protect = 0		/*	trying to protect cue that is not saved?	*/		then call Display.Notice(NT#MustSaveCueBeforeProtect, ATTR#Reverse, NulStr, 0, 0, 0);		else do;			Current.Cue.Protect = Current.Cue.Protect xor 1;			call Display.Current.Cue.Protect;	/*	turning off protect for unsaved cue?	*/		end;	end;end TOGGLE.CURRENT.CUE.PROTECT;/*	$page - undo routines	*//*	not used as of 9/26/87	*/UNDO.CURRENT.CUE: proc swapable;	/*	nothing yet	*/end UNDO.CURRENT.CUE;UPDATE.CUE.PANEL: proc public swapable;	/*	recompute all cue times (etc) since cur project sampling	*/	/*	rate may have changed												*/	/*	only update here if shuttle is not going to do it for		*/	/*	us																			*/	if Shuttle.Group = 0	then call Display.Cue.And.Shuttle.Displays;end UPDATE.CUE.PANEL;