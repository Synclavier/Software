/* EDIT  $TITLE  A Driver Program for Cue Editing Commands */dcl initialization proc  external;dcl Cue.Build.Ptr  fixed external; /* work cue record buffer */insert ':synlits:comlits';insert ':synlits:globlits';insert ':synauxs:lodlits';insert ':synmods:globdcl';insert ':synmods:xmemdcl';insert ':synmods:leditdcl';insert ':synmods:syndummy';disable; /* turn of interrupts for debug prints *//* $SUBTITLE */SETUP.NULL.CUE: proc (Cue.Ptr,Name) public swapable;   dcl Cue.Ptr fixed;   dcl Name    array;   dcl I       fixed;   write(mam)=Cue.Ptr;   do I=0 to Max.Cue.Record.Len-1; /* zero out cue info */      write(mdi)=0;   end;   write(mam)=Cue.Ptr;   write(mal)=Cue.S.Msb; write(mdi)= 0; write(md)= 0; /* initialize IN & OUT times */   write(mal)=Cue.E.Msb; write(mdi)=-1; write(md)=-1;   write(mal)=Cue.Trks;  write(md )=1; /* turn on trk 1 only */   write(mal)=Cue.Name;   do i=0 to shr(Name(0)+1,1);     /* stuff name into cue record */      write(mdi)=Name(i);   end;   call Cue.Store(Cue.Ptr,Cue.RLen,Cue.Name+1+shr(Name(0)+1,1)); /* set length to reflect name */end SETUP.NULL.CUE;DISPLAY.EDIT.SEGMENT: proc (Cue.Ptr,Seg#) public swapable;   dcl Cue.Ptr            fixed;   dcl (Seg#,MaxSeg#,Ptr) fixed;   MaxSeg#=Cue.Lookup(Cue.Ptr,Cue.List.Len)/Cue.Seg.Stride;   if Seg# IGT MaxSeg# then do;      print 'Edit Segment out of range: ',Seg#,'   Max Segment: ',MaxSeg#;   end;   else do;      Ptr=Cue.Lookup(Cue.Ptr,Cue.List.Ptr)+Seg#*Cue.Seg.Stride;      write(mam)=Cue.Ptr+shr(Ptr,8);      write(mal)=Ptr;      print 'Seg#',Seg#,':',;      print ' At Time:'  ,read(mdi),read(mdi),;      print ' Play from:',read(mdi),read(mdi),;      print ' to:'       ,read(mdi),read(mdi);   end;end DISPLAY.EDIT.SEGMENT;DISPLAY.CUE: proc (Cue.Ptr) public swapable;   dcl Cue.Ptr       fixed; /* external memory sector ptr to cue to display */   dcl Name  (1+shr(Cue.Name.L+1,1)) fixed;   dcl (RLen,SLen,I) fixed;   write(mam)=Cue.Ptr;   write(mal)=Cue.Name;   do I=0 to shr(read(md)+1,1); Name(I)=read(mdi); end;   print 'Reel "',String(Name),'" (@ Sector ',Cue.Ptr,')';   print 'Cue Record Len: '      ,Cue.Lookup(Cue.Ptr,Cue.RLen);   print 'EDL Ptr: '  ,Cue.Lookup(Cue.Ptr,Cue.List.Ptr),;   print '  EDL Len: ',Cue.Lookup(Cue.Ptr,Cue.List.Len);   print 'Cue  In:  ',Cue.Lookup(Cue.Ptr,Cue.S.Msb),' ',Cue.Lookup(Cue.Ptr,Cue.S.Lsb),;   print '   Edit In:  ',Cue.Lookup(Cue.Ptr,Cue.Edit.In.Msb),' ', Cue.Lookup(Cue.Ptr,Cue.Edit.In.Lsb);   print 'Cue  Out: ',Cue.Lookup(Cue.Ptr,Cue.E.Msb),' ',Cue.Lookup(Cue.Ptr,Cue.E.Lsb),;   print '   Edit Out: ',Cue.Lookup(Cue.Ptr,Cue.Edit.Out.Msb),' ',Cue.Lookup(Cue.Ptr,Cue.Edit.Out.Lsb);   do I=0 to Cue.Lookup(Cue.Ptr,Cue.List.Len)/Cue.Seg.Stride-1;      call Display.Edit.Segment(Cue.Ptr,I);   end;   print;end DISPLAY.CUE;/* $SUBTITLE Main Driver for Edit Test Code */dcl Clip.Cue        fixed;        /* xmem ptr to clipboard cue */dcl Cue.A           fixed;        /* xmem ptr to user      cue */dcl (cmd,ok)     fixed;dcl (In,Out) (1) fixed;dcl C#Quit              lit '00'; /* literals for defined commands */dcl C#Init.Cue.A        lit '01';dcl C#Delete            lit '02';dcl C#Insert            lit '03';dcl C#Extract.Extend    lit '04';dcl C#Extract.No.Extend lit '05';dcl C#Fill.Leader       lit '06';dcl C#Copy              lit '07';dcl C#Cut               lit '08';dcl C#Slide             lit '09';dcl C#Mix               lit '100'; /* (was 09) */dcl C#Paste             lit '10';dcl C#Fill.Cue          lit '11';dcl C#Display           lit '12';dcl C#Exchange          lit '13';dcl C#Loop.Fill.Cue     lit '14';dcl C#Loop.Paste        lit '15';dcl C#Init.Clip         lit '16';DISPLAY.MENU: proc swapable;   print;   print ' 0. Quit';   print ' 1. Initialize Cue A Reel';   print ' 2. Delete Part of Reel';   print ' 3. Insert Leader on Reel';   print ' 4. Extract Part of Reel (w/ Extend)';   print ' 5. Extract Part of Reel (w/o Extend)';   print ' 6. Fill Reel with Leader';   print ' 7. Copy Part of Reel';   print ' 8. Cut Part of Reel';   print ' 9. Slide Edit Region (w/ Shuffle)';/* print ' 9. Mix Two Reels'; */   print '10. Paste One Reel into Another (w/o Looping)';   print '11. Fill One Reel with Another (w/o Looping)';   print '12. Display Cues';   print '13. Exchange ClipBoard with Edit Region';   print '14. Fill One Reel with Another (w/Looping)';   print '15. Paste One Reel into Another (w/Looping)';   print '16. Initialize Clipboard Reel';   print;end DISPLAY.MENU;GET.COMMAND: proc fixed swapable;   dcl cmd fixed;   print 'Enter command',; input cmd;   if cmd=0 then call exit(0);   else          return cmd;end GET.COMMAND;SET.EDIT.IN.AND.OUT: proc(Cue.Ptr,In,Out) swapable;   dcl Cue.Ptr  fixed;   dcl (In,Out) array;   print 'Enter Edit IN and OUT times (16-bit)',;   input In(1),Out(1);   In(0)=0; Out(0)=0;   write(mam)=Cue.Ptr;   write(mal)=Cue.Edit.In.Msb;  write(mdi)= In(0); write(md)= In(1);   write(mal)=Cue.Edit.Out.Msb; write(mdi)=Out(0); write(md)=Out(1);end SET.EDIT.IN.AND.OUT;SET.EDIT.IN.AND.LEN: proc(Cue.Ptr,In,Out) swapable;   dcl Cue.Ptr  fixed;   dcl (In,Out) array;   print 'Enter Edit Point and Len (16-bit)',;   input In(1),Out(1);   In(0)=0; Out(0)=0;   Out(1)=Out(1)+In(1);         /* convert length to end time */   if Out(1) ilt In(1) then Out(0)=Out(0)+1;   write(mam)=Cue.A;   write(mal)=Cue.Edit.In.Msb;  write(mdi)= In(0); write(md)= In(1);   write(mal)=Cue.Edit.Out.Msb; write(mdi)=Out(0); write(md)=Out(1);end SET.EDIT.IN.AND.LEN;/* $PAGE */Cue.A           =Alloc.Examount(shr(Max.Cue.Record.Len+255,8));Clip.Cue        =Alloc.Examount(shr(Max.Cue.Record.Len+255,8));Scratch.Cue.Ptr1=Alloc.Examount(shr(Max.Cue.Record.Len+255,8));Scratch.Cue.Ptr2=Alloc.Examount(shr(Max.Cue.Record.Len+255,8));Scratch.Cue.Ptr3=Alloc.Examount(shr(Max.Cue.Record.Len+255,8));Cue.Build.Ptr   =Alloc.Examount(shr(Max.Cue.Record.Len+255,8));if (Cue.A=0) or (Clip.Cue=0)or (Scratch.Cue.Ptr1=0)or (Scratch.Cue.Ptr2=0)or (Scratch.Cue.Ptr3=0)or (Cue.Build.Ptr=0) then do;   print 'Not enough memory to start up!';   call exit(0);end;print 'Cue.A     @ Sector',cue.a;print 'Clip.Cue  @ Sector',clip.cue;print 'Scratch 1 @ Sector',scratch.cue.ptr1;print 'Scratch 2 @ Sector',scratch.cue.ptr2;print 'Scratch 3 @ Sector',scratch.cue.ptr3;print 'Scratch 4 @ Sector',cue.build.ptr;print;call Initialization; /* do some syncl init */call Setup.Null.Cue(Cue.A   ,'A');call Setup.Null.Cue(Clip.Cue,'CLIPBOARD');call Initialize.Reel(Cue.A);call Display.Cue    (Cue.A);call Initialize.Reel(Clip.Cue);call Display.Cue    (Clip.Cue);do while 1;   call Display.Menu;   cmd=Get.Command;   if cmd=C#Init.Cue.A then do;      call Setup.Null.Cue (Cue.A,'A');      call Initialize.Reel(Cue.A);      call Display.Cue    (Cue.A);   end;   else if cmd=C#Init.Clip then do;      call Setup.Null.Cue (Clip.Cue,'ClipBoard');      call Initialize.Reel(Clip.Cue);      call Display.Cue    (Clip.Cue);   end;   else if cmd=C#Delete then do;      call Set.Edit.In.And.Out(Cue.A,In,Out);      print;   /***** DEBUG *****/      ok=Delete.from.Reel(Cue.A,Cue.A,false);      print;   /***** DEBUG *****/      if ok=E#Good       then call Display.Cue(Cue.A);      else print 'Not enough room in cue for edit';   end;   else if cmd=C#Insert then do;      call Set.Edit.In.And.Len(Cue.A,In,Out);      print;   /***** DEBUG *****/      ok=Insert.Leader.On.Reel(Cue.A,Cue.A,false);      print;   /***** DEBUG *****/      if ok=E#Good       then call Display.Cue(Cue.A);      else print 'Not enough room in cue for edit';   end;   else if cmd=C#Extract.Extend then do;      call Set.Edit.In.And.Out(Cue.A,In,Out);      print;   /***** DEBUG *****/      ok=Extract.from.Reel.With.Extend(Cue.A,Clip.Cue,true);      print;   /***** DEBUG *****/      if ok=E#Good       then call Display.Cue(Clip.Cue);      else print 'Not enough room in cue for edit';   end;   /* $PAGE */   else if cmd=C#Extract.No.Extend then do;      call Set.Edit.In.And.Out(Cue.A,In,Out);      print;   /***** DEBUG *****/      ok=Extract.from.Reel.Without.Extend(Cue.A,Clip.Cue,true);      print;   /***** DEBUG *****/      if ok=E#Good       then call Display.Cue(Clip.Cue);      else print 'Not enough room in cue for edit';   end;   else if cmd=C#Fill.Leader then do;      call Set.Edit.In.And.Out(Cue.A,In,Out);      print;   /***** DEBUG *****/      ok=Fill.Reel.With.Leader(Cue.A,Cue.A,false);      print;   /***** DEBUG *****/      if ok=E#Good       then call Display.Cue(Cue.A);      else print 'Not enough room in cue for edit';   end;   else if cmd=C#Copy then do;      call Set.Edit.In.And.Out(Cue.A,In,Out);      print;   /***** DEBUG *****/      ok=Copy.From.Reel(Cue.A,Clip.Cue,true);      print;   /***** DEBUG *****/      if ok=E#Good       then call Display.Cue(Clip.Cue);      else print 'Not enough room in cue for edit';   end;   else if cmd=C#Cut then do;      call Set.Edit.In.And.Out(Cue.A,In,Out);      print;   /***** DEBUG *****/      ok=Cut.From.Reel(Cue.A,Cue.A,Clip.Cue,false,true);      print;   /***** DEBUG *****/      if ok=E#Good then do;         call Display.Cue(Cue.A);         print;         call Display.Cue(Clip.Cue);      end;      else print 'Not enough room in cue for edit';   end;   /* $PAGE */   else if cmd=C#Paste then do;      call Set.Edit.In.And.Out(Cue.A,In,Out);      print;   /***** DEBUG *****/      ok=Paste.Into.Reel(Cue.A,Clip.Cue,Cue.A,false,false);      print;   /***** DEBUG *****/      if ok=E#Good then do;         call Display.Cue(Cue.A);         print;         call Display.Cue(Clip.Cue);      end;      else print 'Not enough room in cue for edit';   end;   else if cmd=C#Loop.Paste then do;      call Set.Edit.In.And.Out(Cue.A,In,Out);      print;   /***** DEBUG *****/      ok=Paste.Into.Reel(Cue.A,Clip.Cue,Cue.A,false,true);      print;   /***** DEBUG *****/      if ok=E#Good then do;         call Display.Cue(Cue.A);         print;         call Display.Cue(Clip.Cue);      end;      else print 'Not enough room in cue for edit';   end;   else if cmd=C#Fill.Cue then do;      call Set.Edit.In.And.Out(Cue.A,In,Out);      print;   /***** DEBUG *****/      ok=Fill.Reel(Cue.A,Clip.Cue,Cue.A,false,false);      print;   /***** DEBUG *****/      if ok=E#Good then do;         call Display.Cue(Cue.A);         print;         call Display.Cue(Clip.Cue);      end;      else print 'Not enough room in cue for edit';   end;   else if cmd=C#Loop.Fill.Cue then do;      call Set.Edit.In.And.Out(Cue.A,In,Out);      print;   /***** DEBUG *****/      ok=Fill.Reel(Cue.A,Clip.Cue,Cue.A,false,true);      print;   /***** DEBUG *****/      if ok=E#Good then do;         call Display.Cue(Cue.A);         print;         call Display.Cue(Clip.Cue);      end;      else print 'Not enough room in cue for edit';   end;   else if 0&cmd=C#Slide then do;      call Set.Edit.In.And.Out(Cue.A,In,Out);      print;   /***** DEBUG *****/      ok=Slide.Edit.Region(In,Out,In,Cue.A,Clip.Cue,-1);      print;   /***** DEBUG *****/      if ok=E#Good then do;         call Display.Cue(Clip.Cue);      end;      else do;         print 'Not enough room in cue for edit';      end;   end;   else if 0&cmd=C#Mix then do;      /* MIX.REELS: proc(Reel1.Ptr,Reel2.Ptr,Des.Ptr,Protect.Des.Name) fixed public swapable; */      ok=Copy.From.Reel(Cue.A,Clip.Cue,true);      print;   /***** DEBUG *****/      if ok=E#Good then do;         call Display.Cue(Clip.Cue);      end;      else do;         print 'Not enough room in cue for edit';      end;   end;   else if cmd=C#Display then do;      call Display.Cue(Cue.A);      print;      call Display.Cue(Clip.Cue);   end;   else if cmd=C#Exchange then do;      call Set.Edit.In.And.Out(Cue.A,In,Out);      print;   /***** DEBUG *****/      ok=Exchange.Reel.With.Edit.Region(Cue.A,Clip.Cue,Cue.A,false);      print;   /***** DEBUG *****/      if ok=E#Good then do;         call Display.Cue(Cue.A);         print;         call Display.Cue(Clip.Cue);      end;      else print 'Not enough room in cue for edit';   end;end;