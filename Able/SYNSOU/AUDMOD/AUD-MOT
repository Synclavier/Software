/*	:SYNSOU:AUDMOD:AUD-MOT  Sequencer Motion Control PanelModified:2000/06/15 - TY  - Enabled Motion Control Panel's STOP button to stop sequencer even when SMPTE is incoming1991/03/27 - MWH - Add arg to Read and Store Locate Stack routines1991/03/07 - MWH - Add AEE's 20 saved mark points to the protocol1991/02/13 - cj  - Checked for magic #61989/12/22 - MWH - changes to solo logic1989/12/01 - cj  - added argument to deposit.32bit.msec1988/11/15 - tss - fixed user trap with MIDI RECORD TRACK and ERASE on motion panel1988/10/31 - cj  - make scrolling routines available for cue files1988/08/16 - CJ  - check for negative numbers from take.system.sequence.time*/dcl Motion.Group					fixed public;dcl Motion.Row						fixed public;dcl Motion.Size					fixed public;dcl Motion.Size.Box				fixed;dcl Motion.Screen.Space			fixed;/*	top row:	*/dcl Motion.Control.Table		fixed;dcl Midi.Control.Table			fixed;dcl Midi.Recd.Track				fixed;dcl Sequencer.Storage.Table	fixed;dcl Sequencer.Switch.Button	fixed;dcl Sequencer.Name.Id			fixed;dcl Sequencer.Protect.Button	fixed;/*	second row:	*/dcl Locate.Button.Table			fixed;dcl Locator.Label.Button		fixed;dcl Locate.Off.Store.Table		fixed;dcl Verse.Name.Id.#1				fixed;dcl Verse.Name.Id.#2				fixed;dcl Locate.Take.Button			fixed;dcl Locate.Time.Id				fixed public;dcl Sequencer.Caption.#1		fixed;dcl Sequencer.Caption.#2		fixed;dcl Currently.Highlighted.Locate.Button	fixed;dcl Currently.Displayed.Recd.Trk		fixed;dcl Locate.Store.Button.Is.Active	fixed;dcl Protect.Button.Is.Highlighted	fixed;dcl Cat.Cache.File.Type					fixed PUBLIC;dcl Cat.Cache.Entries					fixed;dcl Protocol.Cat.Cache.File.Type		fixed external;dcl Protocol.Cat.Cache.Entries		fixed external;/*	$page - routine to highlight sequencer motion panel	*/Highlight.AEE.Sequencer.Motion.Panel:proc PUBLIC swapable;	dcl info	fixed;	if Motion.Group = 0 then return;	IF  (PLAY<>0)	AND (MOVE=0) THEN	INFO = INFO \ 1;	/*	START BUTTON	*/	IF CONT<>0	 THEN	INFO = INFO \ 4;	/*	IF CONTINUE IS ACTIVE, LIGHT IT	*/	IF (MOVE<>0) THEN DO;					/*	FF OR REW		*/		IF MOVE.SPEED<0		THEN				INFO = INFO \ 8;	/*	REWIND			*/		ELSE				INFO = INFO \ 16;	/*	FAST FORWARD	*/	END;	call Highlight.Graphics.Button.Table(Motion.Control.Table, info, 2, 0);	call Check.Next.Event;	info = 0;	IF ((RECD		  )<>0)					/*	IF RECORDING, LIGHT RECORD BUTTON	*/	OR ((SMPTE.RECD&1)<>0)	THEN					INFO = INFO \ 1;	/*	ALSO IF SMPTE FF/REW	*/	IF ((PNCH		  )<>0)					/*	ALWAYS BLINK FOR PUNCH IN	*/	OR ((SMPTE.RECD&2)<>0)	THEN					INFO = INFO \ 2;	/*	ALSO IF SMPTE FF/REW	*/	call Highlight.Graphics.Button.Table(Midi.Control.Table, info, 2, 0);	call Check.Next.Event;end Highlight.AEE.Sequencer.Motion.Panel;Highlight.AEE.Sequencer.Track.Display:proc PUBLIC swapable;	dcl str(10)	fixed;   dcl s1 (10) fixed;   dcl s2 (10) fixed;	if Motion.Group = 0 then return;	/*	check record track display on motion panel	*/	if RECD.TRK <> Currently.Displayed.Recd.Trk	then do;		Currently.Displayed.Recd.Trk = RECD.TRK;		if RECD.TRK ilt Num.KBD.Tracks		then str(0) = 0;		else call CONV.FIXED.TO.STR (RECD.TRK-1, 0, 3, CF#Right\CF#Spfill, str);		disable.deposits = 1;				call Deposit.Graphics.String(Midi.Recd.Track,str);				disable.deposits = 0;	end;	call Check.Next.Event;end Highlight.AEE.Sequencer.Track.Display;/*	$page - handle mark start/locate time displays	*/Update.Motion.Panel.Mark.Start.Info: proc PUBLIC swapable;	if Motion.Group <> 0 then do;		call Highlight.Graphics.Button.Table.Entry		(Locate.Off.Store.Table, 1, 0, Mark.Button.Disabled = 0, 2, 0);		disable.deposits = 1;		call deposit.32bit.msec(Locate.Time.Id, loc(addr(mark.button.msb)), Zero.Zero);		disable.deposits = 0;		call Highlight.Graphics.Button.Table.Entry		(Locate.Off.Store.Table, 0, 0, Locate.Store.Button.Is.Active, 2, 0);	end;end Update.Motion.Panel.Mark.Start.Info;/*	$page - highlight entry of locate button table	*/Highlight.Locate.Button.Table.Entry:proc (but) swapable;	dcl but	fixed;	/*	pass 1-20.  0 means no highlight	*/	if Currently.Highlighted.Locate.Button = But	then return;	if Currently.Highlighted.Locate.Button <> 0		/*	un-highlight current	*/	then do;														/*	button					*/		load Currently.Highlighted.Locate.Button - 1;		div 10;		call Highlight.Graphics.Button.Table.Entry		(Locate.Button.Table, rem, res, 0, 2, 0);	end;	Currently.Highlighted.Locate.Button = but;		/*	assign new highlight	*/	if Currently.Highlighted.Locate.Button <> 0		/*	and turn it on			*/	then do;		load Currently.Highlighted.Locate.Button - 1;		div 10;		call Highlight.Graphics.Button.Table.Entry	/*	quickly turn on		*/		(Locate.Button.Table, rem, res, 1, 2, 0);	end;end Highlight.Locate.Button.Table.Entry;/*	$page - routines to access the locate point list	*//*	the AEE stores a 20 location locate stack in two sectors of	*//*	external memory.  This information is also stored in the		*//*	sequence in a coded format												*//*	The basic locate stack stored in external memory at			*//*	Locate.Stack.Ptr looks as follows:									*/dcl AEE.Locate.Stack.Size			lit '20';	/*	20 entries		*/dcl AEE.Locate.Stack.Stride		lit '24';	/*	stride, words	*/dcl AEE.Locate.Stack.Time			lit ' 0';	/*	time (2 wrds)	*/dcl AEE.Locate.Stack.String.#1	lit ' 2';	/*	first string	*/dcl AEE.Locate.Stack.String.#2	lit '13';	/*	second string	*/dcl AEE.Locate.Stack.String.Wlen	lit '11';	/*	word length of str	*//*	fetch a locate stack entry into handy variables:	*/Fetch.AEE.Locate.Stack.Entry: proc (e#, time, str1, str2) public swapable;	dcl e#	fixed;	/*	entry #, 0 - 19			*/	dcl time	array;	/*	time is returned here	*/	dcl str1	array;	/*	first string				*/	dcl str2	array;	/*	second string				*/	dcl i		fixed;	i = e# * AEE.Locate.Stack.Stride;	write(mam) = Locate.Stack.Ptr + shr(i,8);	write(mal) = i;	time(0) = read(mdi);	time(1) = read(mdi);	write("313")=addr(str1(0));	rpc AEE.Locate.Stack.String.Wlen;	write("373") = read(mdi);	write("313")=addr(str2(0));	rpc AEE.Locate.Stack.String.Wlen;	write("373") = read(mdi);end Fetch.AEE.Locate.Stack.Entry;/*	store handy variables in locate stack entry:	*/Store.AEE.Locate.Stack.Entry: proc (e#, time, str1, str2) public swapable;	dcl e#	fixed;	/*	entry #, 0 - 19			*/	dcl time	array;	/*	time is returned here	*/	dcl str1	array;	/*	first string				*/	dcl str2	array;	/*	second string				*/	dcl i		fixed;	i = e# * AEE.Locate.Stack.Stride;	write(mam) = Locate.Stack.Ptr + shr(i,8);	write(mal) = i;	write(mdi) = time(0);	write(mdi) = time(1);	write("313")=addr(str1(0));	rpc AEE.Locate.Stack.String.Wlen;	write(mdi) = read("373");	write("313")=addr(str2(0));	rpc AEE.Locate.Stack.String.Wlen;	write(mdi) = read("373");end Store.AEE.Locate.Stack.Entry;/*	$page - read in locate stack from sequence			*//*	track 249 in the sequencer is used to store the locate point stack	*//*	the following routine reads this stack into dedicated sectors			*//*	of external memory where it can easily be processed						*//*	fetch or store entire stack in current sequence:	*//*	5 nls are allocated to store the locate info.  the first 4 each hold	*//*	5 locate points (see below for format).  the last one holds the		*//*	current locate point selection, time, and string (it may not be		*//*	saved)																					*//*	description of nls in sequence holding locate info	*//*	words 0 - 8 of the nls indicate an nls with no notes stored	*//*	on it																			*/dcl Seq.Locate.Info.Magic.#1	lit '12';	/*	magic #2 stored in	*/dcl Seq.Locate.Info.Magic.#2	lit '13';	/*	12, 13				*/dcl Seq.Locate.Info.Current	lit '14';	/*	current locate #	*/dcl Locate.Magic.#1	lit '09837';dcl Locate.Magic.#2	lit '53426';dcl Seq.Locate.Info.Base		lit '16';	/*	start of locate	*/dcl Seq.Locate.Info.Stride		lit '48';	/*	stride, words		*/dcl Seq.Locate.Info.Time		lit ' 0';	/*	time  (2 wrds)		*/dcl Seq.Locate.Info.Spare		lit ' 2';	/*	spare (2 wrds)		*/dcl Seq.Locate.Info.Strings	lit ' 4';	/*	strings, variable	*//*	read in entire locate stack from current sequence:	*/Read.In.Entire.AEE.Locate.Stack:proc (update) PUBLIC swapable;	dcl update		fixed;	dcl (i,j,k)		fixed;	dcl (l,m,n)		fixed;	dcl (tmp) (1)	fixed;	dcl (s1 ) (AEE.Locate.Stack.String.Wlen)	fixed;	dcl (s2 ) (AEE.Locate.Stack.String.Wlen)	fixed;	dcl ptr			fixed;	dcl new			fixed;	/*	zero out all info in case one nls is missing	*/	write(mam) = Locate.Stack.Ptr;	rpc 256;	write(mdi) = 0;	rpc 256;	write(mdi) = 0;	/*	read in entire cue stack from disk	*/	write(mam) = TRK.HEAD;				/*	get pointer to trak head	*/	write(mal) = Locate.Info.Track;	/*	for possible locate info	*/	ptr		  = read(md);				/*	track								*/	if ptr <> 0 then do;					/*	may be none						*/		write(mam) = ptr;					/*	point to trk head				*/		write(mal) = THD.FOR;			/*	get ptr to first nls			*/		ptr		  = read(md);			/*	may be it is there			*/	end;	do i = 0 to 3;							/*	go through 4 segments and get 5 locate points from each	*/		if ptr <> 0 then do;								/*	double check ptr	*/			write(mam) = NAH.PTR + ptr;				/*	go there				*/			write(mal) = Seq.Locate.Info.Magic.#1;	/*	check magic #s		*/			if  (read(mdi) = Locate.Magic.#1)			and (read(mdi) = Locate.Magic.#2)			then			do j = 0 to 4;									/*	then get them		*/				l = Seq.Locate.Info.Base + j*Seq.Locate.Info.Stride;				write(mam) = NAH.PTR + ptr;					/*	go there				*/				write(mal) = l+Seq.Locate.Info.Time;		/*	read locate time	*/				tmp(0) = read(mdi);				tmp(1) = read(mdi);				write(mal) = l+Seq.Locate.Info.Strings;	/*	read strings in	*/				m = shr(read(md)+3,1);			/*	# of	*/	/*	from variable		*/														/*	wrds	*/	/*	length format		*/				if m igt AEE.Locate.Stack.String.Wlen				then m = AEE.Locate.Stack.String.Wlen;				write("313") = addr(s1(0));					/*	to provide room	*/				rpc m;												/*	for growth			*/				write("373") = read(mdi);				if s1(0) igt shl(AEE.Locate.Stack.String.Wlen-1,1)				then s1(0) = shl(AEE.Locate.Stack.String.Wlen-1,1);				write(mal) = l+Seq.Locate.Info.Strings+m;				n = shr(read(md)+3,1);				if n igt AEE.Locate.Stack.String.Wlen				then n = AEE.Locate.Stack.String.Wlen;				write("313") = addr(s2(0));				rpc n;				write("373") = read(mdi);				if s2(0) igt shl(AEE.Locate.Stack.String.Wlen-1,1)				then s2(0) = shl(AEE.Locate.Stack.String.Wlen-1,1);				k = i*5+j;									/*	get index		*/				call Store.AEE.Locate.Stack.Entry (k, tmp, s1, s2);			end;			write(mam) = NAH.PTR + ptr;			write(mal) = NLS.FOR;			ptr		  = read(md);		end;	end;	/*	read in most recently used locate position for	*/	/*	this sequence and select it							*/	if (Motion.Group <> 0) AND (update <> 0)	then do;		s1(0) = 0; s2(0) = 0; new = 0;		if ptr <> 0 then do;								/*	double check ptr	*/			write(mam) = NAH.PTR + ptr;				/*	go there				*/			write(mal) = Seq.Locate.Info.Current;	/*	look up new			*/			new		  = read(md);						/*	current selection	*/			write(mal) = Seq.Locate.Info.Magic.#1;	/*	check magic #s		*/			if  (read(mdi) = Locate.Magic.#1)			and (read(mdi) = Locate.Magic.#2)			then do;				l = Seq.Locate.Info.Base + Seq.Locate.Info.Stride;				write(mam) = NAH.PTR + ptr;					/*	go there				*/				write(mal) = l+Seq.Locate.Info.Time;		/*	read locate time	*/				/*	read(mdi);	*/	/*	could look up mark.button.msb, lsb from sequence	*/				/*	read(mdi);	*/	/*	but this is already done for us							*/				write(mal) = l+Seq.Locate.Info.Strings;	/*	read strings in	*/				m = shr(read(md)+3,1);			/*	# of	*/	/*	from variable		*/														/*	wrds	*/	/*	length format		*/				if m igt AEE.Locate.Stack.String.Wlen				then m = AEE.Locate.Stack.String.Wlen;				write("313") = addr(s1(0));					/*	to provide room	*/				rpc m;												/*	for growth			*/				write("373") = read(mdi);				if s1(0) igt shl(AEE.Locate.Stack.String.Wlen-1,1)				then s1(0) = shl(AEE.Locate.Stack.String.Wlen-1,1);				write(mal) = l+Seq.Locate.Info.Strings+m;				n = shr(read(md)+3,1);				if n igt AEE.Locate.Stack.String.Wlen				then n = AEE.Locate.Stack.String.Wlen;				write("313") = addr(s2(0));				rpc n;				write("373") = read(mdi);				if s2(0) igt shl(AEE.Locate.Stack.String.Wlen-1,1)				then s2(0) = shl(AEE.Locate.Stack.String.Wlen-1,1);			end;			write(mam) = NAH.PTR + ptr;			write(mal) = NLS.FOR;			ptr		  = read(md);		end;		disable.deposits = 1;		call Deposit.Graphics.String(Verse.Name.Id.#1, s1);		call Deposit.Graphics.String(Verse.Name.Id.#2, s2);		disable.deposits = 0;		call Highlight.Locate.Button.Table.Entry(new);		/*	set protect button highlight		*/		write(mam) = BAS.PTR;		write(mal) = SEQ.PROT;		Protect.Button.Is.Highlighted = read(md)&1;		call Highlight.Graphics.Button.Table.Entry		(Sequencer.Protect.Button, 0, 0, Protect.Button.Is.Highlighted&1, 2, 0);		/*	read in sequence caption from sequence header	*/		write(mam) = BAS.PTR;		write(mal) = SEQ.CAPTS;		m = shr(read(md)+3,1);		/*	# of	*/											/*	wrds	*/		if m igt 17 then m = 17;		write("313") = addr(misc.buf(0));		rpc m;		write("373") = read(mdi);		if Misc.Buf(0) igt 32 then Misc.Buf(0) = 32;		disable.deposits = 1;		call Deposit.Graphics.String(Sequencer.Caption.#1, Misc.Buf);		disable.deposits = 0;		write(mam) = BAS.PTR;		write(mal) = SEQ.CAPTS+m;		n = shr(read(md)+3,1);		if n igt 17 then n = 17;		write("313") = addr(misc.buf(0));		rpc n;		write("373") = read(mdi);		if Misc.Buf(0) igt 32 then Misc.Buf(0) = 32;		disable.deposits = 1;		call Deposit.Graphics.String(Sequencer.Caption.#2, Misc.Buf);		disable.deposits = 0;	end;end Read.In.Entire.AEE.Locate.Stack;/*	store entire locate stack in sequence so it can	*//*	be written to disk										*/Store.Entire.AEE.Locate.Stack:proc (update) public swapable;	dcl update		fixed;	dcl (i,j,k)		fixed;	dcl (l,m,n)		fixed;	dcl (tmp) (1)	fixed;	dcl (s1 ) (AEE.Locate.Stack.String.Wlen)	fixed;	dcl (s2 ) (AEE.Locate.Stack.String.Wlen)	fixed;	dcl ptr			fixed;	if ALLOCATE.NLS.BLOCKS.FOR.DATA.STORAGE (Locate.Info.Track, 5) = 0	then do;		call DISPLAY.ERR(0);	/*	not enough memory	*/		return;	end;	write(mam) = TRK.HEAD;				/*	at this point we should have	*/	write(mal) = Locate.Info.Track;	/*	4 empty nls's to store			*/	ptr		  = read(md);				/*	data in								*/	write(mam) = ptr;						/*	point to trk head					*/	write(mal) = THD.FOR;				/*	get ptr to first nls				*/	ptr		  = read(md);				/*	hope he is there					*/	do i = 0 to 3;							/*	fill 4 nls's with 5 locate points each	*/		if ptr <> 0 then do;								/*	double check ptr	*/			write(mam) = NAH.PTR + ptr;				/*	go there				*/			WRITE(MAL)=NLS.FP;							/*	erase any errant	*/			WRITE(MDI)=NLS.FIRSTL;						/*	notes.				*/			WRITE(MDI)=NLS.FIRSTL;			WRITE(MAL)=NLS.FIRSTL;			WRITE(MD )=NLS.EOS;			write(mal) = Seq.Locate.Info.Magic.#1;	/*	save magic #'s	*/			write(md ) = Locate.Magic.#1;				/*	for safety		*/			write(mal) = Seq.Locate.Info.Magic.#2;	/*	and revisions	*/			write(md ) = Locate.Magic.#2;			do j = 0 to 4;									/*	store 5 per seg	*/				k = i*5+j;									/*	get index			*/				call Fetch.AEE.Locate.Stack.Entry (k, tmp, s1, s2);				l = Seq.Locate.Info.Base + j*Seq.Locate.Info.Stride;				write(mam) = NAH.PTR + ptr;					/*	go there				*/				write(mal) = l+Seq.Locate.Info.Time;		/*	save locate time	*/				write(mdi) = tmp(0);				write(mdi) = tmp(1);				write(mal) = l+Seq.Locate.Info.Spare;		/*	two spare words	*/				write(mdi) = 0;				write(mdi) = 0;				write(mal) = l+Seq.Locate.Info.Strings;	/*	write strings out	*/				m = shr(s1(0)+3,1);				/*	# of	*/	/*	in variable			*/				n = m;								/*	wrds	*/	/*	length format		*/				write("313") = addr(s1(0));					/*	to provide room	*/				rpc m;												/*	for growth			*/				write(mdi) = read("373");				m = shr(s2(0)+3,1);				/*	length		*/				n = n + m;							/*	of second	*/				write("313") = addr(s2(0));	/*	string		*/				rpc m;				write(mdi) = read("373");				/*	zero fill to end of stride	*/				rpc (Seq.Locate.Info.Stride - Seq.Locate.Info.Strings - n);				write(mdi) = 0;			end;			write(mam) = NAH.PTR + ptr;			write(mal) = NLS.FOR;			ptr		  = read(md);		end;	end;	/*	store current locate info in sequence as well	*/	/*	(but only if motion panel is displayed)			*/	if (Motion.Group <> 0) AND (update <> 0)	then do;		if ptr <> 0 then do;									/*	double check ptr	*/			write(mam) = NAH.PTR + ptr;					/*	go there				*/			WRITE(MAL)=NLS.FP;								/*	erase any errant	*/			WRITE(MDI)=NLS.FIRSTL;							/*	notes.				*/			WRITE(MDI)=NLS.FIRSTL;			WRITE(MAL)=NLS.FIRSTL;			WRITE(MD )=NLS.EOS;			write(mal) = Seq.Locate.Info.Magic.#1;		/*	save magic #'s	*/			write(md ) = Locate.Magic.#1;					/*	for safety		*/			write(mal) = Seq.Locate.Info.Magic.#2;		/*	and revisions	*/			write(md ) = Locate.Magic.#2;			write(mal) = Seq.Locate.Info.Current;			write(md ) = Currently.Highlighted.Locate.Button;			call Fetch.Graphics.String(Verse.Name.Id.#1, s1);			call Fetch.Graphics.String(Verse.Name.Id.#2, s2);			l = Seq.Locate.Info.Base + Seq.Locate.Info.Stride;			write(mam) = NAH.PTR + ptr;					/*	go there				*/			write(mal) = l+Seq.Locate.Info.Time;		/*	save locate time	*/			write(mdi) = Mark.Button.Msb;			write(mdi) = Mark.Button.Lsb;			write(mal) = l+Seq.Locate.Info.Spare;		/*	two spare words	*/			write(mdi) = 0;			write(mdi) = 0;			write(mal) = l+Seq.Locate.Info.Strings;	/*	write strings out	*/			m = shr(s1(0)+3,1);				/*	# of	*/	/*	in variable			*/			n = m;								/*	wrds	*/	/*	length format		*/			write("313") = addr(s1(0));					/*	to provide room	*/			rpc m;												/*	for growth			*/			write(mdi) = read("373");			m = shr(s2(0)+3,1);				/*	length		*/			n = n + m;							/*	of second	*/			write("313") = addr(s2(0));	/*	string		*/			rpc m;			write(mdi) = read("373");			/*	zero fill to end of sector	*/			rpc (256 - l - Seq.Locate.Info.Strings - n);			write(mdi) = 0;			write(mam) = NAH.PTR + ptr;			write(mal) = NLS.FOR;			ptr		  = read(md);		end;		/*	also write sequence caption and protect bits to external	*/		/*	memory sequence area													*/		write(mam) = BAS.PTR;		write(mal) = SEQ.PROT;		write(md ) = (read(md)&"177776") \ Protect.Button.Is.Highlighted;		call Fetch.Graphics.String(Sequencer.Caption.#1, Misc.Buf);		write(mam) = BAS.PTR;		write(mal) = SEQ.CAPTS;						/*	write strings out	*/		m = shr(misc.buf(0)+3,1);	/*	# of	*/	/*	in variable			*/		n = m;							/*	wrds	*/	/*	length format		*/		write("313") = addr(Misc.Buf(0));		/*	to provide room	*/		rpc m;											/*	for growth			*/		write(mdi) = read("373");		call Fetch.Graphics.String(Sequencer.Caption.#2, Misc.Buf);		write(mam) = BAS.PTR;		write(mal) = SEQ.CAPTS+n;		m = shr(misc.buf(0)+3,1);					/*	length		*/		n = n + m;										/*	of second	*/		write("313") = addr(misc.buf(0));		/*	string		*/		rpc m;		write(mdi) = read("373");		rpc (SEQ.CAPTS.LEN - n);		write(mdi) = 0;	end;end Store.Entire.AEE.Locate.Stack;/*	Update AEE.Sequence.Name on sequence recall	*/Update.Motion.Panel.Seq.Name: proc PUBLIC swapable;	dcl tmp(AEE.Sequence.Name.Wlen)	fixed;	call GID(AEE.Sequence.Name);	call COPY.IN(addr(tmp(0)), AEE.Sequence.Name.Wlen);	disable.deposits = 1;	if tmp(0) > 27 then tmp(0) = 27;	call Deposit.Graphics.String (Sequencer.Name.Id, tmp);	disable.deposits = 0;	call Update.Object(Sequencer.Name.Id);end;/*	$page - read in cat buffer to scroll through sequences	*//*	routine looks for the passed file name	*//*	if it is found, then the catalog is		*//*	cached in memory								*//*	if the name is that of a subcatalog,	*//*	then a colon is appended to the end		*//*	of the name string							*//*	returns a 1 if the passed name is		*//*	actually the name of a catalog			*/Cache.Cat.If.Possible:proc (where, nam, ftyp) PUBLIC swapable;	dcl where	fixed;	/*	where in ext memeory	*/	dcl nam		array;	/*	sequence name			*/	dcl ftyp		fixed;	/*	file type				*/	dcl entries	fixed;	dcl tmp(AEE.Sequence.Name.Wlen+10)	fixed;	cache.seq.cat: proc(where, ftyp);		dcl where	fixed;		dcl ftyp		fixed;		dcl entries	fixed;		call COPY.EXT.MEM(C#BufPtr, 0, where, 0, C#Dir_Size);		entries = Filter.Cat.Buffer.By.Filetype(where, 8, shr(C#Dir_Size,3), bits(ftyp));		call Sort.Cat.Buffer.By.Filename (where, 8, entries);		if (where == PCACHE.PTR)			{Protocol.Cat.Cache.Entries = entries; Protocol.Cat.Cache.File.Type = ftyp;}		else			{Cat.Cache.Entries = entries; Cat.Cache.File.Type = ftyp;}	end cache.seq.cat;	if (where == PCACHE.PTR)		{Protocol.Cat.Cache.Entries = 0; Protocol.Cat.Cache.File.Type = 0;}	else		{Cat.Cache.Entries = 0; Cat.Cache.File.Type = 0;}	call COPY.STRING(nam,tmp);						/*	get temp copy					*/	if (tmp(0) = 0)									/*	if user enters null string	*/	or (byte(tmp,tmp(0)-1) = colon)				/*	or ends in colon				*/	then call APPEND.TO.STR(tmp, 'X5X4X1X2');	/*	append file name to get catalog	*/	if Locate(tmp,1) then do;						/*	found - check lots of info	*/		if (F#Type = T#Subc )						/*	subcatalog - append :		*/		or (F#Type = T#LSubc)		then do;			if F#Type = T#Subc then C#Dir_Size = 128;			else C#Dir_Size = 1024;			call Ext.Readdata(F#MS_Sector, F#LS_Sector, where, 0, 0, C#Dir_Size);			entries = Filter.Cat.Buffer.By.Filetype(where, 8, shr(C#Dir_Size,3), bits(ftyp));			call Sort.Cat.Buffer.By.Filename (where, 8, entries);			if (where == PCACHE.PTR)				{Protocol.Cat.Cache.Entries = entries; Protocol.Cat.Cache.File.Type = ftyp;}			else				{Cat.Cache.Entries = entries; Cat.Cache.File.Type = ftyp;}			return 1;		end;		else call cache.seq.cat(where, ftyp);	/*	else cache that directory		*/	end;	else do;												/*	not found - may be ok or not	*/		if C#Status = E#No_File						/*	if file not found, cache		*/		then call cache.seq.cat(where, ftyp);	/*	seq cat anyways					*/	end;	return 0;end Cache.Cat.If.Possible;/*	routine to cache T#SYNC files only:	*/Cache.Seq.Cat.If.Possible: proc (nam) swapable;	dcl nam	array;	return Cache.Cat.If.Possible(AEE.Seq.Cat, nam, T#SYNC);end Cache.Seq.Cat.If.Possible;insert ':synsou:audmod:aud-mot1';	/*	bring in define routine	*//*	$page - handle motion control table mouse activity	*//*	remember - perform highlighting quickly to provide snappy	*//*	response to user															*/Handle.Motion.Control.Table:proc swapable;	dcl tmp(1)	fixed;	if Screen.Event.Info = S#MouseSelect	then do;		call Map.Graphics.Button.Table.Mouse.Press(Motion.Control.Table, tmp);		do case (tmp(0));		/*	branch on column	*/			do;				call Highlight.Graphics.Button.Table.Entry	/*	quickly turn on	*/				(Motion.Control.Table, 0, 0, 1, 2, 0);			/*	start button		*/				call START.SEQUENCER;			end;			do;				call Highlight.Graphics.Button.Table			/*	turn off all		*/				(Motion.Control.Table, 0, 2, 0);					/*	lights quickly		*/				call Highlight.Graphics.Button.Table			/*	turn off all		*/				(Midi.Control.Table,   0, 2, 0);					/*	lights quickly		*/				if (Play != 0) {					if (SLOCKED != 0) DISABLE.SMPTE.START = true;	//	for the love of God, just STOP					STOP.SEQUENCER();									/*	stop seq				*/				}				else call Stop.DTD.Playback;						/*	abort cues			*/			end;			do;				call Highlight.Graphics.Button.Table.Entry	/*	quickly turn on	*/				(Motion.Control.Table, 0, 0, 1, 2, 0);			/*	start button		*/				call CONTINUE.SEQUENCER;			end;			do;				call Highlight.Graphics.Button.Table.Entry	/*	quickly turn on	*/				(Motion.Control.Table, 3, 0, 1, 2, 0);			/*	rew   button		*/				call REWIND.SEQUENCER;			end;			do;				call Highlight.Graphics.Button.Table.Entry	/*	quickly turn on	*/				(Motion.Control.Table, 4, 0, 1, 2, 0);			/*	for   button		*/				call FAST.FORWARD.SEQUENCER;			end;		end;		/*	provide speedy display by updating right here	*/		/*	even if we will come back to update later on		*/		call Highlight.AEE.Sequencer.Motion.Panel;		call DISPLAY.SEQUENCER.STATUS;	end;end Handle.Motion.Control.Table;/*	$page - handle midi control table mouse activity	*/Handle.Midi.Control.Table:proc swapable;	dcl tmp(1)	fixed;	if Screen.Event.Info = S#MouseSelect	then do;		call Map.Graphics.Button.Table.Mouse.Press(Midi.Control.Table, tmp);		do case (tmp(0));		/*	branch on column	*/			do;				call PROCESS.RECORD.BUTTON;				call Highlight.Graphics.Button.Table.Entry	/*	quickly turn on	*/				(Midi.Control.Table,   0, 0, 1, 2, 0);			/*	recrd button		*/				call Highlight.Graphics.Button.Table.Entry	/*	quickly turn on	*/				(Motion.Control.Table, 0, 0, 1, 2, 0);			/*	start button		*/			end;			do;				call PROCESS.PUNCH.BUTTON;				call Highlight.Graphics.Button.Table.Entry	/*	quickly turn on	*/				(Midi.Control.Table,   1, 0, 1, 2, 0);			/*	punch button		*/				call Highlight.Graphics.Button.Table.Entry	/*	quickly turn on	*/				(Midi.Control.Table,   0, 0, 1, 2, 0);			/*	recrd button		*/				call Highlight.Graphics.Button.Table.Entry	/*	quickly turn on	*/				(Motion.Control.Table, 0, 0, 1, 2, 0);			/*	start button		*/			end;			do;					/*	locate sequencer	*/				call Highlight.Graphics.Button.Table.Entry	/*	quickly turn on	*/				(Midi.Control.Table,   2, 0, 1, 2, 0);			/*	locat button		*/				Mark.Button.Disabled = 0;							/*	enable mark			*/				call Update.Motion.Panel.Mark.Start.Info;		/*	get mark on/off button to highlight quickly	*/				call SET.SEQUENCER.MARK.START.POINT(Mark.Button.Msb, Mark.Button.Lsb, 2);				call Highlight.Graphics.Button.Table.Entry	/*	and turn off		*/				(Midi.Control.Table,   2, 0, 0, 2, 0);			/*	locate button		*/			end;		end;		/*	provide speedy display by updating right here	*/		/*	even if we will come back to update later on		*/		/*	if we turned on/off the correct ones up above	*/		/*	then the following call will just check			*/		/*	all the other lights										*/		call Highlight.AEE.Sequencer.Motion.Panel;		call DISPLAY.SEQUENCER.STATUS;	end;end Handle.Midi.Control.Table;/*	$page - handle entry of record track from terminal	*/Handle.Midi.Recd.Track:proc swapable;	dcl str(10)	fixed;	dcl i			fixed;	dcl new		fixed;	clear.statuses:proc;		call DISPLAY.NOTICE (NT#EraseNotice,ATTR#Normal,NulStr,0,0,0);		call REMOVE.ERR;	end clear.statuses;	new = RECD.TRK;	/*	get cur value; assume no change	*/	if Screen.Event.Info = S#Deposit	then do;		call clear.statuses;		Currently.Displayed.Recd.Trk = -99;		/*	force update	*/		call Fetch.Graphics.String(Midi.Recd.Track, Str);		if (RECD<>0)		then call Display.Notice(NT#NoRecdTrkChangeWhileRecording,ATTR#Reverse,NulStr,0,0,0);		else if str(0) = 0 then new = 0;		else if byte(str,0) = SP then new = 0;		else do;			i = CONV.STR.TO.FIXED(Str,0,0);			if ertyp = 0 then do;				if i = 0 then new = 0;				else if (i<1) or (i>200)				then do;					new = 0;					call Display.Notice(NT#RecdTrkTooLarge,ATTR#Reverse,NulStr,0,0,0);				end;				else new = i + 1;			end;		end;	end;	else if (Screen.Event.Info = S#MouseSelect)	or		  (Screen.Event.Info = S#MouseActivate) then do;		if abs(Mouse(Button.Result)) = 1		then do;			call clear.statuses;			if (RECD<>0)			then call Display.Notice(NT#NoRecdTrkChangeWhileRecording,ATTR#Reverse,NulStr,0,0,0);			else if RECD.TRK = 0 then new = Num.Kbd.Tracks;			else if RECD.TRK < 201 then new = RECD.TRK + 1;		end;		else if abs(Mouse(Button.Result)) = 3		then do;			call clear.statuses;			if (RECD<>0)			then call Display.Notice(NT#NoRecdTrkChangeWhileRecording,ATTR#Reverse,NulStr,0,0,0);			else if RECD.TRK ILE Num.Kbd.Tracks			then new=0;			else new = RECD.TRK-1;		end;	end;	/*	see if record track changed.  change carefully to match	*/	/*	button panel logic													*/	if new <> RECD.TRK then do;		if (RECD.TRK IGE Num.Kbd.Tracks)	/*	unsolo current recd.trk	*/		{			write(mam) = tbut.ptr;			write(mal) = RECD.TRK;			if ((read(md) & B.SOLOED.TRK) != 0)				/*	will virtually	*/				call TOGGLE.TRACK.SOLO.STATE (RECD.TRK);	/*	always be true	*/		}		if (NEW IGE Num.Kbd.Tracks)					/*	solo/select new one	*/		{			write(mam) = tbut.ptr;			write(mal) = NEW;			if ((read(md) & B.SOLOED.TRK) != 0)		/*	done this way			*/				call TOGGLE.TRACK.SOLO.STATE (NEW);	/*	to handle groups		*/			call TOGGLE.TRACK.SOLO.STATE (NEW);		}		call Highlight.AEE.Sequencer.Track.Display;	end;	/*	present track buttons to user.  force update of	*/	/*	Midi.Recd.Track field									*/	call DISPLAY.TRACK.BUTTONS;end Handle.Midi.Recd.Track;/*	$page - handle motion panel change of mark start information	*/Handle.Locate.Off.Store.Table:proc swapable;	dcl tmp(1)	fixed;	if Screen.Event.Info = S#MouseSelect	then do;		call Map.Graphics.Button.Table.Mouse.Press(Locate.Off.Store.Table, tmp);		do case (tmp(0));		/*	branch on column	*/			do;					/*	store button		*/				Locate.Store.Button.Is.Active = Locate.Store.Button.Is.Active xor 1;				call Update.Motion.Panel.Mark.Start.Info;	/*	show to user SNAPPILY	*/			end;			do;					/*	on/off button		*/				mark.button.disabled = mark.button.disabled xor 1;				Locate.Store.Button.Is.Active = 0;			/*	stop store activity on on/off	*/				call Update.Motion.Panel.Mark.Start.Info;	/*	show to user SNAPPILY	*/				call Update.Motion.Panel.Mark.Start.Info;	/*	show to user SNAPPILY	*/				call select.parameter(mark.l-par.l);		/*	and show to VK users		*/			end;		end;	end;end Handle.Locate.Off.Store.Table;Handle.Locate.Time.Id:proc swapable;	dcl (msw,lsw)	fixed;	clear.statuses:proc;		call DISPLAY.NOTICE (NT#EraseNotice,ATTR#Normal,NulStr,0,0,0);		call REMOVE.ERR;	end clear.statuses;	if Screen.Event.Info = S#Deposit	then do;		call fetch.32bit.msec(Locate.Time.Id, loc(addr(msw)));		if (msw = 0) and (lsw = zero.time) then lsw = 0;		mark.button.msb		= msw;		mark.button.lsb		= lsw;		mark.button.disabled	= 0;		call Update.Motion.Panel.Mark.Start.Info;	/*	show to user SNAPPILY	*/		call select.parameter(mark.l-par.l);		/*	show to VK user too		*/	end;	else if Screen.Event.Info = S#ObjectDrag then do;		call Perform.AEE.Drag.Function(Screen.Event.Id,Screen.Event.Obj.Info);		call Select.New.Cur.Obj(Corner.Label,-1,-1);	end;end Handle.Locate.Time.Id;Handle.Locate.Take.Button:proc swapable;	dcl tmp(1)	fixed;	if Screen.Event.Info = S#MouseSelect	then do;		call TAKE.SYSTEM.SEQUENCE.TIME(tmp);		/*	get synclav time			*/		if tmp(0) < 0 then call STR32(0, 0, tmp);		call COPY32(tmp, loc(addr(Mark.Button.Msb)));		mark.button.disabled = 0;						/*	turn on start pt			*/		call Update.Motion.Panel.Mark.Start.Info;	/*	show to user SNAPPILY	*/		call Update.Object(Locate.Time.Id);		call select.parameter(mark.l-par.l);		/*	show to VK user too		*/	end;end Handle.Locate.Take.Button;/*	$page - handle mouse activity in locate button table	*/Handle.Locate.Button.Table:proc swapable;	dcl tmp(1)	fixed;	dcl s1 (AEE.Locate.Stack.String.Wlen)	fixed;	dcl s2 (AEE.Locate.Stack.String.Wlen)	fixed;	dcl i		fixed;	dcl msw	fixed;	dcl lsw	fixed;	if Screen.Event.Info = S#MouseSelect	then do;		call Map.Graphics.Button.Table.Mouse.Press(Locate.Button.Table, tmp);		i = 10*tmp(1) + tmp(0);	/*	10 * row + column	*/		if Locate.Store.Button.Is.Active then do;			call Highlight.Locate.Button.Table.Entry(i+1);			call Fetch.Graphics.String(Verse.Name.Id.#1,s1);			call Fetch.Graphics.String(Verse.Name.Id.#2,s2);			call Store.AEE.Locate.Stack.Entry(i, loc(addr(Mark.Button.Msb)), s1, s2);			/*	Declare an event so the protocol knows this has changed	*/			New.Seq.Info = New.Seq.Info | 8;	/*	New constants	*/			Locate.Store.Button.Is.Active = 0;			/*	only 1 store per mouse press	*/			call Update.Motion.Panel.Mark.Start.Info;	/*	turn off store light for user quickly	*/		end;		else do;			call Highlight.Locate.Button.Table.Entry(i+1);			call Fetch.AEE.Locate.Stack.Entry(i, loc(addr(msw)), s1, s2);			if (msw = 0) and (lsw = zero.time) then lsw = 0;			mark.button.msb		= msw;			mark.button.lsb		= lsw;			mark.button.disabled	= 0;			call Update.Motion.Panel.Mark.Start.Info;	/*	show to user SNAPPILY	*/			disable.deposits = 1;			call Deposit.Graphics.String(Verse.Name.Id.#1,s1);			call Deposit.Graphics.String(Verse.Name.Id.#2,s2);			disable.deposits = 0;			call Update.Object(Locate.Time.Id);			/*	present info to user	*/			call Check.Next.Event;			call Update.Object(Verse.Name.Id.#1);		/*	quickly on mouse		*/			call Check.Next.Event;			call Update.Object(Verse.Name.Id.#2);		/*	select					*/			call Check.Next.Event;			call select.parameter(mark.l-par.l);		/*	show to VK user too	*/		end;		/*	store in sequence on every select so current information	*/		/*	is always up to date on sequence recall						*/		call Store.Entire.AEE.Locate.Stack(1);			/*	save in sequence for write to disk	*/	end;end Handle.Locate.Button.Table;Handle.Sequencer.Protect.Button:proc swapable;	dcl tmp(AEE.Sequence.Name.Wlen)	fixed;	call Fetch.Graphics.String(Sequencer.Name.Id, tmp);	if Screen.Event.Info = S#MouseSelect	then do;		/*	if file is not saved, allow turning off protect bit.	*/		/*	otherwise give error message									*/		if not(LOCATE(tmp,1))		then do;			if Protect.Button.Is.Highlighted <> 0			then Protect.Button.Is.Highlighted = 0;			else if C#Status = E#No_file			then call DISPLAY.NOTICE (NT#MustSaveSeqToProt,ATTR#Reverse,tmp,0,0,0);			else call handle.cat.error(1);		end;		else if (F#Type <> T#Sync)		or		  (F#LS_Length = 0 )		then do;			if Protect.Button.Is.Highlighted <> 0			then Protect.Button.Is.Highlighted = 0;			else call DISPLAY.NOTICE (NT#NotASyncFile,ATTR#Reverse,tmp,0,0,0);		end;		else do;			call READDATA(F#MS_Sector, F#LS_Sector, Misc.Buf, 256);			if ((Misc.Buf(MAGIC.NUMBER) <> MAGIC#5)			&&  (Misc.Buf(MAGIC.NUMBER) <> MAGIC#6)			&&  (Misc.Buf(MAGIC.NUMBER) <> MAGIC#7))			then do;				if Protect.Button.Is.Highlighted <> 0				then Protect.Button.Is.Highlighted = 0;				else call DISPLAY.NOTICE (NT#MustSaveSeqToProt,ATTR#Reverse,tmp,1,0,0);			end;			else do;				Protect.Button.Is.Highlighted = Protect.Button.Is.Highlighted xor 1;				Misc.Buf(SEQ.PROT) = (Misc.Buf(SEQ.PROT)&"177776") \ Protect.Button.Is.Highlighted;				if (F#MS_Sector\F#LS_Sector)<>0				then call WRITEDATA(F#MS_Sector, F#LS_Sector, Misc.Buf, 256);			end;		end;		call Highlight.Graphics.Button.Table.Entry		(Sequencer.Protect.Button, 0, 0, Protect.Button.Is.Highlighted&1, 2, 0);		/*	store in sequence on every select so current information	*/		/*	is always up to date on sequence recall						*/		call Store.Entire.AEE.Locate.Stack(1);	/*	save in sequence for write to disk (but not on top of protected sequence!!)	*/	end;end Handle.Sequencer.Protect.Button;/*	$page - handle name entry of sequencer name	*/Handle.Sequencer.Name.Id:proc swapable;	dcl tmp(AEE.Sequence.Name.Wlen)	fixed;	if Screen.Event.Info = S#Deposit	then do;		call Fetch.Graphics.String(Sequencer.Name.Id, tmp);		/*	save in ext memory for startup	*/		call GID(AEE.Sequence.Name);		call COPY.OUT(addr(tmp(0)), AEE.Sequence.Name.Wlen);		/*	read and cache catalog for scrolling.  Append : to file name	*/		/*	if it is really the name of a catalog									*/		if Cache.Seq.Cat.If.Possible(tmp) then do;			call APPENDC(tmp, colon);			call GID(AEE.Sequence.Name);			call COPY.OUT(addr(tmp(0)), AEE.Sequence.Name.Wlen);			disable.deposits = 1;			call Deposit.Graphics.String (Sequencer.Name.Id, tmp);			disable.deposits = 0;		end;		Protocol.Cat.Cache.File.Type = 0;		/*	refresh protocol catalog cache too	*/		new.prm.info = new.prm.info | 256;		/*	update everyones seq name display	*/	end;end Handle.Sequencer.Name.Id;/*	$page - scroll through catalog to find sequences		*//*	handle switch to scroll amongst sequences, or other	*//*	file types:															*//*	Pass current name.												*/Handle.Cat.Cache.Switch.Button: proc (nam, ftyp) PUBLIC swapable;	dcl nam		array;	/*	pass current name				*/	dcl ftyp		fixed;	/*	pass file type of interest	*/	dcl p.y		fixed;	dcl t.y		fixed;	dcl dir		fixed;	dcl path(AEE.Sequence.Name.Wlen+10)	fixed;	dcl file(AEE.Sequence.Name.Wlen+1 )	fixed;	dcl outfile(4)								fixed;	dcl i			fixed;	/*	check for scroll up/down	*/	p.y	 = mouse(press.y);							/*	if click is in upper	*/	t.y	 = tpos.y(p.y);								/*	half of the transp	*/	if p.y > gpos.y(t.y*100-50) then dir = -1;	/*	row, then dir is up	*/	else										dir = +1;	if Cat.Cache.File.Type <> ftyp					/*	not cached - tell user	*/	then do;													/*	why now						*/		call Cache.Cat.If.Possible(AEE.Seq.Cat, nam, ftyp);	/*	try once more	*/		if Cat.Cache.File.Type <> ftyp				/*	not cached - tell user	*/		then do;												/*	why now						*/			call handle.cat.error(1);			return 0;		end;	end;	/*	scroll forward or backwards for file	*/	if nam(0) = 0 then do;								/*	null string					*/		path(0) = 0;										/*	use null path				*/		if dir = (+ 1)		then call COPY.STRING('        ',file);	/*	set up for first file	*/		else call COPY.STRING('ZZZZZZZZ',file);	/*	set up for last file		*/	end;	else if (byte(nam,nam(0)-1) = colon)			/*	file name ends in colon	*/	then do;		call COPY.STRING(nam, path);					/*	it is path					*/		if dir = (+ 1)		then call COPY.STRING('        ',file);	/*	set up for first file	*/		else call COPY.STRING('ZZZZZZZZ',file);	/*	set up for last file		*/	end;	else do;													/*	hope for combined name	*/		call Parse.Treename.String (nam, path, file);		if  (path(0) <> 0)								/*	for our purposes we need	*/		and (byte(path,path(0)-1) <> colon)			/*	a colon at the end of the	*/		then call APPENDC(path,colon);				/*	file name						*/	end;	i = Find.Next.Sorted.Filename (AEE.Seq.Cat, 8, Cat.Cache.Entries, dir, file, outfile, bits(ftyp));	if i = 0 then do;										/*	no file name is available	*/		if dir = -1 then call Display.Notice(NT#TopOfAlphaList,   ATTR#Reverse,NulStr,0,0,0);		else				  call Display.Notice(NT#BottomOfAlphaList,ATTR#Reverse,NulStr,0,0,0);		return 0;	end;	/*	construct and deposit new file name	*/	call APPEND.TO.STR(path,outfile);	if (path(0) > shl(Cur.Seq.Path.Name.Wlen-1,1))		 path(0) = shl(Cur.Seq.Path.Name.Wlen-1,1);	call COPY.STRING(path, nam);	return 1;end Handle.Cat.Cache.Switch.Button;Handle.Sequencer.Switch.Button:proc swapable;	dcl tmp(AEE.Sequence.Name.Wlen)	fixed;	/*	get current user string	*/	if Screen.Event.Info = S#MouseSelect	then do;		call Fetch.Graphics.String(Sequencer.Name.Id, tmp);		if Handle.Cat.Cache.Switch.Button (tmp, T#Sync)		then do;			call GID(AEE.Sequence.Name);			call COPY.OUT(addr(tmp(0)), AEE.Sequence.Name.Wlen);			new.prm.info = new.prm.info | 256;	/*	update editview's seq name display	*/			disable.deposits = 1;			if tmp(0) > 27 then tmp(0) = 27;			call Deposit.Graphics.String (Sequencer.Name.Id, tmp);			disable.deposits = 0;			call Update.Object(Sequencer.Name.Id);		end;	end;end Handle.Sequencer.Switch.Button;/*	$page - handle sequencer storage activity	*/Handle.Sequencer.Storage.Table: proc swapable;	dcl col(1)									fixed;	dcl tmp(AEE.Sequence.Name.Wlen)		fixed;	dcl path(AEE.Sequence.Name.Wlen)		fixed;	dcl file(AEE.Sequence.Name.Wlen+8)	fixed;	dcl new(4)									fixed;	dcl Get.Complete.Tree.Name proc (array, array) external;	clear.statuses:proc;		call DISPLAY.NOTICE (NT#EraseNotice,ATTR#Normal,NulStr,0,0,0);		call REMOVE.ERR;	end clear.statuses;	Locate.Type.And.Protect:proc (tmp);	/*	check exists, type, not protected	*/		dcl tmp	array;		if not(LOCATE(tmp,1))		then do;			call handle.cat.error(1);			return 0;		end;		if (F#Type <> T#Sync)		or (F#LS_Length = 0 )		then do;			call DISPLAY.NOTICE (NT#NotASyncFile,ATTR#Reverse,tmp,0,0,0);			return 0;		end;		call READDATA(F#MS_Sector, F#LS_Sector, Misc.Buf, 256);		if (((Misc.Buf(MAGIC.NUMBER) = MAGIC#5)		||   (Misc.Buf(MAGIC.NUMBER) = MAGIC#6)		||   (Misc.Buf(MAGIC.NUMBER) = MAGIC#7))		&&  ((Misc.Buf(SEQ.PROT)&1) <> 0))		then do;			call DISPLAY.NOTICE (NT#SeqIsProtected,ATTR#Reverse,tmp,0,0,0);			return 0;		end;		call Check.Next.Event;		return 1;	end Locate.Type.And.Protect;	call Fetch.Graphics.String(Sequencer.Name.Id, tmp);	if Screen.Event.Info = S#MouseSelect	then do;		call clear.statuses;		CALL STOP.RECD.MOVE.PLAY.XPOS.CONT.ERAS;		CALL DISPLAY.SEQUENCER.STATUS;		call Map.Graphics.Button.Table.Mouse.Press(Sequencer.Storage.Table, col);		call Highlight.Graphics.Button.Table(Sequencer.Storage.Table, bits(col(0)), 2, 0);		call Check.Next.Event;		do case (col(0));				/*	branch on column	*/			do;							/*	delete sequence	*/				if  (Locate.Type.And.Protect(tmp))				and (Get.Motion.Dialog(tmp,0,new,0))				then do;					if not(DELETE(tmp,1))						/*	delete it	*/					then call handle.cat.error(1);					else call DISPLAY.NOTICE (NT#SeqDeleted,ATTR#Normal,tmp,0,0,0);					call Cache.Seq.Cat.If.Possible (tmp);	/*	get new catalog without that file	*/					Protocol.Cat.Cache.File.Type = 0;		/*	refresh protocol catalog cache		*/				end;			end;			do;							/*	rename sequence	*/				if  (Locate.Type.And.Protect(tmp))				and (Get.Motion.Dialog(tmp,1,new,0))				then do;					if not(RENAME(tmp,new,1))					/*	rename it	*/					then do;						if C#Status = E#Duplicate						then call DISPLAY.NOTICE (NT#DupSeqName,ATTR#Reverse,new,0,0,0);						else do;							call COPY.STRING(new,F#NAME);		/*	for error messages	*/							call handle.cat.error(1);						end;					end;					else do;											/*	re-enter string		*/						call Parse.Treename.String (tmp, path, file);						if  (path(0) <> 0)						/*	for our purposes we need	*/						and (byte(path,path(0)-1) <> colon)	/*	a colon at the end of the	*/						then call APPENDC(path,colon);		/*	file name						*/						call APPEND.TO.STR(path,new);						if (path(0) > shl(AEE.Sequence.Name.Wlen-1,1))							 path(0) = shl(AEE.Sequence.Name.Wlen-1,1);						call GID(AEE.Sequence.Name);						call COPY.OUT(addr(path(0)), AEE.Sequence.Name.Wlen);						new.prm.info = new.prm.info \ 256;	/*	update various sequence name displays	*/						disable.deposits = 1;						call Deposit.Graphics.String (Sequencer.Name.Id, path);						disable.deposits = 0;						call Update.Object(Sequencer.Name.Id);						call DISPLAY.NOTICE (NT#SeqRenamed,ATTR#Normal,path,0,0,0);					end;					call Cache.Seq.Cat.If.Possible (tmp);	/*	get new catalog withnew name			*/					Protocol.Cat.Cache.File.Type = 0;		/*	refresh protocol catalog cache too	*/				end;			end;			do;							/*	store sequence	*/				if (LOCATE(tmp, 1))	/*	see if exists	*/				then do;					if F#Type <> T#Sync					then do;						call DISPLAY.NOTICE (NT#MustWriteToSyncFile,ATTR#Reverse,tmp,0,0,0);					end;					else do;						call READDATA(F#MS_Sector, F#LS_Sector, Misc.Buf, 256);						if (Misc.Buf(SEQ.PROT)&1) <> 0						then do;							call DISPLAY.NOTICE (NT#SeqIsProtected,ATTR#Reverse,tmp,0,0,0);						end;						else if (Get.Motion.Dialog(tmp,2,new,1))						then do;							call Set.Term.ATTR(ATTR#Normal);							call DRAW.Message('Saving Sequence to Disk...');							call SAVE.SEQUENCE(tmp, 1, 1);			/*	re-write	*/							call Cache.Seq.Cat.If.Possible (tmp);	/*	get new catalog withnew name			*/							Protocol.Cat.Cache.File.Type = 0;		/*	refresh protocol catalog cache on	*/							call Erase.Message;							if ertyp = 0							then call DISPLAY.NOTICE (NT#SeqSaved,ATTR#Normal,tmp,0,0,0);						end;					end;				end;				else do;					if C#Status <> E#No_File			/*	if bad name, tell him	*/					then call handle.cat.error(1);					else if (Get.Motion.Dialog(tmp,2,new,0))					then do;						call Set.Term.ATTR(ATTR#Normal);						call DRAW.Message('Saving Sequence to Disk...');						call SAVE.SEQUENCE(tmp, 1, 1);	/*	re-write	*/						call Cache.Seq.Cat.If.Possible (tmp);	/*	get new catalog withnew name			*/						Protocol.Cat.Cache.File.Type = 0;		/*	refresh protocol catalog cache on	*/						call Erase.Message;						if ertyp = 0						then call DISPLAY.NOTICE (NT#SeqSaved,ATTR#Normal,tmp,0,0,0);					end;				end;			end;			do;							/*	recall sequence	*/				if not(LOCATE(tmp,1))	/*	see if exists	*/				then do;					call Handle.Cat.Error(1);				end;				else if F#Type <> T#Sync				then do;					call DISPLAY.NOTICE (NT#NotASyncFile,ATTR#Reverse,tmp,0,0,0);				end;				else if (Get.Motion.Dialog(tmp,3,new,0))				then do;					call Set.Term.ATTR(ATTR#Normal);					call DRAW.Message('Recalling Sequence from Disk...');					if not(LOCATE(tmp,1))	/*	set up file pointers again	*/					then do;						call Handle.Cat.Error(1);					end;					else do;						/*	recall sequence				*/						SHOW.FILE.LOADING.MESSAGE = shl(23,8) \ 40;						if (TRY.TO.READ.SEQ(F#MS_SECTOR,F#LS_SECTOR) == TRUE)						{							if (NUM.OF.HELD.TRACK.BUTTONS == 0)							{								Get.Complete.Tree.Name(tmp, file);								if (file(0) > shl(Cur.Seq.Path.Name.Wlen-1,1))									 file(0) = shl(Cur.Seq.Path.Name.Wlen-1,1);								call GID(Cur.Seq.Path.Name);								call COPY.OUT(addr(file(0)), Cur.Seq.Path.Name.Wlen);							}						}						SHOW.FILE.LOADING.MESSAGE = 0;					end;					call Erase.Message;				end;			end;		end;		call Highlight.Graphics.Button.Table(Sequencer.Storage.Table, 0, 2, 0);	end;end Handle.Sequencer.Storage.Table;GET.MOTION.EVENT: proc (event) returns (fixed) public swapable;	dcl event	fixed;	clear.statuses:proc;		call DISPLAY.NOTICE (NT#EraseNotice,ATTR#Normal,NulStr,0,0,0);		call REMOVE.ERR;	end clear.statuses;	do while 1;		if event <> Get.Null.Event then do;			if Screen.Event.Group <> Motion.Group then return event;			if event = Get.Screen.Event then do;				if Screen.Event.Id = Motion.Control.Table				then call Handle.Motion.Control.Table;				else if Screen.Event.Id = Midi.Control.Table				then call Handle.Midi.Control.Table;				else if Screen.Event.Id = Midi.Recd.Track				then call Handle.Midi.Recd.Track;				else if Screen.Event.Id = Locate.Off.Store.Table				then call Handle.Locate.Off.Store.Table;				else if Screen.Event.Id = Locate.Time.Id				then call Handle.Locate.Time.Id;				else if Screen.Event.Id = Locate.Take.Button				then call Handle.Locate.Take.Button;				else if Screen.Event.Id = Locate.Button.Table				then call Handle.Locate.Button.Table;				else if (Screen.Event.Id = Verse.Name.Id.#1)				or		  (Screen.Event.Id = Verse.Name.Id.#2)				or		  (Screen.Event.Id = Sequencer.Caption.#1)				or		  (Screen.Event.Id = Sequencer.Caption.#2)				then do;					if Screen.Event.Info = S#Deposit			/*	store stack in seq	*/					then do;											/*	on string deposit		*/						call clear.statuses;						/*	so current value		*/						call Store.Entire.AEE.Locate.Stack(1);																		/*	is always avail		*/																		/*	also save seq			*/																		/*	caption for write		*//*	provide	*/		if  ((Screen.Event.Id = Verse.Name.Id.#1)/*	crlf for	*/		or   (Screen.Event.Id = Sequencer.Caption.#1))/*	user		*/		and (Cur.Obj.Id = Screen.Event.Id)						then call Select.New.Cur.Obj(Screen.Event.Id + 1, -1, -1);					end;				end;				else if Screen.Event.Id = Sequencer.Protect.Button				then call Handle.Sequencer.Protect.Button;				else if Screen.Event.Id = Sequencer.Name.Id				then call Handle.Sequencer.Name.Id;				else if Screen.Event.Id = Sequencer.Switch.Button				then call Handle.Sequencer.Switch.Button;				else if Screen.Event.Id = Sequencer.Storage.Table				then call Handle.Sequencer.Storage.Table;			end;		end;		event = Get.Next.Screen.Event;	end;end GET.MOTION.EVENT;