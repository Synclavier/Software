/* AUD-SEQ6   $TITLE  handle sequence panel events   Modified:   11/01/90 - cj  - more note moving capability   01/18/90 - MWH - Stop playback properly when mouse button is released   05/24/89 - cj  - allow MONO or POLY playback when triggering cues                    from sequence panal (works better that way with                    polyphonic tracks)   05/05/89 - cj  - recall complete event to cue editor when clicking                    on event   04/29/89 - cj  - move play.#.note to seqmods as audition.music.note                  - changes to trigger event by id   04/26/89 - CJ  - use expand.event.note instead of expand.cue.note to get cue ID*//* Subroutine to handle move/copy of a block of notes */handle.block.move: proc(row, trk, time1) swapable;   dcl row        fixed;   dcl trk        fixed;   dcl time1      array;   dcl time2 (1)  fixed;   dcl time3 (1)  fixed;   Seq.Refresh = Seq.Refresh \ 8;   Note.Area.Force(row) = (-1);   call Fetch.Table(Seq.Event.Time.Table, 0, row);   call Fetch.32Bit.MSEC(Seq.Event.Time.Type, time2);   call SUB32(time2, time1, time3);   /* get delta */   call MOVE.SELECTED.NOTES(time3, 0, 1);   call Find.Note(time2, -1, -1, -1, -1, trk, row, 0, bits(trk));end handle.block.move;/* handle takes from event time take buttons */Handle.Seq.Take: proc swapable;   dcl tmp   (2)   fixed;   dcl time  (2)   fixed;   dcl i           fixed;   dcl j           fixed;   dcl k           fixed;   dcl row         fixed;   dcl time1  (1)  fixed;   dcl trk         fixed;   if Screen.Event.Info = S#MouseSelect   then do;      call TAKE.SYSTEM.SEQUENCE.TIME(time);      /* get synclav time immediately */      call Map.Graphics.Button.Table.Mouse.Press(Seq.Event.Take.Table, tmp);      i = tmp(1);   /* get line #           */      row = i;      /* assume row # matches */      /* see whether headings are being shown.   Offset the table */      /* if they are.                                             */      if  (Show.No.Headings = 0)  /* if headings desired     */      and ((Seq.Size-4) > 1    )  /* and room for them       */      then do;         if i = 0                 /* use clicked on the T on the */         then return;             /* heading row.                */         else row = i - 1;        /* else back up row by 1       */      end;      /* make sure a time in this row is displayed: */      if (Event.Time.Enabled & bits(row)) <> 0      then do;         call Highlight.Graphics.Button.Table      /* flash user */         (Seq.Event.Take.Table, bits(i),  2, 0);          call SELECT.NEW.CUR.OBJ (Seq.Event.Time.Table, 0, row);         /* show new time to user immediately,  even if it is about */         /* to scroll somewhere:                                    */         disable.deposits = 1;         call Fetch.Table       (Seq.Event.Time.Table, 0, row);         call Deposit.32bit.Msec(Seq.Event.Time.Type, time, Zero.Zero);         call Deposit.Table     (Seq.Event.Time.Table, 0, row);         disable.deposits = 0;         /* if no event on this row was selected,  then pick */         /* the first one:                                   */         if (Highlighted(row) = 0)         then do;            call Clear.All.Highlights;   /* clear other highlights */            j = 0;            do while ((Note.Area.Contents(row) & bits(j)) = 0)            and      (j < Seq.Tracks);               j = j + 1;            end;            if j < Seq.Tracks            then call Set.Highlight(row, j);         end;         trk = Find.Row.Time(row, time1);            /* get time of row handy                    */         if ((Event.Time.Enabled & bits(row)) <> 0)  /* if start time enabled on this row        */         &  ((Note.Area.Contents(row)                /* there is a highlighted note on this row  */              &    Highlighted  (row))        <> 0)         &  (Seq.Dialog.Mode = SEQ#EventMoveDialog)  /* and move/copy in progres                 */         &  (trk                              >= 0)  /* and a note shown on row                  */         then call handle.block.move(row, trk, time1);         else call CHANGE.SEQ.SELECTED.NOTE.TIMES (bits(row), 0);         if (Seq.Dialog.Mode = SEQ#EventDeleteDialog)         or (Seq.Dialog.Mode = SEQ#EventMoveDialog  )         then call Close.Seq.Dialog;         call Highlight.Graphics.Button.Table      /* flash user */         (Seq.Event.Take.Table, 0, 2, 0);       end;   end;end Handle.Seq.Take;Handle.Seq.End.Time.Take: proc swapable;   dcl tmp   (2)   fixed;   dcl time  (2)   fixed;   dcl i           fixed;   dcl j           fixed;   dcl k           fixed;   dcl col         fixed;   col = Screen.Event.Id - Seq.End.Time.Take.Table;   if Screen.Event.Info = S#MouseSelect   then do;      call TAKE.SYSTEM.SEQUENCE.TIME(time);      /* get synclav time immediately */      call Map.Graphics.Button.Table.Mouse.Press(Screen.Event.Id, tmp);      i = tmp(1);   /* get row # */      /* make sure a time in this row is displayed: */      if  ((Event.Time.Enabled    & bits(i))   <> 0)      and (Seq.End.Time.Table                  <> 0)      and ((Note.Area.Contents(i) & bits(col)) <> 0)      then do;         call Highlight.Graphics.Button.Table      /* flash user */         (Seq.End.Time.Take.Table + col, bits(i),  2, 0);          call SELECT.NEW.CUR.OBJ (Seq.End.Time.Table + col, 0, i);         /* show new time to user immediately,  even if it is about */         /* to scroll somewhere:                                    */         disable.deposits = 1;         call Fetch.Table       (Seq.End.Time.Table + col, 0, i);         call Deposit.32bit.Msec(Seq.End.Time.Type + col, time, Zero.Zero);         call Deposit.Table     (Seq.End.Time.Table + col, 0, i);         disable.deposits = 0;         call Change.Seq.Note.Duration(i, col, 1, 0);         if  (Seq.Dialog.Mode = SEQ#EventDeleteDialog)         or  (Seq.Dialog.Mode = SEQ#EventMoveDialog  )         then call Close.Seq.Dialog;         call Highlight.Graphics.Button.Table      /* flash user */         (Seq.End.Time.Take.Table + col, 0, 2, 0);       end;   end;end Handle.Seq.End.Time.Take;Handle.Seq.Event.Time: proc swapable;   dcl time1  (1) fixed;   dcl trk        fixed;   Perform.Event.Table.Selection: proc;      dcl (i,j,k) fixed;      /* try highlighting the start time entry quickly: */      call Update.Table.Object(Seq.Event.Time.Table, 0,                                Screen.Event.Table.Row, Seq.Event.Time.Type);      /* Algorithm:  if there is no note on this line,  then clear */      /*             all selections.                               */      /*             If there is a note on this line and it is     */      /*             selected,  leave selections alone.            */      /*             If there is a note on this line and no note   */      /*             on this line is selected,  select first note  */      /*             on line.                                      */      /* so,  begin by seeing if there is a note on this line */      /* If no note on line,  clear all selections */      if  Note.Area.Contents(Screen.Event.Table.Row) = 0      then do;         call Clear.All.Highlights;         call Clean.Out.Verify.Tracks;         if (Seq.Dialog.Mode = SEQ#RippleVerifyDialog)         then call CLOSE.SEQ.DIALOG;      end;      /* else see if an actual note is selected: */      else if  (Note.Area.Contents(Screen.Event.Table.Row)           &    Highlighted       (Screen.Event.Table.Row)) <> 0      then do;         /* leave current selections highlighted */      end;      /* else select the first note on the line */      else do;         i = 0;         do while (Note.Area.Contents(Screen.Event.Table.Row) & bits(i)) = 0;            i = i + 1;         end;         call Clear.All.Highlights;         call Clean.Out.Verify.Tracks;         if (Seq.Dialog.Mode = SEQ#RippleVerifyDialog)         then call CLOSE.SEQ.DIALOG;         call Set.Highlight(Screen.Event.Table.Row, i);      end;   end Perform.Event.Table.Selection;   /* check for new time entered: */   if Screen.Event.Info = S#Deposit then do;      /* reselect our table after drag so user is set to verify */      if  (Cur.Obj.Id <> Seq.Event.Time.Table)      then do;         call SELECT.NEW.CUR.OBJ (Seq.Event.Time.Table, 0, Screen.Event.Table.Row);         call Update.Table.Object(Seq.Event.Time.Table, 0, Screen.Event.Table.Row, Seq.Event.Time.Type);      end;      /* selection is often not there after drag.  do it now:	*/      if Highlighted(Screen.Event.Table.Row) = 0      then call Perform.Event.Table.Selection;      /* If move/copy dialog is selected, then perform move of	*/      /* notes as needed:													*/      trk = Find.Row.Time(Screen.Event.Table.Row, time1);            /* get time of row handy                    */      if ((Event.Time.Enabled & bits(Screen.Event.Table.Row)) <> 0)  /* if start time enabled on this row        */      &  ((Note.Area.Contents(Screen.Event.Table.Row)                /* there is a highlighted note on this row  */           &    Highlighted  (Screen.Event.Table.Row))        <> 0)      &  (Seq.Dialog.Mode = SEQ#EventMoveDialog                   )  /* and move/copy in progres                 */      &  (trk                                                 >= 0)  /* and a note shown on row                  */      then call handle.block.move(Screen.Event.Table.Row, trk, time1);      else call CHANGE.SEQ.SELECTED.NOTE.TIMES (bits(Screen.Event.Table.Row),0);      if (Seq.Dialog.Mode = SEQ#EventDeleteDialog)      or (Seq.Dialog.Mode = SEQ#EventMoveDialog  )      then call Close.Seq.Dialog;   end;   /* when pressing down/up arrows in start time table */   /* move highlight to first note on the row          */   else if ((Screen.Event.Info = S#MouseSelect  ))   or      ((Screen.Event.Info = S#MouseActivate))   or      ((Screen.Event.Info = S#ArrowSelect  )   and      ((Fetch.Object.Info(Prev.Obj.Id, O#Action) & O#ACT.Prev.Obj) = 0)   and      ( Fetch.Object.Info(Prev.Obj.Id, O#Type  )     <> O$Scroll.Bar  )   and      ( Cur.Obj.Id       = Screen.Event.Id                            ))   then do;      call Perform.Event.Table.Selection;   end;   else if Screen.Event.Info = S#ObjectDrag then do;      call Perform.AEE.Drag.Function(Screen.Event.Id,Screen.Event.Obj.Info);      call Select.New.Cur.Obj(Corner.Label,-1,-1);   end;end Handle.Seq.Event.Time;Check.S.Page.Limits: proc swapable;  /* update S page for highlighted region */   dcl tmp(1) fixed;   dcl (i,j ) fixed;   /* Find first highlighted row */   i = 0;   do while (i < Seq.Event.Display.Size)   and      (Highlighted(i) = 0);      i = i + 1;   end;   if i = Seq.Event.Display.Size then return; /* no line highlighted */   /* set S page edit region: */   if Find.Row.Time(Screen.Event.Table.Row, tmp) < 0   then return;  /* no time on row - leave unchanged */   call pid32(sav.time1.ms, tmp);  /* save edit in as time on this row */   /* find last highlighted row */   i = Seq.Event.Display.Size-1;   do while (i >= 0)   and      (Highlighted(i) = 0);      i = i - 1;   end;   /* set edit out equal to time of NEXT note, on or off */   /* screen:                                            */   if  (i >= (Seq.Event.Display.Size-1))   or  (Find.Row.Time(i+1, tmp) < 0)   then do;      if Seq.Screen.End(0) = (-1)      then do;         call Find.Row.Time(i, tmp);         call ADD16(60000, tmp);      end;      else do;         call COPY32(Seq.Screen.End, tmp);      end;   end;   call pid32(sav.time2.ms, tmp);end Check.S.Page.Limits;/* $page - subroutine to handle selection of note area objects: */dcl Seq.Press.Row             fixed;dcl Seq.Press.Col             fixed;Handle.Note.Area.Select: proc(Type.Id, Table.Id) swapable;   dcl Type.Id      fixed;   dcl Table.Id     fixed;   dcl col          fixed;   dcl Event  (event.record.size-1)  fixed;   dcl (trk,msb,lsb,count,i)         fixed;   col = Screen.Event.Id - Table.Id;       /* get col, relative to left */   i   = Mouse(Button.Result);             /* check which button        */   if (Seq.Dialog.Mode = SEQ#EventMoveDialog)   then do;      call SELECT.NEW.CUR.OBJ(Corner.Label, -1, -1);      call Update.Table.Object(Table.Id + col, col,                               Screen.Event.Table.Row, Type.Id + col);      call DRAG.SEQ.NOTE.AND.MOVE (Screen.Event.Table.Row, col);      return;   end;   /* trigger audio quickly if possible     */   if Seq.Info.Track <> 0                  /* turn off any prior        */   then do;                                /* info notes.               */      call Stop.Info.Note(Seq.Info.Track);      Seq.Info.Track = 0;   end;   if Get.Snapshot.Info(AEE.Cur.Seq.Snap, col, TRKINDEX, Screen.Event.Table.Row)   then do;                         /* set up # vars with correct info */      trk=#trk;                     /* save track     */      msb=#nmsb; lsb=#nlsb;         /* save note time */      count=#count;                 /* and count      */      if Trk.Head.Lookup(trk,THD.CUE.TRACK)=0      then do; /* track is not a cue track */         if DTD.Play.State=5                              /* turn off any currently playing cue */         OR DTD.Play.State=2 then call Stop.DTD.PlayBack;         call Audition.Music.Note;                        /* try to play music note */         call Set.Group.Get(Seq.Group,Get.Mouse.Button,true);         Seq.Info.Track = #trk;                           /* save for stopping note */      end;      else do; /* here is a cue track */         call Expand.Event.Note(Event, 1);      /* get cue id & event info */         Event(event.track#    ) = trk;   /* save away track, time, count  */         Event(event.time.msb  ) = msb;   /* of this note for possible     */         Event(event.time.lsb  ) = lsb;   /* "replace" function            */         Event(event.time.count) = count;         if (Event(event.type) = event.type.cue  )         or (Event(event.type) = event.type.event)         then do;            if (GID(Saved.CM.Function.Switch)<2)            then do; /* play cue */               if GID(Saved.CM.Playback.Switch) = 1   /* if mono playbadck desired, */               then call Stop.DTD.Playback;           /* then do so!                */               if (Event(event.type) = event.type.cue)               then call Trigger.DTD.Cue(Event(event.cue.id), 32768\#trk, 0);               else if (Event(event.type) = event.type.event)               then call Trigger.DTD.Cue(Event(event.cue.id), 32768\#trk, addr(Event(0)));               if  (GID(Saved.CM.Function.Switch) <> 1)  /* if we want to recall cue */               and (Shuttle.Group                 <> 0)  /* and shuttle is there     */               and (DTD.Play.State                 = 5)  /* and trigger.dtd.cue was successful */               then DTD.Play.State                 = 2;  /* then pretend we triggered it from the cue editor */            end;            if (GID(Saved.CM.Function.Switch)<>1) then do; /* recall cue */               call Set.Place.Track(trk); /* set place track our trk */               call Recall.Current.Cue.By.Id(Event(event.cue.id),2,Event);            end;            if (GID(Saved.CM.Function.Switch)<2) then do;               call Set.Group.Get(Seq.Group,Get.Mouse.Button,true);            end;         end;         /* else stop playback if user clicked on an ILP or RTE on the */         /* cue list track                                             */         else if DTD.Play.State=5    /* stop any currently playing cue */              OR DTD.Play.State=2 then call Stop.DTD.PlayBack;      end;   end;   else if DTD.Play.State=5      /* turn off any currently playing cue */        OR DTD.Play.State=2 then call Stop.DTD.PlayBack;   /* try highlighting table entry quickly: */   call Update.Table.Object(Table.Id + col, col,                            Screen.Event.Table.Row, Type.Id + col);   /* now select that note.  if no note is there then    */   /* toggle.seq.select will select corner label for us  */   if abs(i) = 2                     /* basic selection - clear out highlights */   then call Clear.All.Highlights;   call Clean.Out.Verify.Tracks;   if (Seq.Dialog.Mode = SEQ#RippleVerifyDialog)   then call CLOSE.SEQ.DIALOG;   if (abs(i) = 2)   then call Set.Highlight(Screen.Event.Table.Row,    col);   else call Toggle.Highlight(Screen.Event.Table.Row, col);   /* set up for drag information if middle button pressed */   if abs(i) = 2   then do;      call Mouse.Switch(0);      Seq.Press.Row   = Screen.Event.Table.Row;      Seq.Press.Col   = col;      /* enable for mouse movements and button releases */      /* so we can drag to select a region              */      call Set.Group.Get(Seq.Group, Get.Mouse.Button,   true);      call Set.Group.Get(Seq.Group, Get.Mouse.Movement, true);   end;   else do;                      /* else no drag */      Seq.Press.Row = (-1);      Seq.Press.Col = (-1);      call Check.S.Page.Limits;  /* update S page for highlighted region */   end;   /* refresh dialog boxes if needed: */   if  (Seq.Dialog.Mode = SEQ#TrackBounceDialog)   and (Trkindex(col)  >= Num.Kbd.Tracks       )   then call STUFF.BOUNCE.TRACK (Trkindex(col) );   else if (Seq.Dialog.Mode = SEQ#TrackEraseDialog)   then call Toggle.Seq.Track.Display.Solo(col);end Handle.Note.Area.Select;/* Now perform the drag selection */Handle.Seq.Mouse.Movement: proc swapable;   dcl (mx,my) fixed;   dcl (tx,ty) fixed;   dcl row     fixed;   dcl col     fixed;   dcl (i ,j ) fixed;   dcl Selected.Upper.Row  fixed;   dcl Selected.Lower.Row  fixed;   dcl Selected.Left.Col   fixed;   dcl Selected.Right.Col  fixed;   if Seq.Press.Row < 0 then return;  /* should not be seing movements */   /* Ignore movements after button has been released: */   if M$RELEASES <> 0   then return;   mx = mouse(current.x);   my = mouse(current.y);   if mx < 23 then mx = 23; /* limit to avoid division errors */   if my < 42 then my = 42; /* in tpos.x and tpos.y           */   tx = tpos.x(mx);   ty = tpos.y(my);   /* limit to note area: */   if  tx < Seq.Event.Display.Left.X then tx = Seq.Event.Display.Left.X;   if  ty < Seq.Event.Display.Row    then ty = Seq.Event.Display.Row;   load  tx - Seq.Event.Display.Left.X;   div   spacing;   col = res;   if   col > (Seq.Tracks             - 1)   then col = (Seq.Tracks             - 1);   row = ty - Seq.Event.Display.Row;   if   row > (Seq.Event.Display.Size - 1)   then row = (Seq.Event.Display.Size - 1);   /* figure out the rectangle covered by the press position */   /* and the current position:                              */   if row > Seq.Press.Row then do;      Selected.Upper.Row = Seq.Press.Row;      Selected.Lower.Row = row;   end;   else do;      Selected.Upper.Row = row;      Selected.Lower.Row = Seq.Press.Row;   end;   if Col > Seq.Press.Col then do;      Selected.Right.Col = Col;      Selected.Left.Col  = Seq.Press.Col;   end;   else do;      Selected.Right.Col = Seq.Press.Col;      Selected.Left.Col  = Col;   end;   /* highlight any notes within that rectangle */   do i = 0 to Seq.Event.Display.Size - 1;      do j = 0 to Seq.Tracks - 1;         if  (i >= Selected.Upper.Row)         and (i <= Selected.Lower.Row)         and (j >= Selected.Left.Col )         and (j <= Selected.Right.Col)         then call Set.Highlight  (i, j);         else call Clear.Highlight(i, j);      end;   end;end Handle.Seq.Mouse.Movement;Handle.Seq.Mouse.Release: proc swapable;   /* done with selecting - disable for these events */   call Set.Group.Get(Seq.Group, Get.Mouse.Button,   false);   call Set.Group.Get(Seq.Group, Get.Mouse.Movement, false);   /* stop playing from 'play from' using intelligent algorithm */   if Seq.Panel.Started.Play <> 0   then do;      Seq.Panel.Started.Play = 0;      if  ((Mouse(Release.Time)-Mouse(Press.Time)) IGE 200)      then call Stop.Sequencer;      call Highlight.Graphics.Button.Table.Entry         (Seq.Delete.Move.Play.From, 2, 0, 0, 2, 0);      return;   end;   if  ((Mouse(Release.Time)-Mouse(Press.Time)) IGE 200)   AND ((DTD.Play.State=5) OR (DTD.Play.State=2))   then do;      call Stop.DTD.Playback; /* turn off currently playing cue */   end;   if Seq.Press.Row >= 0   then call Mouse.Switch(1);   if Seq.Info.Track <> 0   then do;      call Stop.Info.Note(Seq.Info.Track);      Seq.Info.Track = 0;   end;   call Check.S.Page.Limits;  /* update S page for highlighted region */end Handle.Seq.Mouse.Release;/* $page - handle specific note area object events: */Handle.Seq.Pitch.Name: proc swapable;   dcl col          fixed;   col = Screen.Event.Id - Seq.Pitch.Name.Table; /* get col, relative to left */   if Screen.Event.Info = S#Deposit then do;      call Change.Seq.Note.Pitch(Screen.Event.Table.Row, col, 0, 0);   end;   else if (Screen.Event.Info = S#MouseSelect  )   or      (Screen.Event.Info = S#MouseActivate)   then do;      call Handle.Note.Area.Select(Seq.Pitch.Name.Type,  Seq.Pitch.Name.Table);   end;end Handle.Seq.Pitch.Name;Handle.Seq.Key.Number: proc swapable;   dcl col          fixed;   col = Screen.Event.Id - Seq.Key.Number.Table; /* get col, relative to left */   if Screen.Event.Info = S#Deposit then do;      call Change.Seq.Note.Pitch(Screen.Event.Table.Row, col, 1, 0);   end;   /* no dragging animation from key number field: */   else if (Screen.Event.Info = S#MouseSelect  )   or      (Screen.Event.Info = S#MouseActivate)   then do;      call Update.Table.Object(Screen.Event.Id, col,                               Screen.Event.Table.Row, Seq.Key.Number.Type + col);   end;end Handle.Seq.Key.Number;Handle.Seq.Event.Name: proc swapable;   dcl (i,j,k) fixed;   if Screen.Event.Info = S#Deposit then do;      /* label deposit??? oops.*/   end;   /* Select the starting time of the object in question,  since we */   /* we cannot type in a new event name.                           */   else if (Screen.Event.Info = S#MouseSelect  )   or      (Screen.Event.Info = S#MouseActivate)   then do;      call SELECT.NEW.CUR.OBJ(Seq.Event.Time.Table, 0, Screen.Event.Table.Row);      call Handle.Note.Area.Select(Seq.Event.Name.Type,  Seq.Event.Name.Table);      call Update.Table.Object(Seq.Event.Time.Table, 0, Screen.Event.Table.Row, Seq.Event.Time.Type);   end;end Handle.Seq.Event.Name;Handle.Seq.Duration: proc swapable;   dcl col          fixed;   col = Screen.Event.Id - Seq.Duration.Table; /* get col, relative to left */   if Screen.Event.Info = S#Deposit then do;      /* reselect our table after drag so user is set to verify */      if  (Cur.Obj.Id <> (Seq.Duration.Table+col))      then do;         call SELECT.NEW.CUR.OBJ (Seq.Duration.Table+col, 0, Screen.Event.Table.Row);         call Update.Table.Object(Seq.Duration.Table+col, col, Screen.Event.Table.Row, Seq.Duration.Type+col);      end;      call Change.Seq.Note.Duration(Screen.Event.Table.Row, col, 0, 0);   end;   /* no dragging animation from duration field: */   else if (Screen.Event.Info = S#MouseSelect  )   or      (Screen.Event.Info = S#MouseActivate)   then do;     call Update.Table.Object(Screen.Event.Id, col,                              Screen.Event.Table.Row,Seq.Duration.Type+col);   end;   else if Screen.Event.Info = S#ObjectDrag then do;      call Perform.AEE.Drag.Function(Screen.Event.Id,Screen.Event.Obj.Info);      call Select.New.Cur.Obj(Corner.Label,-1,-1);   end;end Handle.Seq.Duration;Handle.Seq.End.Time  : proc swapable;   dcl col          fixed;   col = Screen.Event.Id - Seq.End.Time.Table; /* get col, relative to left */   if Screen.Event.Info = S#Deposit then do;      /* reselect our table after drag so user is set to verify */      if  (Cur.Obj.Id <> (Seq.End.Time.Table+col))      then do;         call SELECT.NEW.CUR.OBJ (Seq.End.Time.Table+col, 0, Screen.Event.Table.Row);         call Update.Table.Object(Seq.End.Time.Table+col, col, Screen.Event.Table.Row, Seq.End.Time.Type+col);      end;      call Change.Seq.Note.Duration(Screen.Event.Table.Row, col, 1, 0);   end;   /* no dragging animation from duration field: */   else if (Screen.Event.Info = S#MouseSelect  )   or      (Screen.Event.Info = S#MouseActivate)   then do;     call Update.Table.Object(Screen.Event.Id, col,                              Screen.Event.Table.Row, Seq.End.Time.Type+ col);   end;   else if Screen.Event.Info = S#ObjectDrag then do;      call Perform.AEE.Drag.Function(Screen.Event.Id,Screen.Event.Obj.Info);      call Select.New.Cur.Obj(Corner.Label,-1,-1);   end;end Handle.Seq.End.Time;Handle.Seq.Velocity  : proc swapable;   dcl col          fixed;   col = Screen.Event.Id - Seq.Velocity.Table; /* get col, relative to left */   if Screen.Event.Info = S#Deposit then do;      call Change.Seq.Note.Velocity(Screen.Event.Table.Row, col);   end;   else if (Screen.Event.Info = S#MouseSelect  )   or      (Screen.Event.Info = S#MouseActivate)   then do;      call Update.Table.Object(Screen.Event.Id, col,                               Screen.Event.Table.Row, Seq.Velocity.Type + col);   end;end Handle.Seq.Velocity;Handle.Seq.Caption: proc swapable;   dcl col          fixed;   col = Screen.Event.Id - Seq.Caption.Table; /* get col, relative to left */   if Screen.Event.Info = S#Deposit then do;      call Change.Seq.Note.Caption(Screen.Event.Table.Row, col);   end;   else if (Screen.Event.Info = S#MouseSelect  )   or      (Screen.Event.Info = S#MouseActivate)   then do;      call Update.Table.Object(Screen.Event.Id, col,                               Screen.Event.Table.Row, Seq.Caption.Type + col);   end;end Handle.Seq.Caption;/* $page - routines for scroll bar - advance and backup display *//* Advance sequencer by one page (accurately): */Advance.AEE.Snapshot.By.1.Page: proc swapable;   dcl tmp (1) fixed;   dcl i       fixed;   /* if bottom line of display is empty,  then there are no more lines */   /* to display:                                                       */   if Find.Row.Time(Seq.Event.Display.Size-1, tmp) < 0   then return 0;   /* If no more notes are after us,  then no more lines to display:    */   if Seq.Screen.End(0) = (-1)   then return 0;   /* If the next note starts AFTER the time of the last line on the    */   /* screen,  then we can just take a snapshot from that time:         */   if COM32(Seq.Screen.End, tmp) <> lw#ieq   then do;      call COPY32(Seq.Screen.End, Seq.Refresh.Time);      Seq.Note.Skip = 0;      call Take.New.AEE.Snapshot;      /* take a sequence snapshot */      return 1;   end;   /* Else we must scroll forward into the middle of a chord: */   if COM32(Seq.Screen.End, Seq.Refresh.Time) <> lw#ieq   then do;      call COPY32(Seq.Screen.End, Seq.Refresh.Time);      Seq.Note.Skip = 0;   end;   /* Count # of chord-rows at end of this screen: */   i = Seq.Event.Display.Size-1;   do while (i                            >= 0     )   and      (Find.Row.Time(i, tmp)        >= 0     )   and      (COM32(Seq.Refresh.Time, tmp) =  lw#ieq);      i = i - 1;      Seq.Note.Skip = Seq.Note.Skip + 1;   end;   call Take.New.AEE.Snapshot;  /* take a sequence snapshot */   return 1;end Advance.AEE.Snapshot.By.1.Page;/* Advance by 1 line (accurately): */Advance.AEE.Snapshot.By.1.Line: proc swapable;   dcl time1(1)   fixed;   dcl time2(1)   fixed;   if Seq.Event.Display.Size = 1               /* if 1 line display then */   then return Advance.AEE.Snapshot.By.1.Page; /* skip by entire page.   */   if Find.Row.Time(0, time1) < 0     /* get time of information    */   then return 0;                     /* on both rows 1 and 2.      */                                      /* (AKA rows 0 and 1)         */   if Find.Row.Time(1, time2) < 0   then return 0;   if COM32(time2, Seq.Refresh.Time) <> lw#ieq   then do;      call COPY32(time2, Seq.Refresh.Time);      Seq.Note.Skip = 0;   end;   if COM32(time1, time2) = lw#ieq   then Seq.Note.Skip = Seq.Note.Skip + 1;   call Take.New.AEE.Snapshot;      /* take a sequence snapshot */   return 1;end Advance.AEE.Snapshot.By.1.Line;/* backup display by 1 line (accurately) : */Backup.AEE.Snapshot.By.1.Line: proc swapable;   dcl time1 (1)  fixed;   dcl time2 (1)  fixed;   if Seq.Note.Skip <> 0               /* back up 1 line of chord  */   then do;      Seq.Note.Skip = Seq.Note.Skip - 1;      call Take.New.AEE.Snapshot;      /* take a sequence snapshot */      return 1;   end;   if COM16(0, Seq.Refresh.Time) = lw#ieq   /* see if we have already  */   then return 0;                           /* backed up to 0,0        */   /* Save time of first row of screen so we can scroll forward to     */   /* then end of the chord we may find lurking behind us:             */   if Find.Row.Time(0, time1) < 0   then call STR32( -1, -1, time1);   /* now get time of first note behind us:       */   /* if nonzero, then do.snap.shot added 1 msec  */   /* to it for us:                               */   call COPY32(Seq.Screen.Begin, Seq.Refresh.Time);   if COM16(0, Seq.Refresh.Time) <> lw#ieq   then call SUB16(1, Seq.Refresh.Time);   Seq.Note.Skip = 0;   call Take.New.AEE.Snapshot;      /* take a sequence snapshot */   /* We have just backed up to the time of the prior note.  This  */   /* note could actually be a chord that is x lines long.  Now    */   /* advance forward through the display until we are showing     */   /* just 1 line of this new chord:                               */   if Seq.Event.Display.Size = 1   then do while (COM32(Seq.Screen.End, Time1) = lw#ilt);      call Advance.AEE.Snapshot.By.1.Line;   end;   else do while (Find.Row.Time(1, time2) >=0)   and           (COM32(Time2, Time1) = lw#ilt);      call Advance.AEE.Snapshot.By.1.Line;   end;   return 1;end Backup.AEE.Snapshot.By.1.Line;Backup.AEE.Snapshot.By.1.Page: proc swapable;   dcl i fixed;   i = Seq.Event.Display.Size;   /* get # of lines to back up      */   do while i <> 0;                 /* backup that many lines         */      if Seq.Note.Skip >= i         /* backup by part of chord:       */      then do;         Seq.Note.Skip = Seq.Note.Skip - i;         call Take.New.AEE.Snapshot;      /* take a sequence snapshot */         i = 0;      end;      else if Seq.Note.Skip <> 0    /* backup by entire chord:        */      then do;         i = i - Seq.Note.Skip;         Seq.Note.Skip = 0;         call Take.New.AEE.Snapshot;      /* take a sequence snapshot */      end;      else do;                      /* else backup by 1 line          */         call Backup.AEE.Snapshot.By.1.Line;         i = i - 1;      end;   end;   return 1;end Backup.AEE.Snapshot.By.1.Page;/* $page - handle events from note scroll bar: */Handle.Seq.Note.Scroll.Bar: proc swapable;   dcl tmp(1) fixed;   dcl i      fixed;   dcl j      fixed;   Scroll.Cur.Obj: proc(dir);      dcl dir   fixed;      dcl orow  fixed;      dcl nrow  fixed;      if  ( Cur.Obj.Id   =  Seq.Event.Time.Table            )      or  ((Cur.Obj.Id   >= Seq.Note.Area.First.Id         )      and  (Cur.Obj.Id   <= Seq.Note.Area.Last.Id          )      and  (Fetch.Object.Info(Cur.Obj.Id, O#Type) = O$Table))      then do;         orow = Fetch.Object.Info(Cur.Obj.Id, O#TABL.Cur.Row);         nrow = orow + dir;         if (nrow <  0                     )         or (nrow >= Seq.Event.Display.Size)         then call Select.New.Cur.Obj(Corner.Label, -1, -1);         else do;            call Set.Table.Cell.Attr.Set(Cur.Obj.Id, 0, orow, 0);            call Set.Table.Cell.Attr.Set(Cur.Obj.Id, 0, nrow, 1);            call Set.Table.Cur.Cell     (Cur.Obj.Id, 0, nrow   );         end;      end;   end Scroll.Cur.Obj;   if Screen.Event.Info = S#SBBoxMove then do;      /* nothing to animate for now */   end;   else do;      if Screen.Event.Info = S#Deposit then do;         i = Fetch.Scroll.Bar(Seq.Note.Scroll.Bar);         if i < 20 then do;            call STR32(0, 0, Seq.Refresh.Time);            Seq.Note.Skip = 0;            call Take.New.AEE.Snapshot;  /* take a sequence snapshot */         end;         else if i > 980 then do;            call STR32(-1, 0, Seq.Refresh.Time);            Seq.Note.Skip = 0;            call Take.New.AEE.Snapshot;  /* take a sequence snapshot */            call Backup.AEE.Snapshot.By.1.Line;         end;         else if i < 500 then do while i < 500;            call Backup.AEE.Snapshot.By.1.Line;            i = i + 10;         end;         else if i > 500 then do while i > 500;            call Advance.AEE.Snapshot.By.1.Line;            i = i - 10;         end;         disable.deposits = 1;         call Deposit.Scroll.Bar(Seq.Note.Scroll.Bar, 500);         disable.deposits = 0;         call Update.Object(Seq.Note.Scroll.Bar);         call Clear.All.Highlights;         call Scroll.Cur.Obj(100);      end;      else if Screen.Event.Info = S#SBArrowForward then do;         if Advance.AEE.Snapshot.By.1.Line then do;            Highlighted(Seq.Event.Display.Size) = 0;            do i = 0 to Seq.Event.Display.Size-1;               if Highlighted(i) <> Highlighted(i + 1)               then do j = 0 to Seq.Tracks - 1;                  if (Highlighted(i+1) & bits(j)) <> 0                  then call Set.Highlight  (i, j);                  else call Clear.Highlight(i, j);               end;            end;            call Scroll.Cur.Obj(-1);         end;      end;      else if Screen.Event.Info = S#SBArrowBack then do;         if Backup.AEE.Snapshot.By.1.Line then do;            do i = Seq.Event.Display.Size-1 to 1 by (-1);               if Highlighted(i) <> Highlighted(i - 1)               then do j = 0 to Seq.Tracks - 1;                  if (Highlighted(i-1) & bits(j)) <> 0                  then call Set.Highlight  (i, j);                  else call Clear.Highlight(i, j);               end;            end;            if Highlighted(0) <> 0            then do j = 0 to Seq.Tracks - 1;               call Clear.Highlight(0, j);            end;            call Scroll.Cur.Obj(+1);         end;      end;      else if Screen.Event.Info = S#SBPageForward then do;         call Advance.AEE.Snapshot.By.1.Page;         call Clear.All.Highlights;         call Scroll.Cur.Obj(100);      end;      else if Screen.Event.Info = S#SBPageBack then do;         call Backup.AEE.Snapshot.By.1.Page;         call Clear.All.Highlights;         call Scroll.Cur.Obj(100);      end;      call UPDATE.SEQ.POSITION.DISPLAY (Seq.Refresh.Time);   end;end Handle.Seq.Note.Scroll.Bar;/* $page - process command buttons */PROCESS.SEQ.TRACK.CMD.BUTTON.EVENT: proc (code) swapable;   dcl code fixed;   dcl i    fixed;   PERFORM.BOUNCE: proc (Replicate);      dcl Replicate         fixed;      dcl (From.Trk,To.Trk) fixed;      From.Trk=Fetch.Fixed.Point(GID(SEQ#FromTrack))+1;      To.Trk  =Fetch.Fixed.Point(GID(SEQ#ToTrack)  )+1;      if  (From.Trk>=Num.Kbd.Tracks)      and (From.Trk<=(Num.Kbd.Tracks+199))      and (To.Trk  >=Num.Kbd.Tracks)      and (To.Trk  <=(Num.Kbd.Tracks+199))      then call Bounce.Down(From.Trk,To.Trk,0,Replicate);      else; /* error message ? */   end PERFORM.BOUNCE;   if code = 0 then do;         							/* ERASE button */      if Seq.Dialog.Mode = SEQ#TrackEraseDialog      then do;                      					/* do the ERASE */	  			 if ((ERAS != 0) && (ERASE.STYLE != 0))		/* if properly armed, that is!	*/		 {		 	i = ERASE.STYLE;			         	Process.Erase.Button();			if (i == ERASE.SOLOED.TRACKS)	        	CLEAR.TRACK.SOLO.STATES(); 				/* clear solos after erase */         		 	Display.Sequencer.Status();         	Close.Seq.Dialog		();		 }				 else			CLEAR.ERAS.BUTTON();								/* hmmm....					*/      	  end;      else call Open.Seq.Track.Erase.Dialog;   end;   else if code = 1 then do; /* BOUNCE button */      if Seq.Dialog.Mode = SEQ#TrackBounceDialog      then do;         call Perform.Bounce(GID(SEQ#Bounce));         call Close.Seq.Dialog;      end;      else call Open.Seq.Track.Bounce.Dialog;   end;   else if code=2 then do; /* CLEAR SOLOS button */      if Seq.Dialog.Mode = SEQ#TrackClearSolosDialog      then do;         call CLEAR.TRACK.SOLO.STATES();         call Close.Seq.Dialog;      end;      else call Open.Seq.Track.Clear.Solos.Dialog;   end;end PROCESS.SEQ.TRACK.CMD.BUTTON.EVENT;