/* AUD-REC1  $TITLE More Audio Event Editor Recording Routines   Modified:   01/05/91 - cj  - Added "bounce/move" capability to record panel   06/26/91 - cj  - moved gpi punch in recording to main loop   06/20/91 - cj  - allowed ready to preserve triggering cues   11/17/90 - cj  - changed arguments to process.record.panel.record.button                    to provide better punch-in response   09/25/89 - SJS - Fixed TSM bug in Stop.Record.Recording   09/21/89 - SJS - added support for 'THREE' algorithm   05/17/89 - SGS - Made change to PROCESS.CUE.RETAKE.DIALOG call   05/01/89 - cj  - set event.in.s#.msb in construct.recorded.cue   04/14/89 - SJS - changed speech to 'ONE' and music to 'TWO'   12/13/88 - cj  - removed QUICK setting;  changed SMART to SPEECH   10/24/88 - CJ - FIXED DSP/TSM PROBLEMS   09/08/88 - MWH - Add "real" DSP user interface   08/08/88 - cj  - store absolute # of smpte bits in cue record   08/04/88 - MWH - Add DSP interface   08/01/88 - cj - used take.system.sequence.time   */dcl Check.TSM.Options    proc (array) recursive;SET.RECORD.RECORDING.STATE: proc (state) public swapable;   dcl state     fixed;   dcl Set.DTD.Motion.Tallies proc external;   Record.Recording.State = state;   if  ( Record.Recording.State = 0)    /* if not actually recording */   and ((DTD.Play.State         = 6)    /* but we think we are       */   or   (DTD.Play.State         = 8))   /* then record the fact that */   then DTD.Play.State = 0;             /* we are not.               */   call Display.AEE.Record.Ready.Buttons;   call Set.DTD.Motion.Tallies;   if   (Record.Recording.State = 2)   or   (Record.Recording.State = 3)   then call PID(Any.Recording.Happened,1);end SET.RECORD.RECORDING.STATE;/* Set.Record.Mode is called to  change the recording mode */SET.RECORD.MODE: proc(mode) swapable;   dcl mode    fixed;   dcl tmp(3)  fixed;   Record.Mode = mode;   call PID(Record.Mode.Switch.Setting,Record.Mode);   if Record.Mode = RM.ALLOCATE   then do;                               /* allocate mode              */      call GID(AEE.Record.Cue.Name);      /* get saved name from static */      call COPY.IN(addr(misc.buf(0)),17); /* area                       */      disable.deposits = 1;      call deposit.string(Record.Cue.Name.Id,misc.buf);      disable.deposits = 0;      /* check record cue name is called from set.record.panel.attributes below */   end;   call SET.RECORD.PANEL.ATTRIBUTES;   if Record.Mode = RM.CUE.LOCK   then do;                        /* Cue lock */      call Set.Record.Cue.Lock.Times;   end;end SET.RECORD.MODE;/* CONSTRUCT.recorded.cue - sets up misc buf to be a cue *//* for the defined record.name, record.start time, bits  */CONSTRUCT.RECORDED.CUE: proc (start.time,stop.time,drive.bits,sync.time) swapable;   dcl start.time   array;   dcl stop.time    array;   dcl drive.bits   fixed;   dcl sync.time    array;   dcl i            fixed;   /* Construct basic cue with no name or caption (in misc.buf): */   call CREATE.DTD.AUTO.ALLOCATE.CUE(start.time,stop.time,drive.bits,sync.time);   /* pick up the cue name from the record panel: */   do i = 0 to shr(GID(AEE.Record.Cue.Name)+1,1);      misc.buf(CUE.NAME+i) = GID(AEE.Record.Cue.Name+i);   end;   misc.buf(0) = CUE.NAME + 1 + shr(misc.buf(CUE.NAME)+1,1); /* compute and set record length */end CONSTRUCT.RECORDED.CUE;/* routine to define a recorded cue */SAVE.RECORDED.CUE: proc (start.time, stop.time, sync.time, drive.bits, fin, fout, ccapt) returns (fixed) swapable;   dcl start.time		array;   dcl stop.time		array;   dcl sync.time		array;   dcl drive.bits		fixed;   dcl fin				fixed;   dcl fout				fixed;   dcl ccapt			array;   dcl i					fixed;   dcl rec.len			fixed;   dcl cname(17-1)	fixed;   dcl retryctr		fixed;   if DTD.MAX.SECS <> 0 then do;      retry:;      /* duplicate name could occur if some bozo entered a name here, then saved a cue by that name from the cue editor (or by loading a tape), and then pressed record */      call CONSTRUCT.RECORDED.CUE(start.time,stop.time,drive.bits,sync.time);      rec.len = misc.buf(0);      /* Add fade in and caption if needed: */      misc.buf(CUE.FIN ) = fin;                    /* store fade in   */      misc.buf(CUE.FOUT) = fout;                   /* store fade out  */      if ccapt(0) <> 0 then do;                    /* copy caption    */         do i = 0 to shr(ccapt(0)+1,1);            /* into place      */            misc.buf(rec.len+i)=ccapt(i);         end;         rec.len = rec.len + shr(ccapt(0)+3,1);    /* compute new     */         misc.buf(0) = rec.len;                    /* record length   */      end;      call Define.DTD.Cue(misc.buf);      if  (DTD.CUE# = (-2))             /* check for duplicate name */      and (retryctr = ( 0))      then do;         retryctr = 1;         call CHECK.RECORD.CUE.NAME;    /* get a name that does not exist */         goto retry;      end;      call GID(AEE.Record.Cue.Name);    /* get name handy */      call COPY.IN(addr(cname(0)),17);  /* for message    */      if DTD.Cue# > 0 then do;         call Display.Notice(NT#CueSaved,ATTR#Normal,cname,0,0,0);         call RECALL.CURRENT.CUE.BY.ID(dtd.cue#,1,Zero.Zero); /* put in cue edit if avail */      end;      else if DTD.Cue# < 0 then do;         do case abs(DTD.Cue#);            call Display.Notice(NT#SystemError,ATTR#Normal,NulStr,0,0,0);            call Display.Notice(NT#CueNameTooLong,ATTR#Normal,NulStr,cname(0),0,0);            call Display.Notice(NT#CueNameAlreadyExists,ATTR#Normal,cname,0,0,0);            call Display.Notice(NT#TooManyCues,ATTR#Normal,NulStr,0,0,0);            call Display.Notice(NT#OutOfCueTableMemory,ATTR#Normal,NulStr,0,0,0);            call Display.Notice(NT#CueRecordTooLong,ATTR#Normal,NulStr,rec.len,0,0);         end;      end;      return DTD.Cue#;   end;   else return 0;end SAVE.RECORDED.CUE;CREATE.ALLOCATE.CUE: proc swapable;   dcl cstart (1)  fixed;   dcl cstop  (1)  fixed;   dcl ctrig  (1)  fixed;   /* all times here are 32-bit milliseconds with */   /* respect to the start of the current         */   /* project                                     */   call FETCH.DTD.SYNC.POINT(cstart,ctrig);    /* get sync point - cue start should match sector boundary of punch in point (ie same as diskstart if all software is working) */   call Update.Allocate.Times;                 /* get times for next cue               */   call COPY32(Record.Disk.Start,cstop);       /* this cue stops where next one starts */   call SET.DTD.SYNC.POINT(Record.Disk.Start); /* set new sync info for next cue to match it's start point */      call Save.Recorded.Cue(cstart, cstop, ctrig, Record.Ready.Bits, 0, 0, '');   call CHECK.RECORD.CUE.NAME;  /* presuming save was successful, get new name here */end CREATE.ALLOCATE.CUE;RECORD.HAPPENED: proc returns (fixed) swapable;   dcl stmp(1)   fixed;   dcl etmp(1)   fixed;   call Fetch.DTD.Auto.Allocate.Time(0, stmp, etmp);   return (stmp(0) <> Record.Disk.Start(0)) or (stmp(1) <> Record.Disk.Start(1));end RECORD.HAPPENED;CHECK.FOR.POST.RECORD.UPDATE: proc PUBLIC swapable;   dcl tmp (1)  fixed;   if  (Record.Recording.State   = 0)     /* if no AEE recording       */   and (Protocol.Recording.State = 0)     /* and no protocol recording */   and (Lod.Punch.In.Tracks      = 0)     /* and no gpi      recording */   and (GID(Any.Recording.Happened)<>0)   /* but some recording had occurred */   then do;                               /* then update pmgr                */      call PID(Any.Recording.Happened,0);      if Project.Manager.Group <> 0 then do;         call Fetch.DTD.Drive.Status(tmp);  /* wait for punch out to finish so used field is correct */         do while (tmp(0)&2)<>0;            call Fetch.DTD.Drive.Status(tmp);           end;         call UPDATE.PROJECT.MANAGER;        /* update used display/allocate display */      end;   end;end CHECK.FOR.POST.RECORD.UPDATE;STOP.RECORD.RECORDING: proc public swapable;  /* stops dtd playback and generates a cue if needed for auto allocation */   dcl tmp (1)      fixed;   dcl old.start(1) fixed;   call Stop.DTD.Playback;         /* Stops recording; shuts off scrolling */   call Set.Record.Recording.State(0);  /* turn off indicators; clear flip/flops */   Record.Recording.Bits = 0;           /* no tracks recording */   call Fetch.DTD.Drive.Status(tmp);    /* wait for punch out to finish so cue gets created correctly */   do while (tmp(0)&2)<>0;      call Fetch.DTD.Drive.Status(tmp);     end;   if  (Record.Mode = RM.ALLOCATE)          /* Allocate mode       */   and (Record.Happened      <> 0)          /* A cue was recorded */   and (DTD.Ready.Enabled    <> 0)          /* never if rehearsing */   then do;      if (Record.Trigger = RT.POLY.XFER)    /* poly transfer trigger */      then do;         call Save.Recorded.Cue(Record.Disk.Start,Record.Disk.Stop,Record.Disk.Start,Record.Ready.Bits,0,0,'');         call Update.Allocate.Times;        /* get times for next cue  */      end;      else if (Record.Trigger = RT.TSM)     /* time scale modification */      or (Record.Trigger = RT.BOUNCE   )    /* bounce                */      or (Record.Trigger = RT.MOVE     )    /* move                  */      then do;         call Copy32(Record.Disk.Start,Old.Start); /* save a copy      */         call Update.Allocate.Times;        /* get times for next cue  */         call Save.Recorded.Cue(Old.Start,Record.Disk.Start,Old.Start,Record.Ready.Bits,0,0,'');         call CHECK.RECORD.CUE.NAME;        /* presuming save was successful, get new name here */      end;      else do;                              /* create cue from manual or sequencer recording */         call Create.Allocate.Cue;          /* create cue; set up times for next */      end;   end;   if ((Play = 0)\(Move <> 0))                /* if sequencer is stopped */   then call CHECK.FOR.POST.RECORD.UPDATE;    /* then update pmgr        */   if Fetch.Switch(Record.Rec.Switch) = 0 then do;  /* Single; no repeat */      if DTD.Ready.Enabled <> 0 then      call TOGGLE.RECORD.READY;                     /* done this so we go through the correct update logic */   end;end STOP.RECORD.RECORDING;Stop.Rehearse.Function:proc swapable;   dcl i fixed;   call Stop.Record.Recording;     /* stop rehearse     */   /* wait here for acknowledge meant */   /* that rehearse has been          */   /* cancelled.  if we don't do      */   /* this, the logic in the          */   /* main loop gets confused and     */   /* we flip out of rehearse/record  */   i = real.milliseconds;          /* timer             */   do while ((new.dtd.info&16)=0)  /* wait to be told   */   and (real.milliseconds-i) ilt 1000;      call send.to.lod(23,0);      /* about rehearse    */	  chill.out.and.run.syn();   end;                            /* end, ignore it    */   new.dtd.info = new.dtd.info & not(16);   call Stop.DTD.Playback;         /* send stop to zap rehearse cue    */end Stop.Rehearse.Function;insert ':synsou:audmod:aud-rec2';/* $page - process record panel record button *//* This routine process mouse clicks of the record panel RECORD button. *//* This button sometimes says: RECORD, REHEARSE, BLOCK, or PROCESS.     */Process.Record.Panel.Record.Button:proc (trackbits, dtdstat) PUBLIC swapable;   dcl trackbits     fixed;   dcl dtdstat       array;   dcl tmp     (1)   fixed;   dcl sfname  (4)   fixed;   dcl sfbase  (1)   fixed;   dcl sfoffset(1)   fixed;   dcl sflen   (1)   fixed;   dcl smsb    (1)   fixed;   dcl emsb    (1)   fixed;   dcl lmsb    (1)   fixed;   dcl ii      (1)   fixed;   dcl oo      (1)   fixed;   dcl (srate)       fixed;   dcl (stereo)      fixed;   dcl audiotracks   fixed;   dcl args(TSM.Opt#array.size-1) fixed; /* holds args     */   dcl info      (5) fixed;   dcl dtd.start (1) fixed;   dcl ccapt     (Event.Cap.Max.Words) fixed;   dcl cuefin    fixed;   dcl cuefout   fixed;   dcl rlen      fixed;   dcl nlen      fixed;   dcl clen      fixed;   dcl Bounce.Move.Cue.on.DTD proc(fixed, array, fixed) external;   /* Set up possible audio tracks for cue lock recording: */   if Record.Mode = RM.CUE.LOCK   then audiotracks = Current.Cue.Drive.Bits; /* hear audio from cue tracks to provide for punch in */   else audiotracks = 0;   /* Handle press of of RECORD button if we are in poly transfer */   /* triggering (ie transfer sound file from poly to DTD)        */   if Record.Trigger = RT.POLY.XFER      /* poly transfer trigger */   then do;      /* Only allow poly transfer if we are READY:                */      if DTD.Ready.Enabled <> 0 then do;         /* look up current sf info */         if LOOKUP.CURRENT.SF.INFO(sfname,sfbase,sfoffset,sflen,loc(addr(srate)),loc(addr(stereo)))=0         then call DISPLAY.NOTICE (NT#NoSoundFileAvail,ATTR#Reverse,NulStr,0,0,0);         else do;  /* sound file exists and is available */            /* present new cue name to user now */            call UPDATE.ALLOC.NAME.FOR.POLY.XFER(sfname);            /* get user dialog */            if GET.POLY.TRANSFER.DIALOG(sfname,sflen,stereo,smsb,emsb,lmsb)            then do;               call Set.Record.Recording.State(2);  /* recording now */               call Update.Screen;                  /* since we wait here, update screen so display gets displayed */               call REMOVE.ERR;                     /* remove prior msg */               call DISPLAY.NOTICE (NT#TransferringPolyToDTD,ATTR#Normal,NulStr,0,0,0);               /* re-check sound file in case it get */               /* erased from button panel activity  */               /* while dialog box occurred          */               if (LOOKUP.CURRENT.SF.INFO(sfname,sfbase,sfoffset,tmp,loc(addr(srate)),loc(addr(stereo)))=0)               or (tmp(0)<>sflen(0))               or (tmp(1)<>sflen(1))               then call DISPLAY.NOTICE (NT#NoSoundFileAvail,ATTR#Reverse,NulStr,0,0,0);               else do;                  call UPDATE.ALLOC.NAME.FOR.POLY.XFER(sfname);                  /* set up default cue in dtd temp cue */                  /* for reading data from disk         */                  call CREATE.DTD.SYSTEM.CUE(Scsi.Ptr);                  call LOAD.DTD.TEMP.CUE    (Scsi.Ptr);                  call Send.Poly.To.DTD(sfbase,sfoffset,sflen,stereo,trackbits,smsb,emsb,lmsb);                  if ertyp=0                   then call DISPLAY.NOTICE (NT#TransferComplete,ATTR#Normal,NulStr,0,0,0);                  else call DISPLAY.NOTICE (NT#EraseNotice,ATTR#Normal,NulStr,0,0,0);               end;               call Stop.Record.Recording; /* will update alloc times as needed */            end;         end;      end;   end;   /* Check cases for manual triggering: */   else if Record.Trigger = RT.MANUAL   then do;               /* Manual */      /* Only process if we are READY (else ignore) */      if DTD.Ready.Enabled <> 0 then do;         /* See if we are recording now,  (in which case we should */         /* block a cue), or if we should start recording:         */         if dtdstat(0) = 0 then do;      /* Not recording or armed */            Record.Recording.Bits = Trackbits;            if Record.Mode = RM.PUNCH.IN then do;               smsb(0) = 0;               smsb(1) = zero.time;               call DTD.Sample.#.To.Msecs(AEE.Current.Project.End, CF#Time, S$Speed, AEE.Current.Project.Rate, AEE.Current.Project.Base, emsb);               Armed.for.Protocol.DTD.Recording = 0;               call Record.DTD.Synced.To.Synclav(smsb, smsb, emsb,                                                  1,    1,    0,                                                  Trackbits,Audiotracks);               DTD.Play.State = 8;  /* sequencer armed recording */            end;            else do;       /* cue lock, allocate */               tmp(0) = 0;               tmp(1) = 0;               Armed.for.Protocol.DTD.Recording = 0;               call Record.DTD.Synced.To.Synclav(tmp,Record.Disk.Start,Record.Disk.Stop,                                                 1,  0,  0,                                                 Trackbits,Audiotracks);               call Send.To.Lod(DTD.Scrolling.On,0);               DTD.Play.State = 6;            end;            call Fetch.DTD.Drive.Status    (dtdstat);            call Set.Record.Recording.State(dtdstat(0));         end;         /* we are recording - check for block */         else if (Record.Mode = RM.ALLOCATE)     /* Allocate */         then do;            if (dtdstat(0)&2) <> 0 then do;   /* Make next cue for block recording */               if (Record.Happened <> 0)      /* Cue was recorded */               then call Create.Allocate.Cue; /* create cue; set up times for next */            end;         end;         /* if cue lock or punch in, and record button pressed - stop recording */         else call Stop.Record.Recording;      end;   end;   else if Record.Trigger = RT.SEQUENCER   then do;     /* Sequencer */      /* Detect pressing REHEARSE button: */      if  (DTD.Ready.Enabled      =  0)  /* detect rehearsing */      and (Record.Recording.State <> 0)  /* means in rehearse */      then do;         call Stop.Rehearse.Function;      end;      else do;                            /* normal record    */         if dtdstat(0) = 0 then do;            if Record.Mode = RM.ALLOCATE then tmp(0) = 2;            else                              tmp(0) = 1;            Armed.for.Protocol.DTD.Recording = 0;            if Record.Mode = RM.PUNCH.IN            then call Record.DTD.Synced.To.Synclav(Record.Trig.Start,Record.Trig.Start,Record.Trig.Stop,                                                   1, 1, (DTD.Ready.Enabled=0),                                                   Trackbits, Audiotracks);            else call Record.DTD.Synced.To.Synclav(Record.Trig.Start,Record.Disk.Start,Record.Disk.Stop,                                                   1, tmp(0), (DTD.Ready.Enabled=0),                                                   Trackbits, Audiotracks);            DTD.Play.State = 8;            call Fetch.DTD.Drive.Status(dtdstat);            call Set.Record.Recording.State(dtdstat(0));            Record.Recording.Bits = Trackbits;         end;         else if (Record.Mode = RM.ALLOCATE)     /* Allocate */         then do;            if (dtdstat(0)&2) <> 0 then do;   /* Make next cue for block recording */               if (Record.Happened <> 0)      /* Cue was recorded */               then call Create.Allocate.Cue; /* create cue; set up times for next */            end;         end;         else call Stop.Record.Recording;      end;   end;            else if Record.Trigger = RT.TSM   then do; /* Time Scale Modification */      if DTD.Ready.Enabled <> 0 then do;         if Record.Mode = RM.ALLOCATE then do;  /* Only in allocate mode for now */            if (Record.Ready.Bits = 0)            then call Display.Notice(NT#TooManyReadyTracks,ATTR#Reverse,NulStr,0,0,0);            else do;               call Set.Record.Recording.State(2);  /* recording now       */               call Update.Screen;                  /* since we wait here, update screen so display gets displayed */               call REMOVE.ERR;                     /* clear message lines */               call DISPLAY.NOTICE (NT#EraseNotice,ATTR#Normal,NulStr,0,0,0);               call UPDATE.ALLOCATE.TIMES;  /* Set record start and stop times */               /* Convert to DTD sample numbers */               call MSEC.To.DTD.Sample.#(Record.Disk.Start, CF#Time, S$Speed, AEE.Current.Project.Rate, AEE.Current.Project.Base, ii);               call MSEC.To.DTD.Sample.#(Record.Disk.Stop,  CF#Time, S$Speed, AEE.Current.Project.Rate, AEE.Current.Project.Base, oo);               /* We must put the current cue in the DTD's temp area so it will follow */               /* the complete edit segment list when reading the cue                  */               call LOAD.DTD.TEMP.CUE(Current.Cue.Ptr);               call Check.TSM.Options(record.tsm.options);/* checks pitch,max.cut, and just */               /* look up ratio,stereo,length, and alg to send to subroutine */               record.tsm.options(TSM.Opt#ratio ) = Fetch.Fixed.Point(Record.TSM.Ratio);               record.tsm.options(TSM.Opt#stereo) = 0; /* set in dsp.cue based on # of tracks to do */               call Fetch.32bit.Msec(Record.TSM.Length,loc(addr(Record.TSM.Options(TSM.Opt#len.ms))));/* fill ms,ls */               /* save temp copy of arguments since they are changed */               /* by DSP.CUE:                                        */               call blockmove(record.tsm.options, args, TSM.Opt#array.size);               /* note: must pass static array to DSP.CUE because    */               /* of push.system.pdl                                 */               /* Run the DTD/DSP process on the cue */               call DSP.CUE(0,ii,oo,Record.Ready.Bits,dsp#tsm,record.tsm.alg-1,record.tsm.options);               call blockmove(args, record.tsm.options, TSM.Opt#array.size);               call Stop.Record.Recording; /* will update alloc times as needed */            end;         end;         else do;            call DISPLAY.NOTICE (NT#TSMAllocate,ATTR#Reverse,NulStr,0,0,0);         end;      end;   end;   else if (Record.Trigger = RT.BOUNCE)   or      (Record.Trigger = RT.MOVE  )   then do;      /* Only allow move/bounce if we are READY:                */      if DTD.Ready.Enabled <> 0 then do;         /* get user dialog */         if GET.MOVE.BOUNCE.DIALOG(info, dtd.start)         then do;            call Set.Record.Recording.State(2);  /* recording now */            call Update.Screen;                  /* since we wait here, update screen so display gets displayed */            call REMOVE.ERR;                     /* remove prior msg */            if Record.Trigger = RT.BOUNCE            then call DISPLAY.NOTICE (NT#BouncingCue,ATTR#Normal,NulStr,0,0,0);            else call DISPLAY.NOTICE (NT#MovingCue,ATTR#Normal,NulStr,0,0,0);            /* Get caption and fin/fout handy for new cue */            write(mam) = Current.Cue.Ptr;            write(mal) = CUE.FIN;            cuefin     = read(md);            write(mal) = CUE.FOUT;            cuefout    = read(md);            write(mal) = CUE.RLEN;            rlen       = read(md);            write(mal) = CUE.NAME;            nlen       = shr(read(md)+3,1);   /* # of wrds in cue name */            if rlen igt CUE.NAME+nlen            then do;               write(mal) = CUE.NAME+nlen;               clen       = read(md);         /* caption len, bytes    */               if clen IGT event.cap.max.bytes               then clen = event.cap.max.bytes;               write(mal) = CUE.NAME+nlen;               call COPY.IN(addr(ccapt(0)), shr(clen+3,1));               ccapt(0) = clen;               /* in case we truncated */            end;            call LOAD.DTD.TEMP.CUE(Current.Cue.Ptr); /* store current cue in temp area (also scsi.ptr) */            call Bounce.Move.Cue.on.DTD(0, dtd.start, Record.Ready.Bits);            if ertyp<>0             then call DISPLAY.NOTICE (NT#EraseNotice,ATTR#Normal,NulStr,0,0,0);            else do;               call Set.Record.Recording.State(0);  /* turn off indicators; clear flip/flops */               Record.Recording.Bits = 0;           /* no tracks recording */               if  (Record.Trigger = RT.MOVE)       /* if moving and prior */               and (info(2) <> 0)                   /* cue exists, trash   */               then call DELETE.DTD.CUE(info(2));   /* it.                 */               call Copy32(Record.Disk.Start,tmp); /* save a copy         */               call Update.Allocate.Times;          /* get times for next cue  */               call Save.Recorded.Cue(tmp, Record.Disk.Start, Cue.Sync.Time, Record.Ready.Bits, cuefin, cuefout, ccapt);               call CHECK.RECORD.CUE.NAME;          /* presuming save was successful, get new name here */               call CHECK.FOR.POST.RECORD.UPDATE;   /* update pmgr        */               if Fetch.Switch(Record.Rec.Switch) = 0 then do;  /* Single; no repeat */                  if DTD.Ready.Enabled <> 0 then                  call TOGGLE.RECORD.READY;                     /* done this so we go through the correct update logic */               end;               /* Replace cue in sequence */               if info(0) <> 0               then call Handle.AEE.Cue.Place(Recalled.Event.Spointer, 1);               else call DISPLAY.NOTICE (NT#OpCompleted,ATTR#Normal,NulStr,0,0,0);            end;         end;      end;      else call Display.Notice(NT#ReadyForBounce,ATTR#Reverse,NulStr,0,0,0);   end;end Process.Record.Panel.Record.Button;Check.Poly.Xfer:proc swapable;   dcl sfname  (4)   fixed;   dcl sfbase  (1)   fixed;   dcl sfoffset(1)   fixed;   dcl sflen   (1)   fixed;   dcl srate         fixed;   dcl stereo        fixed;   if LOOKUP.CURRENT.SF.INFO(sfname,sfbase,sfoffset,sflen,loc(addr(srate)),loc(addr(stereo)))=0   then call DISPLAY.NOTICE (NT#NoSoundFileAvail,ATTR#Reverse,NulStr,0,0,0);   else do;  /* sound file exists and is available */      /* present new cue name to user now */      call UPDATE.ALLOC.NAME.FOR.POLY.XFER(sfname);   end;end Check.Poly.Xfer;Check.TSM.Options: proc (TSM.Options) swapable;/* see if options are within limits */   dcl TSM.Options     array;   dcl pitch           fixed;   dcl max.cut         fixed;   dcl just            fixed;   do case Fetch.Switch(Record.TSM.Alg.Switch);      do;/* 0: THREE */         /* no options to date */      end;/* of case 0: */      do;/* 1: ONE */         max.cut = TSM.Options(TSM.Opt#max.cut);         if max.cut = 0 then do;            max.cut = TSM#Max.Cut.Default;         end;         else if max.cut igt TSM#Max.Cut.u.limit         then max.cut = TSM#Max.Cut.u.limit;         else if max.cut ilt TSM#Max.Cut.l.limit         then max.cut = TSM#Max.Cut.l.limit;         TSM.Options(TSM.Opt#max.cut) = max.cut;         just    = TSM.Options(TSM.Opt#just);         if just = 0 then do;            just = TSM#Just.Default;         end;         else if just igt TSM#Just.u.limit         then just = TSM#Just.u.limit;         else if just ilt TSM#Just.l.limit         then just = TSM#Just.l.limit;         TSM.Options(TSM.Opt#just) = just;      end;      do;/* 2: TWO */         /* no options to date */      end;   end;/* of do case */end Check.TSM.Options;Check.TSM.Ratio: proc swapable;/* see if user ratio is within bounds*/   dcl ratio           fixed;   dcl new.length(1)   fixed;/* value of Record.TSM.Length (32 bit msec) */   dcl old.length(1)   fixed;/* value of cue length                      */   dcl new.SF.len(2)   fixed;/* new.length in SF length format           */   dcl old.SF.len(2)   fixed;/* old.length in SF length format           */   dcl ratio.info(1)   fixed;/* parms returned from compute ratio        */   dcl C.or.E          fixed;/* flag indicating compression or expansion */   dcl CRatio          fixed;/* comp/exp ratio in 56k format             */   dcl l.or.r          fixed;/* local copy of Record.TSM.Len.or.Ratio    */   dcl u_limit         fixed;/* upper limit for ratio                    */   dcl l_limit         fixed;/* lower limit for ratio                    */   dcl denom           fixed;   dcl i               fixed;   dcl start(1)        fixed;   dcl stop (1)        fixed;   /* Look up length (milliseconds) of current cue: */   write(mam) = Current.Cue.Ptr;     /* look up info from current cue */   write(mal) = CUE.S.MSB;           /* get info about current cue */   call COPY.IN(addr(start(0)), 2);   write(mal) = CUE.E.MSB;   call COPY.IN(addr(stop (0)), 2);   call SUB32(stop, start, old.length);     /* get cue length in samples */   call DTD.Sample.#.To.Msecs(old.length, CF#Dur, S$Speed, AEE.Current.Project.Rate, Zero.Zero, Old.Length);   disable.deposits = 1;   l.or.r = Record.TSM.Len.or.Ratio;/* make local copy */   if (l.or.r=0) then do;/* length typed in */   	call Fetch.32bit.Msec(Record.TSM.Length,new.length);      call Convert.Samples.to.SF.Len(old.length,old.SF.len);/* needed for Compute.Ratio */      call Convert.Samples.to.SF.Len(new.length,new.SF.len);/* ditto */      i = Compute.Ratio.For.Time.Fit(old.SF.len,new.SF.len,ratio.info);      if i = 1 then do;     /* ratio result is good */         C.or.E = ratio.info(0);         load ratio.info(1);/* ratio in 56000 format */         mul 10000;         if C.or.E = 1         then do;/* expansion */            ratio = 10000 + ures + (res igt shr(10000,1));         end;         else do;/* compression */            denom = 10000 + ures + (res igt shr(10000,1));            bitmsb = 0;bitlsb = 10000;            call ratio_multiply(10000,denom);            ratio = bitlsb;         end;      end;      else if i = (-1) then do;    /* length too large                  */         ratio = 30000;            /* bomb out below with max ratio     */      end;      else if i = (-2) then do;    /* length too small                  */         ratio = 0;                /* bomb out below with minimum ratio */      end;      else ratio = 10000;          /* else use 1.0000                   */   end;/* of if l.or.r = 0 */   else ratio = Fetch.Fixed.Point(Record.TSM.Ratio);   /* check ratio for in bounds */   if Fetch.Switch(Record.TSM.Alg.Switch) == 1 then do;      u_limit = TSM#ONE.Ratio.u;      l_limit = TSM#ONE.Ratio.l;   end;   else do;      u_limit = TSM#TWO.Ratio.u;      l_limit = TSM#TWO.Ratio.l;   end;   if ratio igt u_limit then do;      ratio  = u_limit;      l.or.r = 1;/* force to recompute the length */   end;   else if ratio ilt l_limit then do;      ratio  = l_limit;      l.or.r = 1;   end;   call Deposit.Fixed.Point(Record.TSM.Ratio,ratio);   if (l.or.r=1) then do;/* ratio typed in */      /* convert ratio to 56k format, set C.or.E flag */      if ratio < 10000      then do;/* compression */         C.or.E = 0;         bitmsb=0;bitlsb=10000;         call ratio_multiply(10000,ratio);         Cratio = bitlsb;      end;      else do;/* expansion */         C.or.E = 1;         CRatio = ratio;      end;      if (CRatio ige 10000) and (CRatio ile 20000)      then do;         load 0; uload CRatio-10000; div 10000;   /* map TSM factor onto */         CRatio=res+(rem ige shr(10000,1));       /* 0-65535 scale       */      end;      if C.or.E =0      then do;/* compute compressed length */         call Compute.Compressed.Length(old.length,new.length,CRatio);      end;      else do;/* compute expanded length*/         call Compute.Expanded.Length(old.length,new.length,CRatio);      end;      call Deposit.32bit.Msec(Record.TSM.Length,Zero.Zerotime,new.length);   end;/* of if l.or.r = 1 */   disable.deposits = 0;end Check.TSM.Ratio;GET.RECORD.EVENT: proc (event) returns (fixed) public swapable;   dcl event         fixed;   dcl i             fixed;   dcl cell(1)       fixed;   dcl tmp(1)        fixed;   dcl dtdstat(1)    fixed;   do while 1;      if event <> Get.Null.Event then do;         if Screen.Event.Group <> Record.Group then return event;         if event = Get.Screen.Event then do;            if Screen.Event.Id = Record.Record.Button then do;               if Screen.Event.Info = S#MouseSelect then do;                  call Fetch.DTD.Drive.Status(dtdstat);                  call Process.Record.Panel.Record.Button(Record.Ready.Bits, dtdstat);               end;            end;            else if Screen.Event.Id = Record.Ready.Button then do;               if Screen.Event.Info = S#MouseSelect then do;                  if  (DTD.Ready.Enabled      =  0)  /* detect rehearsing */                  and (Record.Recording.State <> 0)  /* means in rehearse */                  then do;                     call Stop.Rehearse.Function;                  end;                  if Record.Recording.State = 0   /* only change if not recording */                  then do;                     call Toggle.Record.Ready;                     call UPDATE.ALLOCATE.TIMES;                     if  (DTD.Ready.Enabled <> 0)                     then do;                        if (Record.Ready.Bits = 0)                        then call Display.Notice(NT#PleaseReadyTracks,ATTR#Reverse,NulStr,0,0,0);                        else if Record.Trigger = RT.POLY.XFER  /* poly transfer trigger */                        then do;                           call Check.Poly.Xfer;                        end;                     end;                  end;               end;            end;            else if Screen.Event.Id = Record.Stop.Button then do;               if Screen.Event.Info = S#MouseSelect then do;                  call Stop.Record.Recording;               end;            end;            else if Screen.Event.Id = Record.Mode.Switch then do;               if Screen.Event.Info = S#Deposit then do;                  i = Fetch.Switch(Record.Mode.Switch);                  if i <> Record.Mode then do;                     call Stop.Record.Recording;                     call Set.Record.Mode(i);                     call UPDATE.ALLOCATE.TIMES;                  end;               end;            end;            else if Screen.Event.Id = Record.Trigger.Switch then do;               if Screen.Event.Info = S#Deposit then do;                  i = Fetch.Switch(Record.Trigger.Switch);                  if i <> Record.Trigger then do;                     call Stop.Record.Recording;                     call Set.Record.Trigger(i);                     /* changing trigger will set alloc times as needed */                  end;               end;            end;            else if Screen.Event.Id = Record.Rec.Switch then do;               if Screen.Event.Info = S#Deposit then do;                  call PID(Record.Rec.Switch.Setting,Fetch.Switch(Record.Rec.Switch));               end;            end;            else if Screen.Event.Id = Record.Drive.Table then do;               if Screen.Event.Info = S#MouseSelect then do;                  call Toggle.Record.Drive.Table(Screen.Event.Table.Col);                  call UPDATE.ALLOCATE.TIMES;  /* possibly new times */               end;            end;            else if (Screen.Event.Id = Record.Disk.Stop.Time)            or      (Screen.Event.Id = Record.Disk.Start.Time)            or      (Screen.Event.Id = Record.Trig.Stop.Time)            or      (Screen.Event.Id = Record.Trig.Start.Time)            then do;               if Screen.Event.Info = S#Deposit then do;                  /* if punch in or allocate, must disallow input  */                  /* into these objects by dragging.  cue times    */                  /* will be transferred ok since we explicitly    */                  /* set the static arrays in set.record.cue.times */                  if Record.Mode <> RM.PUNCH.IN then do;                     disable.deposits = 1;                     if Screen.Event.Id = Record.Disk.STart.Time                     then call Deposit.32Bit.Msec(Record.Disk.Start.Time,Record.Disk.Start,Zero.Zero);                     if Screen.Event.Id = Record.Disk.Stop.Time                     then call Deposit.32Bit.Msec(Record.Disk.Stop.Time,Record.Disk.Stop,Zero.Zero);                     disable.deposits = 0;                  end;                  if Record.Recording.State <> 0 then call Stop.Record.Recording;                  call Update.Record.Times(Screen.Event.Id);               end;               else if Screen.Event.Info = S#ObjectDrag then do;                  call Perform.AEE.Drag.Function(Screen.Event.Id,Screen.Event.Obj.Info);  /* let deposit reporting do its job */               end;               else if (Screen.Event.Info = S#MouseSelect  )  /* click in field */               or      (Screen.Event.Info = S#MouseActivate)               then do;                  if (Screen.Event.Id = Record.Disk.Stop.Time)                  then do;                     if Record.Recording.State <> 0 then call Stop.Record.Recording;                     call Set.Record.Dependent.Time(1);                      if Record.Mode = RM.CUE.LOCK                     then do;                        /* Cue lock */                        call Set.Record.Cue.Lock.Times;                        call Select.New.Cur.Obj(Corner.Label,-1,-1);                     end;                     else if Record.Mode = RM.ALLOCATE then do;                        call Update.Allocate.Times;                        call Select.New.Cur.Obj(Corner.Label,-1,-1);                     end;                     else call Update.Record.Times(Record.Disk.Start.Time);                  end;                  if (Screen.Event.Id = Record.Trig.Stop.Time )                  then do;                     if Record.Recording.State <> 0 then call Stop.Record.Recording;                     call Set.Record.Dependent.Time(0);                      /* time values would not change at all */                     /* since trig time is already          */                     /* computed at all times               */                  end;               end;            end;            else if Screen.Event.Id = Record.Cross.Fade.Id then do;                   if Screen.Event.Info = S#Deposit then do;      /* user typed in new cross fade time */                  i = Fetch.Fixed.Point(Record.Cross.Fade.Id);                  if (i<0)  then i=0;                  if (i>99) then i=99;                  call SET.DTD.DRIVE.PARAMETER (0,4,i);                  call Update.Record.Panel;               end;            end;            else if Screen.Event.Id = Record.Cue.Name.Id then do;               if Screen.Event.Info = S#Deposit then do;                  call CHECK.RECORD.CUE.NAME; /* check name for null and duplicates; save in static area */               end;            end;            /* Handle TSM Items */            else if Screen.Event.Id = Record.TSM.Cue.Arrows then do;               dcl temp(1)    fixed;/* temp buffer to init Record.TSM.Length */               temp(0)=0;temp(1)=0;               if Screen.Event.Info = S#MouseSelect               then do;                  call Switch.Current.Cue(Record.Group);                  call Update.Object(Record.TSM.Name.Id);               end;            end;            else if Screen.Event.Id = Record.TSM.Name.Id            then do;               if Screen.Event.Info = S#Deposit then do;                  call Handle.New.Cue.Name(Record.Group);                  call Update.Object(Record.TSM.Name.Id);               end;            end;            else if Screen.Event.Id = Record.TSM.Alg.Switch            then do;               if Screen.Event.Info = S#Deposit then do;                  Record.TSM.Alg = Fetch.Switch(Record.TSM.Alg.Switch)+1;                  call Check.TSM.Ratio;   /* see if user ratio is in bounds */               end;            end;            else if Screen.Event.Id = Record.TSM.Toggle then do;               if Screen.Event.Info = S#MouseSelect then do;                  call map.graphics.button.table.mouse.press(Record.TSM.Toggle,cell);                  if cell(1) = 0                      /* First row: Length */                  then Record.TSM.Len.or.Ratio = 0;   /* Set to Length */                  else Record.TSM.Len.or.Ratio = 1;   /* Set to Ratio  */                  call SET.RECORD.PANEL.ATTRIBUTES;                  call Update.Object(Record.TSM.Length.Label);                  if Record.TSM.Len.or.Ratio = 0      /* length desired */                  then do;                     call Select.New.Cur.Obj(Record.TSM.Length,-1,-1);                     call Update.Object(Record.TSM.Length);                  end;                  else do;                            /* ratio desired  */                     call Select.New.Cur.Obj(Record.TSM.Ratio,-1,-1);                     call Update.Object(Record.TSM.Ratio);                  end;               end;            end;            else if (Screen.Event.Id = Record.TSM.Length)            then do;/* handle length or ratio changes */               if Screen.Event.Info = S#Deposit then do;                  Record.TSM.Len.or.Ratio= 0;                  call Check.TSM.Ratio;   /* see if user ratio is in bounds */               end;            end;            else if (Screen.Event.Id = Record.TSM.Ratio)            then do;/* handle length or ratio changes */               if Screen.Event.Info = S#Deposit then do;                  Record.TSM.Len.or.Ratio= 1;                  call Check.TSM.Ratio;    /* see if user ratio is in bounds */               end;            end;            else if Screen.Event.Id = Record.Retake.Id then do;               if Screen.Event.Info = S#MouseSelect then do;                  call Stop.Record.Recording;     /* stop recording as if 'STOP' */                  call PROCESS.CUE.RETAKE.DIALOG(Record.Group,Record.Disk.Start,Record.Ready.Bits); /* then activate dialog box    */               end;            end;                        else if Screen.Event.Id = Record.Audition.Button then do;               if Screen.Event.Info = S#MouseSelect then do;                  call ASSIGN.NEW.DTD.AUDITION(Current.Cue.Audition xor 1);                  call DEPOSIT.AUDITION.BUTTON.DISPLAY; /* provide snappy response */                  call Select.New.Cur.Obj(Corner.Label,-1,-1);               end;            end;            else if Screen.Event.Id = Record.TSM.Options.Id then do;               if Screen.Event.Info = S#MouseSelect then do;                  /* take care of options dialog */                  call Stop.Record.Recording;                  call PROCESS.TSM.OPTIONS.DIALOG(record.TSM.options);/* get values */               end;            end;  /* of Record.TSM.Options.Id */                        else if (Screen.Event.Id = Record.Trig.Start.Take)            or      (Screen.Event.Id = Record.Trig.Stop.Take )            then do;               if Screen.Event.Info = S#MouseSelect then do;                  if (Record.Trigger = RT.SEQUENCER)                   then do;                     call TAKE.SYSTEM.REAL.TIME(tmp);  /* get sequencer or smpte time */                     if Screen.Event.Id = Record.Trig.Start.Take                     then call Deposit.32Bit.MSEC(Record.Trig.Start.Time,tmp,Zero.Zero); /* let deposit reporting do its job */                     else call Deposit.32Bit.MSEC(Record.Trig.Stop.Time, tmp,Zero.Zero);                  end;               end;            end;         end;      end;      event = Get.Next.Screen.Event;   end;end GET.RECORD.EVENT;