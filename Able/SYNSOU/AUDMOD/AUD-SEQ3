/* :SYNSOU:AUDMOD:AUD-SEQ3 - routines for editing, adding, deleting notes *//*1998/06/24 - TY  - Modified CHECK.FOR.LIVE.CLICK to account for independence of CLICK.TRACK.MODE from CLICKON.1998/05/16 - TY  - Substituted call to SCALE.RTE.VAL passing 1, to call to SCALE.PERCENT.TO.RTE.1998/05/07 - TY  - Changed ADD.SEQ.ILP so that the default loop length is set according to the meter map.1998/04/21 - TY  - Rewrote the scaling algorithm in the pitchbend block of CHANGE.SEQ.NOTE.VELOCITY						 to have the following rounding characteristics:						 1) for even divisors, a value at the halfway point will round up.						 2) for negative values, "rounding up" means more negative.					  - Also rewrote the algorithm in the pitchbend block of CHANGE.SEQ.NOTE.VELOCITY that						 limits the input value if it exceeds "pitch.bend.range".  The original algorithm						 failed when "pitch.bend.range" was outside the range of -16384 TO 16383.1991/08/07 - cj  - fixed q page cue duration entry1991/06/19 - PF  - Added RAM Event stuff1991/05/17 - PF  - changed MIDI program numbers from 1-128 to 0-1271992/04/02 - pf  - Removed prescan offsets in display of rtes1990/11/06 - pf  - Added screen support for new sustain update record1990/09/27 - cj  - changed args to add.seq.ilp1990/08/27 - PF  - Support all MIDI controllers1989/10/15 - cj  - re-wrote change.seq.note.duration to handle						 tempo changes in the best way possible.1989/06/14 - cj  - allow change of cue duration by changing to event.						 Make entry of cue caption change type to event.1989/05/03 - cj  - convert sample # to sequence time for event duration and						 mark point.  Also allow entry of new durations for EVENTS1989/04/20 - cj  - moved compute.default.note to seqmods1988/10/03 - cj  - remapped new duration input if using live click.						 also fixed bug with changing pitches with end						 time locked if showing multiple tracks*/Check.For.Live.Click: proc swapable;	/* Force update of all tracks if changing live */	/* click track times                           */	if  (Click.Track.Mode igt 3)	and (#TRK = (click.track.mode+NUM.KBD.TRACKS-4))	and ((AEE.Time.Format = O#MSEC.Beats         )	or   (AEE.Time.Format = O#MSEC.Measures.Beats))	then Seq.Refresh = Seq.Refresh \ (8 \ 16);end Check.For.Live.Click;CHANGE.SEQ.SELECTED.NOTE.TIMES: proc (rows, verified) swapable;	dcl rows     fixed;	/* which rows to change them on */	dcl verified fixed;	dcl row      fixed;	/* for now, can only change on  */	dcl trk      fixed;	/* one row at a crack, since    */	dcl i        fixed;	/* the sequence gets randomized */	dcl first    fixed;	/* once the first time is       */	dcl w1       fixed;	/* changed                      */	dcl w2       fixed;	dcl w3       fixed;	dcl w4       fixed;	dcl selected fixed;	dcl ntrk     fixed;	dcl nrow     fixed;	dcl j        fixed;	dcl edited   fixed;	dcl time    (1) fixed;	dcl newtime (1) fixed;	/* check for various error conditions */	if (Event.Time.Enabled & rows) = 0						/* user is typing */	then do;															/* into row       */		do i = 0 to Seq.Event.Display.Size - 1;			/* with no time.  */			if  (rows & bits(i)) <> 0			then Note.Area.Force(i) = Note.Area.Force(i) \ 1;		end;		Seq.Refresh = Seq.Refresh \ 8;		call no.edit.allowed;		call Clean.Out.Verify.Tracks;		return;	end;	/* If verify - set bits for later processing */	if  (Ripple.Mode = 2)	and (verified    = 0)	then do;		if PLAY <> 0		then call Stop.Sequencer;		if  ( Ripple.Verify.Rows <> 0    )		and ((Ripple.Verify.Rows <> rows)		or   (Ripple.Edit.Type   <> 0   ))		then do;			call Clean.Out.Verify.Tracks;		end;		if (Seq.Dialog.Mode <> SEQ#RippleVerifyDialog)		then call OPEN.SEQ.RIPPLE.VERIFY.DIALOG;		Ripple.Verify.Rows = Ripple.Verify.Rows \ rows;		Ripple.Edit.Type   = 0;		call Highlight.Graphics.Button.Table.Entry(Seq.Verify.Undo.Search, 0, 0, 1, 2, 0);		return;	end;	edited = 0;		/* keep track of which tracks have been edited */	do row = 0 to Seq.Event.Display.Size - 1;		if (rows & bits(row)) <> 0		then do;			/* Now set the bit to cause an update at some point */			Seq.Refresh = Seq.Refresh \ 8;	/* redraw correct value sometime */			Note.Area.Force(row) = (-1);			if ((New.Seq.Info &      (1\4)) <> 0)	/* if someone has called up a sequence since we took a snapshot */			or ((New.ABLE.Seq.Info & (1\4)) <> 0)	/* or our screen code is out of date                            */			or ((Seq.Refresh  &      (4  )) <> 0)	/* or new snapshot is needed                                    */			then do;				call Display.Notice(NT#SystemError,ATTR#Reverse, NulStr,0,0,0);				call Clean.Out.Verify.Tracks;				return;			end;			call Fetch.Table(Seq.Event.Time.Table, 0, row);			call Fetch.32Bit.MSEC(Seq.Event.Time.Type, time);			do trk = 0 to Seq.Tracks-1;				if ((Highlighted(row) & bits(trk)) <> 0)				then do;					/* see if this track appeared earlier in the list.  if so, */					/* cannot change the note start times twice!!              */					i = 0;					do j = 0 to trk-1;						if  (TrkIndex(trk) = Trkindex(j))						and ((edited & bits(j)) <> 0)						then i = 1;					end;					if  (Get.Snapshot.Info(AEE.Cur.Seq.Snap, trk, TRKINDEX, row) <> 0)					and (i = 0)					and (TrkIndex(trk) >= Num.Kbd.Tracks)					then do;						/* save info about the first note we move, so  */						/* we can find it again (maybe)                */						if first = 0 then do;							selected = Highlighted(row);	/* save which are selected */							w1       = #w1;							w2       = #w2;					/* save description */							w3       = #w3;					/* of note          */							w4       = #w4;							first    = 1;							ntrk     = trk;							nrow     = row;							call COPY32(time, newtime);						end;						call CHANGE.NOTE.START(time, Ripple.Mode <> 0);						call Check.For.Live.Click;						edited = edited \ bits(trk);	/* snapshot area is now useless */					end;				end;			end;		end;	end;	/* done with ripple verify rows = either we got them or not */	if Ripple.Verify.Rows <> 0	then do;		do row = 0 to Seq.Event.Display.Size - 1;			if (Ripple.Verify.Rows & bits(row)) <> 0			then Note.Area.Force(row) = (-1);		end;		Ripple.Verify.Rows = 0;		Ripple.Edit.Type   = 0;		call Highlight.Graphics.Button.Table.Entry(Seq.Verify.Undo.Search, 0, 0, 0, 2, 0);		call Close.Seq.Dialog;	end;	call Take.New.AEE.Snapshot;	/* take new snapshot immediately */	/* Now try to find & highlight the same notes on the new */	/* line (if they have moved)                             */	if first <> 0	/* make sure we found a note (error if not) */	then do;		call Find.Note(NewTime, w1, w2, w3, w4, ntrk, nrow, 0, selected);	end;end CHANGE.SEQ.SELECTED.NOTE.TIMES;/* $page - routine to add ilp to track */Add.Seq.Ilp: proc(trk, time, code, etime) swapable;	dcl trk		fixed;	dcl time		array;	dcl code		fixed;	dcl etime	array;	dcl p(1)	fixed;	dcl q(1)	fixed;	dcl m(2)	fixed;	/* FOR METER-MAP SAVVY LOOP END TIME CALCULATION */	call Stop.Sequencer;				/* for ilp create        */	p(0) = play.time.msb;			/* save current position */	p(1) = play.time.lsb;	call Map.Real.Time.To.Sequence.Time(p, p);	call REMOVE.ILP.FROM.TRACK(trk);	/* get rid of possible earlier loop */	call PLAY.INITIALIZE;				/* get fresh pointers               */	#TRK = trk;	call Check.For.Live.Click;	/* compute loop end time if desired: */	if code = 0 then do;		/* CREATE LOOP (METER MAP AND CLICK TRACK SAVVY VERSION) */		/* compute loop end time */				if Click.Track.Mode igt 3			/* live click track */		then do;				/* only adds one measure */			/* CALCULATE LOOP LENGTH IN "CLICK TRACK" MILLIBEATS */			load Lookup.Beats.Per.Measure(time);mul 1000;			/* CONVERT THIS TO SEQUENCE LOOP DURATION */			call Remap.With.Live.Click(time(0),time(1),ures,res,2);			/* ADD SEQUENCE LOOP DURATION TO SEQUENCE LOOP START AND SAVE AS SEQUENCE LOOP END TIME */			call add32(time,loc(addr(Remapped.Dur.Msb)),q);		end;		else do;			call Map.Sequence.Time.To.Measures.Beats(time,m);			m(0)=m(0)+2;	/* add two measures */			call Map.Measures.Beats.To.Sequence.Time(m,q);		end;		/* METER MAP AND CLICK TRACK UN-SAVVY VERSION */		/*		call COPY32(time, q);										/ * get loop start time   * /		call ADD16(shl(SAMP.CLICK.RATE * SAMP.BPM,1), q);	/ * set up 2 measure loop * /		*/	end;	else call COPY32(etime, q);									/* else use passed end time */	call CREATE.ILP.ON.TRACK(trk,time(0),time(1),q(0),q(1));	if COM32(p, time) = lw#igt			/* limit scroll forward to where */	then call COPY32(time, p);			/* we created loop to avoid      */												/* random time displays.         */	call SCROLL.SEQ(p(0),p(1),1);		/* move back to where we were before edit */	Display.Note.Contents = Display.Note.Contents \ Display.Loops;	if Display.Events.Table <> 0	then call Highlight.Graphics.Button.Table		(Display.Events.Table, shr(Display.Note.Contents,8), 2, 0);	/* Take a new snapshot right away unless we are doing a move: */	if code <> 2	then call Take.New.AEE.Snapshot;					/* take new snapshot immediately */end Add.Seq.Ilp;/* change the time for a note */Change.Seq.Note.Duration: proc (row, trk, code, verified) swapable;	dcl row                         fixed;	dcl trk                         fixed;	dcl code                        fixed;	/* 0 - duration entered.  1 = end time entered */	dcl verified                    fixed;	dcl change.start                fixed;	dcl new.start    (1)            fixed;	dcl change.duration             fixed;	dcl new.duration (1)            fixed;	dcl start.error                 fixed;	dcl Event (event.record.size-1) fixed;	dcl start   (1) fixed;	dcl time    (1) fixed;	dcl tmp     (1) fixed;	dcl time1   (1) fixed;	dcl time2   (1) fixed;	dcl etime   (1) fixed;	dcl real        fixed;	/* check for various error conditions */	if (Note.Area.Contents(row) & bits(trk)) = 0	/* user typing into */	then do;													/* an empty row?    */		call no.edit.allowed;		call Clean.Out.Verify.Tracks;		Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);		Seq.Refresh = Seq.Refresh \ 8;		return;	end;	if ((New.Seq.Info &      (1\4)) <> 0)	/* if someone has called up a sequence since we took a snapshot */	or ((New.ABLE.Seq.Info & (1\4)) <> 0)	/* or our screen code is out of date                            */	or ((Seq.Refresh  &      (4  )) <> 0)	/* or new snapshot is needed                                    */	then do;		call Display.Notice(NT#SystemError,ATTR#Reverse, NulStr,0,0,0);		call Clean.Out.Verify.Tracks;		Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);		Seq.Refresh = Seq.Refresh \ 8;		return;	end;	if (Get.Snapshot.Info(AEE.Cur.Seq.Snap, trk, TRKINDEX, row) = 0)	then do;		call no.edit.allowed;		call Clean.Out.Verify.Tracks;		Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);		Seq.Refresh = Seq.Refresh \ 8;		return;	end;	if (isa.rest.note)				/* cannot change duration/end time */	or (isa.rte.note )				/* of rest note/rte note,          */	then do;								/* especially since these fields   */		call no.changes.allowed;	/* are not even displayed          */		call Clean.Out.Verify.Tracks;		Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);		Seq.Refresh = Seq.Refresh \ 8;		return;	end;	/* NOTE: philosophy of operations is as follows:              */	/*       if the user is seeing beats or measures:beats, then  */	/*       we will use SEQUENCE times to perform time shifting. */	/*       If the user is seeing a REAL time,  then we will use */	/*       real times.   This probably provides the most        */	/*       predictable operation when moving notes around when  */	/*       a tempo map is in effect.                            */	/*       This basically assures that a note will be still be  */	/*       1 beat (or 1 second) long after the start time has   */	/*       been changed despite various tempo changes.          */	if  (AEE.Time.Format = O#MSEC.Beats         )	or  (AEE.Time.Format = O#MSEC.Measures.Beats)	then real = 0;	else real = 1;	if real	then call Map.Sequence.Time.To.Real.Time(loc(addr(#NMSB)), start);	else call COPY32                        (loc(addr(#NMSB)), start);	/* Look up basic info about ILP if needed: */	if  (isa.ilp.note)	then do;		if (#w1&"174001") <> "104001"		then do;			call CANT.EDIT.LOOP;			call Clean.Out.Verify.Tracks;			Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);			Seq.Refresh = Seq.Refresh \ 8;			return;		end;		/* look up current loop information: start time, length */		call TRK.HEAD.LOOKUP(trkindex(trk), THD.COUNTIN.MSB);		call COPY.IN(addr(time1(0)), 2);		/* THD.COUNTIN.MSB */		call COPY.IN(addr(time2(0)), 2);		/* THD.LOOPLEN.MSB */		call COPY32(time2, loc(addr(Event(event.duration.msb))));		if real then do;							/* get info in real units */			call Map.Sequence.Duration.To.Real.Duration(loc(addr(#NMSB)),																	  loc(addr(Event(event.duration.msb))),																	  loc(addr(Event(event.duration.msb))));		end;		call ADD32 (start, loc(addr(Event(event.duration.msb))), etime);	end;	else do;	/* must be normal note,  either music or cue */		call Expand.Sequencer.Event.Information (Event, 1);		/* note: durations for events & cues are in REAL units.  durations */		/* for music notes are in SEQUENCER units.   Get in the correct    */		/* format for our purposes now:                                    */		if (Event(event.type) = event.type.note)		or (Event(event.type) = event.type.poly)		then do;			if real										/* get info in real units */			then call Map.Sequence.Duration.To.Real.Duration(loc(addr(#NMSB)),																			 loc(addr(Event(event.duration.msb))),																			 loc(addr(Event(event.duration.msb))));		end;		else do;			if real = 0			then call Map.Real.Duration.To.Sequence.Duration(loc(addr(#NMSB)),																			 loc(addr(Event(event.duration.msb))),																			 loc(addr(Event(event.duration.msb))));		end;		/* If showing offsets, compute in ETIME the time of the */		/* synchronization point:                               */		if Show.Offsets <> 0 then do;			/* compute offset point for simple cues:                      */			if Event(event.type) = event.type.cue			then do;				run.syn = 0;	/* keep pointers from changing during run syn */				if (Fetch.DTD.Cue(Event(event.cue.id), misc.buf) <> 0)				then call SUB32 (loc(addr(misc.buf(CUE.OFF.MSB))),									  loc(addr(misc.buf(CUE.S.MSB  ))), tmp);				run.syn = 1;			end;			/* compute offset point for events: */			else if Event(event.type) = event.type.event			then do;				if COM32(loc(addr(event(event.mark.msb))),							loc(addr(event(event.in.msb)))) = lw#igt				then do;					call SUB32(loc(addr(event(event.mark.msb))),								  loc(addr(event(event.in.msb))), tmp);					call DTD.Sample.#.To.Msecs (tmp,														 CF#Dur,														 S$Speed,														 AEE.Current.Project.Rate, Zero.Zero,														 tmp);				end;			end;			/* compute offset point for music notes: */			else if (Event(event.type) = event.type.note)			or      (Event(event.type) = event.type.poly)			then call COMPUTE.SOUND.FILE.OFFSET.TIME(trkindex(trk),																  Event(event.key#), tmp, 0);			/* compute absolute time of offset point (if any): */			if COM16(0, tmp) <> lw#ieq			then do;				if real = 0				then call Map.Real.Duration.To.Sequence.Duration(loc(addr(#NMSB)),																				 tmp, tmp);				call ADD32 (start, tmp, etime);			end;			else call STR32(-1, -1, etime);		end;	end;	/* initialize to assume no changes needed:         */	change.start    = 0;	change.duration = 0;	/* handle case where user typed in a new duration: */	if code = 0 then do;				/* get new duration */		call Fetch.Table(Seq.Duration.Table + trk, 0, row);		call Fetch.32Bit.MSEC(Seq.Duration.Type + trk, new.duration);		change.duration = 1;		if real		then call Map.Sequence.Duration.To.Real.Duration(loc(addr(#NMSB)),																		 new.duration,																		 new.duration);		/* if end time is locked,  compute new start time */		if  ( Seq.End.Time.Locked.Table         <> 0)		and ((Seq.End.Times.Locked & bits(trk)) <> 0)		then do;			call SUB32(loc(addr(Event(event.duration.msb))), new.duration, tmp);			call ADD32(start, tmp, New.Start);			change.start = 1;		end;	end;	/* else handle case where user typed in new end time */	else do;		call Fetch.Table(Seq.End.Time.Table     + trk, 0, row );		call Fetch.32Bit.MSEC(Seq.End.Time.Type + trk,    time);		if real		then call Map.Sequence.Time.To.Real.Time(time, time);		/* If user types in new offset time, then slide note start: */		if Show.Offsets <> 0		then do;			if Etime(0) = (-1)		/* present error if no offset time avail */			then do;				call no.edit.allowed;				call Clean.Out.Verify.Tracks;				Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);				Seq.Refresh = Seq.Refresh \ 8;				return;			end;			call SUB32(Time, Etime, Etime);	/* get difference */			call ADD32(Start, Etime, New.Start);			change.start = 1;		end;		/* Else if new end time enterred with duration locked,  then */		/* change note start as well:                                */		else if ((Seq.End.Times.Locked & bits(trk)) <> 0)		then do;			call SUB32(Time, loc(addr(Event(event.duration.msb))), New.Start);			change.start = 1;		end;		/* else change duration of note to create proper end time: */		else do;			if COM32(Time, start) = lw#ilt			then call STR32(0, 0, New.Duration);			else call SUB32(time, start, New.Duration);			change.duration = 1;		end;	end;	/* present dialog if ripple edit being attempted: */	if  (change.start <> 0)	and (Ripple.Mode  =  2)	and (verified     =  0)	then do;		if PLAY <> 0		then call Stop.Sequencer;		if  ( Ripple.Verify.Rows <> 0        )		and ((Ripple.Verify.Rows <> bits(row))		or   (Ripple.Edit.Type   <> 1       )		or   (Ripple.Edit.Track  <> trk     )		or   (Ripple.Edit.Code   <> code    ))		then do;			call Clean.Out.Verify.Tracks;		end;		if (Seq.Dialog.Mode <> SEQ#RippleVerifyDialog)		then call OPEN.SEQ.RIPPLE.VERIFY.DIALOG;		Ripple.Verify.Rows = Ripple.Verify.Rows \ bits(row);		Ripple.Edit.Type   = 1;		Ripple.Edit.Row    = row;		Ripple.Edit.Track  = trk;		Ripple.Edit.Code   = code;		call Highlight.Graphics.Button.Table.Entry(Seq.Verify.Undo.Search, 0, 0, 1, 2, 0);		return;	end;	Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);	Seq.Refresh = Seq.Refresh \ 8;	/* Compute new sequence time of possible new note start,  so */	/* the correct duration can be computed:                     */	if change.start <> 0	then do;		if (New.Start(0) < 0)		or (COM16(Zero.Time, New.Start) = lw#IGT)		then do;			call STR32(0, Zero.Time, New.Start);			start.error = 1;		end;		if real		then call Map.Real.Time.To.Sequence.Time(New.Start, New.Start);	end;	else call COPY32(loc(addr(#NMSB)), New.Start);	/* change duration if needed.   Must do this first since we */	/* mosty likely cannot find the note again after changing   */	/* the start time:                                          */	if change.duration <> 0	then do;		if isa.ilp.note then do;			if real			then call Map.Real.Duration.To.Sequence.Duration(New.Start,																			 New.Duration,																			 New.Duration);			call COPY32(New.Duration, time2);			/* changing loop - change start time first, if needed, then get correct length */		end;		else if Trk.Head.Lookup(TRKINDEX(trk),THD.CUE.TRACK) <> 0 then do;	/* cue track duration change */			/* change simple cue triggers to complex cue event to change */			/* duration.   All the event info has been set up            */			if   (event(event.type) = event.type.cue)		/* if was a cue trig */			and  (event(event.cue.id) <> 0          )		/* and info avail    */			then event(event.type) = event.type.event;	/* then make event   */			/* change duration of events here: */			/* note: duration information stored in event records is */			/* in real time (not sequence time) for events & cues:   */			if event(event.type) = event.type.event			then do;				event(event.track#    ) = trkindex(trk);	/* set up rest of */				event(event.time.msb  ) = #nmsb;				/* event info     */				event(event.time.lsb  ) = #nlsb;				/* for place.     */				event(event.time.count) = #count;				if real = 0				then call Map.Sequence.Duration.To.Real.Duration(New.Start,																				 New.Duration,																				 loc(addr(event(event.duration.msb))));				else call COPY32(New.Duration, loc(addr(event(event.duration.msb))));				call MSEC.To.DTD.Sample.#(loc(addr(event(event.duration.msb))),												  CF#Dur,												  S$Speed,												  AEE.Current.Project.Rate, Zero.Zero, tmp);				call ADD32(loc(addr(event(event.in.msb))),							  tmp,							  loc(addr(event(event.out.msb))));				call REMOVE.NOTE.RECORD;	/* remove note record for earlier event */				call Place.Event.In.Sequence(event);	/* replace event with new caption */				call Garbage.Collect.Event.List(trkindex(trk));	/* get rid of earlier event information */				/* retake the snapshot.  hopefully information will not */				/* change,  except for the new duration.  This will     */				/* make sure that all pointers in the snapshot area     */				/* will be up to date.                                  */				call Take.New.AEE.Snapshot;				/* so user can jog quickly. also for upoming start time take */				if (Get.Snapshot.Info(AEE.Cur.Seq.Snap, trk, TRKINDEX, row) = 0)				then do;					call Clean.Out.Verify.Tracks;					return;				end;				change.duration = 0;			end;		end;		else do;						/* music track */			if real			then call Map.Real.Duration.To.Sequence.Duration(New.Start,																			 New.Duration, New.Duration);			call CHANGE.NOTE.DURATION(New.Duration, 0);			/* retake the snapshot.  hopefully information will not */			/* change,  except for the new duration.  This will     */			/* make sure that all pointers in the snapshot area     */			/* will be up to date.                                  */			call Take.New.AEE.Snapshot;				/* so user can jog quickly. also for upoming start time take */			if (Get.Snapshot.Info(AEE.Cur.Seq.Snap, trk, TRKINDEX, row) = 0)			then do;				call Clean.Out.Verify.Tracks;				return;			end;			change.duration = 0;		end;	end;	/* Change the note start time to accomblish the desired */	/* edit if needed:                                      */	if change.start <> 0	then do;		/* Accomplish this by storing the new start time back */		/* into the SMGR,  selecting this note,  and calling  */		/* standard new start time routine:                   */		call COPY32(New.Start, time1);	/* save for possible ILS */		disable.deposits = 1;		call Fetch.Table       (Seq.Event.Time.Table, 0, row);		call Deposit.32bit.Msec(Seq.Event.Time.Type, New.Start, Zero.Zero);		call Deposit.Table     (Seq.Event.Time.Table, 0, row);		disable.deposits = 0;		/* if an event other than this one is selected, */		/* then get just this event:                    */		if (Highlighted(row) <>  bits(trk))		then do;			call Clear.All.Highlights;	/* clear other highlights */			call Set.Highlight(row, trk);		end;		call CHANGE.SEQ.SELECTED.NOTE.TIMES (bits(row), verified);		change.start = 0;	end;	else call Clean.Out.Verify.Tracks;	/* now adjust duration of ilp if needed: */	if  (change.duration <> 0)	and (ertyp           =  0)	then do;		call ADD32(time1, time2, time2);							/* compute new end  */		call Add.Seq.Ilp(trkindex(trk), time1, 1, time2);	/* reconstruct loop */		call Find.Note(time1, "104000", 0, 0, Vel.Note, trk, row, 1, bits(trk));	end;	if  (start.error)	and (ertyp   = 0)	then call DISPLAY.NOTICE (NT#SyncTimeError,ATTR#Reverse,NulStr,0,0,0);end Change.Seq.Note.Duration;/* $page - change pitch (key number) if sequencer note */Change.Seq.Note.Pitch: proc (row, trk, code, verified) swapable;	dcl row					fixed;	dcl trk					fixed;	dcl code					fixed;	dcl verified			fixed;	dcl pitch				fixed;	dcl name(5)				fixed;	dcl change.start		fixed;	dcl change.duration	fixed;	dcl oldpitch			fixed;	dcl olddur   (1)		fixed;	dcl NewStart (1)		fixed;	dcl NewDur   (1)		fixed;	dcl a (1)				fixed;	dcl b (1)				fixed;	dcl c (1)				fixed;	/* check for various error conditions */	if (Note.Area.Contents(row) & bits(trk)) = 0	/* user typing into */	then do;													/* an empty row?    */		call no.edit.allowed;		call Clean.Out.Verify.Tracks;		Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);		Seq.Refresh = Seq.Refresh \ 8;		return;	end;	if ((New.Seq.Info &      (1\4)) <> 0)	/* if someone has called up a sequence since we took a snapshot */	or ((New.ABLE.Seq.Info & (1\4)) <> 0)	/* or our screen code is out of date                            */	or ((Seq.Refresh  &      (4  )) <> 0)	/* or new snapshot is needed                                    */	then do;		call Display.Notice(NT#SystemError,ATTR#Reverse, NulStr,0,0,0);		call Clean.Out.Verify.Tracks;		Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);		Seq.Refresh = Seq.Refresh \ 8;		return;	end;	if (Get.Snapshot.Info(AEE.Cur.Seq.Snap, trk, TRKINDEX, row) = 0)	then do;		call no.edit.allowed;		call Clean.Out.Verify.Tracks;		Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);		Seq.Refresh = Seq.Refresh \ 8;		return;	end;	if (isa.ilp.note )	or (isa.rest.note)	then do;		call CANT.EDIT.LOOP;		call Clean.Out.Verify.Tracks;		Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);		Seq.Refresh = Seq.Refresh \ 8;		return;	end;	/* change rte code: */	if (isa.rte.note)	then do;		call Fetch.Table (Seq.Pitch.Name.Table + trk, 0, row);		call Fetch.String(Seq.Pitch.Name.Type  + trk,   name);		if      (eqstr(name,'PD1' )=0) then call CHANGE.RTE.CODE(0);		else if (eqstr(name,'PD2' )=0) then call CHANGE.RTE.CODE(1);		else if (eqstr(name,'MOD' )=0) then call CHANGE.RTE.CODE(2);		else if (eqstr(name,'BRT' )=0) then call CHANGE.RTE.CODE(3);		else if (eqstr(name,'PTC' )=0) then call CHANGE.RTE.CODE(4);		else if (eqstr(name,'RIB' )=0) then call CHANGE.RTE.CODE(5);		else if (eqstr(name,'TOG' )=0) then call CHANGE.RTE.CODE(6);		else if (eqstr(name,'PRE' )=0) then do;			token(0) = 0;			call CHANGE.RTE.CODE(7);		end;		else if (eqstr(name,'MPG' )=0) then call CHANGE.RTE.CODE(8);		else if (eqstr(name,'SYS' )=0) then call CHANGE.RTE.CODE(9);		else if ((byte(name,0)>=asc.0) and (byte(name,0)<=asc.9))		then do;			call copy.string(name,token);			call CHANGE.RTE.CODE(10);		end;		else if (eqstr(name,'SUS' )=0) then call CHANGE.RTE.CODE(11);		else call format.error;		call Take.New.AEE.Snapshot;		/* so user can jog quickly. also for upoming start time take */		call Clean.Out.Verify.Tracks;		Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);		Seq.Refresh = Seq.Refresh \ 8;		return;	end;	if Trk.Head.Lookup(TRKINDEX(trk),THD.CUE.TRACK) <> 0	then do;		call cannot.change.pitch;		call Clean.Out.Verify.Tracks;		Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);		Seq.Refresh = Seq.Refresh \ 8;		return;	end;	/* Now proceed to change pitch for music notes: */	if code = 0 then do;						/* name entered */		call Fetch.Table (Seq.Pitch.Name.Table + trk, 0, row);		call Fetch.String(Seq.Pitch.Name.Type  + trk,   name);		pitch = CONV.STR.TO.KEY#(name);	/* try to read new pitch */		if ertyp <> 0 then do;			call Clean.Out.Verify.Tracks;			Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);			Seq.Refresh = Seq.Refresh \ 8;			return;								/* error in format */		end;	end;	else do;										/* new number */		call     Fetch.Table      (Seq.Key.Number.Table + trk, 0, row);		pitch =  Fetch.Fixed.Point(Seq.Key.Number.Type  + trk        ) - 24;	end;	if pitch < 0         then pitch = 0;	if pitch >= NUM.KEYS then pitch = NUM.KEYS-1;	/* if the end time/offset of the note is locked,  and the user */	/* is changing the pitch,  then compute a new start time       */	if  ( Seq.End.Time.Locked.Table         <> 0)	and ((Seq.End.Times.Locked & bits(trk)) <> 0)	then do;		oldpitch = EXTRACT.KEY(loc(addr(#w1)));	/* get current note pitch */		call EXTRACT.DUR(loc(addr(#w1)),olddur);	/* and duration           */		/* Begin by computing what new duration would go with this */		/* sound file,  based on the new pitch:                    */		if  (COMPUTE.SOUND.FILE.OFFSET.TIME(trkindex(trk), oldpitch, a, 1))		and (COMPUTE.SOUND.FILE.OFFSET.TIME(trkindex(trk), pitch,    b, 1))		then do;			/* scale to 16-bit ratio for ratio multiply: */			do while (a(0) <> 0) or (b(0) <> 0);	/* scale new and old lengths */				call SHR32(a,1); call SHR32(b, 1);	/* for ratio_multiply         */			end;			/* get durations in real time:               */			call Map.Sequence.Duration.To.Real.Duration(loc(addr(#NMSB)),																	  olddur,																	  olddur);			/* compute new duration & store in NewDur in REAL units */			/* for now:                                             */			call COPY32(OldDur, BitMsbArray);			call ratio_multiply(b(1), a(1));			call COPY32(BitMsbArray, NewDur);			/* If showing offsets,  then change start time by amount needed */			/* to keep offset point at the same time:                       */			if Show.Offsets <> 0 then do;				call COMPUTE.SOUND.FILE.OFFSET.TIME(trkindex(trk), oldpitch, a, 0);				call COMPUTE.SOUND.FILE.OFFSET.TIME(trkindex(trk), pitch,    b, 0);			end;			/* else change start time by amount of time needed to keep */			/* the end time at the same point                          */			else do;				call COPY32(olddur, a);				call COPY32(newdur, b);			end;			/* Compute new start time and new duration in REAL units */			/* always so that we still hear the whole sound file     */			/* no matter what tempo changes are taking place:        */			call Map.Sequence.Time.To.Real.Time(loc(addr(#NMSB)),															NewStart);			call SUB32(a, b, c);			call ADD32(Newstart, c, NewStart);			if NewStart(0) < 0 then call STR32(0, 0, NewStart);			call Map.Real.Time.To.Sequence.Time(NewStart, NewStart);			Change.Start = 1;			call Map.Real.Duration.To.Sequence.Duration(NewStart,																	  NewDur,																	  NewDur);			Change.Duration = 1;		end;	end;	if  (change.start <> 0)	and (Ripple.Mode  =  2)	and (verified     =  0)	then do;		if PLAY <> 0		then call Stop.Sequencer;		if  ( Ripple.Verify.Rows <> 0        )		and ((Ripple.Verify.Rows <> bits(row))		or   (Ripple.Edit.Type   <> 2       )		or   (Ripple.Edit.Track  <> trk     )		or   (Ripple.Edit.Code   <> code    ))		then do;			call Clean.Out.Verify.Tracks;		end;		if (Seq.Dialog.Mode <> SEQ#RippleVerifyDialog)		then call OPEN.SEQ.RIPPLE.VERIFY.DIALOG;		Ripple.Verify.Rows = Ripple.Verify.Rows \ bits(row);		Ripple.Edit.Type   = 2;		Ripple.Edit.Row    = row;		Ripple.Edit.Track  = trk;		Ripple.Edit.Code   = code;		call Highlight.Graphics.Button.Table.Entry(Seq.Verify.Undo.Search, 0, 0, 1, 2, 0);		return;	end;	Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);	Seq.Refresh = Seq.Refresh \ 8;	if Change.Duration <> 0					/* change duration first,  because */	then do;										/* note will not move on us.       */		call CHANGE.NOTE.DURATION(NewDur, 0);		call Take.New.AEE.Snapshot;		if (Get.Snapshot.Info(AEE.Cur.Seq.Snap, trk, TRKINDEX, row) = 0)		then do;			call Clean.Out.Verify.Tracks;			return;		end;	end;	call CHANGE.NOTE.PITCH(pitch);		/* now change note pitch           */	call Take.New.AEE.Snapshot;	if (Get.Snapshot.Info(AEE.Cur.Seq.Snap, trk, TRKINDEX, row) = 0)	then do;		call Clean.Out.Verify.Tracks;		return;	end;	if Change.Start <> 0						/* and now start time if needed.   */	then do;		disable.deposits = 1;		call Fetch.Table       (Seq.Event.Time.Table, 0, row);		call Deposit.32bit.Msec(Seq.Event.Time.Type, NewStart, Zero.Zero);		call Deposit.Table     (Seq.Event.Time.Table, 0, row);		disable.deposits = 0;		/* if an event other than this one is selected, */		/* then get just this event:                    */		if (Highlighted(row) <>  bits(trk))		then do;			call Clear.All.Highlights;	/* clear other highlights */			call Set.Highlight(row, trk);		end;		call CHANGE.SEQ.SELECTED.NOTE.TIMES (bits(row), verified);	end;	else call Clean.Out.Verify.Tracks;end Change.Seq.Note.Pitch;/* $page - change velocity */Change.Seq.Note.Velocity: proc (row, trk) swapable;	dcl row           fixed;	dcl trk           fixed;	dcl i             fixed;	dcl val           fixed;	dcl t             fixed;	dcl ptr           fixed;	dcl pitch.bend.range fixed;	dcl name(5)          fixed;	READ.NORMAL.RTE.VAL: proc(name);		dcl name  array;		dcl val   fixed;		val = CONV.STR.TO.FIXED(name,1,0);		if ertyp<>0 then do;			call format.error; return (-1);		end;		if val igt 1000 then val=1000;		return SCALE.PERCENT.TO.RTE(val);	/* scale 0-1000 to 0-rte.max */;	end READ.NORMAL.RTE.VAL;	/* set bits for screen update now - we will want to re-write this */	/* field at some time for sure.                                   */	Note.Area.Force(row) = Note.Area.Force(row) \ bits(trk);	Seq.Refresh = Seq.Refresh \ 8;	/* check for various error conditions */	if (Note.Area.Contents(row) & bits(trk)) = 0	/* user typing into */	then do;													/* an empty row?    */		call no.edit.allowed;		return;	end;	if ((New.Seq.Info &      (1\4)) <> 0)	/* if someone has called up a sequence since we took a snapshot */	or ((New.ABLE.Seq.Info & (1\4)) <> 0)	/* or our screen code is out of date                            */	or ((Seq.Refresh  &      (4  )) <> 0)	/* or new snapshot is needed                                    */	then do;		call Display.Notice(NT#SystemError,ATTR#Reverse, NulStr,0,0,0);		return;	end;	if (Get.Snapshot.Info(AEE.Cur.Seq.Snap, trk, TRKINDEX, row) <> 0)	then do;		call Fetch.Table (Seq.Velocity.Table + trk, 0, row);		call Fetch.String(Seq.Velocity.Type  + trk,   name);		call COPY.STRING(name, TOKEN);		/* save string for error messages */		if (isa.ilp.note )		or (isa.rest.note)		then call CANT.EDIT.LOOP;		/* changing an rte value */		else if (isa.rte.note)		then do;			if (#w3 & shl(b.gui,8)) <> 0			/* guitar update record */			then do;										/* change rte knob      */				val = Read.Normal.Rte.Val(name);				if val >= 0 then do;					call CHANGE.RTE.VALUE(val);					call Take.New.AEE.Snapshot;			/* so user can jog quickly. also for upoming start time take */				end;			end;			else do case (shr(#w2,6)&3);			/* else loook at type of update record */				do;										/* 0 => normal update   */					i = shr(#w2,8);					/* get rte code handy   */					if (i & "200") <> 0 then do;	/* midi controller update */						val = CONV.STR.TO.FIXED(name,0,0);						if ertyp=0 then do;							if (val > 127) then val = 127;							else if (val < 0) then val = 0;							call CHANGE.RTE.VALUE(val);							call Take.New.AEE.Snapshot;	/* so user can jog quickly. also for upoming start time take */						end;					end;					else if (i = r.ribbon) then do;						val = CONV.STR.TO.FIXED(name,0,1);						if (val > 100) then val = 100;						else if (val < (-100)) then val=(-100);						val = val&255;						call CHANGE.RTE.VALUE(val);						call Take.New.AEE.Snapshot;		/* so user can jog quickly. also for upoming start time take */					end;					else if (i = r.pwheel) then do;						pitch.bend.range = get.pitch.bend.range(trkindex(trk));						val = CONV.STR.TO.FIXED(name,2,1);						/* THE FOLLOWING ALGORITHM LIMITS "val" IF IT EXCEEDS "pitch.bend.range".  THE ORIGINAL ALGORITHM USED							THE OPERATORS < AND > WHICH ONLY WORK RELIABLY FOR VALUES IN THE RANGE OF -16384 TO 16383, BUT							"pitch.bend.range" CAN HAVE ANY VALUE FROM -24000 TO 24000.  THE REWRITTEN ALGORITHM HANDLES VALUES							FROM -32768 TO 32767. */						if val < 0						then do;if -val igt pitch.bend.range then val=-pitch.bend.range;end;						else do;if val igt pitch.bend.range then val=pitch.bend.range;end;						val = srscale(val,100,pitch.bend.range) & 255;						call CHANGE.RTE.VALUE(val);						call Take.New.AEE.Snapshot;		/* so user can jog quickly. also for upcoming start time take */					end;					else do;	/* print normal parameter value */						val = Read.Normal.Rte.Val(name);						if val >= 0 then do;							call CHANGE.RTE.VALUE(val);							call Take.New.AEE.Snapshot;	/* so user can jog quickly. also for upoming start time take */						end;					end;				end;				do;										/* 1 => toggle bits     */					call no.changes.allowed;				end;				do;										/* 2 => pressure update  */					val = Read.Normal.Rte.Val(name);					if val >= 0 then do;						call CHANGE.RTE.VALUE(val);						call Take.New.AEE.Snapshot;				/* so user can jog quickly. also for upoming start time take */					end;				end;				do;										/* midi */					do case shr(#w2,8);				/* editing rte update record - find type */						do;							val = CONV.STR.TO.FIXED(name, 0, 0);	/* midi program change, # in between 0 and 127 */							if (val > 127 or val < 0) then							call FORMAT.ERROR;							else do;								call CHANGE.RTE.VALUE(val);								call Take.New.AEE.Snapshot;	/* so user can jog quickly. also for upoming start time take */							end;						end;						do;							val = CONV.HEXSTR.TO.FIXED(name);							if (val > 255 or val < 0)							then call FORMAT.ERROR;							else do;								call CHANGE.RTE.VALUE(val);								call Take.New.AEE.Snapshot;	/* so user can jog quickly. also for upoming start time take */							end;						end;						do;											/* sustain switch update */							val = CONV.HEXSTR.TO.FIXED(name);							if (val <> 0) then val = 127;		/* midi rte max */							call CHANGE.RTE.VALUE(val);							call Take.New.AEE.Snapshot;		/* so user can jog quickly. also for upoming start time take */						end;					end;				end;			end;		end;		/* changing volume for a cue trigger: */		else if Trk.Head.Lookup(TRKINDEX(trk),THD.CUE.TRACK) <> 0		then do;			val = Read.Normal.Rte.Val(name);			if val >= 0 then do;				call CHANGE.RTE.VALUE(val);				call Take.New.AEE.Snapshot;				/* so user can jog quickly. also for upoming start time take */			end;		end;		/* changing a velocity for a music note code */		else do;			val = Read.Normal.Rte.Val(name);			if val >= 0 then do;				call CHANGE.RTE.VALUE(val);				call Take.New.AEE.Snapshot;				/* so user can jog quickly. also for upoming start time take */			end;		end;		TOKEN(0) = 0;	/* clean out temporary use of 'TOKEN' */	end;end Change.Seq.Note.Velocity;/* $page - change caption */Change.Seq.Note.Caption: proc (row, trk) swapable;	dcl row           fixed;	dcl trk           fixed;	dcl event(event.record.size-1) fixed;	dcl time     (1)               fixed;	/* set bits for screen update now - we will want to re-write this */	/* field at some time for sure.  Set bits for complete update     */	/* in case this cue is displayed in other columns/rows.           */	Seq.Refresh = Seq.Refresh \ (8\16);	/* check for various error conditions */	if (Note.Area.Contents(row) & bits(trk)) = 0	/* user typing into */	then do;													/* an empty row?    */		call no.edit.allowed;		return;	end;	if ((New.Seq.Info &      (1\4)) <> 0)	/* if someone has called up a sequence since we took a snapshot */	or ((New.ABLE.Seq.Info & (1\4)) <> 0)	/* or our screen code is out of date                            */	or ((Seq.Refresh  &      (4  )) <> 0)	/* or new snapshot is needed                                    */	then do;		call Display.Notice(NT#SystemError,ATTR#Reverse, NulStr,0,0,0);		return;	end;	if (Get.Snapshot.Info(AEE.Cur.Seq.Snap, trk, TRKINDEX, row) <> 0)	then do;		if (isa.ilp.note )		or (isa.rest.note)		then call CANT.EDIT.LOOP;		else if (isa.rte.note)		then call no.edit.allowed;		/* See if caption is changing for cue: */		else if Trk.Head.Lookup(TRKINDEX(trk),THD.CUE.TRACK) <> 0		then do;			call Expand.Sequencer.Event.Information (Event, 1);			call Fetch.Table (Seq.Caption.Table + trk, 0, row);			call Fetch.String(Seq.Caption.Type  + trk, loc(addr(event(event.caption))));			if   (event(event.type) = event.type.cue)	/* if was a cue trig */			and  (event(event.cue.id) <> 0          )	/* and info avail    */			then event(event.type) = event.type.event;	/* then make event   */			if   event(event.type) = event.type.event then do;				event(event.track#    ) = trkindex(trk);	/* set up rest of */				event(event.time.msb  ) = #nmsb;				/* event info     */				event(event.time.lsb  ) = #nlsb;				/* for place.     */				event(event.time.count) = #count;				call REMOVE.NOTE.RECORD;	/* remove note record for earlier event */				call Place.Event.In.Sequence(event);	/* replace event with new caption */				call Garbage.Collect.Event.List(trkindex(trk));	/* get rid of earlier event information */				call Take.New.AEE.Snapshot;	/* update all our pointers */			end;		end;		/* changing a caption for a music note: */		else do;			call feature.not.available;		end;	end;end Change.Seq.Note.Caption;/* $page - routine to select a region of notes *//* This subroutine deletes selected notes *//* from their tracks.  It returns bits    *//* for all tracks that need to be         *//* garbage collected.                     */DELETE.SEQ.NOTES.SUBROUTINE: proc swapable;	dcl (row,trk,i,j,k) fixed;	dcl (ilpedited    ) fixed;	dcl (deledited    ) fixed;	dcl (ilpfound     ) fixed;	dcl (time)      (1) fixed;	/* make sure the pointers in the current snapshot area */	/* are up to date:                                     */	if ((New.Seq.Info &      (1\4)) <> 0)	/* if someone has called up a sequence since we took a snapshot */	or ((New.ABLE.Seq.Info & (1\4)) <> 0)	/* or our screen code is out of date                            */	or ((Seq.Refresh  &      (4  )) <> 0)	/* or new snapshot is needed                                    */	then do;		call Display.Notice(NT#SystemError,ATTR#Reverse, NulStr,0,0,0);		return 0;	end;	/* begin by removing any independent loops (if needed).  This */	/* can be done without destroying the note pointers.          */	ilpedited = 0;	do trk = 0 to Seq.Tracks - 1;		/* see if this track appeared earlier in the list.  if so, */		/* cannot change the note start times twice!!              */		i = 0;		do j = 0 to trk-1;			if  (TrkIndex(trk) = Trkindex(j))			and ((ilpedited & bits(j)) <> 0)			then i = 1;		end;		if (i = 0) then do;				/* do not EVER edit track twice */			ilpfound = 0;					/* assume not deleting an ilp   */			do row = 0 to Seq.Event.Display.Size - 1;				/* see if any selected notes are independent loops */				if ((Highlighted(row) & bits(trk)) <> 0)				then do;					if  (Get.Snapshot.Info(AEE.Cur.Seq.Snap, trk, TRKINDEX, row) <> 0)					and (TrkIndex(trk) >= Num.Kbd.Tracks)					and (isa.ilp.note)					then ilpfound = 1;				end;			end;			if ilpfound <> 0			then do;				call REMOVE.ILP.FROM.TRACK(trkindex(trk));				ilpedited = ilpedited \ bits(trk);	/* snapshot area is now useless */			end;		end;	end;	/* now go through and remove note records.  If we do this in reverse */	/* order,  then the track pointers should still be intact.           */	deledited = 0;	do trk = 0 to Seq.Tracks - 1;		/* see if this track appeared earlier in the list.  if so, */		/* cannot change the note start times twice!!              */		i = 0;		do j = 0 to trk-1;			if  (TrkIndex(trk) = Trkindex(j))			and ((deledited & bits(j)) <> 0)			then i = 1;		end;		if (i = 0) then do;				/* do not EVER edit track twice */			row = Seq.Event.Display.Size - 1;			do while row >= 0;				/* delete any selected notes: */				if ((Highlighted(row) & bits(trk)) <> 0)				then do;					if  (Get.Snapshot.Info(AEE.Cur.Seq.Snap, trk, TRKINDEX, row) <> 0)					and (TrkIndex(trk) >= Num.Kbd.Tracks)					then do;						if (isa.ilp.note )						or (isa.rest.note)						then do;							/* oops? */						end;						else do;							call REMOVE.NOTE.RECORD;							deledited = deledited \ bits(trk);	/* indicate was edited */							call Check.For.Live.Click;						end;					end;				end;				row = row - 1;			end;		end;	end;	return (ilpedited \ deledited);	/* return bits for tracks needing garbage collection */end DELETE.SEQ.NOTES.SUBROUTINE;/* now garbage collect any tracks we deleted notes or events on */GARBAGE.COLLECT.AFTER.DELETE: proc(bitlist) swapable;	dcl bitlist fixed;	/* pass bits for each track from trkindex to delete */	dcl time(1) fixed;	dcl trk     fixed;	call Stop.Sequencer;	/* stop sequencer for the garbage collect */	call COPY32(loc(addr(Sampled.Actual.Play.Time.Msb)), time);	do trk = 0 to Seq.Tracks-1;		if (bitlist & bits(trk)) <> 0		then do;			call GARBAGE.COLLECT.TRK(trkindex(trk));			call GARBAGE.COLLECT.EVENT.AREA(trkindex(trk));			/* If track is now empty,  then delete the timbre information */			/* so titles get fixed,  also so we can place music notes     */			/* on a now empty cue track.                                  */			if (Trk.Head.Lookup(trkindex(trk),THD.NN.MSB   ) =  0)			&  (Trk.Head.Lookup(trkindex(trk),THD.NN.LSB   ) =  0)			then call copy.timbre(-3, trkindex(trk));	/* put null timbre there */		end;	end;	call Play.Initialize;			/* unscramble sequence pointers */	call SCROLL.SEQ(time(0), time(1), 0);	call Take.New.AEE.Snapshot;	/* take new snapshot immediately */end GARBAGE.COLLECT.AFTER.DELETE;/* $page - routine to add a note to a track */Create.Seq.Note: proc(note.type) swapable;	dcl note.type fixed;	/* 0 = append, 1 = insert, 2 = ilp, 3 = rte */	dcl row       fixed;	dcl trk       fixed;	dcl col       fixed;	dcl w1        fixed;	dcl w2        fixed;	dcl w3        fixed;	dcl w4        fixed;	dcl time    (1) fixed;	dcl tmp     (1) fixed;	dcl tmptime (1) fixed;	dcl bring.in.rtes   fixed;	/* check refresh bits to assure that we have an up to date snap shot: */	if ((New.Seq.Info &      (1\4)) <> 0)	/* if someone has called up a sequence since we took a snapshot */	or ((New.ABLE.Seq.Info & (1\4)) <> 0)	/* or our screen code is out of date                            */	or ((Seq.Refresh  &      (4  )) <> 0)	/* or new snapshot is needed                                    */	then do;		call Display.Notice(NT#SystemError,ATTR#Reverse, NulStr,0,0,0);		return;	end;	/* find first selected row */	row = 0;												/* see if any row is */	do while (row < Seq.Event.Display.Size)	/* highlighted       */	and      (Highlighted(row) = 0);		row = row + 1;	end;	if row = Seq.Event.Display.Size then do;	/* no area selected  */		call no.edit.allowed;		return;	end;	/* find first highlighted note */	trk = 0;	do while (Highlighted(row) & bits(trk)) = 0;		trk = trk + 1;	end;	if (trkindex(trk)=0) then do;		/* if no track is selected */		call NO.EDIT.ALLOWED;		return;	end;	#TRK = trkindex(trk);	call Check.For.Live.Click;	/* if there is a note there,  all is easy: */	if  (Get.Snapshot.Info(AEE.Cur.Seq.Snap, trk, TRKINDEX, row) <> 0)	then do;		if (note.type = 2) then do;	/* add ilp */			call COPY32(loc(addr(#NMSB)), time);			call Add.Seq.Ilp(trkindex(trk), time, 0, time);			call Find.Note(time, "104000", 0, 0, Vel.Note, trk, row, 1, bits(trk));			return;		end;		call COPY32(loc(addr(#NMSB)), tmptime);		if  (note.type = 0)		/* append or rte - after */		or  (note.type = 3)		then call ADVANCE.TO.NEXT.NOTE;		/* create note record of desired type.  duplicate information */		/* if note type matches,  else create default type.           */		if (note.type = 0)		/* if creating a real note,  then */		or (note.type = 1)		/* see if that is what we have    */		then do;			if (isa.ilp.note)		/* if ilp or rte,  then must      */			or (isa.rte.note)		/* create default note;  else     */			then do;					/* duplicate existing note        */				call Compute.Default.Note(trkindex(trk),tmptime);			end;			Display.Note.Contents = Display.Note.Contents \ Display.Events;			if Display.Events.Table <> 0			then call Highlight.Graphics.Button.Table				(Display.Events.Table, shr(Display.Note.Contents,8), 2, 0);		end;		else do;						/* else if creating rte, duplicate rte if that is what we are on */			if (not(isa.rte.note))			then do;				#w1 = 1;				#w2 = shl(2,8);	/* default to ModW, value=0 */				#w3 = rte.max\shl(b.upd,8);				#w4 = vel.note;			end;			bring.in.rtes = 1;		end;		call COPY32(tmptime, tmp);	/* for find.note below */		w1 = #w1;		w2 = #w2;		w3 = #w3;		w4 = #w4;		#w1 = #w1 & "174001";		call INSERT.NOTE.RECORD(tmptime(0),tmptime(1));	/* add the rte or note */	end;	/* user has selected a track,  but no note.  put note on this line */	/* if there are any notes,  else put note on last line of          */	/* display                                                         */	else do;		do while (row >= 0)		and (Find.Row.Time(row, tmp) < 0);			row = row - 1;		end;		/* if screen is empty,  start with refresh time */		if row < 0 then do;			row = 0;			call COPY32(Seq.Refresh.Time, tmp);			if COM16(zero.time, tmp) = lw#igt			then call STR32(0, zero.time, tmp);		end;		/* initialize an empty track if needed: */		write(mam)=trk.head;		write(mal)=trkindex(trk);		if (read(md)=0) then do;					/* if there are no notes on this track yet */			if ALLOCATE.TRK.HEADER(trkindex(trk))=0 then do;	/* create track header */				call NOMEM.ERROR;				return 0;			end;			call COPY.TIMBRE(0,trkindex(trk));	/* put keyboard timbre on this track */		end;		call LOAD.SEQ.GLOBALS(trkindex(trk));		if (note.type = 2)							/* add ilp */		then do;			call Add.Seq.Ilp(trkindex(trk), tmp, 0, tmp);			call Find.Note(tmp, "104000", 0, 0, Vel.Note, trk, row, 1, bits(trk));			return;		end;		if (note.type = 0)		/* if creating a real note,  then */		or (note.type = 1)		/* see if that is what we have    */		then do;			call Compute.Default.Note(trkindex(trk),tmp);			Display.Note.Contents = Display.Note.Contents \ Display.Events;			if Display.Events.Table <> 0			then call Highlight.Graphics.Button.Table				(Display.Events.Table, shr(Display.Note.Contents,8), 2, 0);		end;		else do;						/* else if creating rte, duplicate rte if that is what we are on */			#w1 = 1;			#w2 = shl(2,8);		/* default to ModW, value=0 */			#w3 = rte.max\shl(b.upd,8);			#w4 = vel.note;			bring.in.rtes = 1;		end;		w1 = #w1; w2 = #w2; w3 = #w3; w4 = #w4;		#w1 = #w1 & "174001";		call INSERT.NOTE.RECORD(tmp(0),tmp(1));	end;	/* redefine screen after insert note record to avoid glomming variables: */	if  (bring.in.rtes)	and ((Display.Note.Contents & Display.Rtes) = 0)	then do;		Display.Note.Contents = Display.Note.Contents \ Display.Rtes;		if Display.Events.Table <> 0		then call Highlight.Graphics.Button.Table			(Display.Events.Table, shr(Display.Note.Contents,8), 2, 0);		if NOTE.AREA.INFORMATION.WOULD.BE.DIFFERENT then do;			call Define.Sequencer.Template(Seq.Row,Seq.Event.Display.Left.X,Seq.Size,Seq.Tracks,2);			Seq.Refresh = Seq.Refresh \ (4\8\16\32\64\128);			call Select.New.Cur.Obj(Corner.Label,-1,-1);	/* in case old object is no longer there */			call Set.Highlight(row, trk);						/* re-highlight                          */		end;	end;	call Take.New.AEE.Snapshot;				/* take new snapshot immediately */	call Find.Note(tmp, w1, w2, w3, w4, trk, row, 1, bits(trk));end Create.Seq.Note;