/* AUD-CM1   $TITLE  Part 2 of AUD-CUEM   Modified:   01/11/90 - MWH - Correctly stop DTD cues from playing on recall / mouse up   05/03/89 - cj - fixed numerous cue placing/chaining bugs                   when events were also on track.   04/27/89 - cj - changed call to play.real.time.cue for events   04/24/89 - cj - updated cue chaining for expand.event.note   08/16/88 - CJ - check for negative numbers from take.system.sequence.time   08/08/88 - cj  - store absolute # of smpte bits in cue record   */SET.CUE.MENU.PLACE.MODE: proc (Mode) public swapable;   dcl (Mode,I) fixed;   dcl Mode.To.Obj.Map data (Cue.Menu.Drag.Button,Cue.Menu.Sync.Button,Cue.Menu.Chain.Button,Cue.Menu.Real.Button);      if Cue.Menu.Group = 0   /* no cue menu - no change */   then return;   /* set up correct label for the 'DRAG/OFF' button */   disable.deposits = 1;   if Seq.Group <> 0    then call Deposit.Label(GID(Cue.Menu.Drag.Button),' DRAG ');   else call Deposit.Label(GID(Cue.Menu.Drag.Button),' OFF  ');   disable.deposits = 0;   I=GID(Cue.Place.Mode);  /* look up current place mode */   call Set.Object.Attr(GID(Mode.To.Obj.Map(I)),0,ATTR#Normal|ATTR#AltIntensity);   call Set.Object.Attr(GID(Mode.To.Obj.Map(I)),1,ATTR#Normal|ATTR#AltIntensity);   call Update.Object(GID(Mode.To.Obj.Map(I)));  /* snappily turn off light */   call PID(Cue.Place.Mode,Mode);   call Set.Object.Attr(GID(Mode.To.Obj.Map(Mode)),0,ATTR#Normal|ATTR#Reverse|ATTR#AltIntensity);   call Set.Object.Attr(GID(Mode.To.Obj.Map(Mode)),1,ATTR#Normal|ATTR#Reverse|ATTR#AltIntensity);   call Update.Object(GID(Mode.To.Obj.Map(Mode)));  /* snappily turn on light */   if (Fetch.Object.Info(GID(Cue.Menu.Drag.Mode.Switch),O#Status)&O#STAT.Enable) <> 0   then do;               /* drag mode switch is active         */      if (Mode<>P#Drag)   /* but don't want to be in DRAG mode  */      or (Seq.Group = 0)  /* or no seq group                    */      then do;            /* erase and disable drag mode switch */         I=GID(Cue.Menu.Drag.Mode.Switch);         call Erase.Object  (I);         call Disable.Object(I);      end;   end;   if  ((Fetch.Object.Info(GID(Cue.Menu.Place.Track.Field),O#Status)&O#STAT.Enable) <> 0)   then do;                 /* place track field is active     */      if  (Mode=P#Drag)     /* but we want to be in DRAG mode  */      then do;         /* erase and disable place track fields */         I=GID(Cue.Menu.Place.Track.Label);         call Erase.Object  (I);          call Disable.Object(I);         I=GID(Cue.Menu.Place.Track.Field);         call Erase.Object  (I);         call Disable.Object(I);      end;   end;   if  (Mode = P#Drag)     /* want to be in DRAG mode */   and (Seq.Group <> 0)    /* and seq group there     */   then do;      I=GID(Cue.Menu.Drag.Mode.Switch);      call Activate.Object.Range(I,I);      call Update.Object        (I);   end;   else if  (Mode = P#Real)    /* Real Time */   or       (Mode = P#Sync)    /* Sync Time */   or      (Mode = P#Chain)   /* Chaining  */   then do;      I=GID(Cue.Menu.Place.Track.Label);      call Activate.Object.Range(I,I);      call Update.Object        (I);      I=GID(Cue.Menu.Place.Track.Field);      call Activate.Object.Range(I,I);      call Update.Object        (I);   end;   call Select.New.Cur.Obj(Corner.Label,-1,-1);end SET.CUE.MENU.PLACE.MODE;   CHECK.CUE.PLACE.MODE.ON.SEQUENCER.START.OR.STOP: proc public swapable;   if (GID(Cue.Place.Mode) = P#Sync)   or (GID(Cue.Place.Mode) = P#Chain)   then call SET.CUE.MENU.PLACE.MODE(P#Drag);end CHECK.CUE.PLACE.MODE.ON.SEQUENCER.START.OR.STOP;STOP.REAL.TIME.CUE.PLACEMENT: proc public swapable;   call Send.Place.List.To.Sequencer;end STOP.REAL.TIME.CUE.PLACEMENT;GET.CUE.MENU.DIALOG: proc (message,id) returns (fixed) swapable;   dcl i                        fixed;   dcl message                  fixed;   dcl id                       fixed;   dcl Message.Label            fixed;   dcl Save.Button              fixed;   dcl OK.Button                fixed;   dcl Cancel.Button            fixed;   dcl New.Name                 fixed;   dcl exit                     fixed;   dcl cname(shr(cue.name.l,1)) fixed;   dcl line (40)                fixed;   /* Message:  0 - Null                1 - Select cues to delete with mouse  [OK] [CANCEL]                2 - All cues will be deleted          [OK] [CANCEL]                3 - Transfer Cue to Poly Memory       [OK] [CANCEL]   */   call REMOVE.ERR;   call Set.Auto.Allocation.Id(Cue.Menu.Alloc+200);   call Set.Default.Action(O#ACT.Middle.Press);   call Set.Default.Attr(0,ATTR#Normal\ATTR#Reverse);   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);   Disable.Deposits = true;   do case message;      ; /* null */      ; /* Delete all cues */      do;           Message.Label = Define.Label(S#AA,Cue.Menu.Row+Cue.Menu.Size,0,55,'');         OK.Button     = Define.Label(S#AA,Cue.Menu.Row+Cue.Menu.Size,65,0,'[OK]');         Cancel.Button = Define.Label(S#AA,Cue.Menu.Row+Cue.Menu.Size,70,0,'[CANCEL]');         call Deposit.Label(Message.Label,'All cues displayed will be deleted');      end;      do;           call copy.string('Transfer Cue ',line);         if Fetch.DTD.Cue(id,misc.buf) <> 0 then do;            if misc.buf(cue.name) igt cue.name.l            then misc.buf(cue.name) = cue.name.l;            call append.to.str(line,loc(addr(misc.buf(cue.name))));         end;         else call append.to.str(line,'***');         call append.to.str(line,' To Poly Memory');         Message.Label = Define.Label(S#AA,Cue.Menu.Row+Cue.Menu.Size,0,60,'');         OK.Button     = Define.Label(S#AA,Cue.Menu.Row+Cue.Menu.Size,65,0,'[OK]');         Cancel.Button = Define.Label(S#AA,Cue.Menu.Row+Cue.Menu.Size,70,0,'[CANCEL]');         call Deposit.Label(Message.Label,line);      end;   end;   call Deposit.Object.Info(Message.Label,O#EraseMethod,O#ERAS.Whole.Line);   Disable.Deposits = false;   call Set.Default.Attr(0,ATTR#Normal);   call Set.Default.Attr(1,ATTR#AltIntensity\ATTR#Reverse);   call Activate.Object.Range(Cue.Menu.Alloc+200,Cue.Menu.Alloc+210);   do i = Cue.Menu.Alloc+200 to Cue.Menu.Alloc+210;      call Update.Object(i);   end;   do while exit = 0;      i = Get.Next.Screen.Event;      if Screen.Event.Group = Cue.Menu.Group then do;         if i = Get.Screen.Event then do;             if Screen.Event.Id = OK.Button then do;                if Screen.Event.Info = S#MouseSelect then do;                   exit = 1;                end;             end;             else if (Screen.Event.Id = Cancel.Button) then do;                if Screen.Event.Info = S#MouseSelect                then exit = -1;             end;         end;         else if (Screen.Event.Info = S#MouseSelect)         or      (Screen.Event.Info = S#MouseActivate)         then call Display.Notice(NT#MustRespondToDialog,ATTR#Normal,NulStr,0,0,0);      end;      else do;         if (i = Get.Screen.Event)         &  ((Screen.Event.Info = S#MouseSelect)         or  (Screen.Event.Info = S#MouseActivate))         then call Display.Notice(NT#MustRespondToDialog,ATTR#Normal,NulStr,0,0,0);      end;   end;   call Erase.Object(Message.Label);  /* Erases message and whole line */   call Undefine.Object.Range(Cue.Menu.Alloc+200,Cue.Menu.Alloc+210);   call Select.New.Cur.Obj(Corner.Label,-1,-1);   return (exit > 0);   /* if exit < 0 then return false; else true */end GET.CUE.MENU.DIALOG;DELETE.ALL.DISPLAYED.CUES: proc swapable;   dcl i   fixed;   if Get.Cue.Menu.Dialog(2,0) = 0 then return;   call Display.Notice(NT#DeletingAllDisplayedCues,ATTR#Normal,NulStr,0,0,0);   do i = 0 to Cue.Menu.Id.Table.Len-1;      if GID(Cue.Menu.Id.Table + i) <> 0      then call Delete.DTD.Cue(GID(Cue.Menu.Id.Table + i));   end;   call Update.Cue.Menu.Table(0,-1);    /* quickly update cue directory table */end DELETE.ALL.DISPLAYED.CUES;SET.FORMAT.STR.TO.NAME.STR: proc swapable;   call Undefine.Object(Cue.Menu.Format.Switch);   call Define.Switch(Cue.Menu.Format.Switch,Cue.Menu.Row,22, 9,0,'Full Name|3 Columns|5 Columns|8 Columns');   call Set.Object.Attr(Cue.Menu.Format.Switch,0,ATTR#Normal);   call Set.Object.Attr(Cue.Menu.Format.Switch,1,ATTR#Reverse\ATTR#AltIntensity);   call Activate.Object.Range(Cue.Menu.Format.Switch,Cue.Menu.Format.Switch);end SET.FORMAT.STR.TO.NAME.STR;SET.FORMAT.STR.TO.TIME.STR: proc swapable;   call Undefine.Object(Cue.Menu.Format.Switch);   call Define.Switch(Cue.Menu.Format.Switch,Cue.Menu.Row,22,9,0,'Full Name');/* call Define.Switch(Cue.Menu.Format.Switch,Cue.Menu.Row,22,9,0,'2 Columns|3 Columns|5 Columns'); */   call Set.Object.Attr(Cue.Menu.Format.Switch,0,ATTR#Normal);   call Set.Object.Attr(Cue.Menu.Format.Switch,1,ATTR#Reverse\ATTR#AltIntensity);   call Activate.Object.Range(Cue.Menu.Format.Switch,Cue.Menu.Format.Switch);end SET.FORMAT.STR.TO.TIME.STR;SET.CUE.MENU.FORMAT.SWITCH.STR: proc swapable;   dcl i                 fixed;   i = Fetch.Switch(Cue.Menu.Sort.Switch);   call PID(Saved.CM.Sort.Switch, i);        /* store new setting */   if (i <> Cue.Menu.Sort)   then do;      if  (i = 0) & (Cue.Menu.Format >= 5) then do;         call Set.Format.Str.To.Name.Str;         /* Restore format to last alpha format */         Cue.Menu.Format = Last.Alpha.Format;         Disable.Deposits = true;         call Deposit.Switch(Cue.Menu.Format.Switch,Cue.Menu.Format-1);         Disable.Deposits = false;      end;      else if (i <> 0) & (Cue.Menu.Format < 5) then do;         call Set.Format.Str.To.Time.Str;         Last.Alpha.Format = Cue.Menu.Format;         Cue.Menu.Format = 5; /* only one time format available as of 5/10/88 */         Disable.Deposits = true;         call Deposit.Switch(Cue.Menu.Format.Switch,Cue.Menu.Format-5);         Disable.Deposits = false;      end;      call PID(Saved.CM.Format, (Cue.Menu.Format - Default.CM.Format));  /* store new setting */   end;   Cue.Menu.Sort = i;end SET.CUE.MENU.FORMAT.SWITCH.STR;CONVERT.CUE#.TO.POSITION: proc(cue#) swapable;   dcl cue#     fixed; /* id of cue to find position for */   dcl ncues    fixed; /* number of cues to search through */   dcl i        fixed;   if (Fetch.Switch(Cue.Menu.Display.Switch)=0)   then ncues = DTD.NUM.CUES;   else ncues = DTD.CP.CUES;   do i = 0 to ncues-1;      do case (Cue.Menu.Sort);         call Fetch.Nth.Alpha.DTD.Cue(i);         call Fetch.Nth.Time.DTD.Cue (i);         call Fetch.Nth.Sync.DTD.Cue (i);      end;      if DTD.Cue# = cue#                 /* found it */      then return i;   end;   return -1;                             /* error    */end CONVERT.CUE#.TO.POSITION;GET.CUE.TIME: proc (time) swapable;   /* call after a fetch.nth.xxxx.cue to get time */   dcl time    array;   dcl temp(4) fixed;   dcl mode    fixed;   write(mam) = SCSI.Ptr;   if Cue.Menu.Sort = 1 then write(mal) = CUE.IN.S#.MSB;   else                      write(mal) = CUE.SMPT.MSB;   time(0) = read(mdi);   time(1) = read(mdi);   if Cue.Menu.Sort <> 1 then do;     /* if sorting on smpte time, get */      write(mal) = CUE.BITS;          /* absolute # of smpte bits      */      if (read(md) & bit3) = 0        /* based on current offset       */      then do;                        /* so we can sort both new       */         write(mal) = CUE.SMPT.MODE;  /* and old cues.                 */         mode       = read(md);         call SBITS.TO.MSEC(time, cf#time, SAMP.SPEED, mode, time);         call MSEC.TO.SMPTE(time, cf#time, SAMP.SPEED, SM.MODE, loc(addr(SM.HRS)), temp);         call SMPTE.TO.SBITS(temp, SM.MODE, time);      end;   end;end GET.CUE.TIME;/* no longer used  05/16/88 */FETCH.FIRST.CUE.OF.A.PREVIOUS.ROW: proc(rows) returns (fixed) swapable;   dcl rows           fixed;  /* number of rows to go back  */   dcl top.time  (1)  fixed;  /* time of current top cue    */   dcl prev.time (1)  fixed;  /* 1st cue time before top cue time  */   dcl this.time (1)  fixed;  /* time of most recently fetched cue */   dcl last.cue#      fixed;  /* cue# for cue before current cue   */   dcl position       fixed;  /* position of new top cue           */   dcl (i, x)         fixed;   do while (rows > 0);      if Cue.Menu.Sort = 1 then call Fetch.Nth.Time.DTD.Cue(Cue.Menu.Position);      else                      call Fetch.Nth.Sync.DTD.Cue(Cue.Menu.Position);      call Get.Cue.Time(top.time);   /* get time of top cue */      DTD.Cue# = 0;      if Cue.Menu.Sort = 1 then call Send.To.Lod(27,0);      else                      call Send.To.Lod(32,0);      if DTD.Cue# <> 0 then do;                /* Fetch got a cue */         call Get.Cue.Time(this.time);         x = com32(this.time, top.time);         if (x = lw#ieq) then do;                      /* top.time = this.time, this implies entire prev. row is filled */            position = Cue.Menu.Position - Cue.Menu.Columns;             GOTO NEXT;         end;         else if (x = lw#ilt) then do;         /* this.time < top.time */            prev.time(0) = this.time(0);            prev.time(1) = this.time(1);            last.cue# = DTD.Cue#;            do i = 0 to Cue.Menu.Columns-2;               DTD.Cue# = 0;               if Cue.Menu.Sort = 1 then call Send.To.Lod(27,0);               else                      call Send.To.Lod(32,0);               if DTD.CUE# <> 0 then do;                  call Get.Cue.Time(this.time);                  x = com32(this.time, prev.time);                  if (x = lw#ilt) then do;       /* this.time < prev.time; implies new row */                     position = Convert.Cue#.To.Position(last.cue#);                        GOTO NEXT;                  end;                  else last.cue# = DTD.Cue#;               end;            end;            position = Convert.Cue#.To.Position(last.cue#);    /* previous row is full */         end;      end;      NEXT:         rows = rows - 1;         Cue.Menu.Position = position;   end;   return position;end FETCH.FIRST.CUE.OF.A.PREVIOUS.ROW;SHUFFLE.TABLE.IDS: proc(NumLines,Direction) swapable;   dcl NumLines    fixed; /* number of lines to shuffle  */   dcl Direction   fixed; /* >0 = scroll forward; <0 = scroll backward */   dcl (col,row)   fixed;   dcl value       fixed;   if NumLines > (Cue.Menu.Rows-1) then return;   if direction > 0 then do;      do col = 0 to Cue.Menu.Columns-1;         do row = NumLines to (Cue.Menu.Rows-1);            value = GID(Cue.Menu.Id.Table + (Cue.Menu.Rows*col) + row);            call PID(Cue.Menu.Id.Table + (Cue.Menu.Rows*col) + row - NumLines, value);         end;         /* fill rest of column with 0's */         do row = (Cue.Menu.Rows-NumLines) to (Cue.Menu.Rows-1);            call PID(Cue.Menu.Id.Table + (Cue.Menu.Rows*col) + row,0);         end;      end;   end;   else if direction < 0 then do;      do col = 0 to Cue.Menu.Columns-1;         do row = (Cue.Menu.Rows-1) to NumLines by -1;            value = GID(Cue.Menu.Id.Table + (Cue.Menu.Rows*col) + row - NumLines);            call PID(Cue.Menu.Id.Table + (Cue.Menu.Rows*col) + row, value);         end;         /* fill top of table with 0's */         do row = 0 to NumLines-1;            call PID(Cue.Menu.Id.Table + (Cue.Menu.Rows*col) + row,0);         end;      end;   end;end SHUFFLE.TABLE.IDS;SCROLL.CUE.DIRECTORY: proc (NumLines,Direction) swapable;   dcl NumLines    fixed; /* number of lines to scroll   */   dcl Direction   fixed; /* >0 = forward; <0 = backward */   dcl start.cue   fixed; /* cue # to start filling rows with */   dcl LastCuePos  fixed;   dcl (row,col)   fixed;   dcl (i,j,k)     fixed;   if NumLines igt (Cue.Menu.Rows-1) then NumLines=Cue.Menu.Rows-1; /* farthest we can scroll */   if (NumLines=0) or (Direction=0) then return;   if Direction > 0 then do;      call Fetch.DTD.System.Info; /* get current vals for DTD.NUM.CUES & DTD.CP.CUES */      if (Fetch.Switch(Cue.Menu.Display.Switch)=0)      then j = DTD.NUM.CUES;      else j = DTD.CP.CUES;      /* make sure user can't scroll beyond end of table */      if ((Cue.Menu.Position + (Cue.Menu.Columns*NumLines)) >= j)       then do;          LastCuePos = ((j-1)/Cue.Menu.Columns)*Cue.Menu.Columns;          NumLines   = (LastCuePos-Cue.Menu.Position)/Cue.Menu.Columns;         if NumLines = 0 then return Cue.Menu.Position; /* can't scroll any further */         start.cue  = -1;      end;      else do;         start.cue = Cue.Menu.Position + (Cue.Menu.Columns*Cue.Menu.Rows);         if start.cue igt (j-1) then start.cue = -1; /* fill table with blanks */      end;      call Shuffle.Table.Ids(NumLines,Direction);  /* shuffle memories up NumLines */      call Set.DTD.Scroll.Range(Fetch.Switch(Cue.Menu.Display.Switch));      if Cue.Menu.Format < 5 then do;         /* Hardware scrolled */         call Insert.Table.Rows(Cue.Menu.Name.Table.Id,Cue.Menu.Rows-1,0,NumLines); /* scroll table up N lines */         call Deposit.Alpha.Cue.Table(start.cue,Cue.Menu.Rows-NumLines,Cue.Menu.Rows-1,Cue.Menu.Format);      end;      else do;         /* Hardware scrolled - this will also scroll the name table on the screen */         call Insert.Table.Rows(Cue.Menu.Time.Table.Id,Cue.Menu.Rows-1,0,NumLines); /* scroll tables down N lines */         /* Software scrolled - since the name table has already been scrolled */         /* on the screen, all we need to do is shuffle smgr memory */         call Insert.Table.Rows(Cue.Menu.Name.Table.Id,Cue.Menu.Rows-1,0,NumLines); /* scroll table up N lines */         /* this proc will fill both time and name tables */         call Deposit.Time.Cue.Table(start.cue,Cue.Menu.Rows-NumLines,Cue.Menu.Rows-1,Cue.Menu.Sort,Cue.Menu.Format);      end;      Cue.Menu.Position = Cue.Menu.Position + (NumLines*Cue.Menu.Columns);   end;   else if Direction < 0 then do;      /* make sure user can't scroll beyond beginning of table */      if ((Cue.Menu.Position - (Cue.Menu.Columns*NumLines)) < 0)      then do;          NumLines = Cue.Menu.Position/Cue.Menu.Columns;         if NumLines = 0 then return;              /* can't scroll any further */      end;      start.cue = Cue.Menu.Position - (NumLines*Cue.Menu.Columns);      if start.cue < 0 then return;                /* can't scroll any farther back */      call Shuffle.Table.Ids(NumLines,Direction);  /* shuffle memories up NumLines */      call Set.DTD.Scroll.Range(Fetch.Switch(Cue.Menu.Display.Switch));      if Cue.Menu.Format < 5 then do;         /* Hardware scrolled */         call Insert.Table.Rows(Cue.Menu.Name.Table.Id,0,1,NumLines); /* scroll table down N lines */         call Deposit.Alpha.Cue.Table(start.cue,0,NumLines-1,Cue.Menu.Format);      end;      else do;         /* Hardware scrolled - this will also scroll the name table on the screen */         call Insert.Table.Rows(Cue.Menu.Time.Table.Id,0,1,NumLines); /* scroll tables down NumLines */         /* Software scrolled - since the name table has already been scrolled */         /* on the screen, all we need to do is shuffle its' smgr memory */         call Insert.Table.Rows(Cue.Menu.Name.Table.Id,0,1,NumLines);         /* this proc will fill both time and name tables */         call Deposit.Time.Cue.Table (start.cue,0,NumLines-1,Cue.Menu.Sort,Cue.Menu.Format);      end;      Cue.Menu.Position = Cue.Menu.Position - (NumLines*Cue.Menu.Columns);   end;   return Cue.Menu.Position;end SCROLL.CUE.DIRECTORY;HANDLE.CUE.MENU.SCROLL.BAR: proc swapable;   dcl (i, j, k)    fixed;   dcl TotalRows    fixed;   dcl TopLine      fixed;   dcl TopCue       fixed;   if (Fetch.Switch(Cue.Menu.Display.Switch)=0)   then j = DTD.NUM.CUES;   else j = DTD.CP.CUES;   if j = 0 then return;    /* not enough cues in table to use scrolling */   if Cue.Menu.Format < 5 then      TotalRows = ((j-1)/Cue.Menu.Columns)+1;    /* total possible number of rows */   else      TotalRows = j;   if      Screen.Event.Info = S#SBArrowForward then      TopCue = Scroll.Cue.Directory(1,1);   else if Screen.Event.Info = S#SBPageForward then      TopCue = Scroll.Cue.Directory(Cue.Menu.Rows-1,1);   else if Screen.Event.Info = S#SBArrowBack then      TopCue = Scroll.Cue.Directory(1,-1);   else if Screen.Event.Info = S#SBPageBack then      TopCue = Scroll.Cue.Directory(Cue.Menu.Rows-1,-1);   /* Scroll bar mapping: Box should be at bottom when last cue is in top row */   if Cue.Menu.Format < 5 then do;      TopLine   = TopCue/Cue.Menu.Columns; /* determine which row is at top */   end;   else do;                                /* time format: 1 cue per line */      TopLine   = TopCue+1;   end;   load  TopLine;    mul   1000;         mwait;    div   TotalRows;         mwait; 	i = res;		if (rem != 0)									// round up so screen draws correctly on re-open		i = i + 1;		   disable.deposits = true;   call Deposit.Scroll.Bar(Cue.Menu.Scroll.Bar, i);   disable.deposits = false;   call PID(Saved.CM.Scroll.Bar, i);  /* store new setting */end HANDLE.CUE.MENU.SCROLL.BAR;COMPUTE.DTD.CUE.LENGTH: proc (cue.id,cue.len) fixed swapable;   dcl cue.id  fixed;   dcl cue.len array;   cue.len(0)=0; cue.len(1)=0;   if Fetch.DTD.Cue(cue.id,misc.buf)<>0 then do; /* read in cue info from DTD */      call Copy32(loc(addr(misc.buf(cue.len.msb))),cue.len);   end;   return DTD.Cue#;end COMPUTE.DTD.CUE.LENGTH;/* Compute length of cue or event: */COMPUTE.CUE.OR.EVENT.LENGTH: proc (BasicEvent, cue.len) swapable;   dcl BasicEvent   array;    /* actually an Event record */   dcl cue.len      array;    /* holds length             */   if BasicEvent(Event.type) = Event.type.cue   then return COMPUTE.DTD.CUE.LENGTH(BasicEvent(Event.cue.id), cue.len);   /* else handle BasicEvents */   call DTD.Sample.#.To.Msecs (loc(addr(BasicEvent(event.duration.msb))),                               CF#Dur,                               S$Speed,                               AEE.Current.Project.Rate, Zero.Zero,                                cue.len);   return 1;   /* assume length is correct even if cue is missing */end COMPUTE.CUE.OR.EVENT.LENGTH;COMPUTE.CUE.TRACK.END.TIME: proc(trk,end.time) swapable;   dcl trk                            fixed; /* abs trk # of a cue track    */   dcl end.time                       array; /* output time at end of track */   dcl BasicEvent(event.caption-1)    fixed;   dcl (msb,lsb)                      fixed;   dcl cue.len                    (1) fixed;   dcl cue.id                         fixed;   if  (Load.Seq.Globals(trk)              <> 0)   and (Trk.Head.Lookup(trk,THD.CUE.TRACK) <> 0)    then do;                       /* this is a cue track */      do while #anyf<>0;          /* zip out to end of track */         call Advance.To.Next.Note;      end;      BACKUP.MORE:      if #anyr<>0 then do;         call Backup.To.Prior.Real.Note; /* step back to last cue trigger note */         do while (#anyr<>0)         and      (isa.ilp.note|isa.rte.note|isa.rest.note);            call Backup.To.Prior.Real.Note; /* step back to last cue trigger note */         end;         if (isa.ilp.note|isa.rte.note|isa.rest.note) /* we hit start of track w/o finding valid cue */         then do;             BasicEvent(event.cue.id)=0;  /* no cue found */            msb=0; lsb=zero.time;         end;         else do;                   /* found a real cue trigger */            call Look.Up.Note.Info; /* load note into #w1-#w4 */            call Map.Sequence.Time.To.Real.Time(loc(addr(#NMSB)),                                                loc(addr(  msb)));            call Expand.Event.Note(BasicEvent, 0);            call COMPUTE.CUE.OR.EVENT.LENGTH(BasicEvent, cue.len);            call ADD32(cue.len,loc(addr(msb)),loc(addr(msb))); /* add len to start to get end time */         end;                       /* have found a cue trigger record */      end;                          /* have some note records behind us */   end;                             /* track is a cue track */   if (msb=0) and (lsb ilt zero.time) then lsb=zero.time;   end.time(0)=msb; end.time(1)=lsb;   return BasicEvent(event.cue.id); /* return id of last cue on track or 0 if none */end COMPUTE.CUE.TRACK.END.TIME;SEND.DTD.CUE.TO.POLY: proc (cue.id) swapable;   dcl (cue.id,go) fixed;   go=1;   if Cue.Menu.Group<>0 then do;      if not GET.CUE.MENU.DIALOG (3,cue.id) then go=0;   end;   if go=1 then do;      call REMOVE.ERR;           /* remove prior msg */      call DISPLAY.NOTICE (NT#TransferringCueToPoly,ATTR#Reverse,NulStr,0,0,0);      call TRANSFER.CUE.TO.POLY(cue.id);      if ertyp=0 then call DISPLAY.NOTICE (NT#TransferComplete,ATTR#Normal,NulStr,0,0,0);      else            call DISPLAY.NOTICE (NT#EraseNotice,ATTR#Normal,NulStr,0,0,0);   end;end SEND.DTD.CUE.TO.POLY;PLACE.CUE.AT.PLAY.TIME: proc (cue.id,play.flag) swapable;   dcl (cue.id,k) fixed;   dcl play.flag  fixed; /* set to 1 to play cue in real-time */   dcl tmp    (1) fixed;   if  ((SMPTE.ONOFF <> 0 )      /* if using smpte             */   or   (PLAY        <> 0 ))     /* or actually playing        */   and ( RECD        =  0 )      /* and double check not       */   and ( MOVE        =  0 )      /* recording or ff/rew        */   then do;      call TAKE.SYSTEM.REAL.TIME(tmp);     /* get sequencer or smpte time */      if (tmp(0) < 0)      or (com16(zero.time,tmp) = lw#igt)      then call STR32(0, zero.time, tmp);      if Time.Base.Mode <> 0                   /* if sequencer is playing */      then do;                                 /* then place cue in stack */         k = Real.Milliseconds - M$PT(1);      /* current real time - press time of middle mouse button */         load k; mul samp.speed; mwait;        /* adjust latency since button press for sequencer speed */         div 1000;          k = res+(rem ige 500);         if SMPTE.ONOFF <> 0 then do;                 /* but back up only */            load k; mul smpte.track.rate; mwait;      /* to correct frame */            div smpte.mode.rate;                      /* if doing slow    */            k = res+(rem ige shr(smpte.mode.rate,1)); /* smpte tracking   */         end;         if  (com16(k,tmp) <= lw#ieq)  /* compute actual time of mouse */         then call SUB16(k,tmp);       /* press                        */         if play.flag<>0         then call Manually.Trigger.Event.Or.Cue                (cue.id,  tmp, 1,                 rte.max, 0, 0, 0,                 0, loc(0));         call ADD.CUE.TO.PLACE.LIST(cue.id,GID(Cue.Place.Track),tmp);      end;      else do;                         /* must be smpte sill-framing */         if play.flag <> 0             /* trigger cue to hear it     */         then do;            if   Cue.Menu.Playback.Mode = 1   /* mono cue playback */            then call Stop.DTD.Playback;      /* turn off any currently playing cue */            call Trigger.DTD.Cue(cue.id,0,0); /* start playing new cue */         end;         /* and actually place in sequence */         k = PLACE.CUE.IN.SEQUENCE(cue.id, GID(Cue.Place.Track), tmp, 0);         if k < 0 then call Display.Place.Error(k,GID(Cue.Place.Track)-1);      end;   end;   /* if not smpte, and not playing,  tell user he can't do that.  But */   /* play cue anyways                                                 */   else do;      call Display.Notice(NT#RealTimePlaceRequiresPlay,ATTR#Normal,NulStr,0,0,0);      if play.flag <> 0      then do;         if   Cue.Menu.Playback.Mode = 1   /* mono cue playback */         then call Stop.DTD.Playback;      /* turn off any currently playing cue */         call Trigger.DTD.Cue(cue.id,0,0); /* start playing new cue */      end;   end;end PLACE.CUE.AT.PLAY.TIME;PLACE.CUE.AT.SYNC.TIME: proc (cue.id) swapable;   dcl (cue.id,j) fixed;   dcl tmp    (1) fixed;   dcl mode       fixed;   dcl cuebits    fixed;   dcl stemp  (4) fixed;   if Fetch.DTD.Cue(cue.id,misc.buf) <> 0 then do;      tmp(0)     = misc.buf(CUE.SMPT.MSB);      tmp(1)     = misc.buf(CUE.SMPT.LSB);      mode       = misc.buf(CUE.SMPT.MODE);      cuebits    = misc.buf(CUE.BITS);      if (cuebits & bit3) = 0      /* cue.smpt.msb is relative to smpte offset */      then call SBITS.TO.MSEC(tmp ,cf#time, SAMP.SPEED, mode, tmp);      else do;         call SBITS.TO.SMPTE(tmp, mode, stemp);         call SMPTE.TO.MSEC(stemp, cf#time, SAMP.SPEED, SM.MODE, loc(addr(SM.HRS)), tmp);         if tmp(0) < 0           /* but might be before start of sequence */         then call STR32(0, zero.time, tmp);      end;      j = PLACE.CUE.IN.SEQUENCE(cue.id,GID(Cue.Place.Track),tmp,0);      return j;   end;   return 0;end PLACE.CUE.AT.SYNC.TIME;CHAIN.CUE.ONTO.TRACK: proc (cue.id) swapable;   dcl cue.id       fixed;   dcl cue.len  (1) fixed;   dcl End.Time (1) fixed;   dcl i            fixed;   if not Track.Available.For.Cues(GID(Cue.Place.Track)) then do;      call DISPLAY.NOTICE (NT#BadPlaceTrack,ATTR#Normal,NulStr,0,0,0);      return 0;   end;   call Compute.Cue.Track.End.Time(GID(Cue.Place.Track),End.Time);   i = Place.Cue.In.Sequence(cue.id,GID(Cue.Place.Track),end.time,0);   return i;end CHAIN.CUE.ONTO.TRACK;PLACE.CUE.BY.DRAGGING: proc (cue.id) swapable;   dcl cue.id    fixed;   dcl drag.type fixed;   dcl tmp   (3) fixed;   /* NOTE: routine handles D#Place, D#Replace, and D#RepSync modes ONLY */   if GID(Cue.Drag.Mode)=D#Place   then drag.type=0;   else drag.type=1;   if Drag.Cue.Or.Note(2,tmp,drag.type) <> 0 then do;      if GID(Cue.Drag.Mode)<>D#Place then do; /* Drag Replace or Rep/Sync function */         if Get.Snapshot.Info(AEE.Cur.Seq.Snap,tmp(1),TRKINDEX,tmp(0))         then do;            call Remove.Note.Record;        /* delete existing note */            call Garbage.Collect.Event.List(trkindex(tmp(1)));  /* get rid of earlier event information */         end;      end;      call Set.Place.Track(TRKINDEX(tmp(1))); /* set place track to drag dest trk */      if GID(Cue.Drag.Mode)=D#RepSync      then call Place.Cue.At.Sync.Time(cue.id);      else call Place.Cue.In.Sequence (cue.id,TRKINDEX(tmp(1)),loc(addr(tmp(2))),1);   end;end PLACE.CUE.BY.DRAGGING;INSERT.CUE.BY.DRAGGING: proc (cue.id) swapable;   dcl cue.id        fixed;   dcl tmp(3)        fixed;   dcl BasicEvent(event.caption) fixed;   dcl cue.len   (1) fixed;   dcl (msb,lsb)     fixed;   /* NOTE: routine handles D#Insert and D#RepInsert modes ONLY */   if Drag.Cue.Or.Note(2,tmp,1) <> 0 then do; /* always treat drag as a replace type drag */      if Get.Snapshot.Info(AEE.Cur.Seq.Snap,tmp(1),TRKINDEX,tmp(0))      then do; /* set up # vars with correct info */         call Set.Place.Track(#trk);         /* set place track to drag dest trk */         msb=#nmsb; lsb=#nlsb;               /* save note time */         if GID(Cue.Drag.Mode)=D#RepInsert then do;  /* doing a replace function */            call Expand.Event.Note(BasicEvent, 0); /* extract cue id for note to replace */            if COMPUTE.CUE.OR.EVENT.LENGTH(BasicEvent, cue.len) <> 0            then do;  /* cue exists on DTD system */               call Delete.Time.From.Trk(#trk,msb,lsb,cue.len(0),cue.len(1));            end;            else do; /* cue does not exist, just delete cue trigger record */               call Remove.Note.Record;            end;         end;         if Compute.DTD.Cue.Length(cue.id,cue.len)<>0 then do;            call Insert.Time.On.Trk(#trk,msb,lsb,cue.len(0),cue.len(1));            call Place.Cue.In.Sequence(cue.id,TRKINDEX(tmp(1)),loc(addr(tmp(2))),1);         end;         call Garbage.Collect.Event.List(trkindex(tmp(1)));  /* get rid of earlier event information */      end;   end;end INSERT.CUE.BY.DRAGGING;DRAG.CUE.TO.SEQUENCER: proc (cue.id,drag.mode) public swapable;   dcl cue.id    fixed;   dcl drag.mode fixed; /* D#Place,D#Replace,D#RepSync,D#Insert,D#RepInsert */   if (drag.mode=D#Place)   or (drag.mode=D#Replace)   or (drag.mode=D#RepSync)   then call Place.Cue.By.Dragging (cue.id); /* normal place operation */   else call Insert.Cue.By.Dragging(cue.id); /* chain/ripple operation */end DRAG.CUE.TO.SEQUENCER;DO.CUE.PLACE.TRACK.JOG: proc (button) swapable;   dcl button fixed;   dcl pmode  fixed;   if abs(button)<>2 then do;   /* left or right button pressed (INC/DEC PLACE TRACK) */      pmode=GID(Cue.Place.Mode);      if (pmode=P#Real)         /* placing in real-time */      or (pmode=P#Sync)         /* placing by sync time */      or (pmode=P#Chain)        /* placing by chaining */      then do;         if abs(button)=1         then call Increment.Place.Track;         else call Decrement.Place.Track;      end;      return true;   end;   return false;end DO.CUE.PLACE.TRACK.JOG;GET.CUE.MENU.EVENT: proc (event) returns (fixed) public swapable;   dcl event			fixed;   dcl cue.id			fixed;   dcl funmode			fixed;   dcl which.button	fixed static;   dcl button			fixed;   dcl i					fixed;   do while 1;      if event <> Get.Null.Event then do;         if Screen.Event.Group <> Cue.Menu.Group then return event;         if event = Get.Screen.Event then do;            if Screen.Event.Id = Cue.Menu.Format.Switch then do;               if Screen.Event.Info = S#Deposit then do;                  i = Fetch.Switch(Cue.Menu.Format.Switch);                  if Cue.Menu.Format < 5 then Cue.Menu.Format = i+1;  /* Alpha sort */                  else                        Cue.Menu.Format = i+5;  /* Time sort */                  call PID(Saved.CM.Format, (Cue.Menu.Format - Default.CM.Format));  /* store new setting */                  call Reformat.Cue.Menu.Panel(Cue.Menu.Format);                  call Update.Cue.Menu.Table(0,Cue.Menu.Position);               end;            end;            else if Screen.Event.Id = Cue.Menu.Sort.Switch then do;               if Screen.Event.Info = S#Deposit then do;                  call Set.Cue.Menu.Format.Switch.Str;                  call Reformat.Cue.Menu.Panel(Cue.Menu.Format);                  call Update.Cue.Menu.Table(0,Cue.Menu.Position);               end;            end;            else if Screen.Event.Id = Cue.Menu.Function.Switch then do;               if Screen.Event.Info = S#Deposit then do;                  call PID(Saved.CM.Function.Switch, Fetch.Switch(Screen.Event.Id));  /* store new setting */               end;            end;            else if Screen.Event.Id = Cue.Menu.Display.Switch then do;               if Screen.Event.Info = S#Deposit then do;                  call Update.Cue.Menu.Table(0,-1);  /* Refresh using new sort */                  call PID(Saved.CM.Display.Switch, (Fetch.Switch(Screen.Event.Id)-Default.CM.Display.Switch));  /* store new setting */               end;            end;            else if Screen.Event.Id = Cue.Menu.Playback.Switch then do;               if Screen.Event.Info = S#Deposit then do;                  Cue.Menu.Playback.Mode = Fetch.Switch(Cue.Menu.Playback.Switch);                  call PID(Saved.CM.Playback.Switch, Cue.Menu.Playback.Mode);  /* store new setting */               end;            end;            else if (Screen.Event.Id = Cue.Menu.Scroll.Bar) then do;               if Screen.Event.Info = S#Deposit then do;                  i = Fetch.Scroll.Bar(Cue.Menu.Scroll.Bar);                  call Update.Cue.Menu.Table(1, i);                  call PID(Saved.CM.Scroll.Bar, i);  /* store new setting */               end;               else if Screen.Event.Info = S#SBArrowForward                or      Screen.Event.Info = S#SBArrowBack               or      Screen.Event.Info = S#SBPageForward               or      Screen.Event.Info = S#SBPageBack               then call Handle.Cue.Menu.Scroll.Bar;            end;            else if Screen.Event.Id = GID(Cue.Menu.Delete.Button) then do;               if Screen.Event.Info = S#MouseSelect               then call Delete.All.Displayed.Cues;            end;            else if Screen.Event.Id = GID(Cue.Menu.Place.Track.Field) then do;               if (Screen.Event.Info = S#MouseSelect)               or (Screen.Event.Info = S#MouseActivate) then do;                  call Do.Cue.Place.Track.Jog(Mouse(Button.Result));               end;               else if Screen.Event.Info = S#Deposit then do;                  call Set.Place.Track(Fetch.Fixed.Point(GID(Cue.Menu.Place.Track.Field))+1);               end;            end;            else if Screen.Event.Id = GID(Cue.Menu.Drag.Mode.Switch) then do;               if Screen.Event.Info = S#Deposit then do;                  call PID(Cue.Drag.Mode,Fetch.Switch(GID(Cue.Menu.Drag.Mode.Switch)));               end;            end;            else if Screen.Event.Id = GID(Cue.Menu.Drag.Button) then do;               if Screen.Event.Info = S#MouseSelect then do;                  call Set.Cue.Menu.Place.Mode(P#Drag);               end;            end;            else if Screen.Event.Id = GID(Cue.Menu.Sync.Button) then do;               if Screen.Event.Info = S#MouseSelect then do;                  call Set.Cue.Menu.Place.Mode(P#Sync);               end;            end;            else if Screen.Event.Id = GID(Cue.Menu.Chain.Button) then do;               if Screen.Event.Info = S#MouseSelect then do;                  call Set.Cue.Menu.Place.Mode(P#Chain);               end;            end;            else if Screen.Event.Id = GID(Cue.Menu.Real.Button) then do;               if Screen.Event.Info = S#MouseSelect then do;                  call Set.Cue.Menu.Place.Mode(P#Real);               end;            end;            else if Screen.Event.Id = Cue.Menu.Name.Table.Id then do;               if (Screen.Event.Info = S#MouseSelect)               or (Screen.Event.Info = S#MouseActivate) then do;                  button=Mouse(Button.Result); /* save last mouse button activity info */                                    if abs(button)<>2 then do;                     call Do.Cue.Place.Track.Jog(button); /* handle left & right button presses */                  end;                  else do;                   /* middle mouse button activity */                     funmode = GID(Saved.CM.Function.Switch); /* get PLAY/RECALL mode info */                     cue.id = Compute.Cue.Menu.Cell.Id(Screen.Event.Table.Col,Screen.Event.Table.Row,Cue.Menu.Format);                     if cue.id <> 0 then do; /* have actually clicked on a cue label */                        if  (GID(Cue.Place.Mode)<> P#Real) /* not placing in real-time */                        and (funmode            <  2     ) /* and we want to play cue */                        then do;                           if Cue.Menu.Playback.Mode = 1  /* mono cue playback */                           then call Stop.DTD.Playback;   /* turn off any currently playing cue */                           call Trigger.DTD.Cue(cue.id,0,0); /* start playing new cue */                           if  (funmode       <> 1)  /* if we want to recall cue */                           and (Shuttle.Group <> 0)  /* and shuttle is there     */                           and (DTD.Play.State = 5)  /* and trigger.dtd.cue was successful */                           then DTD.Play.State = 2;  /* then pretend we triggered it from the cue editor */                        end;                        if GID(Cue.Place.Mode)=P#Sync then do;                           i = Place.Cue.At.Sync.Time(cue.id);                           if i < 0 then call Display.Place.Error(i,GID(Cue.Place.Track)-1);                        end;                        else if GID(Cue.Place.Mode)=P#Chain then do;                           i = Chain.Cue.Onto.Track(cue.id);                           if i < 0 then call Display.Place.Error(i,GID(Cue.Place.Track)-1);                        end;                        else if GID(Cue.Place.Mode)=P#Real then do;                           call Place.Cue.At.Play.Time(cue.id,(funmode=0 or funmode=1)); /* real-time place */                        end;                        else if GID(Cue.Place.Mode)=P#Drag then do;                           if funmode=3 /* don't drag, instead do poly xfr */                           then call Send.DTD.Cue.To.Poly (cue.id);                           else call Drag.Cue.To.Sequencer(cue.id,GID(Cue.Drag.Mode));                        end;                        if  ((GID(Cue.Place.Mode)<>P#Real)  /* not placing in real-time */                        or   (PLAY               = 0     ))                        and (funmode             <>1      ) /* and want to recall cue */                        then call Recall.Current.Cue.By.Id(cue.id,0,zero.zero);                        if  (GID(Cue.Place.Mode)<>P#Drag) /* not placing in real-time */                        and (funmode            < 2)      /* and we want to play cue */                        then do;                           call Set.Group.Get(Cue.Menu.Group,Get.Mouse.Button,true);                        end;                     end;                     else if DTD.Play.State=5                     OR      DTD.Play.State=2                     then call Stop.DTD.PlayBack; /* turn off any currently playing cue */                  end; /* process RECALL AND/OR PLACE command */               end;    /* S#MouseSelect event on Cue.Menu.Name.Table.Id */            end;            else if 0&(Screen.Event.Id = Cue.Menu.Move.Box) then do;               if Screen.Event.Info = S#MouseSelect then do;                  which.button = Mouse(button.result);                  if (which.button < 0) then do;   /* button down, start to track mouse */                     call Set.Group.Get(Cue.Menu.Group, Get.Mouse.Button, true);                  end;               end;            end;            else if 0&(Screen.Event.Id = Cue.Menu.Size.Box) then do;               if Screen.Event.Info = S#MouseSelect then do;               end;            end;         end;          /* handle screen event   */         else if event=Get.Mouse.Button then do; /* probably a button release */            call Set.Group.Get(Cue.Menu.Group,Get.Mouse.Button,false);            if  ((Mouse(Release.Time)-Mouse(Press.Time)) IGE 200)            AND ( (DTD.Play.State = 5)            OR    (DTD.Play.State = 2) )            then call Stop.DTD.Playback; /* turn off currently playing cue */            if 0 then do; /* disable move panel logic for now */               if  (Mouse(button.result) > 0)                /* release... */               and (Mouse(button.result) = (-which.button))  /* same button */               then do;                  call Set.Group.Get(Cue.Menu.Group, Get.Mouse.Button, false);                                    i = Tpos.y(Mouse(release.y));      /* find out new row */                  /*                  call Close.Cue.Menu.Panel;                  call Open.Cue.Menu.Panel();                  */               end;            end;         end;          /* of Mouse Button event */      end;             /* have a non-null event */      event = Get.Next.Screen.Event;   end;end GET.CUE.MENU.EVENT;