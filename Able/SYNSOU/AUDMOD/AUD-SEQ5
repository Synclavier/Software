/* AUD-SEQ5 - Process events for Seq panel dialog lines: *//* procedure to stuff track numbers into bounce dialog box */REFRESH.COPY.BOUNCE.BUTTON: proc swapable;   dcl (replicate,id) fixed;   replicate=GID(SEQ#Bounce   );   id       =GID(SEQ#Duplicate);   if replicate then do;  /* highlight the button */      call Set.Object.Attr(id,0,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);      call Set.Object.Attr(id,1,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);   end;   else do;               /* unhighlight the button */      call Set.Object.Attr(id,0,ATTR#Normal|ATTR#AltIntensity);      call Set.Object.Attr(id,1,ATTR#Normal|ATTR#AltIntensity);   end;   call Update.Object(id);end REFRESH.COPY.BOUNCE.BUTTON;STUFF.BOUNCE.TRACK: proc (trk) swapable;   dcl trk               fixed; /* pass abs track # */   dcl (I,J)             fixed;   dcl (From.Trk,To.Trk) fixed;   if trk>=Num.Kbd.Tracks then do;  /* clicked on an assigned track */      From.Trk=Fetch.Fixed.Point(GID(SEQ#FromTrack))+1;      To.Trk  =Fetch.Fixed.Point(GID(SEQ#ToTrack)  )+1;            I=GID(SEQ#Toggle);      if ((I&1)<>0)                 /* expecting click on TO TRACK */      and (trk=From.Trk)  /* clicked on same trk again   */      and (GID(SEQ#Bounce)=0)       /* but not already enabled for REPLICATE bounce */      then do;                      /* assume trying to do REPLICATE bounce */         call PID(SEQ#Bounce,1);    /* set bit for REPLICATE Bounce */         call Refresh.Copy.Bounce.Button;      end;      else do;         call PID(SEQ#Toggle,I xor 1); /* toggle the bit */         Disable.Deposits=true;            if (I&1)=0 then do;               call Deposit.Fixed.Point(GID(SEQ#FromTrack),trk-1);               call Select.New.Cur.Obj (GID(SEQ#ToTrack),-1,-1);               call Update.Object(GID(SEQ#FromTrack));            end;            else do;               call Deposit.Fixed.Point(GID(SEQ#ToTrack)  ,trk-1);               call Select.New.Cur.Obj (GID(SEQ#FromTrack),-1,-1);               call Update.Object(GID(SEQ#ToTrack));            end;         Disable.Deposits=false;      end;   end;end STUFF.BOUNCE.TRACK;PROCESS.SEQ.TRACK.ERASE.DIALOG.EVENT: proc swapable;   /* cancel:   handled elsewhere */   /* erase :   handled elsewhere */end PROCESS.SEQ.TRACK.ERASE.DIALOG.EVENT;PROCESS.SEQ.TRACK.CLEAR.SOLOS.DIALOG.EVENT: proc swapable;   /* nothing except cancel, handled elsewhere */end PROCESS.SEQ.TRACK.CLEAR.SOLOS.DIALOG.EVENT;PROCESS.SEQ.TRACK.BOUNCE.DIALOG.EVENT: proc swapable;   dcl (From.Trk,To.Trk) fixed;   dcl (row,col)         fixed;   VERIFY.VALID.TRACK:  proc (trk.id);      dcl (trk.id,trk#) fixed;      Trk#=Fetch.Fixed.Point(trk.id);      Disable.Deposits=true;         if Trk#<  1 then call Deposit.Fixed.Point(trk.id,  1);         if Trk#>200 then call Deposit.Fixed.Point(trk.id,200);         call Update.Object(trk.id);      Disable.Deposits=false;   end VERIFY.VALID.TRACK;   if Screen.Event.Id = GID(SEQ#Duplicate) then do;      if (Screen.Event.Info=S#MouseSelect)      or (Screen.Event.Info=S#MouseActivate)      or (Screen.Event.Info=S#KeyActivate)      then do;         write(md)=GID(SEQ#Bounce) xor 1;         call Refresh.Copy.Bounce.Button;      end;   end;   else if Screen.Event.Id = GID(SEQ#FromTrack) then do;      if Screen.Event.Info=S#Deposit then do;         call Verify.Valid.Track(GID(SEQ#FromTrack));      end;   end;   else if Screen.Event.Id = GID(SEQ#ToTrack) then do;      if Screen.Event.Info=S#Deposit then do;         call Verify.Valid.Track(GID(SEQ#ToTrack));      end;   end;end PROCESS.SEQ.TRACK.BOUNCE.DIALOG.EVENT;PROCESS.RIPPLE.VERIFY.DIALOG.EVENT: proc swapable;   /* nothing except cancel, handled elsewhere */end PROCESS.RIPPLE.VERIFY.DIALOG.EVENT;PROCESS.SEQ.EVENT.DELETE.DIALOG.EVENT: proc swapable;   /* nothing except cancel, handled elsewhere */end PROCESS.SEQ.EVENT.DELETE.DIALOG.EVENT;PROCESS.SEQ.EVENT.MOVE.DIALOG.EVENT: proc swapable;   /* nothing except cancel, handled elsewhere */end PROCESS.SEQ.EVENT.MOVE.DIALOG.EVENT;HANDLE.SEQ.DIALOG.EVENT: proc swapable;   if Screen.Event.Id = GID(SEQ#Cancel) then do;      if (Screen.Event.Info=S#MouseSelect)      or (Screen.Event.Info=S#MouseActivate)      or (Screen.Event.Info=S#KeyActivate)      then do;         call Close.Seq.Dialog        ();		 CLEAR.ERAS.BUTTON            ();         call Display.Sequencer.Status(); /* display if keyboard there */      end;   end;   else if Seq.Dialog.Mode=SEQ#TrackEraseDialog   then call Process.Seq.Track.Erase.Dialog.Event;   else if Seq.Dialog.Mode=SEQ#TrackBounceDialog   then call Process.Seq.Track.Bounce.Dialog.Event;   else if Seq.Dialog.Mode=SEQ#TrackClearSolosDialog   then call Process.Seq.Track.Clear.Solos.Dialog.Event;   else if Seq.Dialog.Mode=SEQ#EventDeleteDialog   then call Process.Seq.Event.Delete.Dialog.Event;   else if Seq.Dialog.Mode=SEQ#EventMoveDialog   then call Process.Seq.Event.Move.Dialog.Event;   else if Seq.Dialog.Mode=SEQ#RippleVerifyDialog   then call Process.Ripple.Verify.Dialog.Event;end HANDLE.SEQ.DIALOG.EVENT;/* $page - hardcopy output from sequence panel *//* routine to wait for complete screen update before proceeding: */wait.for.complete.refresh: proc swapable;   dcl i fixed;   call Update.Sequencer.Note.Information(2); /* erase complete display */   /* provide spaces in image array to start off with: */   do i=shr(Seq.Event.Display.Row*80,1) to shr((Seq.Event.Display.Row+Seq.Event.Display.Size)*80,1)-1;      write(mam)=img.ptr+shr(i,8);   /* point to the screen image in external memory */      write(mal)=i;      write(md )=(sp \ shl(sp,8));   end;   do i = 0 to 15;      Note.Area.Force(i) = (-1);   end;   call Update.Sequencer.Note.Information(1); /* draw info */end wait.for.complete.refresh;print.headings: proc swapable;   dcl (vmargin)   lit '5';   dcl (tmp)  (40) fixed;   dcl i           fixed;   dcl j           fixed;   dcl k           fixed;   send.cr:proc;      dcl tmp(1) fixed;      tmp(0) = 2;      tmp(1) = cret \ shl(lf,8);      call Send_String(tmp);   end;   Send_Tab:proc (buf, num);      dcl buf array;      dcl num fixed;      dcl i   fixed;      do i = 0 to num-1;         call pbyte(buf, i, sp);      end;      buf(0) = num;      call Send_String(buf);   end;   if D40_PRESENT=0   then return;                      /* if device not available */   call enable_d40;                  /* turn on D40 interrupts */   do i = 0 to vmargin-1;      call send.cr;   end;   call Send_String('New England Digital Synclavier/Direct-to-Disk Event Listing'); call send.cr;   call send.cr;   call send.cr;   call Send_String('Tracks:         ');   do i = 0 to Seq.Tracks-1;      if TRKINDEX(i) > 0 then do;           /* already assigned a track */         call CONV.FIXED.TO.STR(TRKINDEX(i)-1,0,3,cf#left,tmp);         J = TRK.HEAD.LOOKUP(trkindex(i), THD.TRACK.TITLE);         if j <> 0 then do;               /* get track name  */            if j IGT 32 then j = 32;            call COPY.IN(addr(misc.buf(0)), shr(j+3,1));         end;         else do;                         /* get timbre name */            call LOOKUP.TRACK.TIMBRE.NAME(TRKINDEX(i),misc.buf);         end;         call Append.To.Str(tmp, ' "');         call Append.To.Str(tmp, misc.buf);         call Append.To.Str(tmp, '"');         if tmp(0) > (spacing-1) then tmp(0) = (spacing-1);      end;      else do;                              /* no track assigned */         call COPY.STRING('', tmp);      end;      call Send_String(tmp);      call Send_Tab(tmp, spacing-tmp(0));   end;   call send.cr;   call send.cr;   call Send_String('Event Time      ');   do i = 0 to Seq.Tracks-1;      do j = 0 to Caption.Ix;         if current.locations(j) >= 0         then do case(j);            call Send_String('    ');    /* pitch name heading */            call Send_String('   ');     /* key number heading */            do;                          /* event name heading */               call copy.string('Event Name', tmp);               if   tmp(0) > (Current.Locations(Oursize.Ix)-1)               then tmp(0) = (Current.Locations(Oursize.Ix)-1);               call Send_String(tmp);               call Send_Tab(tmp, current.locations(oursize.ix)-tmp(0));            end;            call Send_String('Duration ');            ;                    /* lock - nothing */            do;                  /* end/off time   */               if Show.Offsets <> 0               then call Send_String('  Offset Time ');               else call Send_String('  End Time    ');            end;            call Send_String('Vel   ');            do;                  /* caption         */               call Send_Tab(tmp, defined - current.locations(caption.ix));            end;         end;      end;      if  (current.locations(lock.ix) >= 0)      and (current.locations(end.time.ix) < 0)      then call Send_String(' ');      call Send_Tab(tmp, spacing-defined);   end;   call send.cr;   do i = 0 to 7;      call Send_String('----------');   end;   call send.cr;   call d40_wait;   call disable_d40;                 /* turn off D40 interrupts */end print.headings;print.sequence.panel: proc swapable;   dcl i        fixed;   dcl buf(50)  fixed;   if D40_PRESENT=0   then return;                      /* if device not available */   call enable_d40;                  /* turn on D40 interrupts */   do i=Seq.Event.Display.Row*80 to (Seq.Event.Display.Row+Seq.Event.Display.Size)*80-1 by 80; /* scan by bytes */      write(mam)=img.ptr+shr(i,9);   /* point to the screen image in external memory */      write(mal)=shr(i,1);      call COPY.IN(addr(buf(1)), 40);      buf(0) = 82;      call pbyte(buf, 80, cret);      call pbyte(buf, 81, lf  );      call Send_String(buf);   end;   call d40_wait;   call disable_d40;                 /* turn off D40 interrupts */end print.sequence.panel;print.end.of.page:proc swapable;   dcl tmp(2) fixed;   tmp(0) = 1;   tmp(1) = "14";                 /* form feed */   call Send_String(tmp);end print.end.of.page;