/* AUD-REC2  $TITLE Record Panel Updating Routines  *//* Modified:   01/05/92 - cj  - Added "bounce/move" capability to record panel   12/06/91 - PF  - Log cue as deleted on retake for Quick Updates   06/21/91 - cj  - erased current cue after retake   07/03/89 - SGS - fixed bug in Process.Cue.Retake.Dialog   05/15/89 - SGS - added Optical.Group to Process.Cue.Retake.Dialog   04/14/89 - SJS - changed speech to 'ONE' and music to 'TWO'   12/13/88 - cj  - removed QUICK setting;  changed SMART to SPEECH   10/20/88 - cj  - fixed bug with retake of .audit. cues   10/07/88 - SJS - added PROCESS.TSM.OPTIONS.DIALOG   09/07/88 - MWH - Add "real" DSP user interface   08/02/88 - SGS - Update.Record.Panel now updates switches*/UPDATE.RECORD.TIMES: proc (id) swapable;   dcl id            fixed;   dcl temptime (1)  fixed;   dcl ttime    (1)  fixed;   if (id = Record.Trig.Start.Time)   or (id = Record.Trig.Stop.Time )   then do;      if  (Record.Trigger = RT.MANUAL)       /* manual      */      or  (Record.Trigger = RT.POLY.XFER)    /* poly xfer   */      or  (Record.Trigger = RT.TSM)          /* dsp op      */      or  (Record.Trigger = RT.BOUNCE)       /* bounce      */      or  (Record.Trigger = RT.MOVE  )       /* move        */      then return;              /* erroneous input into trigger fields */   end;   if (id = Record.Disk.Stop.Time)         /* if entering disk stop     */   then call Set.Record.Dependent.Time(1); /* make trig stop dependeant */   if (id = Record.Trig.Stop.Time )        /* if entering trig stop     */   then call Set.Record.Dependent.Time(0); /* make disk stop dependent  */   Disable.Deposits = true;   /* correct begin/end times if out of order */   do case (id-Record.Disk.Start.Time);      do;         call Fetch.32bit.Msec(id,Record.Disk.Start);         if COM32(Record.Disk.Start,Record.Disk.Stop) = lw#igt         then do;            call COPY32(Record.Disk.Start,Record.Disk.Stop);            call Deposit.32Bit.Msec(Record.Disk.Stop.Time,Record.Disk.Stop,Zero.Zero);         end;      end;      do;         call Fetch.32bit.Msec(id,Record.Disk.Stop);         if COM32(Record.Disk.Start,Record.Disk.Stop) = lw#igt         then do;            call COPY32(Record.Disk.Stop,Record.Disk.Start);            call Deposit.32Bit.Msec(Record.Disk.Start.Time,Record.Disk.Start,Zero.Zero);         end;      end;      do;         call Fetch.32bit.Msec(id,Record.Trig.Start);         if COM32(Record.Trig.Start,Record.Trig.Stop) = lw#igt         then do;            call COPY32(Record.Trig.Start,Record.Trig.Stop);            call Deposit.32Bit.Msec(Record.Trig.Stop.Time,Record.Trig.Stop,Zero.Zero);         end;      end;      do;         call Fetch.32bit.Msec(id,Record.Trig.Stop);         if COM32(Record.Trig.Start,Record.Trig.Stop) = lw#igt         then do;            call COPY32(Record.Trig.Stop,Record.Trig.Start);            call Deposit.32Bit.Msec(Record.Trig.Start.Time,Record.Trig.Start,Zero.Zero);         end;      end;   end;   if  ((Record.Trigger = RT.SEQUENCER))    /* if sequencer triggering */   and ((Record.Dependent.Time.Mode =0)     /* and disk stop is dependent */   or   (Record.Mode = RM.PUNCH.IN    ))    /* or punch in              */   then do;                                 /* then check dependent time */      /* compute duration of trigger capture (end-start): */      call SUB32(Record.Trig.Stop,Record.Trig.Start,temptime);      /* if in cue lock recording,  but trig times have priority,  */      /* then limit trig times to length of cue to avoid writing   */      /* to non-cue area of disk                                   */      if  (Record.Mode = RM.CUE.LOCK)      then do;         call SUB32(Cue.Out.Time,Cue.In.Time,ttime);         if COM32(ttime,temptime) = lw#ilt   /* if length of cue is <  */         then do;                            /* length of trig section */            call ADD32(Record.Trig.Start,ttime,Record.Trig.Stop);            call Deposit.32Bit.MSEC(Record.Trig.Stop.Time,Record.Trig.Stop,Zero.Zero);            call COPY32(ttime,temptime);         end;      end;      call ADD32(Record.Disk.Start,temptime,Record.Disk.Stop);  /* compute disk end time */      call Deposit.32Bit.MSEC(Record.Disk.Stop.Time,Record.Disk.Stop,Zero.Zero);   end;   else do;                                                     /* else compute trigger end time */      call SUB32(Record.Disk.Stop,Record.Disk.Start,temptime);  /* compute trigger duration */      call ADD32(Record.Trig.Start,temptime,Record.Trig.Stop);  /* compute disk end time */      call Deposit.32Bit.MSEC(Record.Trig.Stop.Time,Record.Trig.Stop,Zero.Zero);   end;   Disable.Deposits = false;end UPDATE.RECORD.TIMES;/* Set.Record.Trigger is called to change the *//* record trigger state                       */SET.RECORD.TRIGGER: proc(trigger) swapable;   dcl trigger     fixed;   Record.Trigger = trigger;   call PID(Record.Trigger.Switch.Setting,Record.Trigger-RT.DEFAULT);   call SET.RECORD.PANEL.ATTRIBUTES;   call Display.AEE.Record.Ready.Buttons;   /* treat as a deposit of record.disk.start.time so that new */   /* trigger end time gets computed whenever mode is changed: */   if Record.Mode = RM.ALLOCATE then call Update.Allocate.Times;   else call Update.Record.Times(Record.Disk.Start.Time);   if (Record.Trigger = RT.BOUNCE)   or (Record.Trigger = RT.MOVE  )   then call SET.RECORD.CUE.LOCK.TIMES;end SET.RECORD.TRIGGER;UPDATE.RECORD.PANEL: proc public swapable;   dcl tmp (1)  fixed;   dcl i        fixed;   call Display.AEE.Record.Ready.Buttons;   disable.deposits = true;   i = FETCH.DTD.CROSS.FADE;   if Fetch.Fixed.Point(Record.Cross.Fade.Id)<> i then do;      call Deposit.Fixed.Point(Record.Cross.Fade.Id,i);   end;   disable.deposits = false;   /* update switches also */   if Record.Mode<>GID(Record.Mode.Switch.Setting) then do; /* do this before the others */      call Set.Record.Mode(GID(Record.Mode.Switch.Setting));       disable.deposits = true;      call Deposit.Switch(Record.Mode.Switch,Record.Mode);      disable.deposits = false;   end;   else do;      if Record.Mode = RM.CUE.LOCK      then do;                        /* Cue lock */         call Set.Record.Cue.Lock.Times;      end;   end;   if Record.Trigger<>GID(Record.Trigger.Switch.Setting) then do;      call Set.Record.Trigger(GID(Record.Trigger.Switch.Setting));      disable.deposits = true;      call Deposit.Switch(Record.Trigger.Switch,Record.Trigger);      disable.deposits = false;   end;   disable.deposits = true;   call Deposit.Switch(Record.Rec.Switch,GID(Record.Rec.Switch.Setting));   disable.deposits = false;end UPDATE.RECORD.PANEL;/* $page routines to assist with poly transfer dialog box */UPDATE.ALLOC.NAME.FOR.POLY.XFER: proc (sfname) swapable;   dcl sfname		array;   dcl i				fixed;   dcl new(17-1)	fixed;   /* convert underlines to spaces for cue name */   call COPY.STRING(sfname,new);   do i = 0 to new(0) - 1;      if byte(new,i) = ASC.UNL      then call pbyte(new,i,SP);   end;   if Record.Mode = RM.ALLOCATE then do;      disable.deposits = 1;      call Deposit.String(Record.Cue.Name.Id,new);      disable.deposits = 0;      call CHECK.RECORD.CUE.NAME;   end;end UPDATE.ALLOC.NAME.FOR.POLY.XFER;/* get dialog box for poly transfer to direct-to-disk *//* returns 1 if legit transfer is possible            */GET.POLY.TRANSFER.DIALOG: proc (sfname,sflen,stereo,smsb,emsb,lmsb) returns (fixed) swapable;   dcl SfName                   array;  /* sound file name */   dcl SfLen                    array;  /* sound file length. 0 - sectors,  1 - words */   dcl Stereo                   fixed;   dcl (Smsb)                   array;  /* will hold starting disk sector */   dcl (Emsb)                   array;  /* will hold ending   disk sector */   dcl (Lmsb)                   array;  /* sector length on disk          */   dcl Message.Label            fixed;   dcl Calculate.Button         fixed;   dcl Zero.Fill.Button         fixed;   dcl Extract.Button           fixed;   dcl Ok.Button                fixed;   dcl Cancel.Button            fixed;   dcl exit                     fixed;  /* exit flag */   dcl str(40)                  fixed;   dcl (sfsl) (1)               fixed;  /* sound file sector length */   dcl (temp) (1)               fixed;   dcl (SavedEmsb) (1)          fixed;  /* copy of original end sector */   dcl (lengths.are.equal)      fixed;  /* 1 if sound file length = cue length */   dcl (fill.selected)          fixed;  /* 1 if fill option selected */   dcl (extract.selected)       fixed;  /* 1 if extract option selected */   dcl (calculate.selected)     fixed;  /* 1 if calculate option selected */   dcl (sf.is.longer)           fixed;  /* 1 if sound file is longer than cue */   dcl (i, j)							fixed;      /* useful subroutine:                      */   /* calculate new disk stop time based upon */   /* disk start time and length of sound     */   /* file                                    */   /* returns 1 if end time happens to be     */   /* past the end of the current project     */   /* pass smsb = starting disk sector #      */   /* pass sfsl = sound file len (sectors)    */   /* smsb = disk sector # RELATIVE TO START OF DISK (not proj) */   /* sfsl = # of sectors (per track) in sound file             */   calculate.new.stop.time:proc(smsb,sfsl,temp);      dcl smsb array;  /* start sector #           */      dcl sfsl array;  /* sound file sector length */      dcl temp array;      call ADD32(smsb,sfsl,temp);   /* get ending sector # */      temp(0)=shl(temp(0),8) \ shr(temp(1),8);    /* compute sample # */      temp(1)=shl(temp(1),8);                     /* from this disk sector # */      if COM32(temp, AEE.Current.Project.End) >= lw#ieq /* off end of project */      then return 0;      call DTD.Sample.#.To.Msecs(temp, CF#Time, S$Speed, AEE.Current.Project.Rate, AEE.Current.Project.Base, temp);      Disable.Deposits = true;      call Deposit.32Bit.Msec(Record.Disk.Stop.Time,temp,Zero.Zero);      Disable.Deposits = false;      call UPDATE.RECORD.TIMES(Record.Disk.Stop.Time);  /* copy into record.disk.stop; perform error checking */      call Update.Object(Record.Disk.Stop.Time);      return 1;   end calculate.new.stop.time;   call REMOVE.ERR;   if Record.Mode = RM.PUNCH.IN   then do;      call Display.Notice(NT#NoXferPunchIn,ATTR#Reverse,NulStr,0,0,0);      return 0;   end;   call CONSTRUCT.RECORDED.CUE(Record.Disk.Start,Record.Disk.Stop,Record.Ready.Bits,Record.Disk.Start);  /* return cue in misc.buf */   write(mam) = Scsi.Ptr;                /* store in scsi ptr */   call COPY.OUT(addr(misc.buf(0)),256);   call COMPUTE.CUE.LENGTH.IN.SECTORS(SCSI.PTR,SMSB,EMSB,LMSB); /* get cue lenth, in sectors */   /* begin by checking for mono/stereo match */   i=0;               /* count # of ready tracks */   do j=0 to 15;      if (Record.Ready.Bits&bits(j))<>0 then i=i+1;   end;   if  (i=0) then do;      call Display.Notice(NT#NoReadyTracks,ATTR#Reverse,NulStr,0,0,0);      return 0;   end;   if  (i>2) then do;      call Display.Notice(NT#TooManyReadyTracks,ATTR#Reverse,NulStr,0,0,0);      return 0;   end;   if (i=1)&(stereo<>0) then do;      call Display.Notice(NT#MonoStereoMisMatch,ATTR#Reverse,NulStr,0,0,0);      return 0;   end;   if (i=2)&(stereo=0) then do;      call Display.Notice(NT#StereoMonoMisMatch,ATTR#Reverse,NulStr,0,0,0);      return 0;   end;   /* compute sound file length in sectors.  */   /* keep around as a 32-bit format number  */   call COPY32(sflen,sfsl);              /* duplicate sound file length (sectors,words) */   if sfsl(1)<>0 then sfsl(0)=sfsl(0)+1; /* round up sector length of sound file */   sfsl(1)=sfsl(0); sfsl(0)=0;           /* compute data sectors now        */   /* if stereo sound file,  compute actual */   /* sector length of each track:          */   if stereo then sfsl(1) = shr(sfsl(1)+1,1);   if Record.Mode = RM.ALLOCATE then do;           /* if allocate mode               */      call Update.Allocate.Times;        /* then compute new start time    */      if calculate.new.stop.time(smsb,sfsl,temp)=0   /* and end time       */      then do;         call Display.Notice(NT#SfXferPastEof,ATTR#Reverse,NulStr,0,0,0);         return 0;      end;      else do;                            /* recompute cue length info */         call CONSTRUCT.RECORDED.CUE(Record.Disk.Start,Record.Disk.Stop,Record.Ready.Bits,Record.Disk.Start);  /* return cue in misc.buf */         write(mam) = Scsi.Ptr;           /* store in scsi ptr         */         call COPY.OUT(addr(misc.buf(0)),256);         call COMPUTE.CUE.LENGTH.IN.SECTORS(SCSI.PTR,SMSB,EMSB,LMSB); /* get cue lenth, in sectors */      end;   end;                                     /* put up dialog box */   /* TOP LINE OF DIALOG: */   /* 0         1         2         3         4         5         6         7          */   /* 01234567890123456789012345678901234567890123456789012345678901234567890123456789 */   /* Transfer "FILENAME" to DTD:  [COMPUTE END]  [FILL TO END]  [TRANSFER]  [CANCEL]  */   /*                                               [EXTRACT]                       */   call Set.Auto.Allocation.Id(Record.Alloc+900);   call Set.Default.Action(O#ACT.Middle.Press);   call Set.Default.Attr(0,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);   Disable.Deposits = true;   Message.Label      = Define.Label(S#AA,Record.Row+Record.Size,0,27,'');   call Set.Default.Attr(0,ATTR#Normal);   call Set.Default.Attr(1,ATTR#Normal);   Calculate.Button   = Define.Label(S#AA,Record.Row+Record.Size,29,0,'[COMPUTE END]');   Zero.Fill.Button   = Define.Label(S#AA,Record.Row+Record.Size,44,0,'[FILL TO END]');   Extract.Button     = Define.Label(S#AA,Record.Row+Record.Size,46,0,'[EXTRACT]');   OK.Button          = Define.Label(S#AA,Record.Row+Record.Size,59,0,'[TRANSFER]');   Cancel.Button      = Define.Label(S#AA,Record.Row+Record.Size,71,0,'[CANCEL]');   call copy.string('Transfer "',str);   call append.to.str(str,SfName);   call append.to.str(str,'" to DTD:');   call Deposit.Label(Message.Label,str);   call Deposit.Object.Info(Message.Label,O#EraseMethod,O#ERAS.Whole.Line);   Disable.Deposits = false;   call Set.Default.Attr(0,ATTR#Normal);   call Set.Default.Attr(1,ATTR#AltIntensity\ATTR#Reverse);   /* enable objects that should always be on screen */   call Enable.Object(Message.Label);      call Enable.Object(Ok.Button    );   call Enable.Object(Cancel.Button);   /* enable other items based upon comparison of sound file length */   if  (lmsb(lw#msb)<>0)                 /* if cue length and sf length */   or  (lmsb(lw#lsb)<>sfsl(1))           /* are not equal,  then        */   then do;                              /* compute results             */      lengths.are.equal = 0;      call Enable.Object(Calculate.Button);         if  (lmsb(lw#msb)  <> 0)                 /* if cue length is longer */      or  (lmsb(lw#lsb) igt sfsl(1))      then do;         call Enable.Object(Zero.Fill.Button);         call Display.Notice(NT#SfIsShorter,ATTR#Normal,NulStr,0,0,0);      end;      else do;         call Enable.Object(Extract.Button);            sf.is.longer = 1;         call Display.Notice(NT#SfIsLonger,ATTR#Normal,NulStr,0,0,0);      end;   end;   else do;      lengths.are.equal = 1;      call DISPLAY.NOTICE (NT#EraseNotice,ATTR#Normal,NulStr,0,0,0);   end;   /* now present dialog box to user */   do i = Record.Alloc+900 to Record.Alloc+910;      call Update.Object(i);   end;   /* save original stop time */   call Fetch.32Bit.Msec(Record.Disk.Stop.Time, SavedEmsb);   /* wait for user response */   /* make the corner label the current object while the dialog box */   /* is happening so that the user can not make any changes once   */   /* we have compared the input information above                  */   call Select.New.Cur.Obj(Corner.Label,-1,-1);   do while exit = 0;      i = Get.Next.Screen.Event;      if Screen.Event.Group = Record.Group then do;         if i = Get.Screen.Event then do;            if (Screen.Event.Info = S#MouseSelect)            or (Screen.Event.Info = S#MouseActivate)            then do;               if Screen.Event.Id = OK.Button then do;                  if (lengths.are.equal\calculate.selected\fill.selected\extract.selected)<>0                  then exit=1;  /* good exit - match, fill, extract */                  else if sf.is.longer <> 0                  then call Display.Notice(NT#MustComputeOrExtract,ATTR#Reverse,NulStr,0,0,0);                  else call Display.Notice(NT#MustComputeOrFill,ATTR#Reverse,NulStr,0,0,0);               end;               else if (Screen.Event.Id = Cancel.Button)               or      (Screen.Event.Id = Record.Stop.Button)               then do;                  if calculate.selected<>0 then do;                     /* restore original stop time */                     Disable.Deposits = true;                     call Deposit.32Bit.Msec(Record.Disk.Stop.Time,SavedEmsb,Zero.Zero);                     Disable.Deposits = false;                     call UPDATE.RECORD.TIMES(Record.Disk.Stop.Time);  /* copy into record.disk.stop; perform error checking */                     call Update.Object(Record.Disk.Stop.Time);                  end;                  exit = -1;               end;               else if (Screen.Event.Id = Calculate.Button) then do;                  calculate.selected = calculate.selected xor 1;                  if calculate.selected<>0 then do;                     /* first set buttons to proper statuses */                     call Set.Object.Attr(Calculate.Button,0,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);                     call Set.Object.Attr(Calculate.Button,1,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);                     if extract.selected<>0 then do;                        extract.selected = 0;                        call Set.Object.Attr(Extract.Button,0,ATTR#Normal);                        call Set.Object.Attr(Extract.Button,1,ATTR#Normal);                     end;                     else if fill.selected<>0 then do;                        fill.selected = 0;                        call Set.Object.Attr(Zero.Fill.Button,0,ATTR#Normal);                        call Set.Object.Attr(Zero.Fill.Button,1,ATTR#Normal);                     end;                     /* compute the new stop time and display it */                     if calculate.new.stop.time(smsb,sfsl,temp)=0                       then do;                        call Display.Notice(NT#SfXferPastEof,ATTR#Reverse,NulStr,0,0,0);                     end;                     else do;  /* lengths are equal - limit other options */                        call CONSTRUCT.RECORDED.CUE(Record.Disk.Start,Record.Disk.Stop,Record.Ready.Bits,Record.Disk.Start);  /* return cue in misc.buf */                        write(mam) = Scsi.Ptr;                /* store in scsi ptr */                        call COPY.OUT(addr(misc.buf(0)),256);                        call COMPUTE.CUE.LENGTH.IN.SECTORS(SCSI.PTR,SMSB,EMSB,LMSB); /* get cue lenth, in sectors */                        lengths.are.equal = 1;                     end;                  end;                  else do;                     call Set.Object.Attr(Calculate.Button,0,ATTR#Normal);                     call Set.Object.Attr(Calculate.Button,1,ATTR#Normal);                     /* restore original stop time */                     Disable.Deposits = true;                     call Deposit.32Bit.Msec(Record.Disk.Stop.Time,SavedEmsb,Zero.Zero);                     Disable.Deposits = false;                     call UPDATE.RECORD.TIMES(Record.Disk.Stop.Time);  /* copy into record.disk.stop; perform error checking */                     call Update.Object(Record.Disk.Stop.Time);                  end;               end;               else if (Screen.Event.Id = Extract.Button)   then do;                  extract.selected = extract.selected xor 1;                  if extract.selected<>0 then do;                     call Set.Object.Attr(Extract.Button,0,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);                     call Set.Object.Attr(Extract.Button,1,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);                     if calculate.selected<>0 then do;                        calculate.selected = 0;                        call Set.Object.Attr(Calculate.Button,0,ATTR#Normal);                        call Set.Object.Attr(Calculate.Button,1,ATTR#Normal);                        /* restore original stop time */                        Disable.Deposits = true;                        call Deposit.32Bit.Msec(Record.Disk.Stop.Time,SavedEmsb,Zero.Zero);                        Disable.Deposits = false;                        call UPDATE.RECORD.TIMES(Record.Disk.Stop.Time);  /* copy into record.disk.stop; perform error checking */                        call Update.Object(Record.Disk.Stop.Time);                     end;                  end;                  else do;                     call Set.Object.Attr(Extract.Button,0,ATTR#Normal);                     call Set.Object.Attr(Extract.Button,1,ATTR#Normal);                  end;               end;               else if (Screen.Event.Id = Zero.Fill.Button)  then do;                  fill.selected = fill.selected xor 1;                  if fill.selected<>0 then do;                     call Set.Object.Attr(Zero.Fill.Button,0,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);                     call Set.Object.Attr(Zero.Fill.Button,1,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);                     if calculate.selected<>0 then do;                        calculate.selected = 0;                        call Set.Object.Attr(Calculate.Button,0,ATTR#Normal);                        call Set.Object.Attr(Calculate.Button,1,ATTR#Normal);                        /* restore original stop time */                        Disable.Deposits = true;                        call Deposit.32Bit.Msec(Record.Disk.Stop.Time,SavedEmsb,Zero.Zero);                        Disable.Deposits = false;                        call UPDATE.RECORD.TIMES(Record.Disk.Stop.Time);  /* copy into record.disk.stop; perform error checking */                        call Update.Object(Record.Disk.Stop.Time);                     end;                  end;                  else do;                     call Set.Object.Attr(Zero.Fill.Button,0,ATTR#Normal);                     call Set.Object.Attr(Zero.Fill.Button,1,ATTR#Normal);                  end;               end;            end;         end;      end;      else do;         if (i = Get.Screen.Event)         &  (Screen.Event.Group <> 0)         &  ((Screen.Event.Info = S#MouseSelect)         or  (Screen.Event.Info = S#MouseActivate))         then call Display.Notice(NT#MustRespondToDialog,ATTR#Normal,NulStr,0,0,0);      end;      /* always reselect corner object in case user moused */      /* somewhere else                                    */      call Select.New.Cur.Obj(Corner.Label,-1,-1);         end;   call Erase.Object(Message.Label);  /* Erases message and whole line */   call Undefine.Object.Range(Record.Alloc+900,Record.Alloc+910);   call Select.New.Cur.Obj(Corner.Label,-1,-1);   return (exit > 0);end GET.POLY.TRANSFER.DIALOG;/* $page erase prior take: */Erase.Prior.Take: proc (delete.id,delete.in.time,delete.out.time,delete.cue.name,ready.trks) swapable;   dcl delete.id                fixed;   dcl delete.in.time           array;  /* 32-bit millisecond time with respect */   dcl delete.out.time          array;  /* to start of cur project              */   dcl delete.cue.name          array;   dcl ready.trks               fixed;  /* ready track bits */   dcl hist.rec(CUE.HIST.REC.LEN - 1) fixed;   dcl Empty.Reel proc (fixed) external;   /* erasing the data will also get rid of any */   /* cues defined there,  so id# is not needed */   /* really                                    */   write(mam) = Current.Cue.Ptr;        /* Check id of current cue */   write(mal) = cue.alloc#;             /* if it matches the one   */   if read(md) = delete.id              /* we are retaking,        */   then do;                             /* then erase it           */      call Empty.Reel(Current.Cue.Ptr);      call Deposit.A.New.Current.Cue(0);   end;   call BUILD.CUE.HIST.REC(delete.id,1,hist.rec);   call ADD.CUE.TO.HIST(hist.rec);   /* times passed are 32-bit milliseconds with respect */   /* to the current project                            */   call ERASE.DTD.DRIVE.AREA (ready.trks,delete.in.time,delete.out.time);   if Record.Group<>0 then do;      call Deposit.String(Record.Cue.Name.Id,delete.cue.name); /* let deposit reporting do its job */      call Update.Object(Record.Cue.Name.Id);                  /* show it right now */   end;   call WAIT.FOR.DTD.COMMAND.TO.FINISH;   call Update.Audio.Event.Editor;     /* update pmgr; recompute times */end Erase.Prior.Take;/* $page - get dialog box for retake function *//* erases prior take if user responds affirmatively */PROCESS.CUE.RETAKE.DIALOG: proc (group,start,trks) public swapable;   dcl group						fixed;  /* which panel */   dcl start						array;  /* start time of cue to retake */   dcl trks							fixed;  /* track bits */   dcl Message.Label				fixed;   dcl Name.Label					fixed;   dcl Quote.Label				fixed;   dcl Ok.Button					fixed;   dcl Cancel.Button				fixed;   dcl exit							fixed;   dcl delete.id					fixed;   dcl delete.in.time  (1)		fixed;   dcl delete.out.time (1)		fixed;   dcl delete.cue.name (17-1)	fixed;   dcl i								fixed;   dcl row							fixed;   call REMOVE.ERR;   call Select.New.Cur.Obj(Corner.Label,-1,-1); /* keep retake button un-selected */   call ERASE.CUE.AUDITION.TRACK;   /* erase .audit. cue before retake   */   call SET.DTD.SCROLL.RANGE(1);    /* select time scroll in cur project */   call FETCH.TIME.DTD.CUE(start);  /* find cue that starts at this start time. position cursor at end of list if no cues after us. */   do while exit=0;      /* find cue that matches ready tracks */      delete.id = FETCH.PREVIOUS.TIME.DTD.CUE;   /* get prior time cue */      if delete.id=0 then do;                    /* prior cue not found */         call Display.Notice(NT#RetakeCueNotAvail,ATTR#Reverse,NulStr,0,0,0);         return;      end;      write(mam) = Scsi.Ptr;                     /* see if is a reel   */      write(mal) = Cue.List.Ptr;                 /* (god forbid)       */      if read(md) =0 then do;         write(mam) = Scsi.Ptr;         write(mal) = CUE.TRKS;         if  read(md) = trks               /* if prior cue, in current song with matching tracks */         then do;                          /* then assume that is the one we should delete */            write(mal) = cue.s.msb;        /* get cue start time */            call COPY.IN(addr(delete.in.time(0)),2);            write(mal) = cue.e.msb;        /* get cue start time */            call COPY.IN(addr(delete.out.time(0)),2);            write(mal) = cue.name;         /* get name for dialog box */            call COPY.IN(addr(delete.cue.name(0)),17);            exit = 1;         end;      end;   end;   exit = 0;    /* prepare for dialog box */   /* put up dialog box */   /* TOP LINE OF DIALOG: */   /* 0         1         2         3         4         5         6         7          */   /* 01234567890123456789012345678901234567890123456789012345678901234567890123456789 */   /* Erase and retake cue "12345678901234567890123456789012"    [RETAKE]    [CANCEL]  */   if group = Record.Group then do;      call Set.Auto.Allocation.Id(Record.Alloc+900);      row = Record.Row+Record.Size;   end;   else if group = Optical.Group then do;      call Set.Auto.Allocation.Id(Optical.Alloc+900);      row = Optical.Row+Optical.Size;   end;   call Set.Default.Action(O#ACT.Middle.Press);   call Set.Default.Attr(0,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);   Message.Label      = Define.Label(S#AA,row,0,0,'Erase and retake cue "');   Name.Label         = Define.Label(S#AA,row,22,0,delete.cue.name);   Quote.Label        = Define.Label(S#AA,row,22+delete.cue.name(0),0,'"');   call Set.Default.Attr(0,ATTR#Normal);   call Set.Default.Attr(1,ATTR#Normal);   OK.Button          = Define.Label(S#AA,row,59,0,'[RETAKE]');   Cancel.Button      = Define.Label(S#AA,row,71,0,'[CANCEL]');   call Deposit.Object.Info(Message.Label,O#EraseMethod,O#ERAS.Whole.Line);   call Set.Default.Attr(0,ATTR#Normal);   call Set.Default.Attr(1,ATTR#AltIntensity\ATTR#Reverse);   call ENABLE.OBJECT.RANGE(Message.Label,Cancel.Button);   call UPDATE.OBJECT.RANGE(Message.Label,Cancel.Button);   /* wait for user response */   /* make the corner label the current object while the dialog box */   /* is happening so that the user can not make any changes once   */   /* we have compared the input information above                  */   call Select.New.Cur.Obj(Corner.Label,-1,-1);   /* highlight retake button */   if group=Record.Group then      call Set.Object.Attr(Record.Retake.Id,0,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);   do while exit = 0;      i = Get.Next.Screen.Event;      if Screen.Event.Group = group then do;         if i = Get.Screen.Event then do;            if (Screen.Event.Info = S#MouseSelect)            or (Screen.Event.Info = S#MouseActivate)            then do;               if Screen.Event.Id = OK.Button then do;                  call Erase.Prior.Take(delete.id,delete.in.time,delete.out.time,delete.cue.name,trks);                  exit = 1;               end;               else if (Screen.Event.Id = Cancel.Button)               or      (Screen.Event.Id = Record.Stop.Button)               then do;                  exit = -1;               end;            end;         end;      end;      else do;         if (i = Get.Screen.Event)         &  (Screen.Event.Group <> 0)         &  ((Screen.Event.Info = S#MouseSelect)         or  (Screen.Event.Info = S#MouseActivate))         then call Display.Notice(NT#MustRespondToDialog,ATTR#Normal,NulStr,0,0,0);      end;      /* always reselect corner object in case user moused */      /* somewhere else                                    */      call Select.New.Cur.Obj(Corner.Label,-1,-1);         end;   /* un highlight retake button */   if group = Record.Group   then call Set.Object.Attr(Record.Retake.Id,0,ATTR#Normal\ATTR#AltIntensity);   call Erase.Object(Message.Label);  /* Erases message and whole line */   if group = Record.Group   then call Undefine.Object.Range(Record.Alloc+900,Record.Alloc+910);   else if group = Optical.Group   then call Undefine.Object.Range(Optical.Alloc+900,Optical.Alloc+910);   call Select.New.Cur.Obj(Corner.Label,-1,-1);end PROCESS.CUE.RETAKE.DIALOG;PROCESS.TSM.OPTIONS.DIALOG: proc (TSM.Options) swapable;   dcl TSM.Options         array;/* array to return options in */   dcl TSM.Pitch.Label     fixed;   dcl TSM.Max.Cut.Label   fixed;   dcl TSM.Just.Label      fixed;   dcl TSM.No.Opt.Label    fixed;   dcl TSM.Pitch.Val       fixed;   dcl TSM.Max.Cut.Val     fixed;   dcl TSM.Just.Val        fixed;   dcl TSM.Algorithm       fixed;   dcl Ok.Button           fixed;   dcl exit                fixed;      dcl i							fixed;   dcl TSM.Dialog.Min  lit '(Record.Alloc + 900)';   dcl TSM.Dialog.Max  lit '(Record.Alloc + 949)';   /*           1         2         3         4         5         6         7*/   /* 01234567890123456789012345678901234567890123456789012345678901234567890 */   /* Fundamental Pitch (Hz): 123456                             [ OK ]*/   /* Max Cut (MS): 123456        Justification: 1               [ OK ]*/   call Set.Auto.Allocation.Id(TSM.Dialog.Min);   call Set.Default.Attr(0,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse);   call Set.Default.Action(O#ACT.Jog.Enabled\O#ACT.Middle.Press\O#ACT.Left.Press\O#ACT.Right.Press);   TSM.Pitch.Val      = Define.Fixed.Point(S#AA,Record.Row+Record.Size,26,6,1,cf#right);   TSM.Max.Cut.Val    = Define.Fixed.Point(S#AA,Record.Row+Record.Size,16,6,2,cf#right);   TSM.Just.Val       = Define.Fixed.Point(S#AA,Record.Row+Record.Size,43,1,0,cf#right);   call Set.Default.Action(0);   TSM.Pitch.Label    = Define.Label(S#AA,Record.Row+Record.Size,0,0,'Fundamental Pitch (Hz): ');   TSM.Max.Cut.Label  = Define.Label(S#AA,Record.Row+Record.Size,0,0,'Max Cut (MS): ');   TSM.Just.Label     = Define.Label(S#AA,Record.Row+Record.Size,28,0,'Justification ');   TSM.No.Opt.Label   = Define.Label(S#AA,Record.Row+Record.Size,0,0,'This Algorithm Has No Options ');   call Set.Default.Attr(0,ATTR#Normal);   call Set.Default.Attr(1,ATTR#Normal);   call Set.Default.Action(O#ACT.Middle.Press);   OK.Button          = Define.Label(S#AA,Record.Row+Record.Size,59,0,'[ OK ]');   call Set.Default.Attr(0,ATTR#Normal);   call Set.Default.Attr(1,ATTR#AltIntensity\ATTR#Reverse);   call ENABLE.OBJECT.RANGE(TSM.Pitch.Val,OK.Button);   call Deposit.Object.Info(OK.Button,O#EraseMethod,O#ERAS.Whole.Line);   call Set.Object.Arrow.Links (TSM.Pitch.Val,   ARR#Auto,ARR#Auto,ARR#Auto,ARR#Auto);   call Set.Object.Arrow.Links (TSM.Max.Cut.Val, ARR#Auto,ARR#Auto,ARR#Auto,ARR#Auto);   call Set.Object.Arrow.Links (TSM.Just.Val,    ARR#Auto,ARR#Auto,ARR#Auto,ARR#Auto);   call Check.TSM.Options(TSM.Options); /* set up default values if needed */   /* Deposits Initial Values */   disable.deposits=1;   call Deposit.Fixed.Point (TSM.Pitch.Val,TSM.Options(TSM.Opt#pitch));   call Deposit.Fixed.Point (TSM.Max.Cut.Val, TSM.Options(TSM.Opt#max.cut));   call Deposit.Fixed.Point (TSM.Just.Val, TSM.Options(TSM.OPT#just));   disable.deposits=0;   /* do case according to algorithm */   TSM.Algorithm = Fetch.Switch(Record.TSM.Alg.Switch);   do case (TSM.algorithm);      do;/* 0: Quick */         call Disable.Object(TSM.No.Opt.Label);         call Disable.Object(TSM.Max.Cut.Label);         call Disable.Object(TSM.Max.Cut.Val);         call Disable.Object(TSM.Just.Label);         call Disable.Object(TSM.Just.Val);         call Select.New.Cur.Obj(TSM.Pitch.Val,-1,-1);      end;      do;/* 1: ONE */         call Disable.Object(TSM.No.Opt.Label);         call Disable.Object(TSM.Pitch.Label);         call Disable.Object(TSM.Pitch.Val);         call Select.New.Cur.Obj(TSM.Max.Cut.Val,-1,-1);      end;      do;/* 2: TWO */         call Disable.Object(TSM.Max.Cut.Label);         call Disable.Object(TSM.Max.Cut.Val);         call Disable.Object(TSM.Just.Label);         call Disable.Object(TSM.Just.Val);         call Disable.Object(TSM.Pitch.Label);         call Disable.Object(TSM.Pitch.Val);         call Select.New.Cur.Obj(Corner.Label,-1,-1);      end;   end;/* of do case(TSM.Algorithm) */   call UPDATE.OBJECT.RANGE(TSM.Pitch.Val, OK.Button);   /* wait for user response */   /* highlight option button */   call Set.Object.Attr(Record.TSM.Options.Id,0,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);   exit = 0;   do while exit = 0;      i = Get.Next.Screen.Event;      if Screen.Event.Group = Record.Group then do;         if i = Get.Screen.Event then do;            if (Screen.Event.Info = S#MouseSelect)            or (Screen.Event.Info = S#MouseActivate)            then do;               if (Screen.Event.Id = OK.Button)               or (Screen.Event.Id < TSM.Dialog.Min)               or (Screen.Event.Id > TSM.Dialog.Max)               then exit = 1;            end;            else if (Screen.Event.Info = S#Deposit)            then do;               if (Screen.Event.Id < TSM.Dialog.Min)               or (Screen.Event.Id > TSM.Dialog.Max)               then exit = 1;               else do;                  TSM.Options(TSM.Opt#pitch) = Fetch.Fixed.Point (TSM.Pitch.Val);                  TSM.Options(TSM.Opt#max.cut) = Fetch.Fixed.Point (TSM.Max.Cut.Val);                  TSM.Options(TSM.OPT#just) = Fetch.Fixed.Point (TSM.Just.Val);                  call Check.TSM.Options(TSM.Options); /* limit input values to correct range */                  disable.deposits=1;                  call Deposit.Fixed.Point (TSM.Pitch.Val,TSM.Options(TSM.Opt#pitch));                  call Deposit.Fixed.Point (TSM.Max.Cut.Val, TSM.Options(TSM.Opt#max.cut));                  call Deposit.Fixed.Point (TSM.Just.Val, TSM.Options(TSM.OPT#just));                  disable.deposits=0;               end;            end;         end;      end;      else do;         if (i = Get.Screen.Event)         &  (Screen.Event.Group <> 0)         &  ((Screen.Event.Info = S#MouseSelect)         or  (Screen.Event.Info = S#MouseActivate)         or  (Screen.Event.Info = S#Deposit))         then do;            call Display.Notice(NT#MustRespondToDialog,ATTR#Normal,NulStr,0,0,0);            call Select.New.Cur.Obj(Corner.Label,-1,-1);         end;      end;   end;   /* un highlight Options button */   call Set.Object.Attr(Record.TSM.Options.Id,0,ATTR#Normal\ATTR#AltIntensity);   call Erase.Object(Ok.Button);    /* Erases message and whole line */   call Undefine.Object.Range(TSM.Dialog.Min, TSM.Dialog.Max);   call Select.New.Cur.Obj(Corner.Label,-1,-1);end PROCESS.TSM.OPTIONS.DIALOG;/* get dialog box for move/bounce                     *//* returns 1 if legit transfer is possible            */GET.MOVE.BOUNCE.DIALOG: proc (info, dtd.start) swapable;   dcl info                     array;  /* info return here 0 = replace selected        */                                        /*                  1 = erase   selected        */                                        /*                  2 = id of current cue       */   dcl dtd.start                array;  /* returns where on disk (sector #)             */                                        /* to start to write to                         */   dcl Message.Label            fixed;   dcl Replace.In.Seq.Button    fixed;   dcl Erase.Prior.Button       fixed;   dcl Ok.Button                fixed;   dcl Cancel.Button            fixed;   dcl replace.selected         fixed;   dcl erase.selected           fixed;   dcl dtd.end  (1)             fixed;   dcl dtd.len  (1)             fixed;   dcl cue.start(1)             fixed;   dcl cue.end  (1)             fixed;   dcl cue.len  (1)             fixed;   dcl cname		(17-1)			fixed;   dcl event(event.record.size-1) fixed;   dcl exit                     fixed;  /* exit flag */   dcl i			                   fixed;   dcl cuetracks                fixed;   dcl rdytracks                fixed;   dcl cuetbits                 fixed;   dcl rdytbits                 fixed;      dcl Get.Sequencer.Event.Information proc (array) external;   call REMOVE.ERR;   if (Record.Mode = RM.PUNCH.IN)   or (Record.Mode = RM.CUE.LOCK)   then do;      call Display.Notice(NT#MustAllocate,ATTR#Reverse,NulStr,0,0,0);      return 0;   end;   /* Get info about current cue handy:          */   call COMPUTE.CUE.LENGTH.IN.SECTORS(Current.Cue.Ptr, cue.start, cue.end, cue.len);   /* begin by checking for tracks match:        */   cuetracks = 0;   rdytracks = 0;   write(mam) = Current.Cue.Ptr;   write(mal) = CUE.TRKS;   cuetbits   = read(md) & dtd.avail.trks;   rdytbits   = Record.Ready.Bits;   write(mal) = CUE.NAME;                        /* get name handy too */   call COPY.IN(addr(cname(0)),17);   do i=0 to 15;      if (cuetbits&bits(i))<>0 then cuetracks = cuetracks + 1;      if (rdytbits&bits(i))<>0 then rdytracks = rdytracks + 1;   end;   if  ((cuetracks=0)   or   (COM16(0, cue.len) = lw#ieq))   then do;      call Display.Notice(NT#EmtpyProblem,ATTR#Reverse,NulStr,0,0,0);      return 0;   end;   if  (cuetracks > rdytracks)   then do;      call Display.Notice(NT#ReadyMore,ATTR#Reverse,NulStr,0,0,0);      return 0;   end;   if  (cuetracks < rdytracks)   then do;      call Display.Notice(NT#ReadyFewer,ATTR#Reverse,NulStr,0,0,0);      return 0;   end;   /* See if cue will fit on these tracks: */   /* note: use construct.recorded.cue to set up a cue that starts at */   /* record.disk.start.  Then use compute.cue.length.in.sectors to   */   /* get the sector address of where that cue will be on the dtd.    */   /* This is a simple (but bizarre?) way of getting the sector       */   /* of the DTD we should start recording at:                        */   call CONSTRUCT.RECORDED.CUE(Record.Disk.Start,Record.Disk.Stop,Record.Ready.Bits,Record.Disk.Start);  /* return cue in misc.buf */   write(mam) = Scsi.Ptr;                /* store in scsi ptr as temp */   call COPY.OUT(addr(misc.buf(0)),256);   call COMPUTE.CUE.LENGTH.IN.SECTORS(SCSI.PTR, dtd.start, dtd.end, dtd.len);   if COM32(cue.len, dtd.len) = lw#igt   then do;      call Display.Notice(NT#NoRoomForBounce,ATTR#Reverse,NulStr,0,0,0);      return 0;   end;   /* put up dialog box */   /* TOP LINE OF DIALOG: */   /* 0         1         2         3         4         5         6         7          */   /* 01234567890123456789012345678901234567890123456789012345678901234567890123456789 */   /* Bounce cue to new track(s):        [REPLACE IN SEQUENCE]     [BOUNCE]  [CANCEL]  */   /* Move cue to new track(s): [REPL IN SEQ]  [ERASE PRIOR AUDIO]   [MOVE]  [CANCEL]  */   call Set.Auto.Allocation.Id(Record.Alloc+900);   call Set.Default.Action(O#ACT.Middle.Press);   call Set.Default.Attr(0,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);   call Set.Default.Attr(1,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);   Disable.Deposits = true;   if Record.Trigger = RT.BOUNCE   then do;      Message.Label = Define.Label(S#AA,Record.Row+Record.Size,0,0,'BOUNCE cue to new track(s):');      call Set.Default.Attr(0,ATTR#Normal);      call Set.Default.Attr(1,ATTR#Normal);      Replace.In.Seq.Button = Define.Label(S#AA,Record.Row+Record.Size,35,0,'[REPLACE IN SEQUENCE]');      Erase.Prior.Button    = (-1);      OK.Button             = Define.Label(S#AA,Record.Row+Record.Size,61,0,'[BOUNCE]');      Cancel.Button         = Define.Label(S#AA,Record.Row+Record.Size,71,0,'[CANCEL]');   end;   else do;      Message.Label = Define.Label(S#AA,Record.Row+Record.Size,0,0,'MOVE cue to new track(s):');      call Set.Default.Attr(0,ATTR#Normal);      call Set.Default.Attr(1,ATTR#Normal);      Replace.In.Seq.Button   = Define.Label(S#AA,Record.Row+Record.Size,26,0,'[REPL IN SEQ]');      if 0                    /* can't erase audio yet (ready track probs) */      then Erase.Prior.Button = Define.Label(S#AA,Record.Row+Record.Size,41,0,'[ERASE PRIOR AUDIO]');      else Erase.Prior.Button = (-1);      OK.Button               = Define.Label(S#AA,Record.Row+Record.Size,63,0,'[MOVE]');      Cancel.Button           = Define.Label(S#AA,Record.Row+Record.Size,71,0,'[CANCEL]');   end;   Disable.Deposits = false;   call Set.Default.Attr(0,ATTR#Normal);   call Set.Default.Attr(1,ATTR#AltIntensity\ATTR#Reverse);   /* enable objects that should always be on screen */   call Enable.Object(Message.Label);      if Erase.Prior.Button <> (-1)   then call Enable.Object(Erase.Prior.Button);   call Enable.Object(Replace.In.Seq.Button);   call Enable.Object(Ok.Button    );   call Enable.Object(Cancel.Button);   call Deposit.Object.Info(Message.Label,O#EraseMethod,O#ERAS.Whole.Line);   /* now present dialog box to user */   do i = Record.Alloc+900 to Record.Alloc+910;      call Update.Object(i);   end;   /* wait for user response */   /* make the corner label the current object while the dialog box */   /* is happening so that the user can not make any changes once   */   /* we have compared the input information above                  */   call Select.New.Cur.Obj(Corner.Label,-1,-1);   do while exit = 0;      i = Get.Next.Screen.Event;      if Screen.Event.Group = Record.Group then do;         if i = Get.Screen.Event then do;            if (Screen.Event.Info = S#MouseSelect)            or (Screen.Event.Info = S#MouseActivate)            then do;               if Screen.Event.Id = OK.Button then do;                  exit=1;               end;               else if (Screen.Event.Id = Cancel.Button)               or      (Screen.Event.Id = Record.Stop.Button)               then do;                  exit = -1;               end;               else if (Screen.Event.Id = Replace.In.Seq.Button) then do;                  call blockmove(Recalled.Event.Spointer, Event, spointer.record.size);                  if Get.Sequencer.Event.Information(Event) <> Good.Event.Status                  then do;                     call Display.Notice(NT#NoEventForReplace,ATTR#Normal,NulStr,0,0,0);                     replace.selected = 0;                  end;                  else replace.selected = replace.selected xor 1;                  if replace.selected<>0 then do;                     call Set.Object.Attr(Replace.In.Seq.Button,0,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);                     call Set.Object.Attr(Replace.In.Seq.Button,1,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);                  end;                  else do;                     call Set.Object.Attr(Replace.In.Seq.Button,0,ATTR#Normal);                     call Set.Object.Attr(Replace.In.Seq.Button,1,ATTR#Normal);                  end;               end;               else if (Screen.Event.Id = Erase.Prior.Button)   then do;                  erase.selected = erase.selected xor 1;                  if erase.selected<>0 then do;                     call Set.Object.Attr(Erase.Prior.Button,0,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);                     call Set.Object.Attr(Erase.Prior.Button,1,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);                  end;                  else do;                     call Set.Object.Attr(Erase.Prior.Button,0,ATTR#Normal);                     call Set.Object.Attr(Erase.Prior.Button,1,ATTR#Normal);                  end;               end;            end;         end;      end;      else do;         if (i = Get.Screen.Event)         &  (Screen.Event.Group <> 0)         &  ((Screen.Event.Info = S#MouseSelect)         or  (Screen.Event.Info = S#MouseActivate))         then call Display.Notice(NT#MustRespondToDialog,ATTR#Normal,NulStr,0,0,0);      end;      /* always reselect corner object in case user moused */      /* somewhere else                                    */      call Select.New.Cur.Obj(Corner.Label,-1,-1);         end;   call Erase.Object(Message.Label);  /* Erases message and whole line */   call Undefine.Object.Range(Record.Alloc+900,Record.Alloc+910);   call Select.New.Cur.Obj(Corner.Label,-1,-1);   info(0) = replace.selected;   info(1) = erase.selected;   info(2) = Locate.DTD.Cue(cname);   /* get id# for possible replace */   return (exit > 0);end GET.MOVE.BOUNCE.DIALOG;