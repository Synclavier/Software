/* AUD-OPT3  Optical to DTD transfer for protocol activation          *//*   Modifications:   10/30/90 - CJ - Created*//* Handy routine to get information about a sound file (on disk) into *//* internal memory.   Uses misc.buf.                                  *//* Note: this is an adaptation of "Get.Current.Filename.And.Info".    *//* Also some code from "Analyze.Sound.File.Info".                     */Get.Sound.File.Information: proc(FileAddr, FileLen, Info) swapable;   dcl FileAddr    array;   dcl FileLen     array;   dcl Info        array;        /* will hold the following info:     */                                 /* words 0-1 = file address          */                                 /* words 2-3 = file length           */                                 /* word  4   = sample rate           */                                 /* word  5   = stereo/mono           */                                 /* word  6   = data type             */                                 /* word  7   = word length mod 64K   */   /* see SYNAUXS:ODISKLIT for actual literals for INFO fields        */   dcl Compat      fixed;   dcl WordLen     fixed; /* will hold word length of file mod 64K */   dcl SRate       fixed; /* will hold sample rate */   dcl Stereo      fixed; /* will hold whether or not file is stereo */   dcl DataType    fixed; /* will hold file data type (looping type) */   dcl I           fixed;   dcl orig.per    fixed;   dcl orig.srate  fixed;   WordLen    =0;         /* initialize variables                    */   SRate      =0;   Stereo     =0;   DataType   =0;   call readdata(FileAddr(0), FileAddr(1), misc.buf, 256);   compat=misc.buf(sf.compatibility); /* get orig compat number     */   if compat<0 then compat=0;   srate  = misc.buf(sf.sample.rate); /* see if sample rate defined */   stereo = misc.buf(sf.stereo);      /* look up sound file type (stereo or mono ) */   orig.per   = misc.buf(sf.period.index); /* save original period index for label time correction below */   orig.srate = srate;                     /* save original sampling rate too */   if srate=0 then do;                 /* handle old sfm files */      srate=misc.buf(sf.period.index); /* look up sampling period, 600=50 khz */      if compat<1  then srate=600;     /* not set in old files */      if srate<300 then srate=300;     /* handle old files */      orig.per = srate;                /* save in case modified */      load 1000; mul 300; mwait; div srate;      if shl(rem,1)>=srate then srate=res+1;      else                      srate=res;   end;   DataType   = misc.buf(sf.file.data.type) & "1777";   WordLen    = shl(FileLen(1),8);   /* load values into output array */   call Copy32(FileAddr,loc(addr(Info(SFINFO#F_Base  ))));   call Copy32(FileLen, loc(addr(Info(SFINFO#F_SecLen))));   Info(SFINFO#S_Rate   ) = SRate;   Info(SFINFO#Stereo   ) = Stereo;   Info(SFINFO#Data_Type) = DataType;   Info(SFINFO#F_WordLen) = WordLen;end Get.Sound.File.Information;/* Routine to copy optical to dtd from protocol */copy.file.to.dtd: proc(FileAddr, FileLen, NewName, ErrorCodes) public swapable;   dcl FileAddr      array;      			/* passed device, sector of sound file 				*/   dcl FileLen       array;      			/* passed sector length of sound file  				*/   dcl NewName       array;      			/* pass new name of cue to save as     				*/   dcl ErrorCodes    array;      			/* 0 = Xfer$ Status                     				*/                                 			/* 1 = Xfer$ Error                      				*/      dcl SFInfo (SFINFO#Arr_Len)       fixed; /* holds misc info about the current file   		*/   dcl CueInfo(5)                    fixed; /* holds info about the cue to be created   		*/   dcl DSPInfo(SRC.Opt#array.size-1) fixed; /* holds misc info used during DSP transfer 		*/   dcl modes    (15)           fixed;   dcl statuses (15)           fixed;   dcl cue.in   ( 1)           fixed; 		/* where we started recording on DTD 				*/   dcl cue.sync ( 1)           fixed; 		/* what the sync time was when we started recording */   dcl cue.out  ( 1)           fixed; 		/* how much we recorded, in DTD #s 					*/   dcl dummy    ( 1)           fixed;   dcl (i,j,k)       fixed;   ErrorCodes (0) = 0;         				/* initialize error codes to zero      				*/   ErrorCodes (1) = 0;   Xfer$Status    = 0;   Xfer$Error     = 0;   call Get.Sound.File.Information(FileAddr, FileLen, SFInfo);   call SEND.FOR.DTD.TRACK.MODES (modes,statuses);   DTD.TrackBits = 0;   do i = 0 to 15;                 /* lookup new ready bits */      if statuses(i) = 1      then DTD.TrackBits = DTD.TrackBits\bits(i);   end;   DTD.TrackBits = DTD.TrackBits & DTD.AVAIL.TRKS;   k=0;   do j=0 to 15;                   /* see how many tracks are ready */      if (bits(j) & DTD.TrackBits)<>0 then k=k+1;   end;   if k <> (1 + SFInfo(5))        /* tracks must match SF needs    */   then do;      ErrorCodes (0) = Xfer#TrackMismatch;      return false;   end;   call clean.cue.name(NewName);   if Locate.DTD.Cue(NewName)<>0 then do;      ErrorCodes (0) = Xfer#DuplicateName;      return false;   end;   /* set up DSPInfo array and pass it to transfer routine */   if Setup.Opt.To.DTD.Params(SFInfo,CueInfo,DSPInfo,False)=0   then do;      ErrorCodes (0) = Xfer$Status;      return false;   end;   call Transfer.Between.DTD.And.Opt(SFInfo,CueInfo,DTD.TrackBits,DSPInfo,false);   if Xfer$Status <> 0   then do;      ErrorCodes (0) = Xfer$Status;      ErrorCodes (1) = Xfer$Error;      return false;   end;   /* Do we have to do this ? */   call Fetch.DTD.Drive.Status(dummy);    /* wait for punch out to finish so cue gets created correctly */   do while (dummy(0)&2)<>0;      call Fetch.DTD.Drive.Status(dummy);   end;   call GID(AEE.Record.Cue.Name);   call COPY.OUT(addr(NewName(0)),17);   /* Create new cue to point to sound file */   call Str32(0,0,cue.sync);           /* sync point is zero */   call Copy32(loc(addr(CueInfo(1))),cue.in);   call Shl32(cue.in, 8);              /* convert sectors to sample #s */   call Copy32(loc(addr(CueInfo(3))),cue.out);   call Shl32(cue.out,8);   call Save.New.Cue(cue.in,cue.out,cue.sync,DTD.TrackBits);   if DTD.Cue# > 0 then do;      call SET.DTD.CURRENT.REEL(0);    /* select "cue"             */      call Fetch.Entire.DTD.Cue(DTD.Cue#, Current.Cue.Ptr);      call Deposit.A.New.Current.Cue(1);      call UnSet.Cue.Modified;   end;   else do;      if Xfer$Status=Xfer#Good       then Xfer$Status=Xfer#SaveErr;   end;   /* Create system event saying recording happend, lengths have */   /* changed, and a new recording cue has been created          */   new.dtd.info = new.dtd.info \ (32768 \ 16);   ErrorCodes (0) = Xfer$Status;   ErrorCodes (1) = Xfer$Error;   return true;end copy.file.to.dtd;