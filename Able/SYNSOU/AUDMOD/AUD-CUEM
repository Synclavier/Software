/* AUD-CUEM  Cue Menu Routines   Modified:   07/10/90 - PF  - Allow time fields to work with Meter Mapping   12/14/89 - MWH - Set DTD to ALL or CUR proj before filling cue dir display   11/20/89 - MWH - Don't change DTD scroll mode while displaying cue directory   10/03/88 - cj  - Remapped to live click track when necessary.                    Also fixed bug so CUE CAPTION gets displayed when                    it is asked for.   08/08/88 - cj  - store absolute # of smpte bits in cue record   07/09/88 - CJ  - fixed bug in how deposit.table was being called (must                    fetch table first)   05/10/88 - SGS - Define tables to make better use of screen manager,                    and change scroll bar <--> table mapping to be more precise                    Time formats now only show one cue per row.*/dcl Cue.Menu.Group             fixed public;dcl Cue.Menu.Row               fixed;dcl Cue.Menu.Size              fixed;dcl Cue.Menu.Screen.Space      fixed;dcl Cue.Menu.Move.Box          fixed;dcl Cue.Menu.Size.Box          fixed;dcl Cue.Menu.Format.Switch     fixed;dcl Cue.Menu.Sort.Switch       fixed;dcl Cue.Menu.Function.Switch   fixed;dcl Cue.Menu.Playback.Switch   fixed;dcl Cue.Menu.Display.Switch    fixed;dcl Cue.Menu.Time.Table.Type   fixed;dcl Cue.Menu.Time.Table.Id     fixed public;dcl Cue.Menu.Name.Table.Type   fixed;dcl Cue.Menu.Name.Table.Id     fixed public;dcl Cue.Menu.Scroll.Bar        fixed;dcl Cue.Menu.Grid.Lines        fixed;dcl Cue.Menu.Sort              fixed;dcl Cue.Menu.Format            fixed;dcl Last.Alpha.Format          fixed static;  /* save the last alpha format */dcl Cue.Menu.Function          fixed;dcl Cue.Menu.Columns           fixed; /* number of columns in name table */dcl Cue.Menu.Rows              fixed;dcl Cue.Menu.Playback.Mode     fixed;dcl Cue.Menu.Position          fixed; /* cue # at top left of name table: 1 = first cue, DTD.NUM.CUES = last cue, etc. */dcl Update.Cue.Menu.Table          proc (fixed,fixed) recursive;dcl Set.Cue.Menu.Format.Switch.Str proc               recursive;     dcl Set.Format.Str.To.Time.Str     proc               recursive;dcl Set.Format.Str.To.Name.Str     proc               recursive;DEFINE.CUE.MENU.DISPLAY: proc (row,size,format) swapable;   dcl row         fixed;   /* top row of display area */   dcl size        fixed;   /* # of rows to neat line  */   dcl format      fixed;   /* types of format:        */                            /* 1:  Name and comment    */                            /* 2:  3 Col Alpha         */                            /* 3:  5 Col Alpha         */                            /* 4:  8 Col Alpha         */                            /* 5:  1 Col Time          */                            /* scrapped as of 5/10/88: */                            /* 5:  2 Col Time          */                            /* 6:  3 Col Time          */                            /* 7:  5 Col Time          */   /*  FDATA KEY:      Cols, Chars,  Column positions             */   dcl fdata     data (1,    80,     0, 33,  0,  0,  0,  0,  0,  0,                       3,    27,     0, 27, 54,  0,  0,  0,  0,  0,                       5,    16,     0, 16, 32, 48, 64,  0,  0,  0,                       8,    10,     0, 10, 20, 30, 40, 50, 60, 70,                       1,    64,    16,  0,  0,  0,  0,  0,  0,  0);                       /* scrapped as of 5/10/88                  */   /*                  2,    32,    16, 48,  0,  0,  0,  0,  0,  0,                       3,    21,    16, 37, 58,  0,  0,  0,  0,  0,                       5,    13,    16, 29, 42, 55, 68,  0,  0,  0); */   dcl lines (100) fixed;   dcl vlines(8)   fixed;  /* Vertical line positions; filled based on format */   dcl i           fixed;   dcl mr13i       lit 'write("373")';   dcl LastId      fixed;   call PID(Cue.Menu.Id.Table,0);   do i = 1 to Cue.Menu.Id.Table.Len-1;  /* Clear out id table (for delete) */      write(mdi)=0;   end;   /* Compute vertical line positions */   write("313")=addr(vlines(0));   do case format-1;      do; mr13i=1; mr13i=3250; end;      do; mr13i=2; mr13i=2650; mr13i=5350; end;      do; mr13i=4; mr13i=1550; mr13i=3150; mr13i=4750; mr13i=6350; end;      do; mr13i=7; mr13i= 950; mr13i=1950; mr13i=2950; mr13i=3950; mr13i=4950; mr13i=5950; mr13i=6950; end;      do; mr13i=1; mr13i=1550; end;      /* no longer used */      do; mr13i=2; mr13i=1550; mr13i=4750; end;      do; mr13i=3; mr13i=1550; mr13i=3650; mr13i=5750; end;      do; mr13i=5; mr13i=1550; mr13i=2850; mr13i=4150; mr13i=5450; mr13i=6750; end;   end;   /* Build icon for horizontal line layout */   write("313")=addr(lines(0));   mr13i = O#ICON.LineType;   mr13i = 1;       /* dotted lines    */   do i = 0 to size-2;      mr13i = O#ICON.Connect;      if format < 5 then mr13i =   -3;  /* For alpha */      else               mr13i =   -3;  /* For times */      /* NOTE: used to be 1553 -----^; changed since hardware scroll */      /* on Macintosh scrolls graphics icons with text - this   */      /* would cause bottom hor line of table to scroll up into */      /* time table */      mr13i = -(i*100); mr13i = 8010; mr13i = -(i*100);   end;   /* and for vertical line layout */   do i = 1 to vlines(0);      mr13i = O#ICON.Connect;      mr13i = vlines(i);      mr13i = 96;      mr13i = vlines(i);      mr13i = -((size-1)*100)+4;   end;   mr13i = O#ICON.End;   call Set.Auto.Allocation.Id(Cue.Menu.Alloc+100);   call Set.Default.Action(O#ACT.Middle.Press);   Cue.Menu.Grid.Lines = Define.Graphics.Icon(S#AA,0,row*100,0,lines);   /* now define the table(s) */   call Set.Default.Action(O#ACT.Middle.Press);   call Set.Default.Attr  (0,ATTR#Normal\ATTR#AltIntensity);   call Set.Default.Attr  (1,ATTR#Normal\ATTR#AltIntensity);   Cue.Menu.Name.Table.Type = Define.Label(S#AA,row,fdata(((format-1)*10)+2),fdata(((format-1)*10)+1),'');   call Set.Object.Action(Cue.Menu.Name.Table.Type,O#ACT.Prev.Obj,true);   Cue.Menu.Name.Table.Id = Define.Table(S#AA,fdata((format-1)*10),size,Cue.Menu.Name.Table.Type);   call Set.Object.Mouse.Access(Cue.Menu.Name.Table.Id,O#ACT.Left.Press|O#ACT.Middle.Press|O#ACT.Right.Press);   LastId = Cue.Menu.Name.Table.Id;   if format >= 5 then do;        /* define time table if approp */      Cue.Menu.Time.Table.Type = Define.Label(S#AA,row,0,16,'');      Cue.Menu.Time.Table.Id   = Define.Table(S#AA,1,size,Cue.Menu.Time.Table.Type);      call Set.Object.Mouse.Access(Cue.Menu.Time.Table.Id,0);      call Deposit.Object.Info(Cue.Menu.Time.Table.Id,O#TABL.Bits,Fetch.Object.Info(Cue.Menu.Name.Table.Id,O#TABL.Bits)\O#TABL.Bits.Hardware.Scroll);      LastId = Cue.Menu.Time.Table.Id;   end;   /* Only hardware scroll Name.Table if Time.Table does not exist */   /* Otherwise, let Time.Table scroll both tables on screen */   if format < 5 then do;      call Deposit.Object.Info(Cue.Menu.Name.Table.Id,O#TABL.Bits,Fetch.Object.Info(Cue.Menu.Name.Table.Id,O#TABL.Bits)\O#TABL.Bits.Hardware.Scroll);   end;     Cue.Menu.Columns = fdata((format-1)*10);   call Activate.Object.Range(Cue.Menu.Grid.Lines,LastId);   call Update.Object.Range  (Cue.Menu.Grid.Lines,LastId);end DEFINE.CUE.MENU.DISPLAY;dcl SET.CUE.MENU.PLACE.MODE  proc (fixed) recursive;DEFINE.CUE.MENU.PANEL: proc(row,size,format) swapable;   dcl row       fixed;  /* Top row */   dcl size      fixed;  /* Total rows including command bar */   dcl format    fixed;     dcl lines(64) fixed;  /* Neat lines for cue menu */   dcl (i,j)     fixed;   dcl mr13i     lit 'write("373")';   Cue.Menu.Row  = row;   Cue.Menu.Rows = size-2;   call Copy.String('CUE DIRECTORY',lines);   call Print.Panel.Title(row,lines);   i =  -((Cue.Menu.Size-2)*100);   j = i - 100;   write("313") = addr(lines(0));   mr13i = O#ICON.Connect; mr13i=- 10; mr13i=0; mr13i=8010; mr13i=  0;   mr13i = O#ICON.Connect; mr13i=1400; mr13i=0; mr13i=1400; mr13i=100;   mr13i = O#ICON.Connect; mr13i=3200; mr13i=0; mr13i=3200; mr13i=100;   mr13i = O#ICON.Connect; mr13i=6300; mr13i=0; mr13i=6300; mr13i=100;   mr13i = O#ICON.Connect; mr13i=- 10; mr13i=i; mr13i=8010; mr13i=  i;   mr13i = O#ICON.Connect; mr13i=1200; mr13i=i; mr13i=1200; mr13i=  j;   mr13i = O#ICON.Connect; mr13i=1800; mr13i=i; mr13i=1800; mr13i=  j;   mr13i = O#ICON.Connect; mr13i=2400; mr13i=i; mr13i=2400; mr13i=  j;   mr13i = O#ICON.Connect; mr13i=3100; mr13i=i; mr13i=3100; mr13i=  j;   mr13i = O#ICON.Connect; mr13i=3700; mr13i=i; mr13i=3700; mr13i=  j;   mr13i = O#ICON.Connect; mr13i=5800; mr13i=i; mr13i=5800; mr13i=  j;   mr13i = O#ICON.Connect; mr13i=6600; mr13i=i; mr13i=6600; mr13i=  j;   mr13i = O#ICON.End;   call Set.Auto.Allocation.Id (Cue.Menu.Alloc);  /* Reset autoallocation */   call Set.Default.Action(O#ACT.Middle.Press);   call Define.Graphics.Box(S#AA,gpos.x(-10),gpos.y((row-1)*100),gpos.x(8010),gpos.y((row+size-1)*100),0);   call Define.Graphics.Icon(S#AA,0,(row*100),0,lines);   call Load.Close.Box.Icon(lines);   Cue.Menu.Move.Box = Define.Graphics.Icon(S#AA,0,(row*100),1,lines);   call Set.Object.Mouse.Access(Cue.Menu.Move.Box, O#ACT.Middle.Press\O#ACT.Middle.Release);/* Cue.Menu.Size.Box = Define.Graphics.Icon(S#AA,0,((row+size-1)*100),1,lines); *//* call Set.Object.Mouse.Access(Cue.Menu.Size.Box, O#ACT.Middle.Press\O#ACT.Middle.Release); */   Cue.Menu.Scroll.Bar = Define.Scroll.Bar(S#AA,O#SBAR.Orient.Ver,O#SBAR.Just.Left,gpos.x(8010),gpos.y((row-1)*100),gpos.y((row+size-1)*100));   call Set.Default.Attr  (0,ATTR#Normal\ATTR#AltIntensity);   call Set.Default.Attr  (1,ATTR#Normal\ATTR#AltIntensity);   call Set.Default.Action(0);   call Define.Label(S#AA,row       , 1, 0,'Sort By');   call Define.Label(S#AA,row       ,15, 0,'Format');   call Define.Label(S#AA,row       ,33, 0,'Function');   call Define.Label(S#AA,row       ,56, 0,':');   call Define.Label(S#AA,row       ,64, 0,'Display');   call Define.Label(S#AA,row+size-1, 1, 0,'Cue Place:');   I   =Define.Label(S#AA,row+size-1,38, 0,'On Track:');   call PID(Cue.Menu.Place.Track.Label,I);   call Define.Label(S#AA,row+size-1,67, 0,'Cues:');   I  = Define.Fixed.Point(S#AA,row+size-1,72, 5, 0, cf#right);   call PID(Cue.Menu.Current.Cues,I);   call Set.Default.Attr  (0,ATTR#Normal);   call Set.Default.Attr  (1,ATTR#Reverse\ATTR#AltIntensity);   call Set.Default.Action(O#ACT.Middle.Press);   Cue.Menu.Sort.Switch     = Define.Switch(S#AA,row, 9, 4, 0,'Name|Time|Sync');   Cue.Menu.Format.Switch   = Define.Switch(S#AA,row,22, 9, 0,'Full Name|3 Columns|5 Columns|8 Columns');   Cue.Menu.Function.Switch = Define.Switch(S#AA,row,42,13, 0,'Recall & Play|Play Only|Recall Only|Poly Transfer');   Cue.Menu.Playback.Switch = Define.Switch(S#AA,row,58, 4, 0,'Poly|Mono');   Cue.Menu.Display.Switch  = Define.Switch(S#AA,row,72, 8, 0,'All Proj|Cur Proj');   I = Define.Switch(S#AA,row+size-1,37,21, 0,' PLACE by Dragging| REPLACE by Dragging| REPLACE and SYNC| INSERT in Chain| REPLACE in Chain');   call PID(Cue.Menu.Drag.Mode.Switch,I);   call Set.Object.Attr(I,0,ATTR#Normal|ATTR#Reverse|ATTR#AltIntensity);   call Set.Object.Attr(I,1,ATTR#Normal|ATTR#Reverse);   I = Define.Fixed.Point(S#AA,row+size-1,48, 3, 0, cf#right);   call PID(Cue.Menu.Place.Track.Field,I);   call Set.Object.Mouse.Access(I,O#ACT.Left.Press|O#ACT.Middle.Press|O#ACT.Right.Press);   call Set.Object.Attr        (I,0,ATTR#Normal\ATTR#Reverse\ATTR#AltIntensity);   call Set.Object.Attr        (I,1,ATTR#Normal|ATTR#Reverse);   call Set.Default.Attr  (0,ATTR#Normal|ATTR#AltIntensity);   call Set.Default.Attr  (1,ATTR#Normal|ATTR#AltIntensity);   call Set.Default.Action(O#ACT.Middle.Press|O#ACT.Prev.Obj);   call PID(Cue.Place.Mode,P#Drag);  /* always reset back to DRAG on startup */   I=Define.Label(S#AA,row+size-1,12, 0,' DRAG ');   call PID(Cue.Menu.Drag.Button,I);   I=Define.Label(S#AA,row+size-1,18, 0,' SYNC ');   call PID(Cue.Menu.Sync.Button,I);   I=Define.Label(S#AA,row+size-1,24, 0,' CHAIN ');   call PID(Cue.Menu.Chain.Button,I);   I=Define.Label(S#AA,row+size-1,31, 0,' REAL ');   call PID(Cue.Menu.Real.Button,I);   I=Define.Label(S#AA,row+size-1,58, 0,' Delete ');   call PID(Cue.Menu.Delete.Button,I);   call Activate.Object.Range(Cue.Menu.Alloc,GID(Cue.Menu.Delete.Button));   Disable.Deposits = true;   call Activate.Scroll.Bar(Cue.Menu.Scroll.Bar,0);   Disable.Deposits = false;   call Disable.Object(GID(Cue.Menu.Place.Track.Label)); /* don't want either displayed yet */   call Disable.Object(GID(Cue.Menu.Place.Track.Field));   Disable.Deposits = true;      call Deposit.Fixed.Point(GID(Cue.Menu.Current.Cues)     ,DTD.NUM.CUES);      call Deposit.Fixed.Point(GID(Cue.Menu.Place.Track.Field),GID(Cue.Place.Track)-1);      call Deposit.Switch     (GID(Cue.Menu.Drag.Mode.Switch) ,GID(Cue.Drag.Mode));      call Deposit.Switch(Cue.Menu.Sort.Switch, GID(Saved.CM.Sort.Switch));      if (Cue.Menu.Format < 5)      then call Set.Format.Str.To.Name.Str;      else call Set.Format.Str.To.Time.Str;      call Deposit.Switch(Cue.Menu.Format.Switch  , Cue.Menu.Format - 1);      call Deposit.Switch(Cue.Menu.Function.Switch, GID(Saved.CM.Function.Switch));    /* Recall & Play  */      call Deposit.Switch(Cue.Menu.Playback.Switch, GID(Saved.CM.Playback.Switch));    /* poly           */      call Deposit.Switch(Cue.Menu.Display.Switch , Default.CM.Display.Switch + GID(Saved.CM.Display.Switch));    /* All Projects   */      call Deposit.Scroll.Bar(Cue.Menu.Scroll.Bar , GID(Saved.CM.Scroll.Bar));    /* top            */   Disable.Deposits = false;   call Update.Object.Range(Cue.Menu.Alloc,GID(Cue.Menu.Delete.Button));   call Define.Cue.Menu.Display(Cue.Menu.Row+1,Cue.Menu.Rows,format);   /**** Note: Do not define any objects after here ****/   Cue.Menu.Group = Group.Objects(Cue.Menu.Group.Id,Cue.Menu.Alloc,Cue.Menu.Alloc+999,Get#Screen.Event);   call Set.Cue.Menu.Place.Mode(GID(Cue.Place.Mode)); /* set initial mode */end DEFINE.CUE.MENU.PANEL;OPEN.CUE.MENU.PANEL: proc (MaxSize) public swapable;   dcl MaxSize        fixed;   dcl (sid,row,size) fixed;  /*** Declare in Order ***/   dcl name.buf(40)   fixed;   if Cue.Menu.Group <> 0 then return;   if (MaxSize<=0) or (MaxSize>24) then MaxSize=10;   if Allocate.Screen.Space(5,MaxSize,loc(addr(sid))) then do;      call Set.Panel.Menu.Highlight(3,1);      call Set.AEE.Panel.Info      (3,row,size); /* find and set entry for panel */      Cue.Menu.Screen.Space = sid;      Cue.Menu.Size         = size-1;      Cue.Menu.Row          = row+1;      Cue.Menu.Format = Default.CM.Format + GID(Saved.CM.Format);  /* restore/init Format */      call Define.Cue.Menu.Panel(row+1,size-1,Cue.Menu.Format);      /* scroll bar position restored above from GID/PID */      call Update.Cue.Menu.Table(1,Fetch.Scroll.Bar(Cue.Menu.Scroll.Bar));   end;   else call Display.Notice(NT#NoMoreRoomOnScreen,ATTR#Normal,NulStr,0,0,0);end OPEN.CUE.MENU.PANEL;CLOSE.CUE.MENU.PANEL: proc public swapable;   if Cue.Menu.Group <> 0 then do;   /* Group is defined */      call Set.Panel.Menu.Highlight(3,0);      call Set.AEE.Panel.Info(3,0,0); /* mark entry as unused */      Cue.Menu.Screen.Space = Erase.Screen.Space(Cue.Menu.Screen.Space);      Cue.Menu.Group        = Ungroup.Objects(Cue.Menu.Group);      call Undefine.Object.Range(Cue.Menu.Alloc,Cue.Menu.Alloc+999);      call Select.New.Cur.Obj   (Corner.Label,-1,-1);   end;end CLOSE.CUE.MENU.PANEL;REFORMAT.CUE.MENU.PANEL: proc (format) swapable;   dcl format fixed;   call Erase.Object   (Cue.Menu.Name.Table.Id);   call Undefine.Object(Cue.Menu.Name.Table.Id);   call Undefine.Object(Cue.Menu.Name.Table.Type);   Cue.Menu.Name.Table.Id = 0;   Cue.Menu.Name.Table.Type = 0;   if Locate.Object(Cue.Menu.Time.Table.Id) <> 0 then do;      call Erase.Object   (Cue.Menu.Time.Table.Id);      call Undefine.Object(Cue.Menu.Time.Table.Id);      call Undefine.Object(Cue.Menu.Time.Table.Type);      Cue.Menu.Time.Table.Id = 0;      Cue.Menu.Time.Table.Type = 0;   end;   call Erase.Object   (Cue.Menu.Grid.Lines);   call Undefine.Object(Cue.Menu.Grid.Lines);   call Define.Cue.Menu.Display(Cue.Menu.Row+1,Cue.Menu.Rows,format);   Cue.Menu.Format  = format;end REFORMAT.CUE.MENU.PANEL;/* Call this procedure after loading a cue into SCSI.Ptr; Pass DTD.Cue# in cue.id */COMPUTE.CUE.MENU.CELL.ID: proc (col,row,format) returns (fixed) public swapable;   dcl col        fixed;  /* Transparent col of table */   dcl row        fixed;  /* Transparent row of table */   /* not used anymore */   dcl x          fixed;  /* Graphics X coordinate of cell (anywhere in the cell) */   dcl format     fixed;  /* Which format to use for decoding x */   dcl vlines(8)  fixed;   dcl i          fixed;   dcl mr13i      lit 'write("373")';   return GID(Cue.Menu.Id.Table + Cue.Menu.Rows*col + row);   /* old version: before 05/02/88 ... */   if format < 0 then format = Cue.Menu.Format;   do case format;      ; /* null */      do; vlines(0)=1; vlines(1)=3250; end;      do; vlines(0)=2; vlines(1)=2650; vlines(2)=5350; end;      do; vlines(0)=4; vlines(1)=1550; vlines(2)=3150; vlines(3)=4750; vlines(4)=6350; end;      do; vlines(0)=7; vlines(1)= 950; vlines(2)=1950; vlines(3)=2950; vlines(4)=3950; vlines(5)=4950; vlines(6)=5950; vlines(7)=6950; end;      do; vlines(0)=2; vlines(1)=1550; vlines(2)=4750; end;      do; vlines(0)=3; vlines(1)=1550; vlines(2)=3650; vlines(3)=5750; end;      do; vlines(0)=5; vlines(1)=1550; vlines(2)=2850; vlines(3)=4150; vlines(4)=5450; vlines(5)=6750; end;   end;   vlines(vlines(0)+1) = 8010;  /* The last lines=right edge of screen */   i = 0;   do while (i <= vlines(0)) & (x > gpos.x(vlines(i+1)));      i = i + 1;   end;   if i = 0 then do;     /* Between left edge of screen and first line */      if (format > 4)    /* First column is not a cue */      or (x < gpos.x(0)) /* Not on the table at all   */      then i = -1;   end;   else do;           /* One of the central elements or the rightmost element */      if i <= vlines(0) then do;         if format > 4 then i = i - 1;   /* Formats above 4--the leftmost column is not a cue */      end;      else i = - 1;  /* Off of the right edge of the table */   end;   if i <> -1 then return GID(Cue.Menu.Id.Table + Cue.Menu.Rows*i + row);   else            return 0;end COMPUTE.CUE.MENU.CELL.ID;MAP.PERCENT.TO.CUE.ROW: proc (percent) fixed swapable;   dcl percent      fixed;   dcl (i,j,k)      fixed;   dcl TotalNumRows fixed;   /* returns the row number that = (percent * total # of rows) */   /* (a number between 1 and TotalNumRows)                     */   if      percent<  0 then percent=0;   /* 0 <= percent < 1000 */   else if percent>999 then percent=999;   call Fetch.DTD.System.Info; /* get current vals for DTD.NUM.CUES & DTD.CP.CUES */   i = Fetch.Switch(Cue.Menu.Display.Switch);   if i = 0 then j = DTD.NUM.CUES;   else          j = DTD.CP.CUES;   if j = 0 then return 0;    /* scrolling disabled */   /* Scroll bar mapping: Box should be at bottom when last cue is in top row */   if Cue.Menu.Format < 5 then do;      TotalNumRows = ((j-1)/Cue.Menu.Columns)+1; /* total possible number of rows */   end;   else TotalNumRows = j;            /* only one cue per row in time formats */   load      TotalNumRows;   mul       percent;             mwait;   div       1000;   k       = res + 1;   return k;end MAP.PERCENT.TO.CUE.ROW;COMPUTE.TOP.TIME.CUE.FROM.PERCENT: proc (percent,sort,format) returns (fixed) swapable;   dcl percent           fixed;   dcl sort              fixed;  /* Type of time sort: 0 - N/A  1 - Time  2 - Sync */   dcl format            fixed;   dcl top.row           fixed;  /* first row = 0, second row = 1, etc. */   /* Assumes LOD Running */   top.row=Map.Percent.To.Cue.Row(percent)-1;   if top.row < 0    /* not enough cues to enable scrolling */   then return -1;   else return top.row;end COMPUTE.TOP.TIME.CUE.FROM.PERCENT;DEPOSIT.TIME.CUE.TABLE: proc (top.cue,top.row,bot.row,sort,format) swapable;   dcl top.cue        fixed; /* Nth cue to start filling table with     */   dcl top.row        fixed; /*       0 <= top.row <= bot.row           */   dcl bot.row        fixed; /* top.row <= bot.row <= (Cue.Menu.Rows-1) */   dcl sort           fixed; /* 1=by disk time; 2=by sync time          */   dcl format         fixed; /* should be Cue.Menu.Format               */   dcl cue            fixed;   dcl row            fixed;   dcl col            fixed;   dcl maxcol         fixed;   dcl maxlen         fixed;   dcl col#           fixed;   dcl loc.dtd.cue    fixed;   dcl name.buf(40)   fixed; /* string to hold cue name */   dcl time.buf(13)   fixed; /* string to hold cue time */   dcl smpte.time(4)  fixed;   dcl tmp.str(16)    fixed;   dcl this.time(1)   fixed;   dcl last.time(1)   fixed;   dcl tmp(4)         fixed;   dcl new.time       fixed;   dcl (i,j)		  fixed;   dcl mode           fixed;   dcl cuebits        fixed;   /* new format as of 5/10/88: */   dcl fdata        data (1,    64,    16,  0,  0,  0,  0);   /*  fdata key:         Cols, Chars, Col positions       *//* dcl fdata        data (2,    30,    16, 48,  0,  0,  0,                          3,    19,    16, 37, 58,  0,  0,                          5,    11,    16, 29, 42, 55, 68); */   /* Assumes lod running */   Disable.Deposits = true;   if (sort = 1) or (sort = 2) then do;  /* Not valid for other modes */      format  = format - 5;   /* translate */      maxcol  = fdata(format*7);      maxlen  = fdata(format*7+1);      cue     = top.cue;      row     = top.row;      col     = 0;      last.time(0) = -1;      last.time(1) = -1;      do i = 1 to 40;         name.buf(i) = a.sp\shl(a.sp,8);      end;      write(mam) = SCSI.Ptr; /* zero SCSI ptr */      rpc 255;      write(mdi) = 0;      call SET.DTD.SCROLL.RANGE(Fetch.Switch(Cue.Menu.Display.Switch));      if sort = 1 then call Fetch.Nth.Time.DTD.Cue(cue);      else             call Fetch.Nth.Sync.DTD.Cue(cue);      loc.dtd.cue = DTD.Cue#;      do while (row <= bot.row);         /* (row,col) should be pointing to the next cell we will */         /* be depositing into.  */         if loc.dtd.cue <> 0 then do;  /* Fetch got a cue */            write(mam) = SCSI.Ptr;            if sort = 1 then do;           /* sort on cue in time:  get */               write(mal) = CUE.IN.S#.MSB; /* in sample # and convert   */               this.time(0) = read(mdi);   /* to absolute time on disk. */               this.time(1) = read(mdi);               call DTD.Sample.#.To.Msecs(This.Time, CF#Time, S$Speed, AEE.Current.Project.Rate, zero.zero, This.Time);            end;            else do;                       /* else sort by sync time    */               write(mal) = CUE.SMPT.MSB;               this.time(0) = read(mdi);               this.time(1) = read(mdi);               write(mal) = CUE.SMPT.MODE;               mode       = read(md);               write(mal) = CUE.BITS;               cuebits    = read(md);               if (cuebits & bit3) = 0      /* cue.smpt.msb is relative to smpte offset */               then call SBITS.TO.MSEC(this.time ,cf#time, SAMP.SPEED, mode, this.time);               else do;                  call SBITS.TO.SMPTE(this.time, mode, tmp.str);                  call SMPTE.TO.MSEC (tmp.str, cf#time, SAMP.SPEED, SM.MODE, loc(addr(SM.HRS)), this.time);                  /* allow minus times here,  since they are just displayed */               end;            end;            /* put each cue on a separate line - 5/10/88 */            if row <= bot.row then do;      /* Make sure we're still in table */               do case AEE.Time.Format;                  do; /* Seconds */                     call MSEC.TO.SEC(this.time,cf#time,tmp);                     call CONV.SEC.MSEC.TO.STR(tmp,tmp.str,cf#default,cf#default);                  end;                  do; /* Beats */                     call Map.Real.Time.To.Sequence.Time(this.time, this.time);                     if  (Click.Track.Mode igt 3)                     then do;                        call Remap.With.Live.Click(this.time(0), this.time(1),                                                   0, 0, 1);                        call MSEC.TO.BEATS(loc(addr(Remapped.Time.Msb)),cf#time,1000,tmp);                     end;                     else call Map.Sequence.Time.To.Beats(this.time,tmp);                     call CONV.BEATS.TO.STR(tmp,tmp.str,cf#default,cf#default);                  end;                  do; /* Measures:Beats */                     call Map.Real.Time.To.Sequence.Time(this.time, this.time);                     if  (Click.Track.Mode igt 3)                     then do;                        call Remap.With.Live.Click(this.time(0), this.time(1),                                                   0, 0, 1);                        call MSEC.TO.BEATS(loc(addr(Remapped.Time.Msb)),cf#time,1000,tmp);                     end;                     else call Map.Sequence.Time.To.Measures.Beats(this.time,tmp);                     i = Lookup.Beats.Per.Measure(this.time);                     call CONV.MEASURES.BEATS.TO.STR(tmp,i,tmp.str,cf#default,cf#default);                  end;                  do; /* SMPTE */                     call MSEC.TO.SMPTE(this.time,0,S$Speed,S$SMode,S$SOffset,smpte.time);                     call CONV.SMPTE.TO.STR(smpte.time,tmp.str,cf#default,cf#default);                  end;                  do; /* Feet:Frames */                     call MSEC.TO.FEET(this.time,cf#time,S$Speed,S$FMode,S$FOffset,tmp);                     call CONV.FEET.TO.STR(tmp,tmp.str,cf#default,cf#default);                  end;                  do; /* Minutes:Seconds */                     call MSEC.TO.SEC(this.time, cf#time, tmp);                     call CONV.SEC.MSEC.TO.MIN.SEC.STR(tmp, tmp.str, cf#default, cf#default);                  end;               end;               call COPY.STRING(' ', time.buf);               call APPEND.TO.STR(time.buf, tmp.str);               call Fetch.Table  (Cue.Menu.Time.Table.Id,0,row);               call Deposit.Label(Cue.Menu.Time.Table.Type,time.buf);               call Deposit.Table(Cue.Menu.Time.Table.Id,0,row);               call PID(Cue.Menu.Id.Table + row, loc.dtd.cue);               write(mam) = SCSI.Ptr;               write(mal) = CUE.NAME;               call Copy.In(addr(name.buf(0)),17);               if name.buf(0) IGT maxlen then name.buf(0) = maxlen;               /* get cue caption if there is room */               if maxlen >= 40 then do;                  do i = name.buf(0) to 32;                     call pbyte(name.buf, i, a.sp);                  end;                  name.buf(0) = 33;                  call FETCH.CUE.CAPTION(loc.dtd.cue, misc.buf);                  if name.buf(0) + misc.buf(0) IGT maxlen                  then misc.buf(0) = maxlen - name.buf(0);                  call APPEND.TO.STR(name.buf, misc.buf);               end;               call Fetch.Table  (Cue.Menu.Name.Table.Id,0,row);               call Deposit.Label(Cue.Menu.Name.Table.Type,name.buf);               call Deposit.Table(Cue.Menu.Name.Table.Id,0,row);               row = row + 1;            end;         end;         else do;  /* clear out rest of display */            time.buf(0) = 0;            name.buf(0) = 0;            if row <= bot.row then do;               do j = row to bot.row; /* clear out remaining rows */                  call Fetch.Table  (Cue.Menu.Time.Table.Id,0,j);                  call Deposit.Label(Cue.Menu.Time.Table.Type,time.buf);                  call Deposit.Table(Cue.Menu.Time.Table.Id,0,j);                  call Fetch.Table  (Cue.Menu.Name.Table.Id,0,j);                  call Deposit.Label(Cue.Menu.Name.Table.Type,name.buf);                  call Deposit.Table(Cue.Menu.Name.Table.Id,0,j);                  call PID(Cue.Menu.Id.Table + j, 0);               end;            end;            row = bot.row + 1;   /* get out of loop */         end;         cue = cue + 1;         /* Go on to next cue */         call Check.Next.Event; /* keep mouse going */                  if   (loc.dtd.cue <> 0)        /* get next cue if not at end of list */         and  (row <= bot.row) then do; /* and still in table */            write(mam) = SCSI.Ptr; /* zero SCSI ptr */            rpc 255;            write(mdi) = 0;            call SET.DTD.SCROLL.RANGE(Fetch.Switch(Cue.Menu.Display.Switch));            if sort = 1 then call Fetch.Nth.Time.DTD.Cue(cue);            else             call Fetch.Nth.Sync.DTD.Cue(cue);            loc.dtd.cue = DTD.Cue#;         end;      end;   end;   Disable.Deposits = false;end DEPOSIT.TIME.CUE.TABLE;COMPUTE.TOP.ALPHA.CUE.FROM.PERCENT: proc (percent,format) returns (fixed) swapable;   dcl percent      fixed;   dcl format       fixed;   dcl top.row      fixed;  /* first row = 0, second row = 1, etc. */   dcl top.cue      fixed;    /* Returns the Nth cue corresponding to percent of total cues */   /* Assumes LOD Running */   top.row = (Map.Percent.To.Cue.Row(percent)-1);   if top.row < 0 then return -1; /* not enough cues to enable scrolling */   load top.row;    mul  Cue.Menu.Columns;   top.cue = res;   return top.cue;end COMPUTE.TOP.ALPHA.CUE.FROM.PERCENT;DEPOSIT.ALPHA.CUE.TABLE: proc (top.cue,top.row,bot.row,format) swapable;   dcl top.cue        fixed; /* Nth cue to start filling table with     */   dcl top.row        fixed; /*       0 <= top.row <= bot.row           */   dcl bot.row        fixed; /* top.row <= bot.row <= (Cue.Menu.Rows-1) */   dcl format         fixed; /* should be Cue.Menu.Format               */   dcl name.buf(40)   fixed;   dcl cue            fixed;   dcl cue.len        fixed;   dcl row            fixed;   dcl col            fixed;   dcl maxcol         fixed;   dcl maxlen         fixed;   dcl col#           fixed;   dcl loc.dtd.cue    fixed;   dcl tmp.str(40)    fixed;   dcl (i,j)		  fixed;   /*  FDATA KEY:      Cols, Chars,  Column positions             */   dcl fdata     data (1,    32,     0, 33,  0,  0,  0,  0,  0,  0, /* caption is 47 chars */                       3,    26,     0, 27, 54,  0,  0,  0,  0,  0,                       5,    15,     0, 16, 32, 48, 64,  0,  0,  0,                       8,     9,     0, 10, 20, 30, 40, 50, 60, 70);   /* Assumes lod running */   /* error checking first */   if (top.row < 0) or (bot.row < 0) then return;   if bot.row igt (Cue.Menu.Rows-1) then bot.row = Cue.Menu.Rows-1;   if top.row igt bot.row then top.row = bot.row;   Disable.Deposits = true;   format  = format - 1;   /* translate */   maxcol  = fdata(format*10);   maxlen  = fdata(format*10+1);   cue     = top.cue;   row     = top.row;   col     = 0;   /* get first cue to start */   write(mam) = SCSI.Ptr; /* zero SCSI ptr */   rpc 255;   write(mdi) = 0;   call SET.DTD.SCROLL.RANGE(Fetch.Switch(Cue.Menu.Display.Switch));   call Fetch.Nth.Alpha.DTD.Cue(cue);   loc.dtd.cue = DTD.Cue#;   do while (row <= bot.row);      /* (row,col) should be pointing to the next cell we will */      /* be depositing into.  If col=maxcol, it will be reset  */      /* to 0 before we try to deposit a name.                 */      if loc.dtd.cue <> 0 then do;  /* Fetch got a cue */         if col = maxcol then do; /* advance to next row if at end */            col = 0;            row = row + 1;         end;         if row <= bot.row then do;            write(mam) = SCSI.Ptr;            write(mal) = CUE.NAME;            call Copy.In(addr(name.buf(0)),17);            if name.buf(0) > maxlen then name.buf(0) = maxlen;            call PID(Cue.Menu.Id.Table + Cue.Menu.Rows*col + row, loc.dtd.cue);            /* deal with name+comment format */            if format = 0 then do;               do i = name.buf(0) to maxlen; /* space fill name field, plus 1 space */                  call pbyte(name.buf,i,a.sp);               end;               name.buf(0) = maxlen+1;               call FETCH.CUE.CAPTION(loc.dtd.cue, misc.buf);               if name.buf(0) + misc.buf(0) IGT 80               then misc.buf(0) = 80 - name.buf(0);               call APPEND.TO.STR(name.buf, misc.buf);            end;            call Fetch.Table  (Cue.Menu.Name.Table.Id,col,row);            call Deposit.Label(Cue.Menu.Name.Table.Type,name.buf);            call Deposit.Table(Cue.Menu.Name.Table.Id,col,row);            col = col + 1;         end;      end;      else do;  /* clear out rest of display */         name.buf(0) = 0;         if col < maxcol then do;            do i = col to maxcol-1;        /* clear out rest of row */               call Fetch.Table  (Cue.Menu.Name.Table.Id,i,row);               call Deposit.Label(Cue.Menu.Name.Table.Type,name.buf);               call Deposit.Table(Cue.Menu.Name.Table.Id,i,row);               call PID(Cue.Menu.Id.Table + Cue.Menu.Rows*i + row, 0);            end;         end;         else col = 0;                     /* col was at maxcol */         row = row + 1;         if row <= bot.row then do;            do j = row to bot.row;     /* clear out remaining rows */               do i = 0 to maxcol-1;                  call Fetch.Table  (Cue.Menu.Name.Table.Id,i,j);                  call Deposit.Label(Cue.Menu.Name.Table.Type,name.buf);                  call Deposit.Table(Cue.Menu.Name.Table.Id,i,j);                  call PID(Cue.Menu.Id.Table + Cue.Menu.Rows*i + j, 0);               end;            end;         end;         row = bot.row + 1;   /* get out of loop */      end;      cue = cue + 1;         /* Go on to next cue */      call Check.Next.Event; /* keep mouse going */      if   (loc.dtd.cue <> 0)        /* get next cue if not at end of list */      and  (row <= bot.row) then do; /* and still in table */         write(mam) = SCSI.Ptr;         rpc 255;         write(mdi) = 0;         call SET.DTD.SCROLL.RANGE(Fetch.Switch(Cue.Menu.Display.Switch));         call Fetch.Nth.Alpha.DTD.Cue(cue);         loc.dtd.cue = DTD.Cue#;      end;   end;   Disable.Deposits = false;end DEPOSIT.ALPHA.CUE.TABLE;UPDATE.CUE.MENU.TABLE: proc (parm,n) public swapable;  /* uses Cue.Menu globals to construct a new display */   dcl parm    fixed;  /* 0: n = position  1: n = percent */   dcl n       fixed;  /* position or percent based on what is passed in format */   dcl j       fixed;   dcl TotalRows fixed;  /* used in case we have to reposition the scroll bar box */   /* update flag area in case we are */   /* showing cues in flag area       */   call Set.Shuttle.Flags.And.Edits;     /* do always, even if cue menu not up */   if Cue.Menu.Group = 0 then return;   if n < 0 then do;      if parm = 0 then do;         /* check to make sure Cue.Menu.Position is still valid */         /* (cues may have been deleted since we checked last,  */         /* or we may have changed projects)                    */         call Fetch.DTD.System.Info;      /* get new globals */         if (Fetch.Switch(Cue.Menu.Display.Switch)=0)         then j = DTD.NUM.CUES;         else j = DTD.CP.CUES;         TotalRows = ((j-1)/Cue.Menu.Columns)+1;         if Cue.Menu.Position > (j-1) then do;            /* reset current position to last row */            Cue.Menu.Position = (TotalRows - 1)*Cue.Menu.Columns;         end;         if TotalRows ile Cue.Menu.Rows          then Cue.Menu.Position = 0;    /* scrolling is disabled */         /* update the scroll bar box position */         load  Cue.Menu.Position;         div   Cue.Menu.Columns;                 mwait;         mul   1000;                             mwait;         div   TotalRows;                        mwait;         Disable.Deposits = true;         call Deposit.Scroll.Bar(Cue.Menu.Scroll.Bar,res);         Disable.Deposits = false;         n = Cue.Menu.Position;      end;      else n = Fetch.Scroll.Bar(Cue.Menu.Scroll.Bar);   end;   call Set.DTD.Scroll.Range(Fetch.Switch(Cue.Menu.Display.Switch));   if Cue.Menu.Format < 5 then do;  /* Alpha format */      if parm = 1 then n = COMPUTE.TOP.ALPHA.CUE.FROM.PERCENT(n,Cue.Menu.Format);      if n < 0 then n = 0;          /* not enough cues to scroll with */      call Deposit.Alpha.Cue.Table(n,0,Cue.Menu.Rows-1,Cue.Menu.Format);   end;   else do;                         /* Time format  */      if parm = 1 then n = COMPUTE.TOP.TIME.CUE.FROM.PERCENT(n,Cue.Menu.Sort,Cue.Menu.Format);      if n < 0 then n = 0;          /* not enough cues to scroll with */      call Deposit.Time.Cue.Table(n,0,Cue.Menu.Rows-1,Cue.Menu.Sort,Cue.Menu.Format);   end;   Cue.Menu.Position = n;   call Fetch.DTD.System.Info;      /* to update DTD.NUM.CUES */   Disable.Deposits = true;      if (Fetch.Switch(Cue.Menu.Display.Switch)=0)      then call Deposit.Fixed.Point(GID(Cue.Menu.Current.Cues),DTD.NUM.CUES);      else call Deposit.Fixed.Point(GID(Cue.Menu.Current.Cues),DTD.CP.CUES);   Disable.Deposits = false;end UPDATE.CUE.MENU.TABLE;