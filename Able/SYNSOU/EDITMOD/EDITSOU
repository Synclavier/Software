/*	:SYNSOU:EDITMOD:EDITSOU - $title - MAIN Module for: Sequence Editor Screen	*//*Modified:2001/09/09 - TY  - If no time display mode was set from the G-page or by the .SDEF-7 file, it will be set to						 match that of the VK keyboard rather than arbitrarily defaulting to meas:beats. 2001/02/13 - TY  - Fixed an ancient bug: when initializing, time fields weren't replotted with correct format 1998/06/14 - TY  - Changed initial RTE type back to Ped1.  (Lee Kopp objected... shit.)1998/04/22 - TY  - Made "Change RTE" and "Change Velocity" initialize to Scale instead of Set.						 Also made RTE type initialize to ModW.1990/08/27 - PF  - Support all MIDI controllers1990/01/11 - MWH - Clean up handling of MIDI mapping with MIDInet ON & OFF1988/09/07 - eg  - set new.ABLE.seq.info1988/06/29 - MWH - Remove unused inserts1988/01/05 - eg  - split editsou into 2 parts1987/03/04 - eg  - created this file*/module editmod;	insert ':synlits:comlits';	insert ':synlits:globlits';	insert ':synlits:asciilit';	insert ':synauxs:editlits';	/*	literals for this module	*/	/*	get libraries	*/	insert ':synmods:globdcl';	insert ':synmods:ttydcl';	insert ':synmods:plotdcl';	insert ':synmods:errdcl';	insert ':synmods:getdcl';	insert ':synmods:getvdcl';	insert ':synmods:tformdcl';	insert ':synmods:tprimdcl';	insert ':synmods:linkdcl';	insert ':synmods:giddcl';	insert ':synmods:smgrdcl';	insert ':synmods:mathdcl';	insert ':synmods:seqdcl';	insert ':synrdcls:03-pdcls';	/*	From 05-bdcls	*/	DCL (POLY.TIMBRE.MIDI.CONTROL)	FIXED EXTERNAL;	DCL (OMS.MIDI.ENABLED        )	FIXED EXTERNAL;	DCL (MIDI.INPUT.ENABLED      )	FIXED EXTERNAL;	insert ':synrdcls:12-edcls';	INSERT ':SYNMODS:EDITADCL';			/*	get dcls for FIRST half		*/	INSERT ':SYNMODS:EDITBDCL';			/*	get dcls for SECOND half	*/	dcl not.first.time	boolean;			/* true if first time on screen has already been performed */	insert ':synsou:editmod:submenus';	/*	general sub-menu handler	*/	insert ':synsou:editmod:editscrn';	/*	definition & plotting code	*/	/*	main initialization routine for sequence editor	*/	INITIALIZE.EDIT.SCREEN: proc swapable;		call init.pid.gid.area;		current.sub.menu = -1;	/*	id# of last submenu chosen	*/		current.display = -1;	/*	id# of last display chosen	*/		current.dialog  = gid(sav.cur.dialog);	/*	id# of last dialog box		*/		call STR32(0,	 0, Screen.Begin		  );		call STR32(0,	 0, Cursor.Begin		  );		call STR32(-1,	-1, Screen.End			  );		call STR32(-1,	-1, Cursor.End			  );		call STR32(0,	 0, Screen.Scroll.Begin);		call STR32(0,	 0, Cursor.Scroll.Begin);		call STR32(-1,	-1, Screen.Scroll.End  );		call STR32(-1,	-1, Cursor.Scroll.End  );	end INITIALIZE.EDIT.SCREEN;	INITIALIZE.EDIT.FILTER: proc swapable;		//	Because the edit filter can used by other S-page dialogs without the edit filter dialog itself having been opened,		//	its parameters are initialzed when the S-page starts up rather than when the dialog is opened.		//	These parameters are stored in global internal memory variables declared in ":SYNRSOU:12-EDIT:CUT".		//	Consequently the edit filter does not use the external memory gid/pid area to save its state when its dialog		//	is not active, and therefore no CLOSE.FILTER.DIALOG() routine is needed.		apply.filter			= false;	//	true if filter should be applied to region and cut/paste functions		//	switch positions		check.pitches			= 0;		//	All Pitches		check.vel				= 0;		//	All Velocities		check.dur				= 0;		//	All Durations		check.ctrl				= 0;		//	All Controllers		check.monopolar.val	= 0;		//	All monopolar RTE Controller Values		check.bipolar.val		= 0;		//	All bipolar RTE Controller Values		check.midi.val			= 0;		//	All MIDI Controller Values		//	3 controllers to filter		ctrl1						= -1;		//	no controller		ctrl2						= -1;		//	no controller		ctrl3						= -1;		//	no controller		//	midi controllers to filter		midi.ctrl1				= 0;		midi.ctrl2				= 0;		midi.ctrl3				= 0;		//	pitch boundaries		pitch.lo					= 0;		//	C0		pitch.hi					= 84;		//	C7		//	velocity boundaries		vel.lo					= 0;		vel.hi					= rte.max;		//	monopolar rte controller value boundaries		monopolar.lo			= 0;		monopolar.hi			= rte.max;		//	bipolar rte controller value boundaries		bipolar.lo				= -100;		bipolar.hi				= 100;		//	midi controller value boundaries		midi.lo					= 0;		midi.hi					= 127;		//	duration boundaries (32bit)		copy32(zero.zero,		dur.lo);		copy32(max.duration,	dur.hi);	end INITIALIZE.EDIT.FILTER;	/*	routine to save important screen info and clean up berfore exiting	*/	SAVE.SETTINGS.AND.CLEANUP: proc swapable;		dcl i			fixed;		dcl time(1)	fixed;		not.first.time = true;			/*	flag so we know we've been here	*/		/*	first save current edit times	*/		Fetch.32Bit.Msec(gid(time1), time); pid32(sav.time1.ms, time);		Fetch.32Bit.Msec(gid(time2), time); pid32(sav.time2.ms, time);		Fetch.32Bit.Msec(gid(time3), time); pid32(sav.time3.ms, time);		/*	save time display mode & set valid flag	*/		call pid(sav.time.mode, Fetch.Switch(gid(time.mode.switch)));		/*	save contents of memories	*/		do i = 0 to 7;			call pid(sav.mem.ms+i, mem.ms(i));			call pid(sav.mem.ls+i, mem.ls(i));		end;		call close.dialog;		/*	closing dialog saves current state in ext mem	*/		call Set.Term.Attr(ATTR#Normal);	end SAVE.SETTINGS.AND.CLEANUP;	RESTORE.SETTINGS: proc swapable;		dcl i					fixed;		dcl time		(1)	fixed;		dcl duration(1)	fixed;		dcl first			fixed;		dcl tmpbits			fixed;		/*	first restore saved edit times	*/		gid32(sav.time1.ms, time); Deposit.32Bit.Msec(gid(time1), time, Zero.Zero);		gid32(sav.time2.ms, time); Deposit.32Bit.Msec(gid(time2), time, Zero.Zero);		/*	store edit duration in time3 (or store paste time if cutpaste)	*/		gid32(sav.time3.ms, duration);		if gid(sav.cur.dialog) == D#CutPaste		then Deposit.32Bit.Msec(gid(time3), duration, Zero.Zero);		else Deposit.32Bit.Msec(gid(time3), time, duration);		/*	restore time display mode	*/		call Deposit.Switch(gid(time.mode.switch), gid(sav.time.mode));		call run.syn.loop;	/*	keep things going	*/		/*	restore contents of memories	*/		do i = 0 to 7;			mem.ms(i) = gid(sav.mem.ms+i);			mem.ls(i) = gid(sav.mem.ls+i);			if ((mem.ms(i)\mem.ls(i)) <> 0)			/*	reverse to indicate filled	*/			then call Set.Table.Cell.Attr(gid(mem.buttons), i, 0, 0, Attr#Reverse\Attr#AltIntensity);			else call Set.Table.Cell.Attr(gid(mem.buttons), i, 0, 0, Attr#NoReverse\Attr#RegIntensity);			call Update.Object(gid(mem.buttons));		end;		if (undo.enabled=false)							/*	erase button if undo is off	*/		then do;			call Erase.Object  (gid(undo.button));			call Disable.Object(gid(undo.button));		end;		call run.syn.loop;	/*	keep things going	*/		info.on = info.mode;				/*	set to same mode as synclavier global	*/		call set.info.display;			/*	display appropriate state on trkmgr		*/		/***	if mg600 then do;						*/	/*	for pericom, need to fake out		*/		/***		tmpbits = gid(dispbits);		*/	/*	the screen manager, because		*/		/***		call Update.Buttons;				*/	/*	highlight.object only does a		*/		/***		call pid(dispbits, tmpbits);	*/	/*	complement mode re-draw of icons	*/		/***	end;										*/		call update.buttons(true);		/*	Set bit to cause update of the entire screen.			*/		/*	We do not need to create a system event at this time:	*/		new.ABLE.seq.info = new.ABLE.seq.info\8;		current.dialog = gid(sav.cur.dialog);		/*	id# of last dialog box		*/		if (current.dialog = 0) then return;		/*	finished restoring things	*/		call Set.Auto.Allocation.Id(dialog.base);	/*	reset where auto-allocation begins	*/		do case (current.dialog);			;			call open.bounce.dialog;			call open.change.dur.dialog;			call open.change.pitch.dialog;			call open.change.rte.dialog;			call open.change.vel.dialog;			call open.cut.paste.dialog;			call open.filter.dialog;			call open.fit.time.dialog;			call open.justify.dialog;			call open.midi.dialog;			call open.setup.dialog;			call open.seq.storage.dialog;			call open.smt.skt.dialog;			call open.trk.solos.dialog;			call open.trk.vol.dialog;			call open.unwrap.dialog;		end;	end RESTORE.SETTINGS;	/*	$PAGE - MAIN driver for Sequence Editor Screen	*/	SEQ.EDIT.SCREEN:proc (arg) public swapable;		dcl arg					fixed;	/*	argument - must pass 0 for now	*/		dcl event				fixed;		dcl start_time	(1)	fixed;		dcl end_time	(1)	fixed;		dcl duration	(1)	fixed;		if (gtype=0) then do;			call no.graphics.terminal;			return (-1);		end;		call Initialize.Edit.Screen;	/*	set up some fields, etc.	*/		call Define.Edit.Screen;		/*	define screen					*/		if (not.first.time != false)		then call Restore.Settings;	/*	only want to do this if settings have been saved	*/		else do;			disable.deposits = true;			/*	set up edit times (may have been set on g-screen	*/			gid32(sav.time1.ms, start_time);			if ((start_time(0) | start_time(1)) == 0) start_time(1) = zero.time;			call Deposit.32Bit.Msec(gid(time1), start_time, Zero.Zero);			gid32(sav.time2.ms, end_time);			if ((end_time(0) | end_time(1)) == 0) end_time(1) = zero.time;			call Deposit.32Bit.Msec(gid(time2), end_time, Zero.Zero);			call SUB32(end_time, start_time, duration);			call Deposit.32Bit.Msec(gid(time3), start_time, duration);			/* default to the display mode set by the G-page or the .SDEF-7 file */			write("313")	= gid(sav.time.mode);			if (read("313") < 0)	/* (haven't been to the G-page yet) && (no preference stored in .SDEF-7)	*/			{				if (gid(saved.aee.time.format) < 0)	/* haven't been to the Q-page yet	*/				{	/* default to the display mode currently set on the VK keyboard */					do case TRACK.FORMAT;						write("313")	= 2;	//	case 0: BEATS				->	2: beats						write("313")	= 3;	//	case 1: MEASURES/BEATS	->	3: measures/beats						write("313")	= 0;	//	case 2: SECONDS			->	0: seconds						write("313")	= 4;	//	case 3: SMPTE				->	4: smpte					end;				}				else				{	/* default to the display mode currently set on the Q-page */					do case gid(saved.aee.time.format);						write("313")	= 0;	//	case 0: Seconds			->	0: seconds						write("313")	= 2;	//	case 1: Beats				->	2: beats						write("313")	= 3;	//	case 2: Meas:Beats		->	3: measures/beats						write("313")	= 4;	//	case 3: SMPTE				->	4: smpte						write("313")	= 5;	//	case 4: Feet:Frames		->	5: feet:frames						write("313")	= 1;	//	case 5: Mins:Seconds		->	1: min:sec					end;				}			}			//	NOTE: THIS CALL ALONE DOESN'T FORCE THE EDIT TIMES TO CHANGE FORMAT!			//	That must be done indirectly by setting the "new constant" bit of new.able.seq.info at the end of this block			Deposit.Switch(gid(time.mode.switch), read("313"));			disable.deposits = false;			call initialize.edit.filter;			undo.enabled = true;				/*	have it available unless switched off	*/			//	Set bit to cause update of time fields since the time mode has been changed above.			new.ABLE.seq.info = new.ABLE.seq.info|8;		end;		call run.syn.loop;	/*	keep things going	*/		call update.click.state.vars;		/*	update variables based on click.track.mode	*/		call update.click.switches;		/*	actually change switches							*/		EXIT.MY.SCREEN   = false;			/*	clear these flags before loop	*/		GOTO.THIS.SCREEN = 0;		call Get_Enable(get.ertyp);		call Get_Enable(get.program.exit);		call Get_Enable(get.new.seq.info);	/*	new seq notes/constants	*/		do while EXIT.MY.SCREEN = false;			if event <> Get.Null.Event then do;				if Screen.Event.Group = 0 then do;	/*	something happened that this level cares about	*/					if  (Screen.Event.Code = get.in.char) then do;						if (Screen.Event.Info = esc)						then exit.my.screen = true;					end;					else if (Screen.Event.Code = get.new.seq.info) then do;						/*	If a "new constants" event	*/						if (next.event.info & 8) <> 0	/*	Somebody may have changed MIDI input routing	*/						AND current.dialog = D#Midi	/*	And we're trying to display it now	*/						then do;							call Fill.Midi.In.Table;	/*	Update the MIDI mapping display		*/							/*	Define value as switch if changable (for OLD midi) or LABEL otherwise	*/							call Undefine.Object(gid(poly.timbre.switch));							if MAX.MIDINET.CHAN = 0 then do;								call Define.Switch(gid(poly.timbre.switch),dialog.top+2, dialog.col+45,8,0,'Keyboard|Recorder');								disable.deposits = true;								call Deposit.Switch(gid(poly.timbre.switch),poly.timbre.midi.control);								disable.deposits = false;							end;							else call Define.Label (gid(poly.timbre.switch),dialog.top+2, dialog.col+50,0,'Recorder');							call Set.Object.Status(gid(poly.timbre.switch),O#STAT.Enable,1);						end;					end;					else if (Screen.Event.Code = get.program.exit)					then exit.my.screen = true;					else if (Screen.Event.Code = get.ertyp) then do;			/*	an error occurred	*/						if Screen.Event.Info then do;							call Display.Error.Message(Latched.Ertyp, 0, 1);	/*	ertyp - display error here	*/							err.time = real.milliseconds;						end;					end;					event = Get.Null.Event;			/*	reset event	*/				end;				/*				else if (Screen.Event.Group = debug.grp)				then event = Get.Debug.Event(event);				*/				else if (Screen.Event.Group = main.menu.grp)				then event = Get.Main.Menu.Event(event);				else if (Screen.Event.Group = times.grp)	/*	cur.play.time, edit times	*/				then event = Get.Time.Event(event);				else if (Screen.Event.Group = button.grp)	/*	rec buttons, ok/cancel		*/				then event = Get.Button.Event(event);				else if (Screen.Event.Group = current.display.grp)				then event = Get.Display.Event(event);				else if (Screen.Event.Group = current.dialog.grp)				then event = Get.Dialog.Event(event);				else if (Screen.Event.Group = current.sub.menu.grp)				then event = Get.Sub.Menu.Event(event);				else event = Get.Null.Event;			end;			else if not(exit.my.screen)			then event = Get.Main.Menu.Event(event);		/*	default event to look for	*/		end;		call Save.Settings.And.Cleanup;		call Get_Disable(get.ertyp);		call Get_Disable(get.program.exit);		call Get_Disable(get.new.seq.info);		return GOTO.THIS.SCREEN;	end SEQ.EDIT.SCREEN;end editmod;