/*	:SYNSOU:EDITMOD:REGIONS - $TITLE - Routines to define and handle region menu & commands	*//*Modified:2002/08/04 - TY  - The edit filter can now be used in conjunction with the "change rte" dialog.2001/09/07 - TY  - Rewrote the INIT, OPEN and CLOSE routines for all dialogs and moved them from this file						 and from :SYNSOU:EDITMOD:REGIONS2 into a new file named :SYNSOU:EDITMOD:REGIONS1,						 then recombined what little was left of :SYNSOU:EDITMOD:REGIONS2 into this file.1998/05/17 - TY  - Shortened a multitude of switch strings by removing unnecessary trailing spaces.						 These spaces will automatically be supplied by DEFINE.SWITCH().					  - Nuked stray periods in DEFINE.CHANGE.VEL.DIALOG() and DEFINE.CHANGE.DUR.DIALOG() that						 plotted after the numeric parameter in the set case.1998/05/16 - TY  - Substituted calls to SCALE.RTE.VAL passing 0, to calls to SCALE.RTE.TO.PERCENT.1998/05/09 - TY  - Replaced 8 occurrences of identical strings with string constant identifiers.1998/04/22 - TY  - Disabled deposits during OPEN.CHANGE.VEL.DIALOG (as in OPEN.CHANGE.RTE.DIALOG).1990/08/27 - PF  - Support all MIDI controllers1990/01/11 - MWH - Clean up handling of MIDI mapping with MIDInet ON & OFF1989/03/14 - PF  - Fix bug in Update of MIDI IN Table1989/03/09 - EG  - allow duration dialog parameters to accept a negative #1989/03/09 - EG  - add current catalog to save seq dialog1988/12/16 - MWH - When protocol changes input/output routing, update screen1988/10/03 - CJ  - DEFINED TIMES TO WORK WITH LIVE CLICK TRACKS*/OPEN.REGION.SUB.MENU: proc public swapable;	dcl region.menu.label	fixed;	dcl first					fixed;	dcl reg.menu.len			lit '16';	/*	16 FOR NOW	*/	call Set.Auto.Allocation.Id(sub.menu.base);	/*	reset where auto-allocation begins	*/	/*** call Set.Default.Attr(0, ATTR#AltIntensity); ***/	/*	dim menu choices	*/	region.menu.label = Define.Label(S#AA, sub.menu.row, menu.col, 15, '');	/*	object used by sub.menus	*/	first = Define.Table(S#AA, 1, reg.menu.len, region.menu.label);	call Copy.String('Bounce|Change Duration|Change Pitch|Change RTE|Change Velocity|Cut/Paste|Edit Filter|Fit to Time',misc.buf);	call Fill.String.Table(first, 0, 0, 0, misc.buf);	call Copy.String('Justify|MIDI Mapping|Settings|Sequence Files|SMT/SKT|Track Solos|Track Volume|Unwrap Loops',misc.buf);	call Fill.String.Table(first, 0, 8, 0, misc.buf);	call Set.Object.Erase(first, O#ERAS.End.Of.Line);	call pid(region.sub.menu, first);	/*** call Set.Default.Attr(0, ATTR#RegIntensity); ***/	call Deposit.Label(gid(t1.label), 'Edit Start  :');	call Deposit.Label(gid(t2.label), 'Edit End    :');	call Deposit.Label(gid(t3.label), 'Edit Length :');	current.sub.menu.grp = Group.Objects(S#AA, first, first, Get#Screen.Event);	current.sub.menu = M#Region;	call Activate.Group.Objects(current.sub.menu.grp);	call Update.Group.Objects(current.sub.menu.grp);end OPEN.REGION.SUB.MENU;/*	loop through notes and call appropriate functions to operate on notes	*/PERFORM.REGION.COMMAND: proc(val, method, min, max) swapable;	dcl val							fixed;	/*	value to apply to region	*/	dcl method						fixed;	/*	how to use the val, 0-set, 1-scale, 2-add, 3-slope	*/	dcl (min, max)					fixed;	/*	minimum and maximum possible values (as set in dialog box)	*/	dcl trk							fixed;	/*	track to be modified	*/	dcl alltrks						boolean;	/*	true if edit will affect all tracks	*/	dcl inside.filter.region	boolean;	/*	true if current note falls within the range of filter parameters	*/	//	used only if (current.dialog == D#Change.RTE)	dcl code							fixed;	/*	holds rte code	*/	dcl sav.check.ctrl			fixed;	if (current.dialog == D#Change.RTE)	{		code = Fetch.Switch(gid(rte.type.switch));		/*	need to know this later	*/		if (code == 7)												/*	midi cntrl	*/		then code = (Fetch.Fixed.Point(gid(rte.midi.cntrl))\"200");		//	to allow the edit filter to be used in conjunction with the "change rte" dialog,		//	we need to temporarily alter the state of the edit filter so that it passes all controllers		sav.check.ctrl	= check.ctrl;	//	remember the previous setting so we can restore it when we're done		check.ctrl		= 0;				//	pass all controllers	}	if (num.of.soloed.tracks == 0)	alltrks	= true;	else										alltrks	= false;	do trk = num.kbd.tracks to first.lod.track-1;		/*	loop through all tracks	*/		write(mam)=tbut.ptr;		write(mal)=trk;		if		(	(	(alltrks != false)								/*	if editing all tracks	*/			||	((read(md)&b.soloed.trk) != 0)				/*	or this track is soloed	*/			)		&&	(trk.head.lookup(trk, thd.cue.track) == 0)	/*	and NOT a cue track		*/		)		{			call scroll.seq(start(0), start(1), 1);		//	scroll to the start of the region			if (load.seq.globals(trk) != 0)			{				call look.up.note.info;				if (current.dialog=D#Trk.Vol)					/*	these are operations which affect the whole track	*/				{	Set.Track.Param(1, val, method);				}				else													/* all of the following act on individual note records */				{					while												/*	loop through all notes in the selected region of the current track	*/					(	(#anyf <> 0)					&&	(	(#nmsb ilt finish(0))						||	((#nmsb == finish(0)) && (#nlsb ilt finish(1)))						)					)					{						if						(	(apply.filter != false)						&&	(	(current.dialog == D#Change.Vel)							||	(current.dialog == D#Change.RTE)							||	(current.dialog == D#Change.Pitch)							)						)						then inside.filter.region = check.note.filter();						else inside.filter.region = true;							if (inside.filter.region != false)						{							if			(current.dialog == D#Change.Pitch)	TRANSPOSE.NOTE(val, method);							else if	(current.dialog == D#Change.Vel)		SCALE.VELOCITY(val, method, min, max);								else if							(	(current.dialog == D#Change.RTE)							&&	(isa.rte.note() != false)			/*	this is an rte note	*/							)							{								write("313")	= shr(#w2,6) & 3;	//	the type of update record								if								(	(	(code == 6)						/*	if we want to change pressure	*/									&&	(read("313") == 2)			/*	2 = pressure update record		*/									)								||	(	(read("313") == 0)			/*	0 = rte update record			*/									&&	(shr(#w2,8) == code)			/*	and this is the controller we want to change	*/									)								)								then SCALE.RTE.NOTE(val, method, min, max);							}						}							if (advance.to.next.note<>0)						then call look.up.note.info;			/*	load #w1 - #w4	*/					}	//	end of loop through all notes in the selected region of the current track				}	//	end of if the operation acts on individual notes			}	//	end of this track has a valid track header		}	//	end of process this track	end;	//	end of loop through all tracks	if (current.dialog == D#Change.RTE)	check.ctrl	= sav.check.ctrl;	//	restore this edit filter parameter to its previous stateend PERFORM.REGION.COMMAND;/*	make a field always appear in reverse video	*/REVERSE.FIELD: proc (id) swapable;	dcl id	fixed;	call Set.Object.Attr(id, 0, ATTR#Reverse\ATTR#AltIntensity);	call Set.Object.Attr(id, 1, ATTR#Reverse\ATTR#RegIntensity);end REVERSE.FIELD;insert ':SYNSOU:EDITMOD:REGIONS1';	//	INSERT THE 'INIT', 'OPEN' AND 'CLOSE' ROUTINES FOR EACH DIALOGGET.REGION.SUB.MENU.EVENT: proc(event) returns(fixed) public swapable;	dcl event				fixed;	dcl (t1, t2, t3) (1)	fixed;	while (true)	{		if (event <> Get.Null.Event)		{			if (Screen.Event.Group <> current.sub.menu.grp) return event;			if			(	(Screen.Event.Info == S#KeyActivate)			||	(Screen.Event.Info == S#MouseSelect)			)			{				/*	change intensities	*/				call close.dialog;								/*	assume user doesn't want to do last selected operation	*/				call Set.Table.Cell.Attr(region.sub.menu, 0, Screen.Event.Table.Row, 0, ATTR#RegIntensity);				call Deposit.Label(gid(t1.label), 'Edit Start  :');				call Deposit.Label(gid(t2.label), 'Edit End    :');				call Deposit.Label(gid(t3.label), 'Edit Length :');				/*	make sure time3 is correct	*/				call Fetch.32Bit.Msec(gid(time1), t1);				call Fetch.32Bit.Msec(gid(time2), t2);				call sub32(t2, t1, t3);				call Set.32Bit.Msec.Display.Format(gid(time3), time.map(Fetch.Switch(gid(time.mode.switch))), cf#dur, cf#default, cf#default);				call Deposit.32Bit.Msec(gid(time3), t1, t3);				call Set.Auto.Allocation.Id(dialog.base);	/*	reset where auto-allocation begins	*/				if ((first.time.bits & bits(Screen.Event.Table.Row)) == 0)				{	/*	this is the first time this dialog has been chosen	*/					first.time.bits = first.time.bits \ bits(Screen.Event.Table.Row);	/*	set bit to show it has been chosen	*/					do case (Screen.Event.Table.Row);						init.bounce.dialog();						init.change.dur.dialog();						init.change.pitch.dialog();						init.change.rte.dialog();						init.change.vel.dialog();						init.cut.paste.dialog();						;									//	no init.filter.dialog();						init.fit.time.dialog();						init.justify.dialog();						;									//	no init.midi.dialog();						;									//	no init.setup.dialog();						;									//	no init.seq.storage.dialog();						init.smt.skt.dialog();						;									//	no init.trk.solos.dialog();						init.trk.vol.dialog();						;									//	no init.unwrap.dialog();					end;				}				do case (Screen.Event.Table.Row);					open.bounce.dialog();					open.change.dur.dialog();					open.change.pitch.dialog();					open.change.rte.dialog();					open.change.vel.dialog();					open.cut.paste.dialog();					open.filter.dialog();					open.fit.time.dialog();					open.justify.dialog();					open.midi.dialog();					open.setup.dialog();					open.seq.storage.dialog();					open.smt.skt.dialog();					open.trk.solos.dialog();					open.trk.vol.dialog();					open.unwrap.dialog();				end;			}		}		event = Get.Next.Edit.Screen.Event;	}end GET.REGION.SUB.MENU.EVENT;