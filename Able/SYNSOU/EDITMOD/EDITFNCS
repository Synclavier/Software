/*	:SYNSOU:EDITMOD:EDITFNCS - $title - contains the routines which actually alter regions of a sequence	*//*2002/09/03 - TY  - Added Inversion capability to TRANSPOSE.NOTE()2002/07/30 - TY  - Rewrote CONV.RATIO.TO.PERCENT() to take advantage of new math routines and improve accuracy.					  - Greatly simplified and improved resolution of the slope block of SCALE.DURATION().1998/07/09 - TY  - Made TRANSPOSE.NOTE public so that the G-page can use it!!1998/05/16 - TY  - Substituted calls to SCALE.RTE.VAL passing 0, to calls to SCALE.RTE.TO.PERCENT.						 Substituted calls to SCALE.RTE.VAL passing 1, to calls to SCALE.PERCENT.TO.RTE.1998/05/14 - TY  - Added rounding to the scaling part of the Track Volume case of SET.TRACK.PARAM to						 maintain proportions as closely as possible.  Also sped up scaling by using D4567						 since no negative values are involved.  Commented out code for features which are						 currently inaccessible.1998/05/10 - TY  - Put in a slew of temporary safeguards to prevent out-of-range results.  These occur						 because of loopholes existing in the user interface.  When these loopholes are fixed,						 these safeguards can be removed.					  - Simplified the SLOPE cases of SCALE.VELOCITY and SCALE.RTE.NOTE avoiding needless loss						 of resolution in the process.  Also removed 4 unnecessary variables from each.					  - Added code to strip the upper byte from ribbon RTEs in the SLOPE case.  Previously this						 was missing causing negative ribbon RTEs to be written as guitar updates.					  - Rewrote the SET, SCALE and ADD cases of SCALE.VELOCITY and SCALE.RTE.NOTE.  The SCALE						 cases conserve resolution better now.  Also the user can invert velocities or RTEs by						 entering a negative scale factor.					  - All RTE scaling now uses the maximum precision.  Previously, two decimal places were						 truncated for scaling ribbon RTEs, and one decimal place was truncated for scaling all						 others except MIDI controllers.  Furthermore, in the case of the min and max values,						 when decimal places are dropped they are now used for rounding the next place rather						 than simply truncated.1998/04/21 - TY  - Added sign extension to the scale pitchwheel and scale ribbon blocks of SCALE.RTE.NOTE.						 These two functions never worked before because sign extension had been left out.						 Another artifact of the way this was previously implemented is that the pitch wheel RTE						 values in the sequence were permanently quantized to the resolution of the pitch bend						 amount of the timbre in use at the time of the edit. Thus, when a timbre with a bend						 range less than 100 was used, resolution was lost.					  - Replaced the scaling algorithms in the pitch wheel blocks of SCALE.RTE.NOTE						 to have the following rounding characteristics:						 1) for even divisors, a value at the halfway point will round up.						 2) for negative values, "rounding up" means more negative.					  - Rewrote the nested procedure LIMIT.VALUE in SCALE.RTE.NOTE because it						 failed when "pitch.bend.range" was outside the range of -16384 to 16383.1988/03/15 - cj  - Send over info to dtd after changing track volume*/CONV.RATIO.TO.PERCENT: proc(n,d)	fixed swapable;	dcl (n, d)	fixed array;	//	both are 32-bit unsigned integers	//	return (1000*n)/d	if (d(0) == 0)	{		bitmsb = 0; bitlsb = n(1);		ratio_multiply(1000, d(1));		return bitlsb;	}	else	{		dcl temp(1) fixed;		str32(0, 1000, temp);		disable;		mul_32by32(n,temp);	//	(the interim 64-bit value is in MATHMOD's static array multiply.result)		div_64by32(d,temp);	//	the result is in temp		enable;		return temp(1);	}end CONV.RATIO.TO.PERCENT;SET.TRACK.PARAM: proc (param, val, method) swapable;	dcl param	fixed;	/*	0-midi routing, 1-trk vol, 2-trk routing, 3-track pan	*/	dcl val		fixed;	dcl method	fixed;	/*	how to use the val, 0-set, 1-scale, 2-add	*/	/*	NOTE: Expects sequencer # variables to be set up before calling	*/	write(mam) = trk.head;	write(mal) = #trk;	if read(md)<>0 then do;		write(mam) = read(md);							/*	point to info for this track	*/		do case (param);			do;												/*	CASE 0: MIDI ROUTING		*/				/*	write(mal) = thd.midi;	*/			/*	NOTHING IMPLEMENTED YET	*/			end;			do;												/*	CASE 1: TRACK VOLUME		*/				write(mal) = thd.tvol;					/*	point to volume param	*/				if method ieq 1 then do;				/*	take percent if scaling	*/					load read(md); mul val; mwait; div 1000;					val=res;					if (rem ige 500) val = val+1;		/*	round	*/				end;				if (val > 1000) then val = 1000;		/*	limit	*/				else if (val <  0  ) then val = 0;				write(md) = val;							/*	update volume param	*/				call compute.volume.levels;				trout.trk# = #trk-num.kbd.tracks;				call select.parameter(trvol.l-par.l);				NEW.MOTION				  = 1;			/*	SEND NEW CUE TRACK CONSTANTS	*/				NEW.CUE.TRACK.SETTINGS = 1;			/*	OVER AFTER TIMBRE RECALL		*/			end;			do;												/*	CASE 2: TRACK ROUTING	*/				/*	write(mal) = thd.trou;	*/			/*	NOTHING IMPLEMENTED YET	*/			end;			do;												/*	CASE 3: TRACK PANNING	*/				/*				write(mal) = thd.tpan;				if (method=1)				then val = srscale(read(md),val,1000);	/ * take percent if scaling * /				if (val > 500) then val = 500;			/ * limit to +/- 50 * /				else if (val < -500) then val = -500;				write(md) = val;								/ * update pan param * /				*/			end;		end;	end;end SET.TRACK.PARAM;TRANSPOSE.NOTE: proc (steps, method) public swapable;	dcl steps	fixed;	/*	number of steps +/- to transpose by	*/	dcl method	fixed;	//	0 = transpose, 1 = invert, 2 = scale	dcl cur.key	fixed;	/*	NOTE: Expects sequencer # variables and #w1-#w4 to be set up before it is called	*/	if (((#w1 & "100000") <> 0)				/*	not a normal format note	*/	or  ((isa.rte.note=true) and ((shr(#w2,6)&3)<>2)))	/*	or note is an rte update which is not a pressure update	*/	then return 0;									/*	then we can't transpose it	*/	cur.key = EXTRACT.KEY(loc(addr(#w1)));	/*	get key #	*/	do case method;		{	//	CASE 0:	Transpose			cur.key	= cur.key + steps;		/*	add in transformation		*/		}		{	//	CASE 1:	Invert			cur.key	= steps - cur.key;		}		{	//	CASE 2:	Scale			//	Note:	"steps" contains the address of a32[0]			//	compute ((a32 * cur.key) + b32) / c32			dcl negative	boolean;			//	(a32 * cur.key) will never overflow			BITMSB	= core(steps);			BITLSB	= core(steps+1);			if (BITMSB < 0)			{	neg32(BitMsbArray);				negative		= true;			}			else			{	negative		= false;			}			load BITLSB;			mul cur.key;			write("313")	= ures;			BITLSB			= res;			load BITMSB;	uload read("313");			mul cur.key;			BITMSB			= res;			if (negative != false)	neg32(BitMsbArray);			add32(BitMsbArray, loc(steps+2), BitMsbArray);			if (BITMSB < 0)			{	neg32(BitMsbArray);				negative		= true;			}			else			{	negative		= false;			}			disable;			multiply.result(0) = 0;			multiply.result(1) = 0;			multiply.result(2) = BITMSB;			multiply.result(3) = BITLSB;			BITMSB	= core(steps+4);			BITLSB	= core(steps+5);			if (BITMSB < 0)			{	neg32(BitMsbArray);				negative		= negative xor true;			}			div_64by32(BitMsbArray, BitMsbArray);			enable;			if (negative != false)			{	neg32(BitMsbArray);			}			cur.key	= BITLSB;		}	end;	//	end of do case	do while (cur.key > max.key#);	/*	if cur.key is too big...	*/		cur.key = cur.key - 12;			/*	drop by an octave				*/	end;	do while (cur.key < 0);		cur.key = cur.key + 12;			/*	raise an octave				*/	end;	return(CHANGE.NOTE.PITCH(cur.key));end TRANSPOSE.NOTE;SCALE.VELOCITY: proc (val, method, min, max) swapable;	dcl val			fixed;	/*	value to apply to region	*/	dcl method		fixed;	/*	how to use the val, 0-set, 1-scale, 2-add, 3-slope	*/	dcl (min,max)	fixed;	/*	minimum and maximum possible values (as set in dialog box)	*/	dcl cur.vel		fixed;	dcl t1 (1)		fixed;	dcl t2 (1)		fixed;	/*	NOTE: Expects sequencer # variables and		#w1-#w4 to be set up before it is called	*/	if (((#w1 & "100000") <> 0)	/*	not a normal format note	*/	or  (isa.rte.note=true))		/*	or note is an rte update	*/	then return 0;						/*	then we can't scale it		*/	if ((#w1 & 1) = 0)				/*	2 word record					*/	then cur.vel = RTE.MAX;	else cur.vel = (#w3 & 255);	do case (method);		do;								/*	CASE 0: SET to absolute amount	*/			val = SCALE.PERCENT.TO.RTE(val);		/*	convert 0-1000 to 0-RTE.MAX	*/		end;		do;								/*	CASE 1: SCALE by val percent	*/			cur.vel = srscale(cur.vel,val,1000);		/*	"val" MUST BE RETAINED HERE FOR THE FOLLOWING CONDITIONAL	*/			if val<0 then cur.vel = cur.vel+rte.max;	/*	bias if inverted	*/			/*	LIMIT SINCE THE UPCOMING CALL TO "SCALE.RTE.TO.PERCENT" CAN PRODUCE ERRONEOUS RESULTS FOR NEGATIVE INPUT	*/			if cur.vel<0 then cur.vel = 0;			val = SCALE.RTE.TO.PERCENT(cur.vel);		/*	convert 0-RTE.MAX to 0-1000	*/			if val > max then val = max;					/*	LIMIT	*/			else if val < min then val = min;			val = SCALE.PERCENT.TO.RTE(val);				/*	convert 0-1000 to 0-RTE.MAX	*/		end;		do;								/*	CASE 2: ADD val to velocity	*/			val = SCALE.RTE.TO.PERCENT(cur.vel)+val;	/*	convert 0-RTE.MAX to 0-1000	*/			if val > max then val = max;					/*	LIMIT	*/			else if val < min then val = min;			val = SCALE.PERCENT.TO.RTE(val);				/*	convert 0-1000 to 0-RTE.MAX	*/		end;		do;								/*	CASE 3: SLOPE from min to max	*/			call sub32(loc(addr(#nmsb)), start, t1);	/*	t1 = current note time minus region start	*/			call sub32(finish, start, t2);				/*	t2 = region end minus region start	*/			/*	NOTE: THE FOLLOWING WORKS EVEN IF min > max	*/			val = SCALE.PERCENT.TO.RTE(min + srscale(max-min,conv.ratio.to.percent(t1,t2),1000));	/*	convert 0-1000 to 0-RTE.MAX	*/		end;	end;	/*	of do case (method)	*/	return(CHANGE.RTE.VALUE(val));	/*	set to new value	*/end SCALE.VELOCITY;SCALE.RTE.NOTE: proc (val, method, min, max) swapable;	dcl val			fixed;	/*	value to apply to region	*/	dcl method		fixed;	/*	how to use the val, 0 = set, 1 = scale, 2 = add, 3 = slope	*/	dcl (min,max)	fixed;	/*	minimum and maximum possible values (as set in dialog box)	*/	dcl cur.val		fixed;	dcl rte.code	fixed;	dcl t1 (1)		fixed;	dcl t2 (1)		fixed;	dcl pitch.bend.range	fixed;	LIMIT.VALUE: proc(val, lo, hi) returns (fixed);		dcl (val, lo, hi)	fixed;		val=val+Bit15;lo=lo+Bit15;hi=hi+Bit15;		if val igt hi then val=hi;		else if val ilt lo then val=lo;		return val-Bit15;	end LIMIT.VALUE;	/*	find out what type of controller is being changed	*/	if ((shr(#w2,6) & 3) == 2)	rte.code	= 6;	//	pressure	else								rte.code	= shr(#w2,8);	cur.val	= (#w3 & 255);			/*	get current rte value	*/	/*	FIRST NORMALIZE VAL, MIN & MAX DEPENDING ON TYPE OF RTE	*/	if (rte.code & "200") <> 0 then do;		/*	midi controller	*/	end;												/*	do nothing	*/	else if (rte.code = 5) then do;			/*	ribbon filter, therefore val is 2 places too big	*/		if method<>1 then val = srscale(val,1,100);	/*	drop decimal info unless scaling	*/		min = srscale(min,1,100);		max = srscale(max,1,100);	end;	else if (rte.code <> 4) then do;			/*	normal rte, therefore val is 1 place too big	*/		if method<>1 then val = srscale(val,1,10);	/*	drop decimal info unless scaling	*/		min = srscale(min,1,10);		max = srscale(max,1,10);	end;	if (rte.code == 4)	//	pitch wheel	{		pitch.bend.range = get.pitch.bend.range(#trk);	//	look up pitch.bend.range		//	this is needed to limit the pitch bend range to that of the timbre on the track of the note being processed 		min = Limit.Value(min, -pitch.bend.range, pitch.bend.range);		max = Limit.Value(max, -pitch.bend.range, pitch.bend.range);		if (method == 0)	val = Limit.Value(val, -pitch.bend.range, pitch.bend.range);	}	do case (method);		do;								/*	CASE 0: SET to absolute amount	*/			if (rte.code & "200") <> 0 then do;		/*	midi controller	*/				/*	do nothing	*/			end;			else if (rte.code = 5) then do;			/*	ribbon filter	*/				val = val & 255;			end;			else if (rte.code = 4) then do;			/*	pitch wheel	*/				val = srscale(val,100,pitch.bend.range) & 255;			end;			else val = SCALE.PERCENT.TO.RTE(val);	/*	normal rtes	*/		end;		do;								/*	Case 1: SCALE by val percent	*/			if (rte.code & "200") <> 0 then do;		/*	midi controller	*/				cur.val = srscale(cur.val,val,10000);	/*	"val" MUST BE RETAINED HERE FOR THE FOLLOWING CONDITIONAL	*/				if val<0 then cur.val = cur.val+127;	/*	bias if inverted	*/				val = Limit.Value(cur.val,min,max);			end;			else if (rte.code = 5) then do;			/*	ribbon filter	*/				if cur.val ige 128 then cur.val=cur.val\"177400";	/*	should be negative, so sign extend	*/				val = Limit.Value(srscale(cur.val,val,10000),min,max) & 255;			end;			else if (rte.code = 4) then do;			/*	pitch wheel	*/				if cur.val ige 128 then cur.val=cur.val\"177400";	/*	should be negative, so sign extend	*/				cur.val = srscale(cur.val,val,10000);					/*	scale cur.val by val %	*/				/*	FOR THE UPCOMING CALL TO "Limit.Value", WE'LL SCALE "min" AND "max" TO THEIR RTE EQUIVALENTS RATHER THAN					SCALE "cur.val" TO SEMITONES.  THIS WILL PREVENT THE RTES FROM BEING QUANTIZED TO THE RESOLUTION OF THE					CURRENT TIMBRE'S PITCH BEND RANGE.	*/				min = srscale(min,100,pitch.bend.range);	/*	convert +-pitch.bend.range to +-100	*/				max = srscale(max,100,pitch.bend.range);	/*	convert +-pitch.bend.range to +-100	*/				val = Limit.Value(cur.val,min,max) & 255;			end;			else do;											/*	normal rtes	*/				cur.val = srscale(cur.val,val,10000);		/*	"val" MUST BE RETAINED HERE FOR THE FOLLOWING CONDITIONAL	*/				if val<0 then cur.val = cur.val+rte.max;	/*	bias if inverted	*/				/*	LIMIT SINCE THE UPCOMING CALL TO "SCALE.RTE.TO.PERCENT" CAN PRODUCE ERRONEOUS RESULTS FOR NEGATIVE INPUT	*/				if cur.val<0 then cur.val = 0;				val = SCALE.PERCENT.TO.RTE(Limit.Value(SCALE.RTE.TO.PERCENT(cur.val),min,max));			end;		end;		do;								/*	CASE 2: ADD val to rte	*/			if (rte.code & "200") <> 0 then do;		/*	midi controller	*/				val = Limit.Value(cur.val+val,min,max);			end;			else if (rte.code = 5) then do;			/*	ribbon filter	*/				if cur.val ige 128 then cur.val=cur.val\"177400";	/*	should be negative, so sign extend	*/				val = Limit.Value(cur.val+val,min,max) & 255;			end;			else if (rte.code = 4) then do;			/*	pitch wheel	*/				if cur.val ige 128 then cur.val=cur.val\"177400";	/*	should be negative, so sign extend	*/				val = srscale(Limit.Value(srscale(cur.val,pitch.bend.range,100)+val,min,max),100,pitch.bend.range) & 255;			end;																/*	normal rtes	*/			else val = SCALE.PERCENT.TO.RTE(Limit.Value(SCALE.RTE.TO.PERCENT(cur.val)+val,min,max));		end;		do;								/*	CASE 3: SLOPE from min to max	*/			call sub32(loc(addr(#nmsb)), start, t1);	/*	t1 = current note time minus region start	*/			call sub32(finish, start, t2);				/*	t2 = region end minus region start			*/			/*	NOTE: THE FOLLOWING WORKS EVEN IF min > max	*/			val = min + srscale(max-min,conv.ratio.to.percent(t1,t2),1000);			if (rte.code & "200") <> 0 then do;		/*	midi controller	*/				/*	do nothing	*/			end;			else if (rte.code = 5) then do;			/*	ribbon filter	*/				val = val & 255;			end;			else if (rte.code = 4) then do;			/*	pitch wheel	*/				val = srscale(val,100,pitch.bend.range) & 255;			end;			else val = SCALE.PERCENT.TO.RTE(val);	/*	normal rtes	*/		end;	end;	/*	of do case (method)	*/	return(CHANGE.RTE.VALUE(val));end SCALE.RTE.NOTE;/*	loop through notes and call appropriate functions to operate on notes	*/SCALE.DURATION: proc(val,method,min,max) swapable;	dcl val			array;	/*	holds a 32bit value	*/	dcl method		fixed;	/*	how to use the val, 0 = set, 1 = scale, 2 = add, 3 = slope	*/	dcl min			array;	dcl max			array;	dcl time	 (1)	fixed;	dcl range (1)	fixed;	//	used only for slope	dcl dur1	 (1)	fixed;	//	used only for slope	dcl dur2	 (1)	fixed;	//	used only for slope	dcl pct			fixed;	//	used only for slope	dcl trk			fixed;					/*	track to be modified	*/	dcl alltrks		boolean;					/*	true if edit will affect all tracks	*/	dcl inside.filter.region boolean;	/*	true if current note falls within the range of filter parameters	*/	if (num.of.soloed.tracks = 0)	then alltrks = true;	else alltrks = false;	do trk = num.kbd.tracks to first.lod.track-1;		/*	loop through all non-dtd tracks	*/		write(mam)=tbut.ptr;		write(mal)=trk;		if ((alltrks)												/*	if editing all tracks	*/		or ((read(md)&b.soloed.trk)<>0))						/*	or this track is soloed	*/		and (trk.head.lookup(trk, thd.cue.track) = 0)	/*	and NOT a cue track		*/		then do;			call scroll.seq(start(0), start(1), 1);		//	scroll to the start of the region			if load.seq.globals(trk)<>0 then do;				call look.up.note.info;				do while	((#anyf <> 0)					/*	loop through selected region of current track	*/				and		((#nmsb ilt finish(0))				or			((#nmsb = finish(0)) and (#nlsb ilt finish(1)))));					if  (apply.filter)					then inside.filter.region = check.note.filter;					else inside.filter.region = true;					if (inside.filter.region) then do;						if (((#w1 & "100000") == 0)	//	this is a normal format note						&&  (isa.rte.note	== false))	//	but not an rte update						{							do case (method);								//	CASE 0:	SET to absolute amount								copy32(val, time);																//	CASE 1:	SCALE current duration by percent								{									Extract.Dur(loc(addr(#w1)), loc(addr(bitmsb)));									ratio_multiply(val(0), 1000);									time(0) = bitmsb; time(1) = bitlsb;									if (com32(time, min) = lw#ilt) then call copy32(min, time);									else if ((max(0) | max(1)) <> 0) and (com32(time, max) = lw#igt) then call copy32(max, time);								}								//	CASE 2:	ADD time to current duration								{									Extract.Dur(loc(addr(#w1)), loc(addr(bitmsb)));									add32(loc(addr(bitmsb)), val, time);									if (com32(time, min) = lw#ilt) then call copy32(min, time);									else if ((max(0) | max(1)) <> 0) and (com32(time, max) = lw#igt) then call copy32(max, time);								}								//	CASE 3:	SLOPE								{									sub32(loc(addr(#nmsb)), start, dur1);		//	current note time - region start									sub32(finish, start, dur2);					//	region end - region start									pct = conv.ratio.to.percent(dur1, dur2);	//	percent of region where this note occurs (expressed as 0 to 1000)									if (com32(max, min) == lw#igt) then do;										sub32(max, min, range);										load range(1); uload range(0);										mul pct;										dur2(0) = ures; dur2(1) = res;										load min(1); uload min(0);									end;									else do;										sub32(min, max, range);										pct = 1000 - pct;										load range(1); uload range(0);										mul pct;										dur2(0) = ures; dur2(1) = res;										load max(1); uload max(0);									end;									mul 1000;									dur1(0) = ures; dur1(1) = res;									add32(dur1, dur2, bitmsbarray);									ratio_multiply(1,1000);									time(0) = bitmsb; time(1) = bitlsb;								}	//	end of slope							end;	//	end of do case							call CHANGE.NOTE.DURATION(time,0);						}	//	end of this is a scaleable note					end;					if (advance.to.next.note<>0)					then call look.up.note.info;		/*	load #w1 - #w4	*/				end;			end;		end;	end;end SCALE.DURATION;