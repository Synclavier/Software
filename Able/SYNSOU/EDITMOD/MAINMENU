/* :SYNSOU:EDITMOD:MAINMENU  $TITLE  Routines to define main menu, and handle selections from it	Modified:	07/24/89 - cj  - moved Undo.Sequence.Changes to operating system	05/18/89 - MWH - Make "restore sequence" a procedure (for PROTOCOL)*//* sets up the main menu icons */DEFINE.MAIN.MENU: proc public swapable;   dcl id_first	fixed;   dcl id_obj		fixed;   Set.Auto.Allocation.Id(main.menu.base);  /* reset where auto-allocation begins */	//	height	(row*100)	//		((1+icon_row_num)*100) + (icon_row_num*100*(total_text_rows-total_icon_rows)/(total_icon_rows+1))	//	width		(col*100)	//		(100*menu.col) +	//		(icon_row_num*100*(total_text_columns-(total_icon_columns*text_cols_per_icon_col))/(total_icon_columns+1))	//		 + ((icon_row_num-1)*500)	//	(100*menu.col) + (icon_row_num*100*(15-(2*5))/3) + ((icon_row_num-1)*500)	dcl total_icon_rows	lit '3';	//	This can be 4 as well	//	set up the cut/paste icon	id_first	= define.cut.paste.icon	(	S#AA,		(100*menu.col) + (1*100*(15-(2*5))/(2+1)) + ((1-1)*500),			//	col * 100		((1+1)*100) + (1*100*(6-total_icon_rows)/(total_icon_rows+1))	//	row * 100	);	Set.Object.Action(id_first, O#ACT.Animate.Disabled, true);	Set.Object.Mouse.Access(id_first, O#ACT.Middle.Press);	pid(cut.paste.button, id_first);	//	set up the settings icon	id_obj	= define.setup.icon	(	S#AA,		(100*menu.col) + (2*100*(15-(2*5))/(2+1)) + ((2-1)*500),			//	col * 100		((1+1)*100) + (1*100*(6-total_icon_rows)/(total_icon_rows+1))	//	row * 100	);	Set.Object.Action(id_obj, O#ACT.Animate.Disabled, true);	Set.Object.Mouse.Access(id_obj, O#ACT.Middle.Press);	pid(setup.button, id_obj);	//	set up the G-page icon	id_obj	= define.gpage.icon	(	S#AA,		(100*menu.col) + (1*100*(15-(2*5))/(2+1)) + ((1-1)*500),			//	col * 100		((1+2)*100) + (2*100*(6-total_icon_rows)/(total_icon_rows+1))	//	row * 100	);	Set.Object.Action(id_obj, O#ACT.Animate.Disabled, true);	//	only respond to the release of the mouse so that the G-page won't also respond to the same mouse click	Set.Object.Mouse.Access(id_obj, O#ACT.Middle.Release);	pid(record.screen.button, id_obj);	//	set up the mouse hole   pid(mouse.hole.icon, define.mouse.hole.icon(S#AA, 8100, 100));	//	set up the info button   pid(info.button, Define.Button.Icon(S#AA, 8100, 300, 0, '?', 0));	//	set up the undo button   id_obj	= Define.Button.Icon(S#AA, 8100, 800, 0, 'U', 1);   pid(undo.button, id_obj);   main.menu.grp	= Group.Objects(S#AA, id_first, id_obj, Get#Screen.Event);   Activate.Group.Objects(main.menu.grp);   Update.Group.Objects(main.menu.grp);end DEFINE.MAIN.MENU;SET.INFO.DISPLAY: proc public swapable;	dcl id     fixed;	dcl str(1) fixed;	id = gid(info.button);	Erase.Object(id);    	Undefine.Object(id);	/* turn off the old */	Copy.String('?',str);	if (info.on == false)	{		Define.Button.Icon(id, 8100, 300, 0, str, 0);	/* single line indicates off */		Activate.Object.Range(id, id);		update.trk.mgr(true, false);	/* take snapshot and update display */	}	else	{		Define.Button.Icon(id, 8100, 300, 0, str, 1);		Activate.Object.Range(id, id);		call turn.on.info.trks;			/* light up buttons with notes on them */	}	Update.Object(id);end SET.INFO.DISPLAY;TOGGLE.INFO.BUTTON: proc public swapable;   info.on = info.on xor 1;		/* toggle state */   if (info.on <> info.mode)   then call info.button.press;	/* make it look like button on kbd was pressed */   call set.info.display;			/* display appropriate state on trkmgr */   if (info.on = 0) then do;		/* make sure any info is removed */      call cpos(0,1);       call erase.to.end.of.line;   end;end TOGGLE.INFO.BUTTON;/* $subtitle - UNDO handlers */HANDLE.UNDO.BUTTON: proc public swapable;   /* want to swap current file w/ undo file for A/B comparisons */   if (undo.enabled) then do;	   dcl id	fixed;		id	=	gid(working.msg);      Enable.Object(id);				/*	put up working... message */      Update.Object(id);          call Undo.Sequence.Changes;	/*	swap the files */      Erase.Object  (id);				/*	remove message */      Disable.Object(id);       end;end HANDLE.UNDO.BUTTON;/* $subtitle - Main Menu Event Handler */GET.MAIN.MENU.EVENT: proc(event) returns (fixed) public swapable;   dcl event fixed;   do while 1;      if event <> Get.Null.Event then do;         if (Screen.Event.Group <> main.menu.grp) then return event;         if (Screen.Event.Code = Get.Screen.Event) then do;            if ((Screen.Event.Info=S#KeyActivate)              or  (Screen.Event.Info=S#MouseSelect)        /* first selection */            or  (Screen.Event.Info=S#MouseActivate))     /* clicked a second time */            then do;               call flash.object(Screen.Event.Id);       /* visual feedback */               if (Screen.Event.Id = gid(mouse.hole.icon)) then do; /* leave ... */                  Exit.My.Screen = true;                  return Get.Null.Event;         /* want to get back to top level to exit */               end;					else if (Screen.Event.Id == gid(cut.paste.button))					and (current.dialog <> D#CutPaste)					{						//	synthesize a virtual mouse click on the appropriate row of the submenu						dcl id_obj	fixed;						id_obj	= gid(region.sub.menu);						if (Locate.Object(id_obj) != false)						{							Write.Object(Object.Ptr+O#TABL.Cur.Row, D#CutPaste-1);							Write.Event.Queue(Get.Screen.Event, S#MouseSelect, id_obj);						}					}					else if (Screen.Event.Id == gid(setup.button))					and (current.dialog <> D#Setup) 					{						//	synthesize a virtual mouse click on the appropriate row of the submenu						dcl id_obj	fixed;						id_obj	= gid(region.sub.menu);						if (Locate.Object(id_obj) != false)						{							Write.Object(Object.Ptr+O#TABL.Cur.Row, D#Setup-1);							Write.Event.Queue(Get.Screen.Event, S#MouseSelect, id_obj);						}					}               else if (Screen.Event.Id = gid(record.screen.button))                then do;                  goto.this.screen = 14;	/*	want to go to recorder screen				*/                  Exit.My.Screen = true;                  return Get.Null.Event;	/*	want to get back to top level to exit	*/               end;               else if (Screen.Event.Id = gid(region.button))               and (current.sub.menu <> M#Region)               then do;                  call Close.Sub.Menu;                  call Open.Region.Sub.Menu;               end;               else if (Screen.Event.Id = gid(info.button))                then call toggle.info.button;               else if (Screen.Event.Id = gid(undo.button))                then call Handle.Undo.Button;               else event = Get.Null.Event;            end;         end;      end;      event = Get.Next.Edit.Screen.Event;   end;end GET.MAIN.MENU.EVENT;