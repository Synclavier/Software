DRAW.ACTIVITY.DISPLAY: PROC public SWAPABLE;   dcl (i,j,k,l,tmp)           fixed;   dcl (row,col)               fixed;   dcl number.of.blocks        fixed;  /* number of blocks that will fit on the screen */   dcl (scrlen.msb,scrlen.lsb) fixed;  /* amount of time that can be shown on screen */   dcl (msb,lsb)               fixed;       dcl last.trk.col            fixed;   dcl time.per.block          fixed;   time.per.block = Fetch.Fixed.Point(gid(click.fld))*Fetch.Fixed.Point(gid(bpm.fld));   /* DRAW TRACK LINES */   do i=1 to num.trks;                           /* draw track numbers */      k=gpos.y((100*(10+i))+50);      call connect(trk.begin.x,k,trk.end.x,k);      call imove(begin.x,k-2);      if i < 10       then call pstring(' ');      else alpha_mode;      call pnum(i,0);   end;END DRAW.ACTIVITY.DISPLAY;EOF   /* draw blocks */   number.of.blocks = (trk.end.x-trk.begin.x)/char.width;   last.trk.col = tpos.x(trk.end.x);   /* find out time length of screen */   load number.of.blocks;   mul time.per.block;   scrlen.lsb = res;   scrlen.msb = ures;   /* calculate screen begin and end */   NOTE: I can show you how to do this.  Cameron.   xxxx code is not active now   screen.begin(1)=play.time.msb;   screen.begin(0)=play.time.lsb;    screen.end(1)=screen.begin(1)+scrlen.msb;   screen.end(0)=screen.begin(0)+scrlen.lsb;   if screen.end(0) ilt scrlen.lsb then screen.end(1)=screen.end(1)+1;   transparent_mode;    do i= 0 to num.trks-1;     /* loop over displayed tracks */      call run.syn.loop;      /* just for good luck         */      #trk = i+2;             /* for now, just tracks 1-8   */      row = tpos.y(trk.y-(char.height*(i+2))); /* set up current row position */      if load.seq.globals(#trk)<>0 then do;         do while (#anyf <> 0)                  /* find first note on screen */         and (((#nmsb ilt screen.begin(1)))         or   ((#nmsb  =  screen.begin(1))         and   (#nlsb ilt screen.begin(0))));            call advance.to.next.real.note;             end;         do while (#anyf <> 0)                  /* loop over notes to be displayed */         and (((#nmsb ilt screen.end(1)))         or   ((#nmsb  =  screen.end(1))         and   (#nlsb ilt screen.end(0))));            /* calculate current column */            msb = #nmsb-screen.begin(1);            if (#nlsb ilt screen.begin(0)) then msb = msb-1;            lsb = #nlsb-screen.begin(0);            load lsb; uload msb;            div time.per.block;            tmp = res;            col = gpos.x(trk.begin.x+(tmp*char.width));            if (col>last.trk.col)             then col=last.trk.col;            call cpos(row,col);            if VT100 then do;            /* print checkerboard character */               call CH.SET(alt);               call pc("141");                 call CH.SET(norm);             end;            /* calculate time of next block */            /*            msb = screen.begin(1);            lsb = screen.begin(0) + ((1+col) * time.per.block);            if lsb ilt screen.begin(0) then msb=msb+1;            */            /* skip notes until a note which belongs in the next block arrives */            /*            do while (#anyf <> 0)                     and (((#nmsb ilt msb))            or   ((#nmsb  =  msb)            and   (#nlsb ilt lsb)));               call advance.to.next.real.note;                end;            */            call advance.to.next.note;         end;         /* DEBUG */         call cpos(23,1);         call ps('R:');         call pnum(row,0);         call ps(' C:');         call pnum(col,0);         call ps(' Ofst(m,l):');         call pnum(msb,0); call pc(sp); call pnum(lsb,0);         call ps(' scrlen(m,l):');         call pnum(scrlen.msb,0); call pc(sp); call pnum(scrlen.lsb,0);         call ps(' #blk:');         call pnum(number.of.blocks,0);         call ps(' tpb:');         call pnum(time.per.block,0);         /* end debug */      end;   end;