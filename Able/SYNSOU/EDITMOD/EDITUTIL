/* :SYNSOU:EDITMOD:EDITUTIL  $TITLE  Dragging routines for the sequence editor *//*Modified:2002/08/25 - TY  - Added smpte.displ.offset to HANDLE.SEQ.EDIT.OBJ.DRAG()1998/06/27 - TY  - Fixed the bug that prevented Mark Start from being updated						 when dragging from one of the memory buttons.*//* special get next event routine to trap certain situations */GET.NEXT.EDIT.SCREEN.EVENT: proc returns(fixed) public swapable;   dcl event fixed;   event = get.next.screen.event;   if  ((info.on <> 0)    and ((Screen.Event.Info=S#MouseSelect)     or  (Screen.Event.Info=S#MouseActivate))    and (Screen.Event.Id <> gid(trk.buttons))   and (Screen.Event.Id <> gid(cur.play.time))   and (Screen.Event.Id <> gid(start.button))   and (Screen.Event.Id <> gid(info.button)))   or  (info.on <> info.mode)   then call toggle.info.button;   if ((err.displayed <> 0)    and ((real.milliseconds-err.time) igt 5000)   and ((Screen.Event.Info=S#KeyActivate)     or  (Screen.Event.Info=S#MouseSelect)     or  (Screen.Event.Info=S#MouseActivate)))   then call remove.err;   return event;end GET.NEXT.EDIT.SCREEN.EVENT;/* Routine to deal with dragging in the sequence editor, checks types, adjusts times, etc. */HANDLE.SEQ.EDIT.OBJ.DRAG: proc public swapable;   dcl (msw, lsw)  fixed;   dcl time (1)    fixed;/*	TO BE DONE://		For now all dragged values are interpreted as 32-bit milliseconds.  Eventually we'll want to include 32-bit smpte bits as well.//		At that time, we'll need to maintain srcType and dstType and convert accordingly.//		if (Current.Dialog == D#CutPaste) support clip.len as a source*/	/* get dragged value */   if (Screen.Event.Id == gid(cur.play.time))   then do;      call Fetch.32Bit.Msec(Screen.Event.Id, loc(addr(msw)));      call Map.Real.Time.To.Sequence.Time(loc(addr(msw)), loc(addr(msw)));   end;   else if (Screen.Event.Id == gid(time1))   or      (Screen.Event.Id == gid(time2))   or      ((Screen.Event.Id == gid(time3)) & (Current.Dialog = D#CutPaste))   or      (Screen.Event.Id == gid(mark.start))   or      ((Current.Dialog == D#UnWrap) && (Screen.Event.Id = gid(unwrap.time)))   then do;      call Fetch.32Bit.Msec(Screen.Event.Id, loc(addr(msw)));   end;   else if ((Screen.Event.Id == gid(silence.len)) && (Current.Dialog == D#CutPaste))   or      ((Screen.Event.Id == gid(time3)) && (Current.Dialog != D#CutPaste))   then do;      call Fetch.32Bit.Msec(Screen.Event.Id, loc(addr(msw)));      call add16(zero.time, loc(addr(msw)));   end;   else if (Screen.Event.Id == gid(smpte.sync.offset)) then do;	/*	look at actual system offset instead of string field	*///		smpte.to.msec(loc(addr(sm.hrs)), cf#time, samp.speed, sm.mode, loc(addr(sm.hrs)), loc(addr(msw)));		//	the above call only accomplishes the following		msw	= 0;		lsw	= 0;   end;   else if (Screen.Event.Id == gid(smpte.displ.offset))	{	//	for now we'll interpret the display offset as a positive value between 0 and 24 hours		dcl smpte(4)	fixed;		Fetch.String(Screen.Event.Id, misc.buf);		conv.str.to.smpte(misc.buf, smpte);      smpte.to.msec(smpte, cf#time, samp.speed, sm.mode, loc(addr(sm.hrs)), loc(addr(msw)));   }   else if (Screen.Event.Id = gid(mem.buttons)) then do;      msw = mem.ms(Screen.Event.Table.Col);      lsw = mem.ls(Screen.Event.Table.Col);		/*if (Screen.Event.Obj.Info <> gid(mark.start)) then do;*/			/* DO THE FOLLOWING ALSO IF Screen.Event.Obj.Info = gid(mark.start).	*/			/* OTHERWISE THE SCREEN MANAGER WILL NOT GENERATE AN S#Deposit EVENT	*/			/* SINCE THE NEWLY DEPOSITED VALUE WAS ALREADY DEPOSITED.				*/			disable.deposits = true;			/* Restore the original mark.start (saved when mouse down on mem.buttons) */			Deposit.32Bit.Msec(gid(mark.start), loc(addr(sav.ms)), Zero.Zero);			disable.deposits = false;		/*end;*/   end;   /* if dropped on a valid field, store it away */   if (Screen.Event.Obj.Info == gid(cur.play.time))   then do;      call Map.Sequence.Time.To.Real.Time(loc(addr(msw)), loc(addr(msw)));      call Deposit.32Bit.Msec(screen.event.obj.info, loc(addr(msw)), Zero.Zero);   end;   else if (Screen.Event.Obj.Info == gid(time1))   or      (Screen.Event.Obj.Info == gid(time2))   or      ((Screen.Event.Obj.Info == gid(time3)) & (Current.Dialog = D#CutPaste))   or      (Screen.Event.Obj.Info == gid(mark.start))   or      ((Current.Dialog == D#UnWrap) && (Screen.Event.Obj.Info == gid(unwrap.time)))   then do;      call Deposit.32Bit.Msec(screen.event.obj.info, loc(addr(msw)), Zero.Zero);   end;   else if ((Screen.Event.Obj.Info == gid(silence.len)) & (Current.Dialog = D#CutPaste))   or      ((Screen.Event.Obj.Info == gid(time3)) & (Current.Dialog <> D#CutPaste))   then do;      if ((msw<>0) or (lsw ige zero.time))      then call sub16(zero.time, loc(addr(msw)));      call Fetch.32Bit.Msec(gid(time1), time);      call Deposit.32Bit.Msec(screen.event.obj.info, time, loc(addr(msw)));   end;   else if	(Screen.Event.Obj.Info == gid(smpte.sync.offset))	{		msec.to.smpte(loc(addr(msw)), cf#time, samp.speed, sm.mode, loc(addr(sm.hrs)), loc(addr(sm.hrs)));		conv.smpte.to.str(loc(addr(sm.hrs)), misc.buf, cf#default, cf#default);		Deposit.String(Screen.Event.Obj.Info, misc.buf);	}   else if	(Screen.Event.Obj.Info == gid(smpte.displ.offset))	{		dcl smpte(4)	fixed;		msec.to.smpte(loc(addr(msw)), cf#time, samp.speed, sm.mode, loc(addr(sm.hrs)), smpte);		conv.smpte.to.str(smpte, misc.buf, cf#default, cf#default);		Deposit.String(Screen.Event.Obj.Info, misc.buf);	}   else if (screen.event.obj.info == gid(mem.buttons)) then do;      mem.ms(screen.event.obj.col) = msw;      mem.ls(screen.event.obj.col) = lsw;      if  ((msw\lsw) = 0)                 /* invert if non-zero,  else clear */      or  ((msw=0) and (lsw=zero.time))      then call Set.Table.Cell.Attr(gid(mem.buttons), screen.event.obj.col, screen.event.obj.row, 0, Attr#NoReverse\Attr#RegIntensity);      else call Set.Table.Cell.Attr(gid(mem.buttons), screen.event.obj.col, screen.event.obj.row, 0, Attr#Reverse\Attr#AltIntensity);      call Update.Object(gid(mem.buttons));   end;end HANDLE.SEQ.EDIT.OBJ.DRAG;/* sets bits in passed array indicating which tracks to edit */SET.SOLOED.TRK.BITS: proc(trks) public swapable;   dcl trks      fixed array;   dcl alltrks   fixed;   dcl bit       fixed;   dcl i         fixed;   alltrks = (num.of.soloed.tracks ieq 0);   bit = num.kbd.tracks;   write(mam) = tbut.ptr;   do i = 0 to 15;                                 /* 16 words of track bits */      trks(i)=0;      do while bit ilt 16;                         /* 16 bits per word */         write(mal) = shl(i, 4)+bit;         if (alltrks)         or (read(md)&b.soloed.trk)<>0         then trks(i) = trks(i) \ bits(bit);         bit = bit+1;      end;      bit = 0;   end;end SET.SOLOED.TRK.BITS;/* $subtitle - routines to define compound objects *//* defines a 32bit field with a label, returns id of label */Define.Labeled.32Bit: proc (row, col, label.str, fw, format, tod, maxl, maxr, bitlit) public swapable;   dcl (row, col)  fixed;         /* transparent coordinates */   dcl label.str   fixed array;   /* string for label        */   dcl fw          fixed;         /* field width for 32bit number */   dcl format      fixed;         /* display format for define.32bit */   dcl tod         fixed;         /* cf#time or cf#duration          */   dcl (maxl, maxr) fixed;        /* left and right width (see Define.32Bit.Msec) */   dcl bitlit      fixed;         /* literal for offset into pid area to store number id */   dcl (label, id) fixed;         /* local id holders */   label = Define.Label(S#AA, row, col, label.str(0), label.str);   call Set.Object.Attr(label, 0, ATTR#AltIntensity);   call Set.Object.Mouse.Access(label, 0); /* no access */   id = Define.32Bit.Msec(S#AA, row, col+label.str(0)+1, fw, format, tod, maxl, maxr);   call Set.Object.Drag(id, true, 1);   call Set.Object.Mouse.Access(id, O#ACT.Left.Press|O#ACT.Middle.Press|O#ACT.Right.Press);   call Set.Object.Action(id, O#ACT.Animate.Disabled, true);   call Set.Object.Action(id, O#ACT.Update.On.Dep, true);   call Set.Object.Action(id, O#ACT.Realtime.Object, true);   call Set.Object.Arrow.Links(id, ARR#Auto, ARR#Auto, ARR#Auto, ARR#Auto);   call pid(bitlit, id);   return label;end Define.Labeled.32Bit;/* defines a fixed point field with a label, returns id of label */Define.Labeled.Fixed.Point: proc (row, col, label.str, fw, dp, format, fplit) public swapable;   dcl (row, col)  fixed;         /* transparent coordinates */   dcl label.str   fixed array;   /* string for label        */   dcl (fw, dp)    fixed;         /* field width and # decimal places for fixed point number */   dcl format      fixed;         /* format for define fixed point    */   dcl fplit       fixed;         /* literal for offset into pid area to store fixed point id */   dcl (label, id) fixed;         /* local id holders */   label = Define.Label(S#AA, row, col, label.str(0), label.str);   call Set.Object.Attr(label, 0, ATTR#AltIntensity);   call Set.Object.Mouse.Access(label, 0);              /* no access */   id    = Define.Fixed.Point(S#AA, row, col+label.str(0)+1, fw, dp, format);   call Set.Object.Mouse.Access(id, O#ACT.Left.Press|O#ACT.Middle.Press|O#ACT.Right.Press);   call Set.Object.Action(id, O#ACT.Animate.Disabled, true);   call Set.Object.Action(id, O#ACT.Update.On.Dep, true);   call Set.Object.Action(id, O#ACT.Realtime.Object, true);   call Set.Object.Arrow.Links(id, ARR#Auto, ARR#Auto, ARR#Auto, ARR#Auto);   call pid(fplit, id);   return label;end Define.Labeled.Fixed.Point;/* defines a switch field with a label, returns id of label */Define.Labeled.Switch: proc (row, col, label.str, sfw, switch.str, swlit) public swapable;	dcl (row, col)		fixed;				/* transparent coordinates	*/	dcl label.str		fixed array;		/* string for label			*/	dcl sfw				fixed;				/* switch field width		*/	dcl switch.str		fixed array;		/* string for switch			*/	dcl swlit			fixed;				/* literal for offset into pid area to store switch id */	dcl (label, id)	fixed;				/* local id holders			*/	label	= Define.Label(S#AA, row, col, label.str(0), label.str);	Set.Object.Attr(label, 0, ATTR#AltIntensity);	Set.Object.Mouse.Access(label, 0);	/* no access */	id		= Define.Switch(S#AA, row, col+label.str(0)+1, sfw, 0, switch.str);	Set.Object.Action(id, O#ACT.Update.On.Dep, true);	pid(swlit, id);	return label;end Define.Labeled.Switch;DISPLAY.AND.UNDEFINE.OBJ: proc(id) public swapable;   dcl id  fixed;   call Activate.Object.Range(id,id);   call Update.Object(id);   call Undefine.Object(id);end DISPLAY.AND.UNDEFINE.OBJ;