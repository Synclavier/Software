/*	:SYNSOU:EDITMOD:DIALOG2 - $title	*//*Modified:2002/08/XX - TY  - Rewrote everything1998/04/21 - TY  - Changed the argument in the call to CHECK.LIMITS in GET.TRK.VOL.DIALOG.EVENT						 from 1000 to 30000 so that we can scale track volumes by more than 100%.1991/02/13 - CJ  - check for MAGIC#6*//////////////////////////////	procedures for SEQUENCE FILES dialog/////////////////////////////	status:	COMPLETEDDRAW.SEQ.STORE.OK.BUTTON: proc (switch_pos, button_status) swapable;	dcl (switch_pos, button_status)	fixed;	if (button_status == 0)	//	0 indicates normal button state	{		do case switch_pos;			Copy.String('SAVE SEQUENCE',		misc.buf);			Copy.String('RECALL SEQUENCE',	misc.buf);			Copy.String('UNSAVE SEQUENCE',	misc.buf);		end;	}	else							//	1 indicates confirmation button state	{		do case switch_pos;			Copy.String('REPLACE SEQUENCE',	misc.buf);			Copy.String('CONFIRM RECALL',		misc.buf);			Copy.String('CONFIRM UNSAVE',		misc.buf);		end;	}	Change.Ok(16, misc.buf);														//	update button to hold the new string	Deposit.Object.Info(gid(ok.button), O#UserData, button_status);	//	store the passed statusend DRAW.SEQ.STORE.OK.BUTTON;TRY.TO.SAVE.SEQUENCE: proc swapable;	dcl treename(23)		fixed;				//	46 character treename	dcl OK.to.Save.Seq	boolean;	Fetch.String(gid(seq.treename), treename);	if (locate(treename, 1) == false)		//	file does not already exist	{		OK.to.Save.Seq	= true;	}	else	{		if (Fetch.Object.Info(gid(ok.button), O#UserData) != 0)	//	if user has clicked on confirmation button		{			OK.to.Save.Seq	= true;		}		else if (F#Type == T#Sync)				//	correct type, but we must first ask the user for confirmation		{			DRAW.SEQ.STORE.OK.BUTTON(0, 1);	//	replot the button in confirmation status ("replace")			Draw.Edit.Message('WARNING: File already exists, saving will replace it.');			OK.to.Save.Seq	= false;		}		else		{			Draw.Edit.Message('ERROR: A non-sequence file exists with the same name.');			OK.to.Save.Seq	= false;		}	}	if (OK.to.Save.Seq != false)	{		call Erase.Edit.Message;		//	do the operation		Save.Sequence(treename, 1, 1);		if (Fetch.Object.Info(gid(ok.button), O#UserData) != 0)	//	if button is in confirmation status ("replace")		{			DRAW.SEQ.STORE.OK.BUTTON(0, 0);								//	replot it in normal status ("save")		}	}end TRY.TO.SAVE.SEQUENCE;TRY.TO.RECALL.SEQUENCE: proc swapable;	dcl treename(23)		fixed;				//	46 character treename	dcl OK.to.Recall.Seq	boolean;	Fetch.String(gid(seq.treename), treename);	if (locate(treename, 1) == false)		//	file not found	{		Handle.Cat.Error(true);		OK.to.Recall.Seq	= false;	}	else	{		if (Fetch.Object.Info(gid(ok.button), O#UserData) != 0)	//	if user has clicked on confirmation button		{			OK.to.Recall.Seq	= true;		}		else if (F#Type == T#Sync)		{			DRAW.SEQ.STORE.OK.BUTTON(1, 1);								//	replot the button in confirmation status			Draw.Edit.Message('Click again to confirm...');			OK.to.Recall.Seq	= false;		}		else		{			call file.type.error;			OK.to.Recall.Seq	= false;		}	}	if (OK.to.Recall.Seq != false)	{		call Erase.Edit.Message;		//	do the operation		if (Try.To.Read.Seq(F#MS_SECTOR, F#LS_SECTOR) != false)		{			if (NUM.OF.HELD.TRACK.BUTTONS == 0)			{	//	set the global current seq path name if not selective track recall				dcl PUBLISH.SEQ.FILE.NAME proc(array, fixed) external;				PUBLISH.SEQ.FILE.NAME(treename, 1);			}		}		DRAW.SEQ.STORE.OK.BUTTON(1, 0);		//	replot the button in normal status	}end TRY.TO.RECALL.SEQUENCE;TRY.TO.UNSAVE.SEQUENCE: proc swapable;	dcl treename(23)		fixed;				//	46 character treename	dcl OK.to.Unsave.Seq	boolean;	Fetch.String(gid(seq.treename), treename);	if (locate(treename, 1) == false)		//	file not found	{		Handle.Cat.Error(true);		OK.to.Unsave.Seq	= false;	}	else	{		if (Fetch.Object.Info(gid(ok.button), O#UserData) != 0)	//	if user has clicked on confirmation button		{			OK.to.Unsave.Seq	= true;		}		else if (F#Type == T#Sync)				//	correct type, but we must first ask the user for confirmation		{			READDATA(F#MS_Sector, F#LS_Sector, Misc.Buf, SEQ.PROT+1);			if			(	(	(Misc.Buf(MAGIC.NUMBER)	== MAGIC#5)				||	(Misc.Buf(MAGIC.NUMBER)	== MAGIC#6)				||	(Misc.Buf(MAGIC.NUMBER)	== MAGIC#7)				)			&&	((Misc.Buf(SEQ.PROT)&1) != 0)			)			{				Draw.Edit.Message('Sequence file is Protected.');				OK.to.Unsave.Seq	= false;			}			else			{				DRAW.SEQ.STORE.OK.BUTTON(2, 1);							//	replot the button in confirmation status				Draw.Edit.Message('Click again to confirm...');				OK.to.Unsave.Seq	= false;			}		}		else		{			Draw.Edit.Message('Cannot delete a non-sequence file.');			OK.to.Unsave.Seq	= false;		}	}	if (OK.to.Unsave.Seq != false)	{		call Erase.Edit.Message;		//	do the operation		if (delete(treename, 1) == false)		{			Handle.Cat.Error(true);		}		else		{			dcl Cat.Cache.File.Type				fixed external;			dcl Protocol.Cat.Cache.File.Type	fixed external;			Draw.Edit.Message('Sequence file deleted.');			Cat.Cache.File.Type				= 0;			Protocol.Cat.Cache.File.Type	= 0;		}		DRAW.SEQ.STORE.OK.BUTTON(2, 0);									//	replot the button in normal status	}end TRY.TO.UNSAVE.SEQUENCE;GET.SEQ.STORE.DIALOG.EVENT: proc (event) returns (fixed) swapable;	dcl event			fixed;	while (true)	{		if (event != Get.Null.Event)		{			if (Screen.Event.Group != current.dialog.grp)	return event;			if (Screen.Event.Info == S#Deposit)			{				if (Screen.Event.Id == gid(seq.sw.pos))				{					call Erase.Edit.Message;													//	remove possible warning					DRAW.SEQ.STORE.OK.BUTTON(Fetch.Switch(Screen.Event.Id), 0);		//	replot the button in normal status				}				else if (Screen.Event.Id == gid(seq.treename))				{																						//	user typed a name					call Erase.Edit.Message;													//	remove possible warning					if (Fetch.Object.Info(gid(ok.button), O#UserData) != 0)			//	if button is in confirmation status					{						DRAW.SEQ.STORE.OK.BUTTON(Fetch.Switch(gid(seq.sw.pos)), 0);	//	replot it in normal status					}				}			}	//	end of if (Screen.Event.Info == S#Deposit)			else if	(Screen.Event.Info == S#MouseSelect)			{				if				(	(Screen.Event.Id igt gid(seq.numbers))				&&	(Screen.Event.Id ilt gid(seq.numbers)+9)				)				{					do case (Screen.Event.Id - gid(seq.numbers));						;	/*	nothing	*/						Copy.String('.sq0data', misc.buf);						Copy.String('.sq1data', misc.buf);						Copy.String('.sq2data', misc.buf);						Copy.String('.sq3data', misc.buf);						Copy.String('.sq4data', misc.buf);						Copy.String('.sq5data', misc.buf);						Copy.String('.sq6data', misc.buf);						Copy.String('.sq7data', misc.buf);					end;					Deposit.String(gid(seq.treename), misc.buf);				}				else if (Screen.Event.Id == gid(seq.save.button))		Deposit.Switch(gid(seq.sw.pos), 0);				else if (Screen.Event.Id == gid(seq.recall.button))	Deposit.Switch(gid(seq.sw.pos), 1);				else if (Screen.Event.Id == gid(seq.unsave.button))	Deposit.Switch(gid(seq.sw.pos), 2);				else if (Screen.Event.Id == gid(ok.button))	/*	want to do the operation	*/				{					work.msg(1);					do case Fetch.Switch(gid(seq.sw.pos));						call Try.To.Save.Sequence;						call Try.To.Recall.Sequence;						call Try.To.Unsave.Sequence;					end;					work.msg(0);				}	//	end of user clicked the Okay button				else if (Screen.Event.Id == gid(cancel.button))				{					call ERASE.EDIT.MESSAGE;					close.dialog();				}			}	//	end of if (Screen.Event.Info == S#MouseSelect)		}	//	end of if (event != Get.Null.Event)		event	= Get.Next.Edit.Screen.Event;	}	//	end of infinite loopend GET.SEQ.STORE.DIALOG.EVENT;/////////////////////////////	procedures for joint SMT/SKT dialog/////////////////////////////	status:	COMPLETED except.../////////////////////////////				Awaiting development of routine for writing timbre entryHANDLE.SMT.SKT.SRC.SWITCH: proc swapable;	dcl id_obj	fixed;	do case Fetch.Switch(Screen.Event.Id);		{	//	CASE 0:	KEYBOARD			//		fields:	(none)			//	remove possible previous fields			id_obj	= gid(smt.skt.src.track);		Erase.Object(id_obj);	Disable.Object(id_obj);			id_obj	= gid(smt.skt.src.bank);		Erase.Object(id_obj);	Disable.Object(id_obj);			id_obj	= gid(smt.skt.src.entry);		Erase.Object(id_obj);	Disable.Object(id_obj);			//	enable the exchange button in case we're switching from NULL TIMBRE			Enable.Object(gid(smt.skt.exch.button));			//	since no source fields are available to be selected, we'll select the appropriate destination field (if one is available)			do case Fetch.Switch(gid(smt.skt.dst.switch));				id_obj	= gid(cur.play.time);		//	CASE 0:	KEYBOARD		//	no fields available, so use old faithful				id_obj	= gid(smt.skt.dst.track);	//	CASE 1:	TRACK://				id_obj	= gid(smt.skt.dst.bank);	//	CASE 2:	BANK, ENTRY:			end;			Select.New.Cur.Obj(id_obj, 0, 0);		}		{	//	CASE 1:	TRACK:			//		fields:	smt.skt.src.track			//	remove possible previous fields			id_obj	= gid(smt.skt.src.bank);		Erase.Object(id_obj);	Disable.Object(id_obj);			id_obj	= gid(smt.skt.src.entry);		Erase.Object(id_obj);	Disable.Object(id_obj);			//	enable the exchange button in case we're switching from NULL TIMBRE			Enable.Object(gid(smt.skt.exch.button));			//	enable new fields			id_obj	= gid(smt.skt.src.track);		Enable.Object(id_obj);	Select.New.Cur.Obj(id_obj, 0, 0);		}		{	//	CASE 2:	BANK, ENTRY:			//		fields:	smt.skt.src.bank			//					smt.skt.src.entry			//	remove possible previous fields			id_obj	= gid(smt.skt.src.track);		Erase.Object(id_obj);	Disable.Object(id_obj);			//	disable the exchange button since BANK, ENTRY: cannot be a destination			id_obj	= gid(smt.skt.exch.button);	Erase.Object(id_obj);	Disable.Object(id_obj);			//	enable new fields			id_obj	= gid(smt.skt.src.bank);		Enable.Object(id_obj);	Select.New.Cur.Obj(id_obj, 0, 0);			Enable.Object(gid(smt.skt.src.entry));		}		{	//	CASE 3:	NULL TIMBRE			//		fields:	(none)			//	remove possible previous fields			id_obj	= gid(smt.skt.src.track);		Erase.Object(id_obj);	Disable.Object(id_obj);			id_obj	= gid(smt.skt.src.bank);		Erase.Object(id_obj);	Disable.Object(id_obj);			id_obj	= gid(smt.skt.src.entry);		Erase.Object(id_obj);	Disable.Object(id_obj);			//	disable the exchange button since NULL TIMBRE cannot be a destination			id_obj	= gid(smt.skt.exch.button);	Erase.Object(id_obj);	Disable.Object(id_obj);			//	since no source fields are available to be selected, we'll select the appropriate destination field (if one is available)			do case Fetch.Switch(gid(smt.skt.dst.switch));				id_obj	= gid(cur.play.time);		//	CASE 0:	KEYBOARD		//	no fields available, so use old faithful				id_obj	= gid(smt.skt.dst.track);	//	CASE 1:	TRACK://				id_obj	= gid(smt.skt.dst.bank);	//	CASE 2:	BANK, ENTRY:			end;			Select.New.Cur.Obj(id_obj, 0, 0);		}	end;end HANDLE.SMT.SKT.SRC.SWITCH;HANDLE.SMT.SKT.DST.SWITCH: proc swapable;	dcl id_obj	fixed;	do case Fetch.Switch(Screen.Event.Id);		{	//	CASE 0:	KEYBOARD			//		fields:	(none)			//	remove possible previous fields			id_obj	= gid(smt.skt.dst.track);	Erase.Object(id_obj);	Disable.Object(id_obj);//			id_obj	= gid(smt.skt.dst.bank);	Erase.Object(id_obj);	Disable.Object(id_obj);//			id_obj	= gid(smt.skt.dst.entry);	Erase.Object(id_obj);	Disable.Object(id_obj);			//	since no destination fields are available to be selected, we'll select the appropriate source field (if one is available)			do case Fetch.Switch(gid(smt.skt.src.switch));				id_obj	= gid(cur.play.time);		//	CASE 0:	KEYBOARD		//	no fields available, so use old faithful				id_obj	= gid(smt.skt.src.track);	//	CASE 1:	TRACK:				id_obj	= gid(smt.skt.src.bank);	//	CASE 2:	BANK, ENTRY:				id_obj	= gid(cur.play.time);		//	CASE 3:	NULL TIMBRE	//	no fields available, so use old faithful			end;			Select.New.Cur.Obj(id_obj, 0, 0);		}		{	//	CASE 1:	TRACK:			//		fields:	smt.skt.dst.track			//	remove possible previous fields//			id_obj	= gid(smt.skt.dst.bank);	Erase.Object(id_obj);	Disable.Object(id_obj);//			id_obj	= gid(smt.skt.dst.entry);	Erase.Object(id_obj);	Disable.Object(id_obj);			//	enable new fields			id_obj	= gid(smt.skt.dst.track);	Enable.Object(id_obj);	Select.New.Cur.Obj(id_obj, 0, 0);		}//		{	//	CASE 2:	BANK, ENTRY://			//		fields:	smt.skt.dst.bank//			//					smt.skt.dst.entry////			//	remove possible previous fields//			id_obj	= gid(smt.skt.dst.track);	Erase.Object(id_obj);	Disable.Object(id_obj);////			//	enable new fields//			id_obj	= gid(smt.skt.dst.bank);	Enable.Object(id_obj);	Select.New.Cur.Obj(id_obj, 0, 0);//			Enable.Object(gid(smt.skt.dst.entry));//		}	end;end HANDLE.SMT.SKT.DST.SWITCH;handle.smt.skt.exchange: proc swapable;	dcl (id_src, id_dst)	fixed;	dcl tmp_val				fixed;	//	step 1:	exchange all field values with deposits disabled	disable.deposits	= true;	id_src	= gid(smt.skt.src.track);	id_dst	= gid(smt.skt.dst.track);	tmp_val	= Fetch.Fixed.Point(id_src);	Deposit.Fixed.Point(id_src, Fetch.Fixed.Point(id_dst));	Deposit.Fixed.Point(id_dst, tmp_val);//	id_src	= gid(smt.skt.src.bank);//	id_dst	= gid(smt.skt.dst.bank);//	tmp_val	= Fetch.Fixed.Point(id_src);//	Deposit.Fixed.Point(id_src, Fetch.Fixed.Point(id_dst));//	Deposit.Fixed.Point(id_dst, tmp_val);//	id_src	= gid(smt.skt.src.entry);//	id_dst	= gid(smt.skt.dst.entry);//	tmp_val	= Fetch.Fixed.Point(id_src);//	Deposit.Fixed.Point(id_src, Fetch.Fixed.Point(id_dst));//	Deposit.Fixed.Point(id_dst, tmp_val);	//	step 2:	exchange switch positions with deposits enabled	disable.deposits	= false;	id_src	= gid(smt.skt.src.switch);	id_dst	= gid(smt.skt.dst.switch);	tmp_val	= Fetch.Switch(id_src);	Deposit.Switch(id_src, Fetch.Switch(id_dst));	Deposit.Switch(id_dst, tmp_val);end handle.smt.skt.exchange;do.smt.skt.operation: proc swapable;	do case Fetch.Switch(gid(smt.skt.src.switch));		//	CASE 0:	source = KEYBOARD		do case Fetch.Switch(gid(smt.skt.dst.switch));			{	//	CASE 0:	copy timbre from KEYBOARD to KEYBOARD				//	NO-OP			}			{	//	CASE 1:	copy timbre from KEYBOARD to TRACK:				work.msg(1);				if undo.enabled then call save.undoseq;				if				(	Copy.Timbre					(	0,						Fetch.Fixed.Point(gid(smt.skt.dst.track))+num.kbd.tracks-1					) == false				)				{					if	(Edit.Error == E#NoRoom)	no.room.error();					else								 	Draw.Edit.Message('SMT Operation failed.');				}				work.msg(0);			}//			{	//	CASE 2:	copy timbre from KEYBOARD to BANK, ENTRY://				Draw.Edit.Message('Feature not implemented.');	//	<<<<<<<<<<<	BUNGLOAD-O-CODE NEEDED HERE//			}		end;		//	CASE 1:	source = TRACK:		do case Fetch.Switch(gid(smt.skt.dst.switch));			{	//	CASE 0:	copy timbre from TRACK: to KEYBOARD				work.msg(1);				if				(	Copy.Timbre					(	Fetch.Fixed.Point(gid(smt.skt.src.track))+num.kbd.tracks-1,						0					) == false				)				{	if (Edit.Error == E#NoRoom)	no.room.error();					else									Draw.Edit.Message('SKT Operation failed.');				}				work.msg(0);			}			{	//	CASE 1:	copy timbre from TRACK: to TRACK:				if (gid(smt.skt.src.track) != gid(smt.skt.dst.track))				{					work.msg(1);					if undo.enabled then call save.undoseq;					if					(	Copy.Timbre						(	Fetch.Fixed.Point(gid(smt.skt.src.track))+num.kbd.tracks-1,							Fetch.Fixed.Point(gid(smt.skt.dst.track))+num.kbd.tracks-1						) == false					)					{						if	(Edit.Error == E#NoRoom)	no.room.error();						else								 	Draw.Edit.Message('SMT Operation failed.');					}					work.msg(0);				}				//	else NO-OP			}//			{	//	CASE 2:	copy timbre from TRACK: to BANK, ENTRY://				Draw.Edit.Message('Feature not implemented.');			//	<<<<<<<<<<<	BUNGLOAD-O-CODE NEEDED HERE//			}		end;		//	CASE 2:	source = BANK, ENTRY://		if (Fetch.Switch(gid(smt.skt.dst.switch)) == 2)					//	copy timbre from BANK, ENTRY: to BANK, ENTRY://		{//			if//			(	(gid(smt.skt.src.entry) != gid(smt.skt.dst.entry))//			||	(gid(smt.skt.src.bank) != gid(smt.skt.dst.bank))//			)//			{//				Draw.Edit.Message('Feature not implemented.');			//	<<<<<<<<<<<	BUNGLOAD-O-CODE NEEDED HERE//			}//			//	else NO-OP//		}//		else		{			work.msg(1);			if (Fetch.Switch(gid(smt.skt.dst.switch)) == 0)				//	copy timbre from BANK, ENTRY: to KEYBOARD			{				Recall.Timbre.To.Track				(	Fetch.Fixed.Point(gid(smt.skt.src.bank))-1,					Fetch.Fixed.Point(gid(smt.skt.src.entry))-1,					0				);			}			else	//	if (Fetch.Switch(gid(smt.skt.dst.switch)) == 1)	//	copy timbre from BANK, ENTRY: to TRACK:			{				if undo.enabled then call save.undoseq;				Recall.Timbre.To.Track				(	Fetch.Fixed.Point(gid(smt.skt.src.bank))-1,					Fetch.Fixed.Point(gid(smt.skt.src.entry))-1,					Fetch.Fixed.Point(gid(smt.skt.dst.track))+num.kbd.tracks-1				);			}			if (Edit.Error != 0)			{				if	(Edit.Error == E#NoRoom)	no.room.error();				else								 	Draw.Edit.Message('Operation failed.');			}//			call Clear.Display;	//	leave VK window alone for now			work.msg(0);		}		//	CASE 3:	source = NULL TIMBRE		do case Fetch.Switch(gid(smt.skt.dst.switch));			{	//	CASE 0:	copy from NULL TIMBRE to KEYBOARD				work.msg(1);				if				(	Copy.Timbre					(	-3,						0					) == false				)				{	if (Edit.Error == E#NoRoom)	no.room.error();					else									Draw.Edit.Message('SKT Operation failed.');				}				work.msg(0);			}			{	//	CASE 1:	copy from NULL TIMBRE to TRACK:				work.msg(1);				if undo.enabled then call save.undoseq;				if				(	Copy.Timbre					(	-3,						Fetch.Fixed.Point(gid(smt.skt.dst.track))+num.kbd.tracks-1					) == false				)				{					if	(Edit.Error == E#NoRoom)	no.room.error();					else								 	Draw.Edit.Message('SMT Operation failed.');				}				work.msg(0);			}//			{	//	CASE 2:	copy from NULL TIMBRE to BANK, ENTRY://				Draw.Edit.Message('Feature not implemented.');	//	<<<<<<<<<<<	BUNGLOAD-O-CODE NEEDED HERE//			}		end;	end;	//	end of do case source switchend do.smt.skt.operation;GET.SMT.SKT.DIALOG.EVENT: proc (event) returns (fixed) swapable;	dcl event	fixed;	dcl id_obj	fixed;	while (true)	{		if (event != Get.Null.Event)		{			if (Screen.Event.Group != current.dialog.grp)	return event;			if (Screen.Event.Info == S#Deposit)			{				call Erase.Edit.Message;	//	call remove.err;	//	clear any previous error message				if			(Screen.Event.Id == gid(smt.skt.src.switch))	Handle.SMT.SKT.Src.Switch();				else if	(Screen.Event.Id == gid(smt.skt.dst.switch))	Handle.SMT.SKT.Dst.Switch();				else if	(Screen.Event.Id == gid(smt.skt.src.track))				{					check.limits(1, 200);					//	select the appropriate destination field if one is available, otherwise leave the current object selected					do case Fetch.Switch(gid(smt.skt.dst.switch));						;																	//	CASE 0:	KEYBOARD		//	no destination fields available, so do nothing						Select.New.Cur.Obj(gid(smt.skt.dst.track), 0, 0);	//	CASE 1:	TRACK://						Select.New.Cur.Obj(gid(smt.skt.dst.bank), 0, 0);	//	CASE 2:	BANK, ENTRY:					end;				}				else if	(Screen.Event.Id == gid(smt.skt.dst.track))				{					check.limits(1, 200);					//	select the appropriate source field if one is available, otherwise leave the current object selected					do case Fetch.Switch(gid(smt.skt.src.switch));						;																	//	CASE 0:	KEYBOARD		//	no source fields available, so do nothing						Select.New.Cur.Obj(gid(smt.skt.src.track), 0, 0);	//	CASE 1:	TRACK:						Select.New.Cur.Obj(gid(smt.skt.src.bank), 0, 0);	//	CASE 2:	BANK, ENTRY:						;																	//	CASE 3:	NULL TIMBRE	//	no source fields available, so do nothing					end;				}				else if				(	(Screen.Event.Id == gid(smt.skt.src.bank))				||	(Screen.Event.Id == gid(smt.skt.src.entry))				)				{					check.limits(1, 8);					/*	select the next field	*/					if (Screen.Event.Id == gid(smt.skt.src.bank))					{						id_obj	= gid(smt.skt.src.entry);					}					else					{	//	select the appropriate destination field if one is available, otherwise bounce back to the source bank field						do case Fetch.Switch(gid(smt.skt.dst.switch));							id_obj	= gid(smt.skt.src.bank);	//	CASE 0:	KEYBOARD		//	no destination fields available							id_obj	= gid(smt.skt.dst.track);	//	CASE 1:	TRACK://							id_obj	= gid(smt.skt.dst.bank);	//	CASE 2:	BANK, ENTRY:						end;					}					Select.New.Cur.Obj(id_obj, 0, 0);				}//				else if//				(	(Screen.Event.Id == gid(smt.skt.dst.bank))//				||	(Screen.Event.Id == gid(smt.skt.dst.entry))//				)//				{//					check.limits(1, 8);//					/*	select the next field	*///					if (Screen.Event.Id == gid(smt.skt.dst.bank))//					{//						id_obj	= gid(smt.skt.dst.entry);//					}//					else//					{	//	select the appropriate source field if one is available, otherwise bounce back to the destination bank field//						do case Fetch.Switch(gid(smt.skt.src.switch));//							id_obj	= gid(smt.skt.dst.bank);	//	CASE 0:	KEYBOARD		//	no source fields available//							id_obj	= gid(smt.skt.src.track);	//	CASE 1:	TRACK://							id_obj	= gid(smt.skt.src.bank);	//	CASE 2:	BANK, ENTRY://							id_obj	= gid(smt.skt.dst.bank);	//	CASE 3:	NULL TIMBRE	//	no source fields available//						end;//					}//					Select.New.Cur.Obj(id_obj, 0, 0);//				}			}	//	end of if (Screen.Event.Info == S#Deposit)			else if	(Screen.Event.Info == S#MouseSelect)			{				if			(Screen.Event.Id == gid(smt.skt.exch.button))	handle.smt.skt.exchange();				else if	(Screen.Event.Id == gid(ok.button))					do.smt.skt.operation();		/*	want to do the operation	*/				else if	(Screen.Event.Id == gid(cancel.button))			close.dialog();			}	//	end of if (Screen.Event.Info == S#MouseSelect)		}	//	end of if (event != Get.Null.Event)		event	= Get.Next.Edit.Screen.Event;	}	//	end of infinite loopend GET.SMT.SKT.DIALOG.EVENT;/////////////////////////////	procedures for TRACK SOLOS dialog/////////////////////////////	status:	COMPLETEDGET.TRK.SOLOS.DIALOG.EVENT: proc (event) returns (fixed) swapable;	dcl event	fixed;	while (true)	{		if (event != Get.Null.Event)		{			if (Screen.Event.Group != current.dialog.grp)	return event;			if	(Screen.Event.Info == S#MouseSelect)			{				if (Screen.Event.Id == gid(ok.button))	//	do the operation				{//					work.msg(1);//					if undo.enabled then call save.undoseq;					//	do the actual work					write("313")	= Fetch.Switch(gid(trk.solos.switch));					if (read("313") == 4)	Clear.Track.Solo.States();					else							Conditionally_Set_Solos(read("313"));//					work.msg(0);				}	//	end of user clicked the Okay button				else if (Screen.Event.Id == gid(cancel.button)) close.dialog();			}	//	end of if (Screen.Event.Info == S#MouseSelect)		}	//	end of if (event != Get.Null.Event)		event	= Get.Next.Edit.Screen.Event;	}	//	end of infinite loopend GET.TRK.SOLOS.DIALOG.EVENT;/////////////////////////////	procedures for TRACK VOLUME dialog/////////////////////////////	status:	COMPLETEDGET.TRK.VOL.DIALOG.EVENT: proc (event) returns (fixed) swapable;	dcl event	fixed;	while (true)	{		if (event != Get.Null.Event)		{			if (Screen.Event.Group != current.dialog.grp)	return event;			if (Screen.Event.Info == S#Deposit)			{				call remove.err;	//	clear any previous error message				if (Screen.Event.Id == gid(trk.vol.switch))				{					//	this should be replaced with a linked switch					if (Fetch.Switch(Screen.Event.Id) == 0)	Change.Ok(12, 'SET VOLUME');		/*	update button to hold new string	*/					else													Change.Ok(12, 'SCALE VOLUME');	/*	update button to hold new string	*/				}				else if (Screen.Event.Id == gid(trk.vol.percent))	check.limits(0, 30000);			}	//	end of if (Screen.Event.Info == S#Deposit)			else if	(Screen.Event.Info == S#MouseSelect)			{				if (Screen.Event.Id == gid(ok.button))	/*	want to do the operation	*/				{//					work.msg(1);					if undo.enabled then call save.undoseq;					Perform.Region.Command(Fetch.Fixed.Point(gid(trk.vol.percent)), Fetch.Switch(gid(trk.vol.switch)), 0, 0);//					work.msg(0);				}	//	end of user clicked the Okay button				else if (Screen.Event.Id == gid(cancel.button))	close.dialog();			}	//	end of if (Screen.Event.Info == S#MouseSelect)		}	//	end of if (event != Get.Null.Event)		event	= Get.Next.Edit.Screen.Event;	}	//	end of infinite loopend GET.TRK.VOL.DIALOG.EVENT;/////////////////////////////	procedures for CHANGE PITCH dialog/////////////////////////////	status:	UNDER DEVELOPMENT/////////////////////////////				TO DO:	Implement pitch scalingcompute_right_pitch_scale_params: proc swapable;	//	compute and deposit values for pitch.scale.semitones and pitch.scale.percent based on pitch.scale.anchor and xa,xb,ya,yb	dcl slope_num	fixed;	dcl slope_den	fixed;	dcl temp_num	fixed;	dcl temp_den	fixed;	dcl temp			fixed;	dcl negative	boolean;	slope_num	= gid(sav.pitch.scale.yb) - gid(sav.pitch.scale.ya);	//	will be between -32760 and +32760	slope_den	= gid(sav.pitch.scale.xb) - gid(sav.pitch.scale.xa);	//	will be between -32760 and +32760	//	percent		= (100 * slope_num/slope_den) * 10	//	we rely on limit checks when deposits are made to assure that this computation won't overflow	//	and that the denominator isn't 0	//	set temps and negative for unsigned D4567 arithmetic	if (slope_num < 0)	{	temp_num	= -slope_num;		negative	= true;	}	else	{	temp_num	= slope_num;		negative	= false;	}	if (slope_den < 0)	{	temp_den	= -slope_den;		negative	= negative xor true;	}	else	{	temp_den	= slope_den;	}	load 1000;		mul temp_num;	mwait; 			div temp_den;	temp				= res;	write("313")	= rem;	load 0; uload read("313"); div temp_den;	//	round: the fdiv method	if (res < 0)				temp = temp+1;	if (negative != false)	temp = -temp;	Deposit.Fixed.Point(gid(pitch.scale.percent), temp);	//	semitones	= (slope_num*(anchor - xb) - slope_den*(anchor - yb)) / (39 * slope_den)	dcl anchor	fixed;	dcl a32(1)	fixed;	dcl b32(1)	fixed;	dcl c32(1)	fixed;	Fetch.String(gid(pitch.scale.anchor), a32);	anchor		= 390 * conv.str.to.key#(a32);	//	will be between 0 and +32760 (as are xa,xb,ya,yb)	//	step 1:	precompute slope_num*(anchor - xb)		put it in a32	temp	= anchor - gid(sav.pitch.scale.xb);	if (temp < 0)	{	temp		= -temp;		negative	= true;	}	else	{	negative	= false;	}	if (slope_num < 0)	{	temp_num	= -slope_num;		negative	= negative xor true;	}	else	{	temp_num	= slope_num;	}	load temp;	mul temp_num;	a32[0]		= ures;	a32[1]		= res;	if (negative != false)	neg32(a32);	//	step 2:	precompute - slope_den*(anchor - yb)	put it in b32	temp	= anchor - gid(sav.pitch.scale.yb);	if (temp < 0)	{	temp		= -temp;		negative	= true;	}	else	{	negative	= false;	}	if (slope_den < 0)	{	temp_den	= -slope_den;		negative	= negative xor true;	}	else	{	temp_den	= slope_den;	}	load temp;	mul temp_den;	b32[0]		= ures;	b32[1]		= res;	if (negative == false)	neg32(b32);	//	note reversal of sign so that add32 can be used as subtract	//	step 3:	add32(a32, b32, b32);	if (b32[0] < 0)	{	neg32(b32);		negative	= true;	}	else	{	negative	= false;	}	//	precompute 39*slope_den		put it in c32	if (slope_den < 0)	{	temp_den	= -slope_den;		negative	= negative xor true;	}	else	{	temp_den	= slope_den;	}	load 39;	mul temp_den;	c32[0]	= ures;	c32[1]	= res;	disable;	multiply.result(0) = 0;	multiply.result(1) = 0;	multiply.result(2) = b32[0];	multiply.result(3) = b32[1];	div_64by32(c32, a32);	enable;	if (negative != false)	{	neg32(a32);	}	Deposit.Fixed.Point(gid(pitch.scale.semitones), a32[1]);end compute_right_pitch_scale_params;//	compute_left_pitch_scale_params: proc swapable;//	end compute_left_pitch_scale_params;compute_pitch_scale_anchor: proc returns (fixed) swapable;	//	anchor	= ( (39 * semitones * slope_den) - (xb*ya - xa*yb) ) / (slope_num - slope_den)	dcl slope_num	fixed;	dcl slope_den	fixed;	dcl temp			fixed;	dcl semitones	fixed;	dcl negative	boolean;	dcl a32(1)		fixed;	dcl b32(1)		fixed;	dcl c32(1)		fixed;	slope_num	= gid(sav.pitch.scale.yb) - gid(sav.pitch.scale.ya);	//	will be between -32760 and +32760	slope_den	= gid(sav.pitch.scale.xb) - gid(sav.pitch.scale.xa);	//	will be between -32760 and +32760	//	avoid division by zero	if (slope_num == slope_den)	{	//	return center pitch	(xb + xa) / (2 * 390)		load	gid(sav.pitch.scale.yb) + gid(sav.pitch.scale.ya);		div	2*390;		if (rem ige 390)	return res+1;		else					return res;	}	//	precompute 39 * semitones * slope_den		it will always be less than (2^31)-1	semitones	= Fetch.Fixed.Point(gid(pitch.scale.semitones));	//	set temps and negative for unsigned D4567 arithmetic	if (semitones < 0)	{	semitones	= -semitones;		negative		= true;	}	else	{	negative		= false;	}	if (slope_den < 0)	{	temp			= -slope_den;		negative		= negative xor true;	}	else	{	temp			= slope_den;	}	load semitones;	mul temp;	BITMSB			= ures;	BITLSB			= res;	load BITLSB;	mul 39;	write("313")	= ures;	a32[1]			= res;	load BITMSB;	uload read("313");	mul 39;	a32[0]			= res;	if (negative != false)	neg32(a32);	//	precompute xb*ya - xa*yb		it too will always be less than (2^31)-1	load gid(sav.pitch.scale.xb);	mul gid(sav.pitch.scale.ya);	b32[0]	= ures;	b32[1]	= res;	load gid(sav.pitch.scale.xa);	mul gid(sav.pitch.scale.yb);	c32[0]	= ures;	c32[1]	= res;	neg32(c32);	add32(b32, c32, b32);	neg32(b32);	add32(a32, b32, c32);	//	c32 is now the entire numerator	//	deal with sign and the possibility of overflow into the sign bit	if	(c32[0] < 0)	{		if	((a32[0] < 0) || (b32[0] < 0))		{	neg32(c32);			negative	= true;		}		else	//	(a32[0] >= 0) && (b32[0] >= 0)		{	negative	= false;	//	interpret sign bit as part of 32-bit unsigned		}	}	else	//	(c32[0] >= 0)	{		if	((a32[0] >= 0) || (b32[0] >= 0))		{	negative	= false;		}		else	//	(a32[0] < 0) && (b32[0] < 0)		{	neg32(c32);			negative	= true;	//	interpret sign bit as part of 32-bit unsigned		}	}	//	precompute 390 * (slope_num - slope_den)	temp	= slope_num - slope_den;	if	(temp < 0)	{		if	((slope_num < 0) || (slope_den > 0))		{	temp	= -temp;			negative	= negative xor true;		}	}	else	//	(temp >= 0)	{		if	(slope_num < 0) && (slope_den > 0)		{	temp	= -temp;			negative	= negative xor true;	//	interpret sign bit as part of 16-bit unsigned		}	}	load temp;	mul 390;	b32[0]	= ures;	b32[1]	= res;	disable;	multiply.result(0) = 0;	multiply.result(1) = 0;	multiply.result(2) = c32[0];	multiply.result(3) = c32[1];	div_64by32(b32, a32);	enable;	if (negative != false)	{	neg32(a32);	}	return a32[1];end compute_pitch_scale_anchor;validxaxbyayb: proc (candidate) returns (boolean) swapable;	dcl candidate	fixed;	dcl slope_num	fixed;	dcl slope_den	fixed;	//	check that (yb-ya)/(xb-xa) doesn't have zero denominator and doesn't exceed maximum	if				(Screen.Event.Id == gid(pitch.scale.xa))	{		if (candidate == gid(sav.pitch.scale.xb))	//	division by zero		{	set.error(err.div.zero,'');			return false;		}		slope_num	= gid(sav.pitch.scale.yb)	- gid(sav.pitch.scale.ya);		slope_den	= gid(sav.pitch.scale.xb)	- candidate;	}	else if		(Screen.Event.Id == gid(pitch.scale.xb))	{		if (candidate == gid(sav.pitch.scale.xa))	//	division by zero		{	set.error(err.div.zero,'');			return false;		}		slope_num	= gid(sav.pitch.scale.yb)	- gid(sav.pitch.scale.ya);		slope_den	= candidate						- gid(sav.pitch.scale.xa);	}	else if		(Screen.Event.Id == gid(pitch.scale.ya))	{		slope_num	= gid(sav.pitch.scale.yb)	- candidate;		slope_den	= gid(sav.pitch.scale.xb)	- gid(sav.pitch.scale.xa);	}	else	/*	if	(Screen.Event.Id == gid(pitch.scale.yb))	*/	{		slope_num	= candidate						- gid(sav.pitch.scale.ya);		slope_den	= gid(sav.pitch.scale.xb)	- gid(sav.pitch.scale.xa);	}	//	absolute values for unsigned D4567 arithmetic	if (slope_num < 0)	{	slope_num	= -slope_num;	}	if (slope_den < 0)	{	slope_den	= -slope_den;	}	load 1000;		mul slope_num;	if (ures ige slope_den)		//	ratio exceeds (2^16)-1	{	Draw.Edit.Message('ERROR: Ratio out of range.');		return false;	}	mwait; 			div slope_den;	candidate		= res;	write("313")	= rem;	load 0; uload read("313"); div slope_den;	//	round: the fdiv method	if (res < 0)	candidate = candidate+1;	if (candidate < 0)	//	ratio exceeds (2^15)-1	{	Draw.Edit.Message('ERROR: Ratio out of range.');		return false;	}	return true;end validxaxbyayb;handle.pitch.mode.switch: proc swapable;	dcl id_lo	fixed;	dcl id_hi	fixed;	do case Fetch.Switch(Screen.Event.Id);		{	//	CASE 0:	TRANSPOSE			//		fields:	pitch.xpos.from			//					pitch.xpos.to			//					pitch.xpos.semitones			//	remove possible previous fields			id_lo	= gid(pitch.inv.from)			- 1;			id_hi	= gid(pitch.inv.to);			Erase.Object.Range(id_lo, id_hi);	Disable.Object.Range(id_lo, id_hi);			id_lo	= gid(pitch.scale.xa)			- 1;			id_hi	= gid(pitch.scale.percent)		+ 1;			Erase.Object.Range(id_lo, id_hi);	Disable.Object.Range(id_lo, id_hi);			//	enable new fields			id_lo	= gid(pitch.xpos.from)			- 1;			id_hi	= gid(pitch.xpos.semitones)	+ 1;			Enable.Object.Range(id_lo, id_hi);			Select.New.Cur.Obj(gid(pitch.xpos.semitones), 0, 0);			Change.Ok(9, 'TRANSPOSE');		}		{	//	CASE 1:	INVERT			//		fields:	pitch.inv.from			//					pitch.inv.to			//	remove possible previous fields			id_lo	= gid(pitch.xpos.from)			- 1;			id_hi	= gid(pitch.xpos.semitones)	+ 1;			Erase.Object.Range(id_lo, id_hi);	Disable.Object.Range(id_lo, id_hi);			id_lo	= gid(pitch.scale.xa)			- 1;			id_hi	= gid(pitch.scale.percent)		+ 1;			Erase.Object.Range(id_lo, id_hi);	Disable.Object.Range(id_lo, id_hi);			//	enable new fields			id_lo	= gid(pitch.inv.from)			- 1;			id_hi	= gid(pitch.inv.to);			Enable.Object.Range(id_lo, id_hi);			Select.New.Cur.Obj(gid(pitch.inv.from), 0, 0);			Change.Ok(9, 'INVERT');		}		{	//	CASE 2:	SCALE			//		fields:	pitch.scale.xa			//					pitch.scale.xb			//					pitch.scale.ya			//					pitch.scale.yb			//					pitch.scale.anchor			//					pitch.scale.semitones			//					pitch.scale.percent			//	remove possible previous fields			id_lo	= gid(pitch.xpos.from) - 1;			id_hi	= gid(pitch.inv.to);			Erase.Object.Range(id_lo, id_hi);	Disable.Object.Range(id_lo, id_hi);			compute_right_pitch_scale_params();			//	enable new fields			id_lo	= gid(pitch.scale.xa)			- 1;			id_hi	= gid(pitch.scale.percent)		+ 1;			Enable.Object.Range(id_lo, id_hi);			Select.New.Cur.Obj(gid(pitch.scale.xa), 0, 0);			Change.Ok(9, 'SCALE');		}	end;end handle.pitch.mode.switch;GET.CHANGE.PITCH.DIALOG.EVENT: proc (event) returns (fixed) swapable;	dcl event						fixed;	dcl (key#_from, key#_to)	fixed;	dcl id_obj						fixed;	dcl pitch_str(2)				fixed;	while (true)	{		if (event != Get.Null.Event)		{			if (Screen.Event.Group != current.dialog.grp)	return event;			if (Screen.Event.Info == S#Deposit)			{				call Erase.Edit.Message;	//	call remove.err;	//	clear any previous error message				disable.deposits	= true;				if (Screen.Event.Id == gid(pitch.mode.switch))				{					handle.pitch.mode.switch();				}				/////////////////////////////////////////////////////////////////////////////				//	TRANSPOSE objects				else if (Screen.Event.Id == gid(pitch.xpos.semitones))				{					check.limits(-(max.key#), max.key#);					//	compute the corresponding "to" pitch and deposit it into pitch.xpos.to					Fetch.String(gid(pitch.xpos.from),	pitch_str);	key#_from	= conv.str.to.key#(pitch_str);					conv.key#.to.str(key#_from + Fetch.Fixed.Point(Screen.Event.Id), pitch_str);	//	key#_to	= key#_from + semitones					Deposit.String(gid(pitch.xpos.to), pitch_str);	//	note:	pitch string may be "???"	(That's just fine...)				}				else if (Screen.Event.Id == gid(pitch.xpos.from))				{					Fetch.String(Screen.Event.Id,	pitch_str);	key#_from	= conv.str.to.key#(pitch_str);					if (key#_from == -1)					{	//	the entry was NOT valid, so use pitch.xpos.to and pitch.xpos.semitones to reset it to its original value						Fetch.String(gid(pitch.xpos.to),	pitch_str);	key#_to	= conv.str.to.key#(pitch_str);						conv.key#.to.str(key#_to - Fetch.Fixed.Point(gid(pitch.xpos.semitones)), pitch_str);	//	key#_from	= key#_to - semitones						//	leave the cursor on this field so the user can try again					}					else					{	//	the entry was valid, so compute and deposit the new pitch.xpos.to keeping pitch.xpos.semitones constant						conv.key#.to.str(key#_from + Fetch.Fixed.Point(gid(pitch.xpos.semitones)), pitch_str);	//	key#_to	= key#_from + semitones						id_obj	= gid(pitch.xpos.to);						Deposit.String(id_obj, pitch_str);	//	note:	pitch string may be "???"	(That's just fine...)						Select.New.Cur.Obj(id_obj, 0, 0);	//	select the next field automatically						//	Regenerate the string from the key number so that a deposited "XX" will display as the actual pitch.						//	(This will also keep formatting consistent - capital letters, sharps instead of flats, etc.)						conv.key#.to.str(key#_from, pitch_str);					}					Deposit.String(Screen.Event.Id, pitch_str);				}				else if	(Screen.Event.Id == gid(pitch.xpos.to))				{					Fetch.String(gid(pitch.xpos.from),	pitch_str);	key#_from	= conv.str.to.key#(pitch_str);					Fetch.String(Screen.Event.Id,			pitch_str);	key#_to		= conv.str.to.key#(pitch_str);					if (key#_to == -1)					{	//	the entry was NOT valid, so use pitch.xpos.from and pitch.xpos.semitones to reset it to its original value						conv.key#.to.str(key#_from + Fetch.Fixed.Point(gid(pitch.xpos.semitones)), pitch_str);	//	key#_to	= key#_from + semitones						//	leave the cursor on this field so the user can try again					}					else					{	//	the entry was valid, so compute the corresponding semitone value and deposit it into pitch.xpos.semitones						Deposit.Fixed.Point(gid(pitch.xpos.semitones), key#_to - key#_from);						//	select the previous field automatically						Select.New.Cur.Obj(gid(pitch.xpos.from), 0, 0);						//	Regenerate the string from the key number so that a deposited "XX" will display as the actual pitch.						//	(This would also keep formatting consistent - capital letters, sharps instead of flats, etc.)						conv.key#.to.str(key#_to, pitch_str);					}					Deposit.String(Screen.Event.Id, pitch_str);				}				/////////////////////////////////////////////////////////////////////////////				//	INVERT objects				else if (Screen.Event.Id == gid(pitch.inv.from))				{					Fetch.String(Screen.Event.Id,	pitch_str);	key#_from	= conv.str.to.key#(pitch_str);					if (key#_from == -1)					{	//	the entry was NOT valid, so replace it with the pitch that's in the "to" field						Fetch.String(gid(pitch.inv.to), pitch_str);	key#_from	= conv.str.to.key#(pitch_str);						//	leave the cursor on this field so the user can try again					}					else					{	//	the entry was valid, so select the next field automatically						Select.New.Cur.Obj(gid(pitch.inv.to), 0, 0);					}					//	Regenerate the string from the key number so that a deposited "XX" will display as the actual pitch.					//	(This will also keep formatting consistent - capital letters, sharps instead of flats, etc.)					conv.key#.to.str(key#_from, pitch_str);					Deposit.String(Screen.Event.Id, pitch_str);				}				else if	(Screen.Event.Id == gid(pitch.inv.to))				{					Fetch.String(Screen.Event.Id,	pitch_str);	key#_to	= conv.str.to.key#(pitch_str);					if (key#_to == -1)					{	//	the entry was NOT valid, so replace it with the pitch that's in the "from" field						Fetch.String(gid(pitch.inv.from), pitch_str);	key#_to	= conv.str.to.key#(pitch_str);						//	leave the cursor on this field so the user can try again					}					else					{	//	the entry was valid, so select the previous field automatically						Select.New.Cur.Obj(gid(pitch.inv.from), 0, 0);					}					//	Regenerate the string from the key number so that a deposited "XX" will display as the actual pitch.					//	(This will also keep formatting consistent - capital letters, sharps instead of flats, etc.)					conv.key#.to.str(key#_to, pitch_str);					Deposit.String(Screen.Event.Id, pitch_str);				}				/////////////////////////////////////////////////////////////////////////////				//	SCALE objects				else if				(	(Screen.Event.Id == gid(pitch.scale.xa))				||	(Screen.Event.Id == gid(pitch.scale.xb))				||	(Screen.Event.Id == gid(pitch.scale.ya))				||	(Screen.Event.Id == gid(pitch.scale.yb))				)				{					Fetch.String(Screen.Event.Id,	pitch_str);	key#_to	= conv.str.to.key#(pitch_str);					//	id_obj holds the address of the exact numerical value corresponding to this pitch field					if				(Screen.Event.Id == gid(pitch.scale.xa))		id_obj	= sav.pitch.scale.xa;					else if		(Screen.Event.Id == gid(pitch.scale.xb))		id_obj	= sav.pitch.scale.xb;					else if		(Screen.Event.Id == gid(pitch.scale.ya))		id_obj	= sav.pitch.scale.ya;					else	/*	if	(Screen.Event.Id == gid(pitch.scale.yb))	*/	id_obj	= sav.pitch.scale.yb;					if					(	(key#_to == -1)					||	(validxaxbyayb(390 * key#_to) == false)					)					{	//	the entry was NOT valid, so deposit the original string in the field using the exact numeric value						write(5)	= gid(id_obj);						write(7)	= 390;						conv.key#.to.str(read(5) + (read(4) ige (390/2)), pitch_str);						//	leave the cursor on this field so the user can try again					}					else					{	//	the entry was valid, so go to town						pid(id_obj,	390 * key#_to);	//	store exact numerical value						compute_right_pitch_scale_params();						//	Regenerate the string from the key number so that a deposited "XX" will display as the actual pitch.						//	(This will also keep formatting consistent - capital letters, sharps instead of flats, etc.)						conv.key#.to.str(key#_to, pitch_str);					}					Deposit.String(Screen.Event.Id, pitch_str);				}				else if	(Screen.Event.Id == gid(pitch.scale.anchor))				{	//	don't change sav.pitch.scale.xa,xb,ya,yb					//	just recompute and deposit pitch.scale.semitones					Fetch.String(Screen.Event.Id,	pitch_str);	key#_to	= conv.str.to.key#(pitch_str);					if (key#_to == -1)					{	//	the entry was NOT valid, so deposit the original string in the field using pitch.scale.semitones and xa,xb,ya,yb						conv.key#.to.str(compute_pitch_scale_anchor(), pitch_str);						//	leave the cursor on this field so the user can try again					}					else					{	//	the entry was valid, so go to town						compute_right_pitch_scale_params();						//	Regenerate the string from the key number so that a deposited "XX" will display as the actual pitch.						//	(This will also keep formatting consistent - capital letters, sharps instead of flats, etc.)						conv.key#.to.str(key#_to, pitch_str);					}					Deposit.String(Screen.Event.Id, pitch_str);				}//				else if//				(	(Screen.Event.Id == gid(pitch.scale.semitones))//				||	(Screen.Event.Id == gid(pitch.scale.percent))//				)//				{	//	compute and deposit new values for sav.pitch.scale.xa,xb,ya,yb//					//	deposit corresponding closest pitches in pitch.scale.xa,xb,ya,yb//					compute_left_pitch_scale_params();//				}				/////////////////////////////////////////////////////////////////////////////				//	COMMON objects				else if (Screen.Event.Id == gid(filter.sw))				{	apply.filter	= Fetch.Switch(Screen.Event.Id);				}				disable.deposits	= false;			}	//	end of if (Screen.Event.Info == S#Deposit)			else if	(Screen.Event.Info == S#MouseSelect)			{				if (Screen.Event.Id == gid(ok.button))	/*	want to do the operation	*/				{					work.msg(1);					if undo.enabled then call save.undoseq;					do case Fetch.Switch(gid(pitch.mode.switch));						{	//	CASE 0:	Transpose							Perform.Region.Command(Fetch.Fixed.Point(gid(pitch.xpos.semitones)), 0, 0, 0);	//	val, method, min, max						}						{	//	CASE 1:	Invert							Fetch.String(gid(pitch.inv.from), pitch_str);	key#_from	= conv.str.to.key#(pitch_str);							Fetch.String(gid(pitch.inv.to  ), pitch_str);	key#_to		= conv.str.to.key#(pitch_str);							if ((key#_from != -1) && (key#_to != -1))	//	if both pitches are valid							{								Perform.Region.Command(key#_to + key#_from, 1, 0, 0);	//	val, method, min, max							}						}						{	//	CASE 2:	Scale							//	precompute constants so that they need not be recomputed for each note in Transpose()							//	(390*slope_num*keynum + xb*ya - xa*yb) / (390*slope_den)  ...becomes...  (a32 * keynum + b32) / c32  with...							//	a32	= 390 * slope_num							//	b32	= (xb * ya) - (xa * yb)							//	c32	= 390 * slope_den							dcl a32(1)	fixed;	//	KEEP THESE IN ORDER							dcl b32(1)	fixed;	//	KEEP THESE IN ORDER							dcl c32(1)	fixed;	//	KEEP THESE IN ORDER							//	for readability							dcl temp			lit 'key#_from';							dcl negative	lit 'key#_to';							//	compute a32	= 390 * slope_num							temp	= gid(sav.pitch.scale.yb) - gid(sav.pitch.scale.ya);	//	this is slope_num							if (temp < 0)							{	temp		= -temp;								negative	= true;							}							else							{	negative	= false;							}							load temp; mul 390;							a32[0]	= ures;							a32[1]	= res;							if (negative != false)	neg32(a32);							//	compute b32	= (xb * ya) - (xa * yb)							temp	= gid(sav.pitch.scale.xb);							if (temp < 0)							{	temp		= -temp;								negative	= true;							}							else							{	negative	= false;							}							load temp;							temp	= gid(sav.pitch.scale.ya);							if (temp < 0)							{	temp		= -temp;								negative	= negative xor true;							}							mul temp;							b32[0]	= ures;							b32[1]	= res;							if (negative != false)	neg32(b32);							temp	= gid(sav.pitch.scale.xa);							if (temp < 0)							{	temp		= -temp;								negative	= true;							}							else							{	negative	= false;							}							load temp;							temp	= gid(sav.pitch.scale.yb);							if (temp < 0)							{	temp		= -temp;								negative	= negative xor true;							}							mul temp;							c32[0]	= ures;							c32[1]	= res;							if (negative == false)	neg32(c32);	//	invert sign to subtract using add32							add32(b32, c32, b32);							//	compute c32	= 390 * slope_den							temp	= gid(sav.pitch.scale.xb) - gid(sav.pitch.scale.xa);	//	this is slope_den							if (temp < 0)							{	temp		= -temp;								negative	= true;							}							else							{	negative	= false;							}							load temp; mul 390;							c32[0]	= ures;							c32[1]	= res;							if (negative != false)	neg32(c32);							Perform.Region.Command(addr(a32[0]), 2, 0, 0);	//	val, method, min, max						}					end;	//	end of do case Fetch.Switch(gid(pitch.mode.switch))					work.msg(0);				}	//	end of user clicked the Okay button				else if (Screen.Event.Id == gid(cancel.button))	close.dialog();			}	//	end of if (Screen.Event.Info == S#MouseSelect)		}	//	end of if (event != Get.Null.Event)		event	= Get.Next.Edit.Screen.Event;	}	//	end of infinite loopend GET.CHANGE.PITCH.DIALOG.EVENT;/////////////////////////////	procedures for UNWRAP LOOPS dialog/////////////////////////////	status:	COMPLETEDGET.UNWRAP.DIALOG.EVENT: proc (event) returns (fixed) swapable;	dcl event		fixed;	dcl (msw, lsw)	fixed;	dcl trks	(15)	fixed;	//	16 words (256 bits) representing which tracks to edit	while (true)	{		if (event != Get.Null.Event)		{			if (Screen.Event.Group != current.dialog.grp)	return event;			if (Screen.Event.Info == S#Deposit)			{				call remove.err;	//	clear any previous error message			}	//	end of if (Screen.Event.Info == S#Deposit)			else if	(Screen.Event.Info == S#MouseSelect)			{				if (Screen.Event.Id == gid(ok.button))	/*	want to do the operation	*/				{					work.msg(1);					if undo.enabled then call save.undoseq;					Fetch.32Bit.Msec(gid(unwrap.time), loc(addr(msw)));					set.soloed.trk.bits(trks);					Unwrap.Sequence(trks, msw, lsw);					work.msg(0);				}	//	end of user clicked the Okay button				else if (Screen.Event.Id == gid(cancel.button))	close.dialog();			}	//	end of if (Screen.Event.Info == S#MouseSelect)		}	//	end of if (event != Get.Null.Event)		event	= Get.Next.Edit.Screen.Event;	}	//	end of infinite loopend GET.UNWRAP.DIALOG.EVENT;GET.DIALOG.EVENT: proc(event) returns (fixed) public swapable;	dcl event	fixed;	while (true)	{		if (event == Get.Null.Event)	event	= Get.Next.Edit.Screen.Event;		else		{			if (Screen.Event.Group != current.dialog.grp) return event;			if (Screen.Event.Info == S#ObjectDrag) then do;				call Handle.Seq.Edit.Obj.Drag;				event	= Get.Null.Event;			/*	reset event	*/			end;			else do case (current.dialog);				;	/*	none at 0	*/				event	= Get.Bounce.Dialog.Event			(event);	//	case  1:				event	= Get.Change.Dur.Dialog.Event		(event);	//	case  2:				event	= Get.Change.Pitch.Dialog.Event	(event);	//	case  3:				event	= Get.Change.RTE.Dialog.Event		(event);	//	case  4:				event	= Get.Change.Vel.Dialog.Event		(event);	//	case  5:				event	= Get.Cut.Paste.Dialog.Event		(event);	//	case  6:				event	= Get.Filter.Dialog.Event			(event);	//	case  7:				event	= Get.Fit.Time.Dialog.Event		(event);	//	case  8:				event	= Get.Justify.Dialog.Event			(event);	//	case  9:				event	= Get.Midi.Dialog.Event				(event);	//	case 10:				event	= Get.Setup.Dialog.Event			(event);	//	case 11:				event	= Get.Seq.Store.Dialog.Event		(event);	//	case 12:				event	= Get.SMT.SKT.Dialog.Event			(event);	//	case 13:				event	= Get.Trk.Solos.Dialog.Event		(event);	//	case 14:				event	= Get.Trk.Vol.Dialog.Event			(event);	//	case 15:				event	= Get.UnWrap.Dialog.Event			(event);	//	case 16:				event	= Get.Cut.Paste.Dialog.Event		(event);	/*	ILP WARNING DIALOG	*/			end;		}	//	end of if (event != Get.Null.Event)	}	//	end of infinite loopend GET.DIALOG.EVENT;