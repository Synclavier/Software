/* :SYNSOU:EDITMOD:EDITTIME  $TITLE  Time routines for the sequence editor *//*Modified:1998/06/27 - TY  - Numerous efficiency tweaks to GET.TIME.EVENT.1998/06/26 - TY  - Mark is automatically set to on when the user changes it's value.1998/05/17 - TY  - Shortened a switch string by removing unnecessary trailing spaces.						 These spaces will automatically be supplied by DEFINE.SWITCH().1991/01/09 - PF  - fix for taking times when tempo map active1990/01/23 - MWH - don't deposit in poly.timbre.switch unless it exists!1989/06/09 - CJ  - fixed Mark Start switch so it updates1989/05/01 - EG  - enable dragging of mark start time1989/04/25 - EG  - bug fix for MARK not staying at TRK setting1989/03/09 - EG  - allow duration dialog parameters to accept a negative #1989/02/14 - EG  - update edit length when time mode changes w/ live click1988/10/03 - CJ  - DEFINED TIMES TO WORK WITH LIVE CLICK TRACK*//*	updates switches based on state variables	*/UPDATE.CLICK.SWITCHES: proc public swapable;	dcl sound.on	fixed;	disable.deposits = true;	sound.on = get.synclav.click.sound;					/*	find out if sound is on or off	*/	call Deposit.Switch(gid(click.switch), sound.on);	if (current.dialog = D#Setup) then do;				/*	only want to do this if showing setup dialog	*/		call Deposit.Switch(gid(click.on.switch), sound.on);		do case (gid(sync.click.mode));			call Deposit.Switch(gid(click.mode.switch), get.synclav.click.disp.format);	/*	0-bpm, 1-msec, 2-Film F/B, 3-SmpteF/B */			call Deposit.Switch(gid(click.mode.switch), 4);	/*	external		*/			call Deposit.Switch(gid(click.mode.switch), 5);	/*	live			*/		end;	end;	disable.deposits = false;end UPDATE.CLICK.SWITCHES;DEFINE.TIMES.GROUP: PROC PUBLIC SWAPABLE;	dcl mem.button.label fixed;	dcl tmp              fixed;	dcl str   (20)       fixed;	/* used for Copy.String before Fill.String.Table */	dcl swstr (10)       fixed;	/* holds switch strings */	dcl time  ( 1)       fixed;	call Set.Auto.Allocation.Id(edit.time.base);	/* reset where auto-allocation begins */	tmp = Define.32Bit.Msec(S#AA, 1, menu.col, 15, O#MSEC.Sec.Msec\O#MSEC.RealTime, cf#time, cf#default, cf#default);	call Set.Object.Arrow.Links(tmp, ARR#Auto, ARR#Auto, ARR#Auto, ARR#Auto);	call Set.Object.Mouse.Access(tmp, O#ACT.Left.Press|O#ACT.Middle.Press|O#ACT.Right.Press);	call Set.Object.Action(tmp, O#ACT.Animate.Disabled, true);	call Set.Object.Action(tmp, O#ACT.Update.On.Dep, true);	call Set.Object.Action(tmp, O#ACT.RealTime.Object, true);	/* since updates could bog real-time stuff down */	call Define.Graphics.Box(S#AA, menu.x, gpos.y(0), gpos.x(100*(menu.col+15)), rec.but.y, 0);	call pid(cur.play.time, tmp);	call Set.Object.Deposit.Reporting(gid(cur.play.time), false);	/* do not report deposits */	tmp = define.grab.icon(S#AA, -20, (100*(dialog.bot+1))+10);	call Set.Object.Action(tmp, O#ACT.Animate.Disabled, true);	call Set.Object.Mouse.Access(tmp, O#ACT.Middle.Press);	call pid(t1.grab.icon, tmp);	call Copy.String('Edit Start  :', str);	tmp = Define.Labeled.32Bit(dialog.bot+1, 3, str, 15, O#MSEC.Sec.Msec,										cf#time, cf#default, cf#default, time1);	call pid(t1.label, tmp);	tmp = define.grab.icon(S#AA, -20, (100*(dialog.bot+2))+10);	call Set.Object.Action(tmp, O#ACT.Animate.Disabled, true);	call Set.Object.Mouse.Access(tmp, O#ACT.Middle.Press);	call pid(t2.grab.icon, tmp);	call Copy.String('Edit End    :', str);	tmp = Define.Labeled.32Bit(dialog.bot+2, 3, str, 15, O#MSEC.Sec.Msec,										cf#time, cf#default, cf#default, time2);	call pid(t2.label, tmp);	tmp = define.grab.icon(S#AA, -20, (100*(dialog.bot+3))+10);	call Set.Object.Action(tmp, O#ACT.Animate.Disabled, true);	call Set.Object.Mouse.Access(tmp, O#ACT.Middle.Press);	call pid(t3.grab.icon, tmp);	call Copy.String('Edit Length :', str);	tmp = Define.Labeled.32Bit(dialog.bot+3, 3, str, 15, O#MSEC.Sec.Msec,										cf#dur, cf#default, cf#default, time3);	call pid(t3.label, tmp);	call Copy.String('Click:', str);	call Copy.String('OFF|ON', swstr);	call Define.Labeled.Switch(dialog.bot+1, 34, str, 3, swstr, click.switch);	call Copy.String('Just:', str);	call Copy.String('OFF|ON', swstr);	call Define.Labeled.Switch(dialog.bot+1, 45, str, 3, swstr, justify.switch);	/* show times in ... */	tmp = Define.Switch(S#AA, dialog.bot+1, 55, 9, 0, ' SECONDS| MINUTES|  BEATS|MEAS:BEAT|  SMPTE|FEET:FRMS');	call Set.Object.Action(tmp, O#ACT.Update.On.Dep, true);	call Set.Object.Arrow.Links(tmp, ARR#Auto, ARR#Auto, ARR#Auto, ARR#Auto);	call pid(time.mode.switch, tmp);	tmp = define.grab.icon(S#AA, 3400, 100*(dialog.bot+2)+10);	call Set.Object.Action(tmp, O#ACT.Animate.Disabled, true);	call Set.Object.Mouse.Access(tmp, O#ACT.Middle.Press);	call pid(mark.grab.icon, tmp);	call Copy.String('Mark:', str);	call Copy.String('OFF|ON|TRK', swstr);	call Define.Labeled.Switch(dialog.bot+2, 37, str, 3, swstr, mark.start.switch);	tmp = Define.32Bit.Msec(S#AA, dialog.bot+2, 48, 14, O#MSEC.Sec.Msec, cf#time, cf#default, cf#default);	call Set.Object.Arrow.Links(tmp, ARR#Auto, ARR#Auto, ARR#Auto, ARR#Auto);	call Set.Object.Mouse.Access(tmp, O#ACT.Left.Press|O#ACT.Middle.Press|O#ACT.Right.Press);	call Set.Object.Action(tmp, O#ACT.Animate.Disabled, true);	call Set.Object.Action(tmp, O#ACT.Update.On.Dep, true);	call Set.Object.Action(tmp, O#ACT.Realtime.Object, true);	call Set.Object.Drag(tmp, true, 1);	call pid(mark.start, tmp);	mem.button.label = Define.Label(S#AA, dialog.bot+3, 32, 4, '');	tmp = Define.Table(S#AA, 8, 1, mem.button.label);	call Set.Object.Drag(tmp, true, 1);	call Set.Object.Mouse.Access(tmp, O#ACT.Middle.Press\O#ACT.Middle.Release);	call Set.Object.Action(tmp, O#ACT.Prev.Obj, true);	call Copy.String('  M1|  M2|  M3|  M4|  M5|  M6|  M7|  M8', str);	call Fill.String.Table(tmp, 0, 0, 0, str);	call pid(mem.buttons, tmp);	times.grp = Group.Objects(S#AA, gid(cur.play.time), gid(mem.buttons), Get#Screen.Event\Get#New.Seq.Info\Get#Play.Scrolling);	call Activate.Group.Objects(times.grp);	call Update.Group.Objects  (times.grp);END DEFINE.TIMES.GROUP;/* This routine does 2 things:  it deposits the current time *//* in the current time display, and it sets up the           *//* Cursor.Scroll.Begin and Cursor.Scroll.End times so that   *//* we see an event when the time next needs to be updated:   */CURSOR.UPDATE: proc (round) swapable;	/* updates current time display */	dcl round     boolean;	dcl time(1)   fixed;	dcl COMPUTE.TIME.DISPLAY.SCROLLING.BOUNDARIES proc(fixed,array,array) external;	/* if rounding, present the rounded beat time that had been computed */	if round then do;		if MOVE >= 0		then call COPY32(Cursor.Scroll.End,   time);		else call COPY32(Cursor.Scroll.Begin, time);	end;	else call COPY32(loc(addr(SAMPLED.ACTUAL.PLAY.TIME.MSB)), time);	disable.deposits = true;	call Deposit.32Bit.Msec(gid(cur.play.time), time, Zero.Zero);	disable.deposits = false;	call run.syn.loop;	/* Now set up Cursor.Scroll.Begin and Cursor.Scroll.End to */	/* create the next event:                                  */	call COMPUTE.TIME.DISPLAY.SCROLLING.BOUNDARIES(time.map(Fetch.Switch(gid(time.mode.switch))),																  Cursor.Scroll.Begin,																  Cursor.Scroll.End);	/* clear possibly errant event bits: */	new.ABLE.seq.info = new.ABLE.seq.info & (not(32\64));end CURSOR.UPDATE;SET.SEQ.TIME.FORMAT: proc (switch.pos) swapable;	dcl switch.pos       fixed;	dcl format           fixed;	dcl (t1, t2, t3) (1) fixed;	format = time.map(switch.pos);		/* map switch pos to O#MSEC number */	call Set.32Bit.Msec.Display.Format(gid(time1), format, cf#time, cf#default, cf#default);	call Set.32Bit.Msec.Display.Format(gid(time2), format, cf#time, cf#default, cf#default);	if (Current.Dialog = D#CutPaste)	then call Set.32Bit.Msec.Display.Format(gid(time3), format, cf#time, cf#default, cf#default);	else call Set.32Bit.Msec.Display.Format(gid(time3), format, cf#dur, cf#default, cf#default);	call Set.32Bit.Msec.Display.Format(gid(cur.play.time), format\O#MSEC.RealTime, cf#time, cf#default, cf#default);	call Set.32Bit.Msec.Display.Format(gid(mark.start), format, cf#time, cf#default, cf#default);	if (Current.Dialog = D#Change.Dur) then do;		call Set.32Bit.Msec.Display.Format(gid(dur.add), format\O#MSEC.Allow.Minus, cf#dur, cf#default, cf#default);		call Set.32Bit.Msec.Display.Format(gid(dur.set), format, cf#dur, cf#default, cf#default);		call Set.32Bit.Msec.Display.Format(gid(dur.min), format, cf#dur, cf#default, cf#default);		call Set.32Bit.Msec.Display.Format(gid(dur.max), format, cf#dur, cf#default, cf#default);		call Set.32Bit.Msec.Display.Format(gid(dur.from),format, cf#dur, cf#default, cf#default);		call Set.32Bit.Msec.Display.Format(gid(dur.to),  format, cf#dur, cf#default, cf#default);	end;	else if (Current.Dialog = D#CutPaste) then do;		call Set.32Bit.Msec.Display.Format(gid(clip.len), format, cf#dur, cf#default, cf#default);		if (Fetch.Switch(gid(fr.switch)) = 2)		then call Set.32Bit.Msec.Display.Format(gid(silence.len), format, cf#dur, cf#default, cf#default);	end;	else if (Current.Dialog = D#EditFilter) then do;		call Set.32Bit.Msec.Display.Format(gid(dur.lo.id), format, cf#dur, cf#default, cf#default);		call Set.32Bit.Msec.Display.Format(gid(dur.hi.id), format, cf#dur, cf#default, cf#default);	end;	else if (Current.Dialog = D#Fit.Time) then do;		call Set.32Bit.Msec.Display.Format(gid(fit.time  ), format, cf#time, cf#default, cf#default);		call Set.32Bit.Msec.Display.Format(gid(fit.length), format, cf#dur, cf#default, cf#default);	end;	else if (Current.Dialog = D#Unwrap)	then call Set.32Bit.Msec.Display.Format(gid(unwrap.time), format, cf#time, cf#default, cf#default);end SET.SEQ.TIME.FORMAT;UPDATE.DISPLAYED.SEQ.INFO: proc swapable;	dcl (msw, lsw) fixed;	dcl t3 (2)     fixed;	dcl i          fixed;	call run.syn.loop;	call sample.syncl.smgr.globals;	call Set.Seq.Time.Format(Fetch.Switch(gid(time.mode.switch)));	call run.syn.loop;	call Cursor.Update(play<>0);	/* redisplay current time (rounded if playing, not rounded otherwise) */	disable.deposits = true;	call Deposit.Switch(gid(justify.switch), recd.just);	if fetch.switch(gid(mark.start.switch)) <> 2	/* if not on TRK setting */	then call Deposit.Switch(gid(mark.start.switch), mark.button.disabled = 0);	/* else leave it where it is... */	call Deposit.32Bit.Msec(gid(mark.start), loc(addr(mark.button.msb)), Zero.Zero);	call run.syn.loop;	call Update.Object(gid(time1));	/* update these objects since */	call Update.Object(gid(time2));	/* smpte offset, speed, etc   */	call Update.Object(gid(time3));	/* may have changed           */	if (current.dialog = D#Midi) AND (MAX.MIDINET.CHAN = 0) then do;		call Deposit.Switch(gid(poly.timbre.switch),poly.timbre.midi.control);	end;	disable.deposits = false;	call update.click.state.vars;		/* update variables based on click.track.mode */	call update.click.switches;		/* actually change switches                   */end UPDATE.DISPLAYED.SEQ.INFO;GET.TIME.EVENT: proc(event) returns (fixed) public swapable;	dcl event     fixed;	dcl (msw, lsw)       fixed;	dcl (col, row)       fixed;	dcl i                fixed;	dcl (t1, t2, t3) (1) fixed;	do while 1;		if event <> Get.Null.Event then do;			if (Screen.Event.Group <> times.grp) then return event;			/* now check for events we care about */			if (Screen.Event.Code = get.new.seq.info) then do;				if (Screen.Event.Info&(1\8\16\128)) <> 0 then do;					call update.displayed.seq.info;				end;				if (Screen.Event.Info&32) <> 0 then do;	/* cursor boundary */					call run.syn.loop;					call Cursor.Update(play<>0);	/* redisplay current time (rounded if playing, not rounded otherwise) */					call run.syn.loop;				end;				event = Get.Null.Event;			end;			else if (Screen.Event.Code = get.screen.event) then do;				if       ((Screen.Event.Info = S#MouseSelect)				or       (Screen.Event.Info = S#MouseActivate))				then do;					if (Screen.Event.Id = gid(mem.buttons)) then do;						call Fetch.Table.Cur.Cell(Screen.Event.Id, loc(addr(col)));						if (Screen.Event.Obj.Info = -2) then do;	/* button down */							call Fetch.32Bit.Msec(gid(mark.start), loc(addr(sav.ms)));	/* save current mark time */							msw = mem.ms(col);							lsw = mem.ls(col);							disable.deposits = 1;							call Deposit.32Bit.Msec(gid(mark.start), loc(addr(msw)), Zero.Zero);							disable.deposits = 0;						end;					end;					else do;						i = Fetch.Switch(gid(time.mode.switch));						if (i=2) or (i=3)	/* beats or meas:beats */						then do;							call compute.nearest.beat.time(loc(addr(msw)));	/* round current play time */							call Map.Real.Time.To.Sequence.Time(loc(addr(msw)),loc(addr(msw)));						end;						else do;							call TAKE.SYSTEM.SEQUENCE.TIME(loc(addr(msw)));	/* get sequencer or smpte time */						end;						if (Screen.Event.Id = gid(t1.grab.icon)) then do;							call Deposit.32Bit.Msec(gid(time1), loc(addr(msw)), Zero.Zero);						end;						else if (Screen.Event.Id = gid(t2.grab.icon)) then do;							call Deposit.32Bit.Msec(gid(time2), loc(addr(msw)), Zero.Zero);						end;						else if (Screen.Event.Id = gid(t3.grab.icon)) then do;							if Current.Dialog = D#CutPaste							then call Deposit.32Bit.Msec(gid(time3), loc(addr(msw)), Zero.Zero);							else do;								call Fetch.32bit.Msec(gid(time1), t1);								call SUB32(loc(addr(msw)), t1, loc(addr(msw)));								call Deposit.32Bit.Msec(gid(time3), t1, loc(addr(msw)));							end;						end;						else if (Screen.Event.Id = gid(mark.grab.icon)) then do;							call Deposit.32Bit.Msec(gid(mark.start), loc(addr(msw)), Zero.Zero);						end;					end;				end;				else if (Screen.Event.Info = S#Deposit) then do;					/* handle entry of time1 or time2: */					if ((Screen.Event.Id = gid(time1))					or  (Screen.Event.Id = gid(time2)))					then do;						call Fetch.32Bit.Msec(gid(time1), start);		/* keep edit region */						call Fetch.32Bit.Msec(gid(time2), finish);	/* globals up to date */						if (com16(zero.time, start) = lw#igt) then do;							start(0) = 0; start(1) = zero.time;							disable.deposits = 1;							call Deposit.32bit.Msec(gid(time1), start, Zero.Zero);							disable.deposits = 0;						end;						if (com16(zero.time, finish) = lw#igt) then do;							finish(0) = 0; finish(1) = zero.time;							disable.deposits = 1;							call Deposit.32bit.Msec(gid(time2), finish, Zero.Zero);							disable.deposits = 0;						end;						/* keep start & finish in order: */						if (Screen.Event.Id = gid(time1))		/* if entering t1 */						and (COM32(start, finish) = lw#igt)		/* but > t2       */						then do;							call COPY32(start, finish);							disable.deposits = 1;							call Deposit.32bit.Msec(gid(time2), finish, Zero.Zero);							disable.deposits = 0;						end;						if (Screen.Event.Id = gid(time2))						and (COM32(start, finish) = lw#igt)						then do;							call COPY32(finish, start);							disable.deposits = 1;							call Deposit.32bit.Msec(Screen.Event.Id, start, Zero.Zero);							disable.deposits = 0;						end;						if (current.dialog <> D#CutPaste) then do;	/* don't want to change PASTE point */							call sub32(finish, start, t3);							disable.deposits = 1;							call Deposit.32Bit.Msec(gid(time3), start, t3);							disable.deposits = 0;						end;					end;					else if (Screen.Event.Id = gid(time3))					and     (current.dialog <> D#CutPaste)					then do;						call Fetch.32Bit.Msec(gid(time1), t1);						call Fetch.32Bit.Msec(Screen.Event.Id, t3);						call add32(t1, t3, t2);						disable.deposits = 1;						call Deposit.32Bit.Msec(gid(time2), t2, Zero.Zero);						disable.deposits = 0;					end;					else if (Screen.Event.Id = gid(time.mode.switch)) then do;						call Set.Seq.Time.Format(Fetch.Switch(Screen.Event.Id));					end;					else if (Screen.Event.Id = gid(click.switch)) then do;						call set.synclav.click.sound(Fetch.Switch(Screen.Event.Id));					end;					else if (Screen.Event.Id = gid(justify.switch)) then do;						recd.just = Fetch.Switch(Screen.Event.Id);						call display.bounce.and.recd.just.buttons;					end;					else if (Screen.Event.Id = gid(mark.start.switch)) then do;						mark.button.disabled = (Fetch.Switch(Screen.Event.Id) = 0);						call select.parameter(mark.l-par.l);					end;					else if (Screen.Event.Id = gid(mark.start)) then do;						call Fetch.32Bit.Msec(Screen.Event.Id, loc(addr(msw)));						if (msw = 0) and (lsw = zero.time) then lsw = 0;						mark.button.msb = msw;						mark.button.lsb = lsw;						/* Turn Mark on for ergonomics (user probably wouldn't change mark unless intending to use it) */						mark.button.disabled = false;						call select.parameter(mark.l-par.l);					end;					else if (Screen.Event.Id = gid(cur.play.time)) then do;	/* current play time field  */						/* set current play time */						call Fetch.32Bit.Msec(Screen.Event.Id, loc(addr(msw)));						call Scroll.Seq(msw, lsw, 0);					end;					if (current.dialog = D#Fit.Time)					and (((Screen.Event.Id = gid(time1))					or   (Screen.Event.Id = gid(time2)))					or   (Screen.Event.Id = gid(time3)))					then do;						i = Fetch.Fixed.Point(gid(fit.pct));						call Deposit.Fixed.Point(gid(fit.pct), 0);	/* kludge to get around screen mgr optimization */						call Deposit.Fixed.Point(gid(fit.pct), i);	/* force dialog to update to reflect new values */					end;				end;				else if (Screen.Event.Info = S#ObjectDrag) then do;					call Handle.Seq.Edit.Obj.Drag;					event = Get.Null.Event;			/* reset event */				end;				else if (Screen.Event.Info = S#ObjectDragAbort) then do;					if (Screen.Event.Id = gid(mem.buttons)) then do;						disable.deposits = true;						/* Restore the original mark.start (saved when mouse down on mem.buttons) */						call Deposit.32Bit.Msec(gid(mark.start), loc(addr(sav.ms)), Zero.Zero);						disable.deposits = false;					end;				end;			end;		end;		event = Get.Next.Edit.Screen.Event;	end;end GET.TIME.EVENT;