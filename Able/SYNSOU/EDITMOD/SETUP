/*	:SYNSOU:EDITMOD:SETUP  $TITLE  procedures for setup dialog box in sequence editor	*//*Modified:2002/08/22 - TY  - Rewrote everything2001/02/12 - TY  - Enabled jogging and set arrow links in click rate field					  - Corrected a failure to report a "constant" change to NEW.SEQ.INFO2000/04/16 - TY  - Made changes to distinguish SMPTE frames per beat from Film frames per beat1999/04/12 - TY  - Fixed minor bug in "RESTORE.SETUP.DIALOG"1991/04/26 - cj  - updated beat display on new tempo/meter event1991/02/15 - cj  - Combined new and old usage of click/meter1991/02/06 - PF  - Update click rate displays for use with Tempo Maps1990/06/14 - LSS - changed pull-down display to NTSC 301990/05/02 - cj  - added "pull-down" smpte code1989/11/15 - TSS - Fixed display bug with SPEED = 10.0001989/08/24 - PF  - Changed smpte mode from 5 to 6 to accommodate MIDInet sync mode1988/08/08 - cj  - saved footage offset in sequence1988/07/22 - MWH - Add SMPTE check and coast time to "settings"1988/06/29 - MWH - ADD VOICE CHECK TO SEQUENCER*//*TO DO://	WHEN JOGGING CLICK FIELD, JOG SUCH THAT BEATS/MIN AND FR/BEAT TEMPOS ALWAYS INCR/DECR.  (Do this on Q-page sync panel as well)//	DO UPGRADES PERTAINING TO SMPTE FIELDS (JOGABILITY, 32-BIT SBITS OBJECT VS. 32-BIT MSEC OBJECT)*/SET.FOOTAGE.OFFSET: proc swapable;	dcl str (6)	fixed;	//	11 characters	dcl i			fixed;	/*	get user input, convert to Footage time, update synclavier	*/	Fetch.String(gid(film.displ.offset), str);	if (Conv.Str.To.Feet(str, misc.buf) == 0)	/*	only update if valid	*/	{		Normalize.Feet(misc.buf, S$FMode);		Conv.Feet.To.Str(misc.buf, str, cf#default, cf#default);		do i = 0 to 2;									/*	copy over to S$Fmode	*/			S$FOffset(i)	= misc.buf(i);			/*	save new footage		*/			write(mam)		= BAS.PTR;				/*	offset in sequence	*/			write(mal)		= SEQ.FOFFSET+i;		/*	as well					*/			write(md )		= misc.buf(i);		end;		//	create a system event when the footage offset is changed		new.seq.info	= new.seq.info \ 8;	}	else Conv.Feet.To.Str(S$FOffset, str, cf#default, cf#default);	disable.deposits	= true;	Deposit.String(gid(film.displ.offset), str);	disable.deposits	= false;end SET.FOOTAGE.OFFSET;UPDATE.DISPLAYED.SETUP.INFO: proc swapable;	dcl str(7)				fixed;	//	14 characters	dcl offset_disabled	fixed;/*		//	deposited by UPDATE.DISPLAYED.SETUP.INFO()	gid(bpm.fld)	gid(speed.fld)	gid(click.mult.fld)	gid(smpte.coast.fld)	gid(smpte.mode.switch)	gid(smpte.sync.offset)	gid(smpte.displ.offset)	gid(smpte.displ.off.sw)	gid(film.mm.switch)	gid(film.fps.switch)	gid(film.displ.offset)	//	linkmod gid/pid variables set by Update.Click.State.Vars()	pid(sync.click.sound	pid(sync.click.mode	pid(live.click.track	//	deposited by Update.Click.Switches()	gid(click.switch)			//	set to linkmod gid/pid sync.click.sound variable	gid(click.on.switch)		//	set to linkmod gid/pid sync.click.sound variable	gid(click.mode.switch)	//	set based on linkmod gid/pid sync.click.mode variable	//	deposited by Update.Click.Field()	gid(click.fld)*/	disable.deposits	= true;	call sample.syncl.smgr.globals;	call run.syn.loop;	Deposit.Fixed.Point(gid(bpm.fld), Lookup.Beats.Per.Measure(loc(addr(sampled.actual.sequence.time.msb))));	Deposit.Fixed.Point(gid(speed.fld), samp.speed);	Deposit.Fixed.Point(gid(click.mult.fld), samp.crm);	Deposit.Fixed.Point(gid(smpte.coast.fld), smpte.coast.msec);	Deposit.Switch(gid(smpte.mode.switch), sm.mode);	conv.smpte.to.str(loc(addr(sm.hrs)), str, cf#default, cf#default);	Deposit.String(gid(smpte.sync.offset), str);	//	convert the sequence's smpte sync offset to smpte bits	smpte.to.sbits(loc(addr(SM.HRS)), SM.MODE, misc.buf);	//	get the smpte display offset (in smpte bits) stored with the sequence	write(mam)			= BAS.PTR;	write(mal)			= SEQ.DOFFSET;	str(0)				= read(mdi);	str(1)				= read(mdi);	offset_disabled	= read(mdi);	add32(misc.buf, str, misc.buf);	//	convert these smpte bits back to a string and deposit it	sbits.to.smpte(misc.buf, SM.MODE, misc.buf);						//	note: input and output arrays CAN be the same	conv.smpte.to.str(misc.buf, str, cf#default, cf#default);	//	note: input and output arrays can NOT be the same	Deposit.String(gid(smpte.displ.offset), str);	Deposit.Switch(gid(smpte.displ.off.sw), (offset_disabled == false));	Deposit.Switch(gid(film.mm.switch), (S$FMode igt 2));	Deposit.Switch(gid(film.fps.switch), S$FMode mod 3);	conv.feet.to.str(S$FOffset, str, cf#default, cf#default);	Deposit.String(gid(film.displ.offset), str);	call Update.Click.State.Vars;				/*	update variables based on click.track.mode	*/	call Update.Click.Switches;				/*	update switches based on state vars	*/	call Update.Click.Field(gid(click.fld), Fetch.Switch(gid(click.mode.switch)));	disable.deposits	= false;end UPDATE.DISPLAYED.SETUP.INFO;OPEN.SETUP.DIALOG: proc public swapable;	dcl id_first	fixed;	dcl id_obj		fixed;	/*	temporary id holder	*/	dcl swstr(31)	fixed;	//	max 62 characters	'Internal|Ext 50hz|Beat|MIDI In|MIDI Aux|MIDInet|OMS MIDI|SMPTE'	dcl smpte(4)	fixed;	dcl col2			lit 'dialog.col+30';	//	Note: Except for voice.check.switch, undo.switch and smpte.check.switch, all initial deposits will be made by	//	a call to UPDATE.DISPLAYED.SETUP.INFO() triggered by setting some bits in new.ABLE.seq.info	disable.deposits	= true;	/////////////////////////////////////////////////////////////////////////////	//	column 1	//	Sync Mode: Ext 50hz	//	(row 0)	construct.sync.mode.switch.string(swstr);	id_first	= Define.Labeled.Switch(dialog.top, dialog.col, 'Sync Mode:', 8, swstr, sync.mode.switch);	//	Click: OFF 0.480 000 Sec/Beat	//	(row 1)	Define.Labeled.Switch(dialog.top+1, dialog.col, 'Click:', 3, 'OFF|ON', click.on.switch);	id_obj	= Define.Sound.File.Time(S#AA, dialog.top+1, dialog.col+11, 9, cf#default, cf#default);	/*	click field	*/	Set.Object.Mouse.Access(id_obj, O#ACT.Left.Press|O#ACT.Middle.Press|O#ACT.Right.Press);	//	necessary for jogging to work	Set.Object.Action(id_obj, O#ACT.Animate.Disabled, true); 	//	apparently also necessary for jogging to work	Set.Object.Action(id_obj, O#ACT.Update.On.Dep, true);	Set.Object.Action(id_obj, O#ACT.Realtime.Object, true);	call Select.New.Cur.Obj(id_obj, 0, 0);	pid(click.fld, id_obj);	id_obj	= Define.Switch(S#AA, dialog.top+1, dialog.col+21, 8, 0, 'Bts/Min|Sec/Beat|Film F/B|SmpteF/B|Ext. Clk|Live Clk');	Set.Object.Action(id_obj, O#ACT.Update.On.Dep, true);	pid(click.mode.switch, id_obj);	//	Speed: 10.000 Beats/Meas: 128	//	(row 2)	Define.Labeled.Fixed.Point(dialog.top+2, dialog.col	, 'Speed:', 6, 3, cf#unsigned\cf#right\cf#spfill, speed.fld);	Define.Labeled.Fixed.Point(dialog.top+2, dialog.col+14, 'Beats/Meas:', 3, 0, cf#unsigned\cf#left\cf#spfill, bpm.fld);	//	Click Multiplier: 48	//	(row 3)	Define.Labeled.Fixed.Point(dialog.top+3, dialog.col, 'Click Multiplier:', 2, 0, cf#unsigned\cf#left\cf#spfill, click.mult.fld);	//	Voice Check: OFF  Undo: OFF	//	(row 4)	Define.Labeled.Switch(dialog.top+4, dialog.col, 'Voice Check:', 3, 'OFF|ON', voice.check.switch);	Deposit.Switch(gid(voice.check.switch), do.voice.check != 0);	Define.Labeled.Switch(dialog.top+4, dialog.col+18, 'Undo:', 3, 'OFF|ON', undo.switch);	Deposit.Switch(gid(undo.switch), undo.enabled);	//	Convert MIDI to Guitar: OFF	//	(row 5)	Define.Labeled.Switch(dialog.top+5, dialog.col, 'Convert MIDI to Guitar:', 3, 'OFF|ON', convert.midi.switch);	/////////////////////////////////////////////////////////////////////////////	//	column 2	//	SMPTE Mode  : NTSC 30 Frame	//	(row 0)	Define.Labeled.Switch(dialog.top, col2, 'SMPTE Mode  :', 13, 'Drop-Frame|Non-Drop|25 Frame|24 Frame|NTSC 30 Frame', smpte.mode.switch);	//	Sync Offset : 00:00:06:00.00 	//	(row 1)	id_obj	= Define.Label(S#AA, dialog.top+1, col2, 0, 'Sync Offset :');	Set.Object.Mouse.Access(id_obj, 0);	/*	no access	*/	Set.Object.Attr(id_obj, 0, ATTR#AltIntensity);	//	POSSIBLE IMPROVEMENT:	We can't jog this field if it's a string	//	maybe we need to define a new type of screen manager object "32-bit SBits" which is joggable	id_obj	= Define.String(S#AA, dialog.top+1, col2+14, 14, O#STR.General);	/*	define as a string	*/	Set.Object.Action(id_obj, O#ACT.Update.On.Dep, true);	Set.Object.Drag(id_obj, true, 1);	pid(smpte.sync.offset, id_obj);	//	Displ Offset: 00:00:06:00.00  OFF	//	(row 2)	id_obj	= Define.Label(S#AA, dialog.top+2, col2, 0, 'Displ Offset:');	Set.Object.Mouse.Access(id_obj, 0);	/*	no access	*/	Set.Object.Attr(id_obj, 0, ATTR#AltIntensity);	id_obj	= Define.String(S#AA, dialog.top+2, col2+14, 14, O#STR.General);	/*	define as a string	*/	Set.Object.Action(id_obj, O#ACT.Update.On.Dep, true);	Set.Object.Drag(id_obj, true, 1);	pid(smpte.displ.offset, id_obj);	id_obj	= Define.Switch(S#AA, dialog.top+2, col2+14+14+2, 3, 0, 'OFF|ON');	Set.Object.Action(id_obj, O#ACT.Update.On.Dep, true);	pid(smpte.displ.off.sw, id_obj);	//	SMPTE Resync: OFF Coast Msec: 5000	//	(row 3)	Define.Labeled.Switch(dialog.top+3, col2, 'SMPTE Resync:', 3, 'OFF|ON', smpte.check.switch);	Deposit.Switch(gid(smpte.check.switch), do.smpte.check != 0);	Define.Labeled.Fixed.Point(dialog.top+3, col2+18, 'Coast Msec:', 4, 0, cf#unsigned\cf#left\cf#spfill, smpte.coast.fld);	//	FILM Mode   : 35 mm  24 fps	//	(row 4)	Define.Labeled.Switch(dialog.top+4, col2, 'FILM Mode   :', 5, '35 mm|16 mm', film.mm.switch);	pid(film.fps.switch, Define.Switch(S#AA, dialog.top+4, col2+21, 6, 0, '30 fps|25 fps|24 fps'));	//	Displ Offset: 30000:00.00	//	(row 5)	id_obj	= Define.Label(S#AA, dialog.top+5, col2, 0, 'Displ Offset:');	Set.Object.Mouse.Access(id_obj, 0);	/*	no access	*/	Set.Object.Attr(id_obj, 0, ATTR#AltIntensity);	id_obj	= Define.String(S#AA, dialog.top+5, col2+14, 11, O#STR.General);		/*	define as a string	*/	Set.Object.Action(id_obj, O#ACT.Update.On.Dep, true);	pid(film.displ.offset, id_obj);	//	note: button is raised by 3 pixels	3*10/3 = 10	id_obj	= Define.Button.Icon(S#AA, 100*(dialog.col+57), (100*dialog.bot)-10, 0, 'DONE', 0);	pid(ok.button, id_obj);	current.dialog.grp	= Group.Objects(S#AA, id_first, id_obj, Get#Screen.Event\Get#New.Seq.Info);	//	set up all the arrow links							up							down							left						right	Set.Object.Arrow.Links(gid(click.fld),				ARR#Auto,				ARR#Auto,					ARR#Auto,				gid(smpte.sync.offset));//	Set.Object.Arrow.Links(gid(speed.fld),				ARR#Auto,				ARR#Auto,					ARR#Auto,				ARR#Auto);	//	set by Define.Labeled.Fixed.Point()	Set.Object.Arrow.Links(gid(bpm.fld),				ARR#Auto,				gid(click.mult.fld),		ARR#Auto,				ARR#Auto);	Set.Object.Arrow.Links(gid(click.mult.fld),		gid(speed.fld),		ARR#Auto,					ARR#Auto,				gid(smpte.coast.fld));	Set.Object.Arrow.Links(gid(smpte.sync.offset),	ARR#Auto,				ARR#Auto,					ARR#Auto,				ARR#Auto);	Set.Object.Arrow.Links(gid(smpte.displ.offset),	ARR#Auto,				gid(smpte.coast.fld),	ARR#Auto,				ARR#Auto);	Set.Object.Arrow.Links(gid(smpte.coast.fld),		ARR#Auto,				gid(film.displ.offset),	gid(click.mult.fld),	ARR#Auto);	Set.Object.Arrow.Links(gid(film.displ.offset),	gid(smpte.coast.fld),ARR#Auto,					gid(click.mult.fld),	ARR#Auto);	Activate.Group.Objects(current.dialog.grp);	//	NOTE:	when click.track.mode is split into separate click.source and click.track	//			the following should be replaced with	pid(live.click.track, click.track);	/*	initialize fields	*/	//	if currently not in live click mode, set up track 1 as eventual initial value	if (Click.Track.Mode ilt 4)	pid(live.click.track, 2);	new.ABLE.seq.info	= new.ABLE.seq.info\8\512;	/*	force some updates to this screen	*/	current.dialog	= D#Setup;	pid(sav.cur.dialog, current.dialog);	/*	save dialog state	*/	disable.deposits	= false;end OPEN.SETUP.DIALOG;DCL DISPLAY.METER PROC EXTERNAL;		/*	VK METER DISPLAY ROUTINE	*/GET.SETUP.DIALOG.EVENT: proc(event) returns(fixed) public swapable;	dcl event		fixed;	dcl str	(7)	fixed;	//	14 characters	dcl tmp			fixed;	dcl time	(2)	fixed;	while (true)	{		if (event != Get.Null.Event)		{			if (Screen.Event.Group != current.dialog.grp)	return event;			if (Screen.Event.Code == get.new.seq.info)			{				//		 1	//	Indicates new sequence recalled				//		 2	//	Indicates new timbre name assigned to sequencer track				//		 4	//	Indicates that a note was added or deleted on a track				//		 8	//	Indicates a new constant (click rate, crm, speed, smpte start time, etc.)				//		16	//	Indicates that a new tempo or meter is now in effect				//		32	//	Indicates cursor boundary reached: the variables "cursor.scroll.begin" and "cursor.scroll.end" must be set up				//		64	//	Indicates screen boundary reached: the variables "screen.scroll.begin" and "screen.scroll.end" must be set up				//	  128	//	Indicates change in sequencer motion (start, stop).  Also set if change in current MARK START				//	  256	//	Indicates change in solo state for any track.  Also set if INFO MODE changes				//	  512	//	Indicates change in sync mode (smpte on/off, auto-punch mode change).  Also change in MIDI sync output channel number				//	 1024	//	Indicates D34 remote control				//	 2048	//	Indicates that the muted state of a synclavier track has changed.				//	 4096	//	Indicates new safe/ready for seq or dtd track (Used for multi-track midi recording & DTD)				//	 8192	//	Indicates a note was placed using VITC				//	16384	//	Indicates change in DTD track mode (input, repro)				//	32768	//	Indicates Sequence was saved				if ((Screen.Event.Info&(1\8\16\128)) != 0)	/*	sequencer constant change happened	*/				{					call update.displayed.setup.info;				}				if ((Screen.Event.Info&512) != 0)				/*	NEW SYNC MODE	*/				{					disable.deposits	= true;					Deposit.Switch(gid(sync.mode.switch), get.synclav.sync.mode);					disable.deposits	= false;				}				event	= Get.Null.Event;			}	//	end of if (Screen.Event.Code == get.new.seq.info)			else if (Screen.Event.Code == get.screen.event)			{				if (Screen.Event.Info == S#Deposit)				{					disable.deposits	= true;					call remove.err;	//	clear any previous error message					//	sync.mode.switch					if (Screen.Event.Id == gid(sync.mode.switch))					{						set.synclav.sync.mode(Fetch.Switch(gid(sync.mode.switch)));					}					//	click.on.switch					else if (Screen.Event.Id == gid(click.on.switch))					{						tmp	= Fetch.Switch(Screen.Event.Id);						set.synclav.click.sound(tmp);						Deposit.Switch(gid(click.switch), tmp);					}					//	click.fld					else if (Screen.Event.Id == gid(click.fld))					{						Fetch.Sound.File.Time(Screen.Event.Id, time);						set.synclav.click.rate(time, Fetch.Switch(gid(click.mode.switch)));	//	UPDATE.CLICK.FIELD						//	NOTE: The call to set.synclav.click.rate() will only indirectly update new.seq.info if the value actually changed.						//	Consequently, in order to assure that a min/max-limited value will replot after jogging beyond the limit,						//	it is necessary to explicitly update new.seq.info here.						new.seq.info	= new.seq.info|8;	/*	force update of all screens	*/					}					//	click.mode.switch					else if (Screen.Event.Id == gid(click.mode.switch))					{						handle.click.mode.switch(Fetch.Switch(Screen.Event.Id));					}					//	speed.fld					else if (Screen.Event.Id == gid(speed.fld))					{						check.limits(0, 10000);						store.syncl.param(3, 0, speed.l, Fetch.Fixed.Point(Screen.Event.Id));					}					//	bpm.fld					else if (Screen.Event.Id == gid(bpm.fld))					{						check.limits(1, 128);						if (meter.map.ptr == NULL)						{	//	unmapped							store.syncl.param(3, 0, bpm.l, Fetch.Fixed.Point(Screen.Event.Id));						}						else						{	//	mapped							Set.Beats.Per.Measure(loc(addr(sampled.actual.sequence.time.msb)), Fetch.Fixed.Point(Screen.Event.Id));							if (upper.disp == bpm.l-par.l)	call display.meter;						}					}					//	click.mult.fld					else if (Screen.Event.Id == gid(click.mult.fld))					{						check.limits(1, 48);						store.syncl.param(3, 0, crm.l, Fetch.Fixed.Point(Screen.Event.Id));					}					//	voice.check.switch					else if (Screen.Event.Id == gid(voice.check.switch))					{						do.voice.check	= Fetch.Switch(Screen.Event.Id);					}					//	undo.switch					else if (Screen.Event.Id == gid(undo.switch))					{						undo.enabled	= Fetch.Switch(Screen.Event.Id);						tmp				= gid(undo.button);						if (undo.enabled != false)						{	Enable.Object(tmp);	Update.Object(tmp);						}						else						{	Erase.Object(tmp);	Disable.Object(tmp);						}					}					//	convert.midi.switch					else if (Screen.Event.Id == gid(convert.midi.switch))					{						midi.to.gtr	= Fetch.Switch(Screen.Event.Id);					}					//	smpte.mode.switch					else if (Screen.Event.Id == gid(smpte.mode.switch))					{						set.synclav.smpte.mode(Fetch.Switch(Screen.Event.Id));					}					//	smpte.sync.offset					else if (Screen.Event.Id == gid(smpte.sync.offset))					{						Fetch.String(Screen.Event.Id, str);						if (conv.str.to.smpte(str, misc.buf) == 0)						{	/*	only update if valid string	*/							set.synclav.smpte.offset(misc.buf);						}						//	else restore to original						//	force a call to UPDATE.DISPLAYED.SETUP.INFO() to replot this field, the dependant display offset field,						//	and all dependant time values						new.seq.info	= new.seq.info | 8;					}					//	smpte.displ.offset					else if (Screen.Event.Id == gid(smpte.displ.offset))					{						Fetch.String(Screen.Event.Id, str);						if (conv.str.to.smpte(str, misc.buf) == 0)						{	/*	only update if valid string	*/							//	subtract the deposited smpte from the sequence's smpte start 							SUB.SMPTE(misc.buf, loc(addr(sm.hrs)), misc.buf, SM.MODE);	//	note: src and dst arrays can be the same							smpte.to.sbits(misc.buf, SM.MODE, misc.buf);						//	note: src and dst arrays can be the same							//	poke the display offset into the sequence							write(mam)	= BAS.PTR;      							write(mal)	= SEQ.DOFFSET;  							write(mdi)	= misc.buf[0];							write(mdi)	= misc.buf[1];						}						//	else restore to original						//	force a call to UPDATE.DISPLAYED.SETUP.INFO() to replot the field and all dependant time values						new.seq.info	= new.seq.info | 8;					}					//	smpte.displ.off.sw					else if (Screen.Event.Id == gid(smpte.displ.off.sw))					{						tmp				= 1 xor Fetch.Switch(Screen.Event.Id);						write(mam)		= BAS.PTR;      						write(mal)		= SEQ.DOFFDIS;  						write(md)		= tmp;						new.seq.info	= new.seq.info | 8;	//	force update of all screens					}					//	smpte.check.switch					else if (Screen.Event.Id == gid(smpte.check.switch))					{						do.smpte.check	= Fetch.Switch(Screen.Event.Id);					}					//	smpte.coast.fld					else if (Screen.Event.Id == gid(smpte.coast.fld))					{						check.limits(0, 5000);						smpte.coast.msec	= Fetch.Fixed.Point(Screen.Event.Id);					}					//	film.mm.switch					//	film.fps.switch					else if					(	(Screen.Event.Id == gid(film.fps.switch))					||	(Screen.Event.Id == gid(film.mm.switch))					)					{						Set.Synclav.Feet.Mode(Fetch.Switch(gid(film.mm.switch)), Fetch.Switch(gid(film.fps.switch)));					}					//	film.displ.offset					else if (Screen.Event.Id == gid(film.displ.offset))					{						call set.footage.offset;					}					disable.deposits	= false;				}	//	end of if (Screen.Event.Info == S#Deposit)				else if	(Screen.Event.Info == S#MouseSelect)				{					if (Screen.Event.Id == gid(ok.button))					{	/** OK BUTTON IS LABELED AS "DONE", closes dialog box and leaves	*/						pid(sav.cur.dialog, 0);	//	close.dialog() won't do this automatically since this is ok.button rather than cancel.button						call close.dialog;					}				}	//	end of if (Screen.Event.Info == S#MouseSelect)				else if (Screen.Event.Info == S#ObjectDrag)				{					call Handle.Seq.Edit.Obj.Drag;					event	= Get.Null.Event;			/*	reset event	*/				}			}	//	end of if (Screen.Event.Code == get.screen.event)		}	//	end of if (event != Get.Null.Event)		event	= Get.Next.Edit.Screen.Event;	}	//	end of infinite loopend GET.SETUP.DIALOG.EVENT;