/*	:SYNSOU:EDITMOD:CUTPASTE - $title - Routines to define and handle the cut/paste dialog box	*//*Modified:2001/09/07 - TY  - DEFINE.CUT.PASTE.DIALOG() and OPEN.CUT.PASTE.DIALOG() have been replaced with						 re-written routines INIT.CUT.PASTE.DIALOG() and OPEN.CUT.PASTE.DIALOG().2001/02/13 - TY  - Ancient bug fix: DEFINE.CUT.PASTE.DIALOG() was adding zero.time to "time3"						 which already contained the zero.time offset, causing a screwy "paste at" time.1998/05/17 - TY  - Shortened several switch strings by removing unnecessary trailing spaces.						 These spaces will automatically be supplied by DEFINE.SWITCH().			  - TY  - Declared three string constants to avoid repeated occurrences of duplicate strings.1989/07/24 - cj  - argument change for save.undoseq1989/05/12 - eeg - fix so ilp warning does not always do a cut after OK1989/05/02 - eeg - added code to restore "paste at" time for cut paste dialog1989/03/09 - EG  - open cut paste dialog was changing edit length by zero.time1988/10/03 - CJ  - DEFINED TIMES TO WORK WITH LIVE CLICK TRACK*//*TO BE DONE:	Allow "Fill from Silence" to do the same as an equivalent move?*/dcl not.first.cut		boolean;	/*	true if first cut, move, or copy has already been performed		*/dcl last.operation	fixed;	/*	used to tell what happened before a ilp warning dialog			*/SET.SOURCE.ATTRS: proc(col) swapable;	dcl col		fixed;	//	pass which of three columns was selected	dcl id_obj	fixed;	dcl i			fixed;	id_obj	= gid(source.choices);	//	unhighlight the other two table cells	do i = 0 to 2;		if (i != col)	Set.Table.Cell.Attr(id_obj, i, 0, 0, Attr#Normal);	end;	//	now highlight the one we want	Set.Table.Cell.Attr(id_obj, col, 0, 0, Attr#Reverse);	Set.Table.Cur.Cell(id_obj, col, 0);	//	undefine the previous cut button	id_obj	= gid(cut.button);	Erase.Object(id_obj);	Undefine.Object(id_obj);	//	define the new cut button and deposit the appropriate labels for the time fields	do case col;		do;			Deposit.Label(gid(t1.label), 'Cut Start   :');			Deposit.Label(gid(t2.label), 'Cut End     :');			Define.Button.Icon(id_obj, 100*(menu.col-8), 100*(dialog.top+1), 5, 'CUT', 1);		end;		do;			Deposit.Label(gid(t1.label), 'Move Start  :');			Deposit.Label(gid(t2.label), 'Move End    :');			Define.Button.Icon(id_obj, 100*(menu.col-8), 100*(dialog.top+1), 5, 'MOVE', 1);		end;		do;			Deposit.Label(gid(t1.label), 'Copy Start  :');			Deposit.Label(gid(t2.label), 'Copy End    :');			Define.Button.Icon(id_obj, 100*(menu.col-8), 100*(dialog.top+1), 5, 'COPY', 0);		end;	end;	//	dont let the following deposit cause us to come right back to this procedure	i						= disable.deposits;	disable.deposits	= true;	Deposit.Switch(gid(source.switch), col);	disable.deposits	= i;	Activate.Object.Range(id_obj, id_obj);	Update.Object(id_obj);end SET.SOURCE.ATTRS;SET.DEST.ATTRS: proc(col) swapable;	dcl col		fixed;	//	pass which of three columns was selected	dcl id_obj	fixed;	dcl i			fixed;	id_obj	= gid(dest.choices);	//	unhighlight the other two table cells	do i = 0 to 2;		if (i != col)	Set.Table.Cell.Attr(id_obj, i, 0, 0, Attr#Normal);	end;	//	now highlight the one we want	Set.Table.Cell.Attr(id_obj, col, 0, 0, Attr#Reverse);	Set.Table.Cur.Cell(id_obj, col, 0);	//	undefine the previous paste button	id_obj	= gid(paste.button);	Erase.Object(id_obj);	Undefine.Object(id_obj);	do case col;		do;			Deposit.Label(gid(t3.label), 'Paste At    :');			Define.Button.Icon(id_obj, 100*(menu.col-8), (100*(dialog.top+3))-10, 0, 'PASTE', 1);		end;		do;			Deposit.Label(gid(t3.label), 'Merge At    :');			Define.Button.Icon(id_obj, 100*(menu.col-8), (100*(dialog.top+3))-10, 0, 'MERGE', 1);		end;		do;			Deposit.Label(gid(t3.label), 'Fill At     :');			Define.Button.Icon(id_obj, 100*(menu.col-8), (100*(dialog.top+3))-10, 5, 'FILL', 1);		end;	end;	//	dont let the following deposit cause us to come right back to this procedure	i						= disable.deposits;	disable.deposits	= true;	Deposit.Switch(gid(dest.switch), col);	disable.deposits	= i;	Activate.Object.Range(id_obj, id_obj);	Update.Object(id_obj);end SET.DEST.ATTRS;/*	sets the time labels to reflect the operation in the cut/paste dialog box	*/SET.CUT.PASTE.LABELS: proc swapable;	dcl col		fixed;	dcl id		fixed;	if (Screen.Event.Id == gid(source.choices))	{		col	= Screen.Event.Table.Col;								/*	find out which table cell was clicked on	*/		if (col == Fetch.Switch(gid(source.switch)))	return;	/*	no change, return	*/	}	else if (Screen.Event.Id == gid(dest.choices))	{		col	= Screen.Event.Table.Col;								/*	find out which table cell was clicked on	*/		if (col == Fetch.Switch(gid(dest.switch)))	return;	/*	no change, return	*/	}	else if	(	(Screen.Event.Id == gid(source.switch))	||	(Screen.Event.Id == gid(dest.switch))	)	{		col	= Fetch.Switch(Screen.Event.Id);						/*	find out switch position	*/		//	no need to check for no change here because the screen manager optimization		//	prevents us from getting here if no change occurred	}	if	(	(Screen.Event.Id == gid(source.choices))	||	(Screen.Event.Id == gid(source.switch))	)	{		set.source.attrs(col);		if ((col == 2) && (Fetch.Switch(gid(to.switch)) == 2))	/*	copy to nowhere, doesn't make sense	*/		{			Deposit.Switch(gid(to.switch), 0);							/*	set to "TO   : Clipboard"				*/		}	}	else if	(	(Screen.Event.Id == gid(dest.choices))	||	(Screen.Event.Id == gid(dest.switch))	)	{		set.dest.attrs(col);		if ((col != 0) && (Fetch.Switch(gid(fr.switch)) == 2))	/*	merge or fill from silence, doesn't make sense	*/		{			Deposit.Switch(gid(fr.switch), 0);							/*	set to "FROM : Clipboard"					*/		}	}end SET.CUT.PASTE.LABELS;SET.CUT.PASTE.WORKING.MSG: proc(id, cell, on) swapable;	dcl id		fixed;	/*	id of table to set or clear					*/	dcl cell		fixed;	/*	which cell is to be set							*/	dcl on		boolean;	/*	if 1, set to blinking, else clear blink	*/	dcl id_msg	fixed;	id_msg	= gid(working.msg);	if (on == false)	{		if (mg600 != false)	Set.Table.Cell.Attr(id, cell, 0, 0, Attr#Normal\Attr#Reverse\Attr#NoBlink);		Update.Object(id);		Erase.Object(id_msg);	Disable.Object(id_msg);	//	remove message	}	else	{						/*	put up working message, or blink depending on terminal	*/		if (mg600 != false)	Set.Table.Cell.Attr(id, cell, 0, 0, Attr#Normal\Attr#Blink);		Update.Object(id);		Enable.Object(id_msg);	Update.Object(id_msg);	//	put up "working..." message	}end SET.CUT.PASTE.WORKING.MSG;INIT.CUT.PASTE.DIALOG: proc public swapable;//	pid								(sav.source.switch,	0);	//	0	= "CUT  : Delete Notes and Time"//	pid								(sav.to.switch,		0);	//	0	= "TO   : Clipboard"//	pid								(sav.dest.switch,		0);	//	0	= "PASTE: Insert Notes and Time"//	pid								(sav.fr.switch,		0);	//	0	= "FROM : Clipboard"	pid								(sav.paste.reps,		1);	//	1//	pid32								(sav.paste.at.ms,		0);	//	//	pid32								(sav.clip.len.ms,		0);	//	//	pid32								(sav.silence.len.ms,	0);	//	//	pid								(sav.to.filename,		0);	//	0	= NulStr//	pid								(sav.fr.filename,		0);	//	0	= NulStrend INIT.CUT.PASTE.DIALOG;/*	definition of the dialog box, called when cut.paste.icon is selected	*/OPEN.CUT.PASTE.DIALOG: proc public swapable;	dcl id_first	fixed;	dcl id_obj		fixed;	dcl id_label	fixed;	//	holds id of labels used for tables	dcl id_aux		fixed;	//	used to remember the begining of a range of objects for Enable.Object.Range()	dcl i				fixed;	dcl time32(1)	fixed;	dcl dur32(1)	fixed;	//	NOTE:	We need to have deposits enabled for the four top level switches, and disabled for all other items.	//	This will force the calls to GET.CUT.PASTE.DIALOG.EVENT() needed to redraw the dialog based on the settings	//	of the various switches.	/////////////////////////////////////////////////////////////////////////////	//	Action buttons	/*	the action buttons/boxes are defined first to optimize the erase procedure	*/	id_first	= Define.Button.Icon(S#AA, 100*(menu.col-8), 100*(dialog.top+1), 5, NulStr, 1);	pid(cut.button, id_first);	//	note:	button is raised by 3 pixels	3*10/3 = 10	pid(paste.button, Define.Button.Icon(S#AA, 100*(menu.col-8), (100*(dialog.top+3))-10, 5, NulStr, 1));	//	note:	button is raised by 6 pixels	6*10/3 = 20	pid(both.button, Define.Button.Icon(S#AA, 100*(menu.col-8), (100*(dialog.top+5))-20, 5, 'BOTH', 1));	/*	define done button	*/	pid(cancel.button, Define.Button.Icon(S#AA, 100*(menu.col-8), 100*dialog.top, 5, 'DONE', 0));	/////////////////////////////////////////////////////////////////////////////	//	CUT choices items	//	set up source.choices table	define.choice.icon(S#AA, 2, 100*(dialog.top+1));						//	box around source.choices table	id_label	= Define.Label(S#AA, dialog.top+1, dialog.col, 6, '');	//	label will be filled by Fill.String.Table() below	Set.Object.Action(id_label, O#ACT.Prev.Obj, true);	/*	cut choices table	*/	id_obj	= Define.Table(S#AA, 3, 1, id_label);	Fill.String.Table(id_obj, 0, 0, O#Tabl.Fill.Across, ' Cut| Move| Copy');	Set.Table.Cell.Attr(id_obj, 0, 0, 0, Attr#Reverse);	pid(source.choices, id_obj);	//	set up source.switch	id_obj	= Define.Switch	(	S#AA, dialog.top+1, dialog.col+20, 31, 0, 'CUT  : Delete Notes and Time|MOVE : Delete Notes Only|COPY : Duplicate Notes and Time'	);	Deposit.Switch(id_obj, gid(sav.source.switch));	pid(source.switch, id_obj);	/*	items for selecting the location of the clipboard	*/	//	set up to.switch	id_obj	= Define.Switch(S#AA, dialog.top+2, dialog.col+20, 16, 0, 'TO   : Clipboard|TO   : File:|TO   : Nowhere');	Deposit.Switch(id_obj, gid(sav.to.switch));	pid(to.switch, id_obj);	Enable.Object.Range(id_first, id_obj);	//	the next object won't be enabled initially	//	set up to.filename	id_obj	= Define.String(S#AA, dialog.top+2, dialog.col+33, 23, O#STR.Treename);	Set.Object.Drag(id_obj, true, 0);	Set.Object.Attr(id_obj, 0, ATTR#Reverse\ATTR#AltIntensity);	Set.Object.Attr(id_obj, 1, ATTR#Reverse\ATTR#RegIntensity);	Set.Object.Arrow.Links(id_obj, ARR#Auto, ARR#Auto, ARR#Auto, ARR#Auto);	do i = 0 to shr(gid(sav.to.filename)+1, 1);	//	note: gid(sav.to.filename) leaves xmem pointed to sav.to.filename		misc.buf(i)	= read(mdi);	end;	disable.deposits	= true;	Deposit.String(id_obj, misc.buf);	disable.deposits	= false;	pid(to.filename, id_obj);	/////////////////////////////////////////////////////////////////////////////	//	PASTE choices items	//	set up dest.choices table	(remember this id for Enable.Object.Range() later)	id_aux	= define.choice.icon(S#AA, 2, 100*(dialog.top+3));			//	box around dest.choices table	id_label	= Define.Label(S#AA, dialog.top+3, dialog.col, 6, '');	//	label will be filled by Fill.String.Table() below	Set.Object.Action(id_label, O#ACT.Prev.Obj, true);	id_obj	= Define.Table(S#AA, 3, 1, id_label);	Fill.String.Table(id_obj, 0, 0, O#Tabl.Fill.Across, ' Paste| Merge| Fill');	Set.Table.Cell.Attr(id_obj, 0, 0, 0, Attr#Reverse);	pid(dest.choices, id_obj);	//	set up dest.switch	id_obj	= Define.Switch	(	S#AA, dialog.top+3, dialog.col+20, 32, 0, 'PASTE: Insert Notes and Time|MERGE: Mix in with Current Track|FILL : Replace Notes on Track'	);	Deposit.Switch(id_obj, gid(sav.dest.switch));	pid(dest.switch, id_obj);	/*	items for selecting the location of the clipboard	*/	//	set up fr.switch	id_obj	= Define.Switch(S#AA, dialog.top+4, dialog.col+20, 16, 0, 'FROM : Clipboard|FROM : File:|FROM : Silence:');	Deposit.Switch(id_obj, gid(sav.fr.switch));	pid(fr.switch, id_obj);	Enable.Object.Range(id_aux, id_obj);	//	the next two objects won't be enabled initially	disable.deposits	= true;					//	done recording deposits for the remainder of this procedure	//	set up fr.filename	id_obj	= Define.String(S#AA, dialog.top+4, dialog.col+33, 23, O#STR.Treename);	Set.Object.Drag(id_obj, true, 0);	Set.Object.Attr(id_obj, 0, ATTR#Reverse\ATTR#AltIntensity);	Set.Object.Attr(id_obj, 1, ATTR#Reverse\ATTR#RegIntensity);	Set.Object.Arrow.Links(id_obj, ARR#Auto, ARR#Auto, ARR#Auto, ARR#Auto);	do i = 0 to shr(gid(sav.fr.filename)+1, 1);	//	note: gid(sav.fr.filename) leaves xmem pointed to sav.fr.filename		misc.buf(i)	= read(mdi);	end;	Deposit.String(id_obj, misc.buf);	pid(fr.filename, id_obj);	//	set up silence.len	id_obj	= Define.32Bit.Msec	(	S#AA, dialog.top+4, dialog.col+36, 14, time.map(Fetch.Switch(gid(time.mode.switch))), cf#dur, cf#default, cf#default	);	Set.Object.Mouse.Access(id_obj, O#ACT.Left.Press|O#ACT.Middle.Press|O#ACT.Right.Press);	Set.Object.Drag(id_obj, true, 1);	Set.Object.Action(id_obj, O#ACT.Animate.Disabled, true);	Set.Object.Action(id_obj, O#ACT.Update.On.Dep, true);	Set.Object.Attr(id_obj, 0, ATTR#Reverse\ATTR#AltIntensity);	Set.Object.Attr(id_obj, 1, ATTR#Reverse\ATTR#RegIntensity);	Set.Object.Arrow.Links(id_obj, ARR#Auto, ARR#Auto, ARR#Auto, ARR#Auto);	Fetch.32bit.Msec(gid(time1), time32);	gid32(sav.silence.len.ms, dur32);	Deposit.32Bit.Msec(id_obj, time32, dur32);	pid(silence.len, id_obj);	//	set up paste.reps		(remember this id for Enable.Object.Range() later)	id_aux	= Define.Labeled.Fixed.Point(dialog.top+5, dialog.col+20, 'COUNT:', 5, 0, cf#unsigned\cf#left\cf#spfill, paste.reps);	Deposit.Fixed.Point(gid(paste.reps), gid(sav.paste.reps));	/////////////////////////////////////////////////////////////////////////////	//	remaining objects in dialog	//	set up filter.sw	Define.Labeled.Switch(dialog.bot, 33, 'Filter:', 3, 'OFF|ON', filter.sw);	Deposit.Switch(gid(filter.sw), apply.filter);	//	inert label	id_obj	= Define.Label(S#AA, dialog.top+4, dialog.col+1, 0, 'Clipboard Length');	Set.Object.Attr(id_obj, 0, ATTR#AltIntensity);	Set.Object.Mouse.Access(id_obj, 0);	//	set up clipboard length	id_obj	= Define.32Bit.Msec	(	S#AA, dialog.top+5, dialog.col+2, 15, time.map(Fetch.Switch(gid(time.mode.switch))), cf#dur, cf#default, cf#default	);	Set.Object.Mouse.Access(id_obj, 0);	Set.Object.Action(id_obj, O#ACT.Update.On.Dep, true);	gid32(sav.clip.len.ms, dur32);	Deposit.32Bit.Msec(id_obj, time32, dur32);	pid(clip.len, id_obj);	Enable.Object.Range(id_aux, id_obj);	current.dialog.grp	= Group.Objects(S#AA, id_first, id_obj, Get#Screen.Event);	/////////////////////////////////////////////////////////////////////////////	//	dependent fields outside the dialog	//	restore saved "Paste/Merge/Fill At" time	id_obj	= gid(time3);	Set.32Bit.Msec.Display.Format(id_obj, time.map(Fetch.Switch(gid(time.mode.switch))), cf#time, cf#default, cf#default);	gid32(sav.paste.at.ms, time32);	//	deposit the saved "Paste/Merge/Fill At" time only if it has been set up	//	else just leave the existing time there (it will match time1 since O#MSEC.Type has been changed from CF#DUR to CF#TIME)	if ((time32(0)|time32(1)) != 0)	Deposit.32Bit.Msec(id_obj, time32, Zero.Zero);	current.dialog	= D#CutPaste;	pid(sav.cur.dialog, current.dialog);	/*	save dialog state	*/	disable.deposits	= false;end OPEN.CUT.PASTE.DIALOG;CLOSE.CUT.PASTE.DIALOG: proc public swapable;	dcl i				fixed;	dcl time32(1)	fixed;	pid(sav.source.switch,	Fetch.Switch		(gid(source.switch)));	pid(sav.to.switch,		Fetch.Switch		(gid(to.switch)));	pid(sav.dest.switch,		Fetch.Switch		(gid(dest.switch)));	pid(sav.fr.switch,		Fetch.Switch		(gid(fr.switch)));	pid(sav.paste.reps,		Fetch.Fixed.Point	(gid(paste.reps)));	Fetch.32Bit.Msec(gid(time3),			time32);	pid32(sav.paste.at.ms,		time32);	Fetch.32Bit.Msec(gid(clip.len),		time32);	pid32(sav.clip.len.ms,		time32);	Fetch.32Bit.Msec(gid(silence.len),	time32);	pid32(sav.silence.len.ms,	time32);	Fetch.String(gid(to.filename), misc.buf);	pid(sav.to.filename, misc.buf(0));	do i = 1 to shr(misc.buf(0)+1, 1);		write(mdi)	= misc.buf(i);	//	note: pid(sav.to.filename) leaves xmem pointed ONE WORD AFTER sav.to.filename	end;	Fetch.String(gid(fr.filename), misc.buf);	pid(sav.fr.filename, misc.buf(0));	do i = 1 to shr(misc.buf(0)+1, 1);		write(mdi)	= misc.buf(i);	//	note: pid(sav.fr.filename) leaves xmem pointed ONE WORD AFTER sav.to.filename	end;end CLOSE.CUT.PASTE.DIALOG;/*	checks the current sequence for independent loops on any tracks	*/CHECK.FOR.ILPS: proc returns(boolean) swapable;	dcl has.ilp boolean;					/*	true if this seq. has ilp's	*/	dcl trk		fixed;	has.ilp	= false;	trk		= num.kbd.tracks;	while ((has.ilp == false) and (trk ilt 202))	{		write(mam)	= trk.head;		write(mal)	= trk;		if (read(md) != 0)	/*	if this trk has a trk head	*/		{			write(mam)	= read(md);		/*	then point to it				*/			write(mal)	= thd.active;	/*	see if active					*/			if (read(md) != 0)			{				write(mal)	= thd.ilp;				has.ilp		= read(md);			}		}		trk	= trk + 1;	}	return has.ilp;end CHECK.FOR.ILPS;/*	checks for ilp's, and if user is cutting or moving, gives a warning	*/MAYBE.OPEN.ILP.WARNING.DIALOG: proc (which) returns(boolean) swapable;	dcl which	fixed;	//	pass in id of cut or paste button	dcl sw_pos	fixed;	dcl id_both	fixed;	dcl warn		boolean;	id_both	= gid(both.button);	warn		= false;	if (which == gid(cut.button))	{		sw_pos	= Fetch.Switch(gid(source.switch));		if		(	((sw_pos == 0) || (sw_pos == 1))		&&	(check.for.ilps != false)		)		{			warn	= true;			if			(Screen.Event.Id == which)		last.operation	= 1;	/*	doing a cut	*/			else if	(Screen.Event.Id == id_both)	last.operation	= 3;	/*	doing both, blew up on the cut	*/		}	}	else if (which == gid(paste.button))	{		if ((Fetch.Switch(gid(dest.switch)) == 0) && (check.for.ilps != false))		{			warn	= true;			if			(Screen.Event.Id == which)		last.operation	= 2;	/*	doing a paste	*/			else if	(Screen.Event.Id == id_both)	last.operation	= 4;	/*	doing both, blew up on the paste	*/		}	}	if (warn != false)	{		dcl id_first	lit 'sw_pos';		dcl id_obj		lit 'id_both';		call close.dialog;		id_first	= Define.Label(S#AA, dialog.top  , dialog.col, 0, 'WARNING: There are Tracks in this Sequence which contain');		id_obj	= Define.Label(S#AA, dialog.top+1, dialog.col, 0, '         Independent Loops. The CUT, MOVE and PASTE operations');		id_obj	= Define.Label(S#AA, dialog.top+2, dialog.col, 0, '         may produce unexpected results unless you first');		id_obj	= Define.Label(S#AA, dialog.top+3, dialog.col, 0, '         UNWRAP the Sequence.');		fill.ok(0, 'GO AHEAD', 'CANCEL');		current.dialog.grp	= Group.Objects(S#AA, id_first, gid(cancel.button), Get#Screen.Event);		Activate.Group.Objects(current.dialog.grp);		Disable.Object(gid(working.msg));		current.dialog			= D#ILP.Warn;		pid(sav.cur.dialog, current.dialog);	/*	save dialog state	*/		return true;	}	else return false;end MAYBE.OPEN.ILP.WARNING.DIALOG;HANDLE.CUT.PASTE.ERROR: proc (stat) swapable;	dcl stat	fixed;	if			(stat == E#NoFindClip)	call no.find.clip.error;	else if	(stat == E#NoOpenClip) then call no.open.clip.error;	else if	(stat == E#NoRoom) then call no.room.error;	else if	(stat == E#OldSeq) then call oldseq.error;	else if	(stat == E#LengthErr) then call length.error;	else if	(stat == E#ZeroLength) then call zerolen.error;	else if	(stat == E#TooLong) then call toolong.error;end HANDLE.CUT.PASTE.ERROR;/*	routine called to perform cut/copy/move operation	*/DO.THE.CUT: proc returns(boolean) swapable;	dcl op					fixed;	dcl treename(13-1)	fixed;	dcl stat					fixed;	dcl tmp					fixed;	dcl trks		(16-1)	fixed;	dcl length	(1)		fixed;	dcl time		(1)		fixed;	dcl i						fixed;	tmp	= Fetch.Switch(gid(source.switch));	do case tmp;		op	= edit#cut;		op	= edit#move;		op	= edit#copy;	end;	set.soloed.trk.bits(trks);	write(mam)	= bas.ptr;		/*	store track solo state with sequence for use in paste	*/	write(mal)	= seq.cbits.valid;	write(mdi)	= 1;				/*	indicate that bits have been saved		*/	do i = 0 to 15;				/*	write out bit words							*/		write(mdi)	= trks(i);	end;	if	(	(start(0) igt finish(0))	|| (	(start(0) == finish(0))		&&	(start(1) ige finish(1))		)	)	{		call inverse.error;		return 0;						/*	error, so exit	*/	}	do case (Fetch.Switch(gid(to.switch)));		treename(0)	= 0;				/*	cut to clip	*/		do;			Fetch.String(gid(to.filename), treename);			if  (locate(treename, 1))				/*	if file is found	*/			and (F#Type != T#Sync) then do;			/*	but not a sequence file	*/				copy.string(treename, token);				call file.type.error;				return 0;				/*	error, so exit	*/			end;		end;		;	/*	cut to nowhere	*/	end;	set.cut.paste.working.msg(gid(source.choices), tmp, 1);	/*	turn on working message	*/	if undo.enabled then call save.undoseq;	if (Fetch.Switch(gid(to.switch)) != 2) then do;		stat	= cut.copy.move(op, trks, start, finish, treename);		if (stat != 0)		then handle.cut.paste.error(stat);		else do;			sub32(finish, start, length);	/*	update clipboard length	*/			Fetch.32bit.Msec(gid(time1), time);			disable.deposits	= 1;			Deposit.32Bit.Msec(gid(clip.len), time, length);			disable.deposits	= 0;			if (not.first.cut == false)				/*	if this is the first cut		*/			&& (Fetch.Switch(gid(to.switch)) == 0)	/*	used clipboard	*/			then not.first.cut	= true;				/*	set flag, used by paste	*/		end;	end;	else do;		sub32(finish, start, length);		Punch.Region(trks, start, length, (op == edit#cut));		call Compute.Active.Trks;			/*	recompute all THD.ACTIVE bits	*/		call Check.Memory.For.Record;		/*	put memory into optimal state	*/		call Play.Initialize;				/*	reset sequencer	*/	end;	/*	move to the edit start time to make it easy to review the edit	*/	Fetch.32Bit.Msec(gid(time1), length);	Scroll.Seq(length(0), length(1), 1);	set.cut.paste.working.msg(gid(source.choices), tmp, 0);	/*	turn off working message	*/	return 1;end DO.THE.CUT;/*	routine called to perform paste/merge/fill operation	*/DO.THE.PASTE: proc swapable;	dcl op						fixed;	dcl treename	(13-1)	fixed;	dcl stat						fixed;	dcl tmp						fixed;	dcl trks			(16-1)	fixed;	dcl frsw						fixed;	dcl paste.time	(1)		fixed;	dcl length		(1)		fixed;	sub32(finish, start, length);							/*	find out region length	*/	tmp	= Fetch.Switch(gid(dest.switch));	do case tmp;		op	= edit#paste;		op	= edit#merge;		op	= edit#fill;	end;	frsw	= Fetch.Switch(gid(fr.switch));	do case (frsw);		do;											/*	pasting from clipboard	*/			if (not.first.cut == false)		/*	first cut hasn't happened yet		*/			then do;				call empty.clip.error;				return 0;							/*	error, so exit	*/			end;			else treename(0)	= 0;		end;		do;											/*	pasting from file		*/			Fetch.String(gid(fr.filename), treename);	/*	use filename	*/			if not(locate(treename, 1)) then do;		/*	couldn't find paste file	*/				call file.not.found.error;				return 0;							/*	error, so exit	*/			end;			if (F#Type != T#Sync) then do;	/*	not a sequence file	*/				copy.string(treename, token);				call file.type.error;				return 0;							/*	error, so exit	*/			end;		end;		do;											/*	pasting from silence	*/			op	= edit#insert;						/*	this overrides the other settings	*/			Fetch.32Bit.Msec(gid(silence.len), length);			Fetch.32Bit.Msec(gid(time3), paste.time);		/*	find out where to paste	*/		end;	end;	Fetch.32Bit.Msec(gid(time3), paste.time);	/*	find out where to paste	*/	set.soloed.trk.bits(trks);						/*	set up tracks to paste	*/	set.cut.paste.working.msg(gid(dest.choices), tmp, 1);	/*	turn on working message	*/	if undo.enabled then call save.undoseq;	if (op == edit#insert)	then stat	= paste.silence(trks, paste.time, length);	else stat	= paste.merge.fill(op, trks, paste.time, treename, Fetch.Fixed.Point(gid(paste.reps)));	if (stat != 0) then handle.cut.paste.error(stat);	/*	move to the paste time to make it easy to review the edit	*/	Fetch.32Bit.Msec(gid(time3), length);	Scroll.Seq(length(0), length(1), 1);	set.cut.paste.working.msg(gid(dest.choices), Fetch.Switch(gid(dest.switch)), 0);	/*	turn off working message	*/	return 1;end DO.THE.PASTE;HANDLE.CUT.TO.SWITCH: proc swapable;	dcl sw.pos	fixed;	dcl fn		fixed;	sw.pos	= Fetch.Switch(gid(to.switch));	fn			= gid(to.filename);	if (sw.pos == 1)	{	//	enable and select the filename field		Enable.Object(fn);		Select.New.Cur.Obj(fn, 0, 0);	}	else	{	//	disable the filename field		Erase.Object(fn);	Disable.Object(fn);		Select.New.Cur.Obj(gid(paste.reps), 0, 0);	//	at least keep the cursor in the dialog		if		(	(sw.pos == 2)										/*	cutting to nowhere	*/		&&	(Fetch.Switch(gid(source.switch)) == 2)	/*	operation is copy (which doesn't make sense)	*/		)		{	Deposit.Switch(gid(source.switch), 0);		/*	set to cut	*/		}	}end HANDLE.CUT.TO.SWITCH;HANDLE.PASTE.FROM.SWITCH: proc swapable;	dcl sw.pos	fixed;	dcl id_obj	fixed;	sw.pos	= Fetch.Switch(gid(fr.switch));	//	first disable possible previous objects	if (sw.pos != 1)	{	/*	don't want to show filename field		*/		id_obj	= gid(fr.filename);	Erase.Object(id_obj);	Disable.Object(id_obj);	}	if (sw.pos != 2)	{	/*	don't want to show silence time field	*/		id_obj	= gid(silence.len);	Erase.Object(id_obj);	Disable.Object(id_obj);	}	//	then enable possible new objects	if (sw.pos == 1)	{	/*	show filename field	*/		id_obj	= gid(fr.filename);	Enable.Object(id_obj);	}	else if (sw.pos == 2)	{	/*	show silence time field	*/		Deposit.Switch(gid(dest.switch), 0);	/*	it only makes sense to PASTE from silence	*/	//	WHY NOT FILL?		id_obj	= gid(silence.len);	Enable.Object(id_obj);	}	else	{		id_obj	= gid(paste.reps);	//	at least keep the cursor in the dialog	}		Select.New.Cur.Obj(id_obj, 0, 0);end HANDLE.PASTE.FROM.SWITCH;GET.CUT.PASTE.DIALOG.EVENT: proc(event) returns (fixed) public swapable;	dcl event				fixed;	dcl tmp					fixed;	dcl (s1, s2)(13-1)	fixed;	dcl bomb.out			label;	while (true)	{		if (event != Get.Null.Event)		{			if (Screen.Event.Group != current.dialog.grp)	return event;			if (Screen.Event.Info == S#Deposit)			{				call remove.err;	//	clear any previous error message				if				(	(Screen.Event.Id == gid(source.switch))	/*	changing cut or paste mode	*/				||	(Screen.Event.Id == gid(dest.switch))				)				{					call set.cut.paste.labels;				}				else if	(Screen.Event.Id == gid(to.switch))				{					call handle.cut.to.switch;				}				else if	(Screen.Event.Id == gid(fr.switch))				{					call handle.paste.from.switch;				}				else if	(Screen.Event.Id == gid(paste.reps))				{					check.limits(1, 32767);				}				else if	(Screen.Event.Id == gid(filter.sw))				{					apply.filter	= Fetch.Switch(Screen.Event.Id);				}			}	//	end of if (Screen.Event.Info == S#Deposit)			else if	(Screen.Event.Info == S#MouseSelect)			{				if				(	(Screen.Event.Id == gid(cut.button))				||	(Screen.Event.Id == gid(paste.button))				||	(Screen.Event.Id == gid(both.button))		/*	want to cut & paste	*/				)				{					if (Screen.Event.Id == gid(both.button))					{	/*	test to make sure that "to" and "from" are the same	*/						if (Fetch.Switch(gid(to.switch)) != Fetch.Switch(gid(fr.switch)))						{							call diff.name.error;							goto bomb.out;								/*	error, so exit	*/						}						else if ((Fetch.Switch(gid(to.switch)) == 1))	/*	using a filename	*/						{							Fetch.String(gid(to.filename), s1);							Fetch.String(gid(fr.filename), s2);							if (eqstr(s1, s2) != 0)							{								call diff.name.error;								goto bomb.out;							/*	error, so exit	*/							}						}					}					if					(	(Screen.Event.Id == gid(cut.button))					||	(Screen.Event.Id == gid(both.button))	/*	want to cut AND paste	*/					)					{	/*	do CUT operation	*/						if (maybe.open.ilp.warning.dialog(gid(cut.button)) != false)						{							goto bomb.out;		/*	want to wait to see if they hit ok or cancel	*/						}						call Do.The.Cut;					}					if					(	(Screen.Event.Id == gid(paste.button))					||	(Screen.Event.Id == gid(both.button))	/*	want to cut AND paste	*/					)					{	/*	do PASTE operation	*/						if (maybe.open.ilp.warning.dialog(gid(paste.button)) != false)						{							goto bomb.out;		/*	want to wait to see if they hit ok or cancel	*/						}						if (num.of.soloed.tracks == 0)						{							call no.solos.error;							goto bomb.out;						}						call Do.The.Paste;					}				}	//	end of if Screen.Event.Id == cut, paste, or both button				else if				(	(Screen.Event.Id == gid(source.choices))	/*	changing cut or paste mode	*/				||	(Screen.Event.Id == gid(dest.choices))				)				{					call set.cut.paste.labels;				}				else if	(Screen.Event.Id == gid(cancel.button))				{					call close.dialog;				}				else if	(Current.Dialog == D#ILP.Warn)				{					tmp	= gid(ok.button);						/*	save id, gets cleared on close.dialog	*/					call close.dialog;					call Open.Cut.Paste.Dialog;				/*	restore settings	*/					if (tmp == Screen.Event.Id)				/*	ok button was hit	*/					{						if						(	(last.operation == 1)				/*	if we were about to cut	*/						||	(last.operation == 3)				/*	or both and blew up on cut	*/						)						{							call do.the.cut;						/*	go ahead and cut	*/						}						if						(	(last.operation == 2)				/*	if we were about to paste	*/						||	(last.operation == 3)				/*	or both and blew up on cut	*/						||	(last.operation == 4)				/*	or both and blew up on paste	*/						)						{							if (num.of.soloed.tracks == 0)							{								call no.solos.error;								goto bomb.out;							}							call do.the.paste;					/*	go ahead and paste	*/						}					}				}	//	end of if warning dialog			}	//	end of if (Screen.Event.Info == S#MouseSelect)			else if	(Screen.Event.Info == S#ObjectDrag)			{				if				(	(Screen.Event.Id == gid(to.filename))				||	(Screen.Event.Id == gid(fr.filename))				)				{					Fetch.String(Screen.Event.Id, s1);					Deposit.String(Screen.Event.Obj.Info, s1);				}				else if (Screen.Event.Id == gid(silence.len))				{					call Handle.Seq.Edit.Obj.Drag;				}//				else if (Screen.Event.Id == gid(clip.len))//				{//					call Handle.Seq.Edit.Obj.Drag;	//	clip.len support not yet implemented//				}			}	//	end of if (Screen.Event.Info == S#ObjectDrag)		}	//	end of if (event != Get.Null.Event)		bomb.out:	//	if something fails, come here		event	= Get.Next.Edit.Screen.Event;	}	//	end of infinite loopend GET.CUT.PASTE.DIALOG.EVENT;