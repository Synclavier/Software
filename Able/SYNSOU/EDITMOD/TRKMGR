/* :SYNSOU:EDITMOD:TRKMGR - $title - Routines to define track manager, and to do animation and soloing *//* Modified:   05/15/90 - tss - fixed info button trk blink bug   07/28/89 - cj - created a system event when the safe/ready status                   of a syncl track is changed.                        10/03/88 - CJ - DEFINED TIMES TO  WORK WITH LIVE CLICK TRACK*//***** information needed by trk.mgr *****/dcl (first.col,first.row)	fixed;	/* where mouse button is first pressed */dcl (last.col,last.row)		fixed;	/* where mouse button was pressed last time we checked */dcl (cur.col,cur.row)		fixed;	/* where mouse button was just pressed */dcl (first.trk, last.trk, cur.trk) fixed ;	/* selected tracks */dcl new.solo.state			fixed;	/* solo state caused by mouse selection */dcl which.button				fixed;dcl animating					fixed;/* looks to see what is currently soloed and sets bits */TAKE.SNAPSHOT.OF.SOLOED.TRACKS: proc swapable;   dcl (mask, i, j, solo.bits) fixed;   dcl my.bits                 fixed;   write(mam)	= trd.ptr;                       /* save record track */   write(mal)	= new.recd.trk;   write(md)	= recd.trk;   solo.bits	= 0;   my.bits		= 0;   mask			= 1;   do i=0 to 255;                               /* loop over all tracks */      if i IGE num.kbd.tracks then do;          /* not a keyboard trk   */         write(mam) = tbut.ptr;         write(mal) = i;                        /* set ptr to next trk */         if  ((read(md)&b.soloed.trk)<>0)       /* trk is soloed       */         or  ((recd<>0) and (recd.trk<>0)       /* or doing syncl      */         and  ((read(md)&b.ready.trk)<>0))      /* recording and this  */         then do;                               /* track is readied    */            solo.bits = solo.bits \ mask;       /* so set bit in word  */            if j<>0 then my.bits = my.bits \ mask;         end;      end;      mask = shl(mask, 1);                      /* advance bit to next pos */      if mask = 0 then do;                      /* done with next group of 16 tracks */         mask = 1;                              /* reset bit */         write(mam) = trd.ptr;                  /* write out bits to snap shot area */         write(mal) = new.solo.bits + shr(i, 4);         write(md)  = solo.bits;         write(mal) = old.solo.bits + shr(i, 4);         write(md)  = read(md)&(not(my.bits));         solo.bits=0;                           /* turn off bits again */         my.bits  =0;         write(mam) = tbut.ptr;                 /* restore ptr to trk button array */      end;   end;end TAKE.SNAPSHOT.OF.SOLOED.TRACKS;TAKE.SNAPSHOT.OF.ENABLED.TRACKS: proc swapable;   dcl (mask, i, solo.bits) fixed;   write(mam) = trd.ptr;                       /* save record track */   write(mal) = new.recd.trk;   write(md)  = 0;   solo.bits   = 0;   mask        = 1;   do i=0 to 255;                               /* loop over all tracks */      if i IGE num.kbd.tracks then do;          /* not a keyboard trk   */         write(mam)=tbut.ptr;         write(mal)=i;         if ((read(md)&b.ready.trk)<>0) and (i<first.lod.track)         then solo.bits = solo.bits \ mask;     /* so set bit in word  */      end;      mask = shl(mask, 1);                      /* advance bit to next pos */      if mask = 0 then do;                      /* done with next group of 16 tracks */         mask = 1;                              /* reset bit */         write(mam) = trd.ptr;                  /* write out bits to snap shot area */         write(mal) = new.solo.bits + shr(i, 4);         write(md)  = solo.bits;         solo.bits=0;                           /* turn off bits again */         write(mam) = tbut.ptr;                 /* restore ptr to trk button array */      end;   end;end TAKE.SNAPSHOT.OF.ENABLED.TRACKS;set.track.enable.state: proc (trk1,trk2,state) public swapable;   dcl (trk1,trk2) fixed;   dcl state       fixed;   dcl i           fixed;   if  (recd<>0)   and (recd.trk<>0) then return;   if trk2 < trk1 then do;      i = trk1;      trk1 = trk2;      trk2 = i;   end;   write(mam) = tbut.ptr;   do i = trk1 to trk2;      if i<first.lod.track then do;         write(mal)=i;         if state=0 then do;            if (read(md)&b.ready.trk)<>0            then do;               num.enabled.trks=num.enabled.trks-1;               write(md)=(read(md)&(not(b.ready.trk)));               /* create a system event when changing the */               /* track safe/ready status of a syncl      */               /* track:                                  */               new.seq.info = new.seq.info \ 4096;            end;         end;         else do;            if (read(md)&b.ready.trk)=0            then do;               num.enabled.trks=num.enabled.trks+1;               write(md)=read(md)\b.ready.trk;               /* create a system event when changing the */               /* track safe/ready status of a syncl      */               /* track:                                  */               new.seq.info = new.seq.info \ 4096;            end;         end;      end;   end;   call display.track.buttons;end set.track.enable.state;/* makes sure solo display matches current settings */UPDATE.TRK.MGR: proc (take.snapshot, force) public swapable;       dcl take.snapshot       boolean;           dcl force               boolean;   /* force update to happen */   dcl (group, trk, i)       fixed;   dcl (new.recd, old.recd) fixed;   dcl (new, old)           fixed;   dcl attrs                fixed;   if take.snapshot   then do case set.enables;      call Take.Snapshot.of.Soloed.Tracks; /* get copy of current state of trks */      call Take.Snapshot.of.Enabled.Tracks; /* get copy of current state of trks */   end;/******************************//*   call cpos(2, 0); call tty_wait; disable;   write(mam)=trd.ptr;   write(mal)=new.recd.trk;   print read(md), ' ', ;   do i=0 to 7;      write(mal)=new.solo.bits+i;      print octal(read(md)), ' ', ;   end; print '                                     ';   print '       ', ;   do i=8 to 15;      write(mal)=new.solo.bits+i;      print octal(read(md)), ' ', ;   end; print '                                     ';   write(mam)=trd.ptr;   write(mal)=old.recd.trk;   print read(md), ' ', ;   do i=0 to 7;      write(mal)=old.solo.bits+i;      print octal(read(md)), ' ', ;   end; print '                                     ';   print '       ', ;   do i=8 to 15;      write(mal)=old.solo.bits+i;      print octal(read(md)), ' ', ;   end; print '                                     ';   enable; *//******************************/   write(mam)=trd.ptr;                  /* look up displayed recd trk */   write(mal)=new.recd.trk;             /* and desired recd trk       */   new.recd=read(md);                   /* process recd trk changes   */   write(mal)=old.recd.trk;             /* outside loop               */   old.recd=read(md);   write(md)=new.recd;                  /* will do update just below  */   if (old.recd <> new.recd)    or (force = true)   then do;                             /* need to do update here */      if old.recd ige num.kbd.tracks then do;         write(mal)=old.solo.bits+shr(old.recd, 4);   /* look up prior solo state */         if ((read(md)&bits(old.recd&15))<>0) /* trk was soloed */         then attrs=ATTR#Reverse  \ATTR#NoBlink\ATTR#AltIntensity; /* display in reverse video */         else attrs=ATTR#NoReverse\ATTR#NoBlink\ATTR#RegIntensity;         i=old.recd-num.kbd.tracks;       /* put in temp */         call Set.Table.Cell.Attr(gid(trk.buttons), i&15, shr(i, 4), 0, attrs); /* unblink old recd.trk */      end;      if new.recd ige num.kbd.tracks then do;         i=new.recd-num.kbd.tracks;       /* put in temp */         call Set.Table.Cell.Attr(gid(trk.buttons), i&15, shr(i, 4), 0, ATTR#Reverse\ATTR#Blink\ATTR#AltIntensity); /* blink new recd.trk */      end;   end;   do group=0 to 255 by 16;                  /* loop over trks in groups of 16 */      if ((new.seq.info     &(256\4096))<>0) /* if more changes are pending from  */      or ((new.ABLE.seq.info&(256\4096))<>0) /* button activity, drop out because */      then return;                           /* we know we will return here       */      write(mam)=trd.ptr;      write(mal)=new.solo.bits + shr(group, 4);      new=read(md);      write(mal)=old.solo.bits + shr(group, 4);      old=read(md);      write(md)=new;                         /* we will update these bits just below */      if (new xor old)<>0                    /* have some changes in this group */      or (force = true)      then do i=0 to 15;                     /* loop through 16 trks in this group */         trk=group+i-num.kbd.tracks;         /* compute logical trk number */         if  (trk >=  0)                     /* not a keyboard trk */         and (trk ilt 208)                   /* and on the display (L1-L8 too) */         and (trk <> (new.recd-num.kbd.tracks)) /* but not the current recd trk */         then do;                            /* check for refresh of this trk display */            if ((new xor old) & bits(i))<>0  /* this trk has changed */            or (force = true)            then do;                         /* set to correct display style */               if ((new&bits(i))<>0)then do;/* this trk is now soloed */                  write(mam)=tbut.ptr;                  write(mal)=group+i;                  if  (recd<>0)                  and (recd.trk<>0)                  and ((read(md)&b.ready.trk)<>0)                  or  (set.enables<>0)                  then attrs=ATTR#Reverse\ATTR#Blink  \ATTR#AltIntensity; /* blink enabled trks */                  else attrs=ATTR#Reverse\ATTR#NoBlink\ATTR#AltIntensity; /* display in reverse video */               end;               else attrs=ATTR#NoReverse\ATTR#NoBlink\ATTR#RegIntensity;               call Set.Table.Cell.Attr(gid(trk.buttons), trk&15, shr(trk, 4), 0, attrs);            end;         end;      end;   end;/******************************//*   call cpos(6, 0); call tty_wait; disable;   write(mam)=trd.ptr;   write(mal)=old.recd.trk;   print read(md), ' ', ;   do i=0 to 7;      write(mal)=old.solo.bits+i;      print octal(read(md)), ' ', ;   end; print '                                     ';   print '       ', ;   do i=8 to 15;      write(mal)=old.solo.bits+i;      print octal(read(md)), ' ', ;   end; print '                                     ';   enable;*//******************************/end UPDATE.TRK.MGR;/* light up buttons with notes on them for info mode */TURN.ON.INFO.TRKS: proc public swapable;   dcl (mask, i, solo.bits)   fixed;   dcl save.new.seq.info      fixed;   dcl save.new.ABLE.seq.info fixed;   solo.bits = 0;   mask      = 1;   do i=0 to 255;    /* loop over tracks */      write(mam) = trk.head;      write(mal) = i;      if (read(md) <> 0)      then solo.bits = solo.bits \ mask;        /* so set bit in word  */      mask = shl(mask, 1);                      /* advance bit to next pos */      if mask = 0 then do;                      /* done with next group of 16 tracks */         mask = 1;                              /* reset bit */         write(mam) = trd.ptr;                  /* write out bits to snap shot area */         write(mal) = new.solo.bits + shr(i, 4);         write(md)  = solo.bits;         solo.bits=0;                           /* turn off bits again */      end;   end;   write(mam) = trd.ptr;                        /* clear record trk */   write(mal) = new.recd.trk;   write(md)  = 0;   save.new.seq.info      = new.seq.info;      /* save current values */   new.seq.info           = 0;                 /* and clear temporarily */   save.new.ABLE.seq.info = new.ABLE.seq.info;   new.ABLE.seq.info      = 0;   /* need to do this or UPDATE.TRK.MGR will bomb out */   call update.trk.mgr(false, true);   new.seq.info      = save.new.seq.info;      /* restore saved values */   new.ABLE.seq.info = save.new.ABLE.seq.info;end TURN.ON.INFO.TRKS;TURN.ON.ENABLE.TRKS: proc public swapable;   dcl (mask, i, solo.bits) fixed;   solo.bits = 0;   mask      = 1;   do i=0 to 255;    /* loop over tracks */      if i ige num.kbd.tracks then do;         write(mam)=tbut.ptr;         write(mal)=i;         if (read(md)&b.ready.trk)<>0         then solo.bits = solo.bits \ mask;     /* so set bit in word  */      end;      mask = shl(mask, 1);                       /* advance bit to next pos */      if mask = 0 then do;                      /* done with next group of 16 tracks */         mask = 1;                              /* reset bit */         write(mam) = trd.ptr;                  /* write out bits to snap shot area */         write(mal) = new.solo.bits + shr(i, 4);         write(md)  = solo.bits;         solo.bits=0;                           /* turn off bits again */      end;   end;   write(mam) = trd.ptr;                        /* clear record trk */   write(mal) = new.recd.trk;   write(md)  = 0;   call update.trk.mgr(false, true);end TURN.ON.ENABLE.TRKS;PRINT.DEBUG.INFO: PROC SWAPABLE;   /*   call cpos(3, 0);   call ps(' CUR   COL: ');call pnum(cur.col, 0);   call ps(' CUR   ROW: ');call pnum(cur.row, 0);   call cpos(4, 0);   call ps(' FIRST COL: ');call pnum(first.col, 0);   call ps(' FIRST ROW: ');call pnum(first.row, 0);   call cpos(5, 0);   call ps(' LAST  COL: ');call pnum(last.col, 0);   call ps(' LAST  ROW: ');call pnum(last.row, 0);   call cpos(6, 0);   call ps(' CUR   TRK: ');call pnum(cur.trk, 0);   call ps(' FIRST TRK: ');call pnum(first.trk, 0);   call ps(' LAST  TRK: ');call pnum(last.trk, 0);   */END PRINT.DEBUG.INFO;/* $subtitle - Define.Trk.Mgr.Disp: initially defines the track button table */DEFINE.TRK.MGR.DISP: PROC PUBLIC SWAPABLE;   dcl first        fixed;   dcl tmp          fixed;  /* temporary id holder */   dcl trk.button   fixed;  /* temporary           */   dcl (row, col)   fixed;   dcl str (3)      fixed;   dcl bank         fixed;   dcl tbl.ptr      fixed; /* Pointer to table */   dcl cell.ptr     fixed; /* Pointer to table cell */   dcl i            fixed;   CONV.TRK#.TO.STR:  proc(val,str);       dcl val          fixed;   /* 16-bit value to convert */      dcl str          array;   /* output string */      dcl outstate     fixed;   /* output state control */      dcl digit        fixed;      dcl temp.str (4) fixed;      dcl i            fixed;      dcl dp           lit '0';      dcl field.width  lit '4'; /* string length used for filling */      str(0)=0;                  /* erase current string to start */      temp.str(0)=0;             /* init temp str to null */      outstate=0;                /* not printing digits yet */      do i=0 to 4;               /* loop over digits - build temp string left justified */         digit=0;                      /* assume zero */         if val IGE powers(i) then do; /* non-zero digit */            load val; div powers(i); digit=res; val=rem;            outstate=1;                /* start printing */         end;         if (outstate<>0) or (i=4)         then call appendc(temp.str,ASC.0+digit);      end;                           /* of digit loop */      do i=temp.str(0) to field.width-1; /* put fill chars into output string */         call appendc(str,sp);        /* fill with spaces */      end;      call append.to.str(str,temp.str);         end CONV.TRK#.TO.STR;   call Set.Auto.Allocation.Id(display.base);  /* reset where auto-allocation begins */   first = define.trk.grid.icon(S#AA, 0, 2300);    call pid(trk.grid, first);    trk.button = Define.Label(S#AA, 11, 0, 4, '');   call Set.Object.Action(trk.button, O#ACT.Prev.Obj, 1);   tmp = Define.Table(S#AA, 16, 13, trk.button);   call Set.Object.Action(tmp, O#ACT.Animate.Disabled, true);    call Set.Object.Mouse.Access(tmp, O#ACT.Left.Press  \O#ACT.Left.Release\                                     O#ACT.Middle.Press\O#ACT.Middle.Release\                                     O#ACT.Right.Press \O#ACT.Right.Release);   call Set.Object.Erase(tmp, O#ERAS.Start.Of.Line);   call pid(trk.buttons, tmp);    call Locate.Object(gid(trk.buttons)); /* get pointer to table */   tbl.ptr = Object.Ptr;   do row=0 to 12;          /* fill in table 1-200 */      call run.syn.loop;    /* keep things going   */      bank = shl(row, 4);      do col=0 to 15;         if (row = 12) and (col > 7) then do;    /* fill in subgroup table */            do case (col-8);               call Copy.String('  L1', str);               call Copy.String('  L2', str);               call Copy.String('  L3', str);               call Copy.String('  L4', str);               call Copy.String('  L5', str);               call Copy.String('  L6', str);               call Copy.String('  L7', str);               call Copy.String('  L8', str);            end;         end;         else call conv.trk#.to.str((bank+col+1), str);          cell.ptr = ((Row * Read.Object(tbl.ptr+O#TABL.Across) + Col) /* Row * Cells Across + Cols  */                    * Read.Object(tbl.ptr+O#TABL.Cell.Mem))           /* * Cellmem */                    + tbl.ptr+O#TABL.Table                            /* + Offset of table */                    + 2;                                              /* + 2 to get to string field */         call write.object(cell.ptr, str(0));   /* write string into table */         do i = 1 to shr(str(0), 1);            write(mdi) = str(i);         end;      end;   end;END DEFINE.TRK.MGR.DISP;OPEN.TRK.MGR.DISP: PROC PUBLIC SWAPABLE;   current.display.grp = Group.Objects(S#AA, gid(trk.grid), gid(trk.buttons), Get#Screen.Event\Get#New.Seq.Info);   current.display = #TrkMgr;   call Activate.Group.Objects(current.display.grp);   call update.trk.mgr(true, true);             /* see what is soloed & update accordingly */   call Update.Group.Objects(current.display.grp);END OPEN.TRK.MGR.DISP;MAP.MOUSE.POS: proc(cur.pos) swapable;   /* maps mouse position to a track manager table cell.      puts result in cur.row,  cur.col      if possible,  uses screen manager routine,        otherwise it calculates cur.row,  cur.col on its own;   */   dcl cur.pos boolean;   dcl (x, y)   fixed;   if (cur.pos = true) then do;      x = mouse(current.x);  /* look up mouse.pos */      y = mouse(current.y);   end;   else do;      x = mouse(release.x);        y = mouse(release.y);   end;   call Map.Point.To.Table.Cell(x, y, gid(trk.buttons), loc(addr(cur.col)));   cur.trk = (cur.row*16) + cur.col+1;   if (x < first.tbl.col) and (cur.trk > first.trk)     /* left side,  moving towards bottom */   then cur.trk = cur.trk-1; /* just want row above */   else if (y < last.tbl.row)     then cur.trk = 208;          /* select to end */end MAP.MOUSE.POS;ANIMATE.TRK.BUTTONS: proc(first, last) swapable;   dcl (first, last)  fixed;   dcl (i, tmp)       fixed;   /* copy the saved (original) solo bits to the "new" bit area */   write(mam) = trd.ptr;     write(mal) = new.recd.trk;   if (new.solo.state=solo.off) or (set.enables<>0)   then write(md) = 0;   else write(md) = last-1+num.kbd.tracks;   do i=0 to 15;      write(mal) = sav.solo.bits+i;      tmp = read(md);      write(mal) = new.solo.bits+i;      write(md) = tmp;   end;   /* now make sure that first <= last and convert to absolute trk numbers */   first=first-1+num.kbd.tracks;   last =last -1+num.kbd.tracks;   if last ilt first then do;      i=first; first=last; last=i;   end;   /* now toggle the new bits to reflect the current selection range */   do i=first to last;      write(mam) = trd.ptr;      write(mal) = new.solo.bits + shr(i, 4);      if (new.solo.state=solo.off)      then write(md)=read(md)&(not bits(i&15));      else write(md)=read(md)\     bits(i&15);   end;   call update.trk.mgr(false, false); end ANIMATE.TRK.BUTTONS;GET.TRK.MGR.ANIMATE.EVENT: proc(event) returns (fixed) swapable;   dcl event          fixed;   dcl (first, last, i) fixed;   do while 1;      if event <> Get.Null.Event then do;         if  (event <> get.mouse.movement)         then return event;         last.row = cur.row;          /* update positions */         last.col = cur.col;         last.trk = cur.trk;         call map.mouse.pos(true);           if last.trk<>cur.trk then do;            /*            call cpos(0, 0); call pc(7);            call tty_wait; disable;            print 'First: ', first.trk, '  Last: ', cur.trk, '                       ', ;            enable;            */            call Animate.Trk.Buttons(first.trk, cur.trk);         end;      end;      event = Get.Next.Edit.Screen.Event;   end;end GET.TRK.MGR.ANIMATE.EVENT;Enter.Track.Number.Into.Dialog: proc swapable; /* Stuffs a track number into a dialog that needs it */   dcl trk fixed;      trk = (Screen.Event.Table.Row*16) + Screen.Event.Table.Col + (num.kbd.tracks - 1); 	if			(current.dialog == D#Bounce)	{	   if		(	(prev.obj.id == gid(bounce.source))		||	(prev.obj.id == gid(bounce.dest))		)		{			//	defeat the screen manager's optimization so that get.bounce.dialog.event will select the next field			//	even if this click deposits the same number that is already there			disable.deposits	= true;			Deposit.Fixed.Point(prev.obj.id, 0);			disable.deposits	= false;			Deposit.Fixed.Point(prev.obj.id, trk);		}	}	else if	(current.dialog == D#SMT_SKT)	{	   if		(	(prev.obj.id == gid(smt.skt.src.track))		||	(prev.obj.id == gid(smt.skt.dst.track))		)		{			//	defeat the screen manager's optimization...			disable.deposits	= true;			Deposit.Fixed.Point(prev.obj.id, 0);			disable.deposits	= false;			Deposit.Fixed.Point(prev.obj.id, trk);		}		//	for bank and entry fields, treat the track buttons as though they were timbre entries in a .NEWDATA		else if		(	(prev.obj.id == gid(smt.skt.src.bank))//		||	(prev.obj.id == gid(smt.skt.dst.bank))		)		{			//	defeat the screen manager's optimization...			disable.deposits	= true;			Deposit.Fixed.Point(prev.obj.id, 0);			disable.deposits	= false;			Deposit.Fixed.Point(prev.obj.id, (shr(trk-1,3)&7)+1);		}		else if		(	(prev.obj.id == gid(smt.skt.src.entry))//		||	(prev.obj.id == gid(smt.skt.dst.entry))		)		{			//	defeat the screen manager's optimization...			disable.deposits	= true;			Deposit.Fixed.Point(prev.obj.id, 0);			disable.deposits	= false;			Deposit.Fixed.Point(prev.obj.id, ((trk-1)&7)+1);		}	}end Enter.Track.Number.Into.Dialog;GET.TRK.MGR.BUTTON.EVENT: proc(event) returns(fixed) swapable;   dcl event        fixed;   dcl tmp          fixed;   dcl i            fixed;   dcl str  (16)    fixed;   dcl (msb,lsb)    fixed;   dcl last.button  fixed;   dcl which.button fixed static;   dcl time.id      fixed static;   dcl time (1)     fixed;   do while 1;      if event <> Get.Null.Event then do;         if  (Screen.Event.Group <> current.display.grp)          then return event;         if (Screen.Event.Code = get.screen.event) then do;            if  (Screen.Event.Id <> gid(trk.buttons))            and (current.dialog <> D#Bounce)				//	for these dialogs, clicking on trk#				and (current.dialog <> D#SMT_SKT)			//	enters data into current field            then return event;            if  (Screen.Event.Info=S#KeyActivate)            or  (Screen.Event.Info=S#MouseSelect)		/* first selection */            or  (Screen.Event.Info=S#MouseActivate)	/* clicked a second time */            then do;               last.button  = which.button;				/* save prior value in temp */               which.button = Screen.Event.Obj.Info;	/* get info about button press/release */               if which.button < 0 then do;				/* a new mouse button PRESS */                  if  (info.on == 0)						/* and not showing info */                  and ((current.dialog == D#Bounce)	/* then for these dialogs, clicking on trk#   */						or   (current.dialog == D#SMT_SKT))	/* enters data into current field */                  then call Enter.Track.Number.Into.Dialog;                  else if (not animating)      /* not already animating */                  and     (info.on = 0)        /* not in info mode */                  then do;                     /* start up trk solo animating */                     animating = true;                     first.row = Screen.Event.Table.Row; /* set up initial values */                     first.col = Screen.Event.Table.Col;                     first.trk = (first.row*16) + first.col+1;                      last.row  = first.row;                     last.col  = first.col;                     last.trk  = first.trk;                     cur.row   = first.row;                     cur.col   = first.col;                     cur.trk   = first.trk;                     /* Display start time of track on kbd & top line */                     call Compute.Start.Time.Display(first.trk+num.kbd.tracks-1);                     call cpos(0,1); call erase.to.end.of.line;                     if (first.trk <= 200) then do;                        call ps('Track ');call pnum(first.trk,0); call ps(': ');                         write(mam)=trk.head; write(mal)=first.trk+num.kbd.tracks-1;                        write(mam)=read(md); write(mal)=thd.nn.msb;                        #msb=read(mdi);                        #lsb=read(md);                        if ((#msb\#lsb) <> 0) then do;                           time.id = Define.32Bit.Msec(S#AA, 0, 12, 15,                                             time.map(Fetch.Switch(gid(time.mode.switch))),                                             cf#time, cf#default, cf#default);                           time(0) = track.first.time.msb;                           time(1) = track.first.time.lsb;                           call Deposit.32Bit.Msec(time.id, time, Zero.Zero);                           call Activate.Object.Range(time.id, time.id);                           call Update.Object(time.id);                        end;                        else call ps(' Empty Track');                        if (Fetch.Switch(gid(mark.start.switch)) = 2)                        then do; /* put track start time into mark.start */                           call Deposit.32Bit.Msec(gid(mark.start), time, Zero.Zero);                        end;                     end;                     else do;                        call ps('Live Track ');                        call pnum(first.trk-200, 0);                     end;                     write(mam) = trd.ptr;        /* save "old" snapshot */                     write(mal)=sav.recd.trk;                     write(md )= 0;                     do i=0 to 15;                        write(mal) = old.solo.bits+i;                        tmp = read(md);                        write(mal) = sav.solo.bits+i;                        write(md) = tmp;                     end;                     write(mam) = trd.ptr;                     write(mal) = old.solo.bits + shr(first.trk+1, 4);                     if  (((read(md)&bits((first.trk+1)&15))<>0)   /* middle button, first.trk is on */                     and (which.button = -2))                      or  (which.button = -3)                     then new.solo.state = solo.off;                      else new.solo.state = solo.on;                     call set.group.get(current.display.grp, get.mouse.movement, true);  /* get ready to track the mouse movements */                     call Animate.Trk.Buttons(first.trk, first.trk);                  end; /* of process PRESS for trk solo animating */                  else if (info.on = 1) then do;  /* info mode is active */                     i = (Screen.Event.Table.Row*16) + Screen.Event.Table.Col + 1;                      first.trk = i + (num.kbd.tracks - 1);                      call info.note.trigger(first.trk); /* play a note from this trk */                     call cpos(0,1);                     if i <= 200 then do; /* regular sequencer trk */                        call lookup.track.timbre.name(first.trk,str);                        call ps('Track ');call pnum(i,0); call ps(': ');                         if (str(0) <> 0)                        then call ps(str);                        else call ps('           ');                        write(mam)=trk.head; write(mal)=first.trk;                        write(mam)=read(md); write(mal)=thd.nn.msb;                        msb=read(mdi);                        lsb=read(md);                        if ((msb\lsb) <> 0) then do;                           call conv.32bit.int.to.str(loc(addr(msb)), misc.buf);                           call ps('  [');                           call ps(misc.buf);                           call ps(' Notes');                           call ps(']');                        end;                        else call ps(' Empty Track');                     end;                     else do; /* Direct to Disk track */                        call ps('Live Track: ');                        call pnum(i-200, 0);                     end;                  end;         /* of process PRESS in INFO mode */               end;            /* of new mouse button PRESS */               else do;        /* new mouse button RELEASE */                  if animating then do;         /* stop animating on RELEASE */                     animating = false;         /* reset animation flag 	 */                     call cpos(0,1); call erase.to.end.of.line;         /* remove timbre name from top line */                     call Undefine.Object(time.id);                     call map.mouse.pos(false); /* find out where we released */                     call set.group.get(current.display.grp, get.mouse.movement, false);                      if  (first.trk < 209)      /* 209 BECAUSE OF L1-L8 */                     and (cur.trk   < 209)                     then do;                        if (set.enables<>0)                        then call set.track.enable.state(first.trk+(num.kbd.tracks-1), cur.trk+(num.kbd.tracks-1), new.solo.state);                         else call set.track.solo.state  (first.trk+(num.kbd.tracks-1), cur.trk+(num.kbd.tracks-1), new.solo.state);                         call update.trk.mgr(true, false);                     end;                  end;                  else if (info.on = 1) then do;                     call stop.info.note(first.trk);                     call cpos(0,1); call erase.to.end.of.line; /* remove timbre name */                  end;               end;            /* of process new mouse button RELEASE */            end;               /* of process Key Activate, Mouse Select, or Mouse Activate */         end;                  /* of process Screen Event */      end;                     /* of process non-null event */      /*  call PRINT.DEBUG.INFO; */      event = Get.Next.Edit.Screen.Event;   end;end GET.TRK.MGR.BUTTON.EVENT;GET.TRK.MGR.EVENT: proc(event) returns (fixed) public swapable;   dcl event fixed;   do while 1;      if event <> Get.Null.Event then do;         if (Screen.Event.Group <> current.display.grp)          then return event;          if (event = get.new.seq.info) then do;            if ((Screen.Event.Info&(256\4096)) <> 0)  /* track solo or track armed */            and (info.on = 0)                         /* not showing info */            then do;                        call update.trk.mgr(true, false);            end;            event = Get.Null.Event;         end;         else if (event = get.mouse.movement)         and     (animating)         then event = Get.Trk.Mgr.Animate.Event(event);         else if (event = get.screen.event)         and     (Screen.Event.Id = gid(trk.buttons))         then event = Get.Trk.Mgr.Button.Event(event);         else event = Get.Null.Event;      end;      else event = Get.Trk.Mgr.Button.Event(event);  /* default event */   end;end GET.TRK.MGR.EVENT;