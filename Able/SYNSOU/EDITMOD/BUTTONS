/* BUTTONS - $title Routines for defining and handling sequence editor buttons *//*Modified:2000/06/15 - TY  - Added code to HANDLE.REC.BUTTONS() so that the STOP button will now stop any playing DtoD cues,						 and will stop the sequencer even when incoming	SMPTE is present.*//* creates or removes a reverse field to indicate button state */UPDATE.BUTTONS: proc (from.restore) public swapable;   dcl from.restore boolean;	/* true if called from restore procedure */   dcl oldbits  fixed;			/* local copy of dispbits  */   dcl newbits  fixed;			/* current state of things */   /* set appropriate bits */   if (play <> 0) then newbits = newbits\b#play;   if (recd <> 0) then newbits = newbits\b#recd;   if (pnch <> 0) then newbits = newbits\b#pnch;   if (cont <> 0) then newbits = newbits\b#cont;   if (move <> 0) and (move.speed > 0) then newbits = newbits\b#ff;   if (move <> 0) and (move.speed < 0) then newbits = newbits\b#rew;   if (eras <> 0) then newbits = newbits\b#eras;   oldbits = gid(dispbits);   if (newbits <> oldbits) then do;      if (((oldbits xor newbits) & b#play) <> 0) then do;         if  (newbits & b#play) <> 0       /* playing, but not ff or rew */         and (newbits & b#ff  )  = 0         and (newbits & b#rew )  = 0         then call highlight.object(gid(start.button), ATTR#AltIntensity\ATTR#Reverse);         else if not(from.restore)          then call highlight.object(gid(start.button), ATTR#Normal);      end;      if (((oldbits xor newbits) & b#recd) <> 0) then do;         if (newbits & b#recd) <> 0         then call highlight.object(gid(rec.button), ATTR#AltIntensity\ATTR#Reverse);         else if not(from.restore)          then call highlight.object(gid(rec.button), ATTR#Normal);      end;      if (((oldbits xor newbits) & b#pnch) <> 0) then do;         if (newbits & b#pnch) <> 0         then call highlight.object(gid(punch.button), ATTR#AltIntensity\ATTR#Reverse);         else if not(from.restore)          then call highlight.object(gid(punch.button), ATTR#Normal);      end;      if (((oldbits xor newbits) & b#cont) <> 0) then do;         if (newbits & b#pnch) <> 0         then call highlight.object(gid(cont.button), ATTR#AltIntensity\ATTR#Reverse);         else if not(from.restore)          then call highlight.object(gid(cont.button), ATTR#Normal);      end;      if (((oldbits xor newbits) & b#ff) <> 0) then do;         if not(from.restore) then call highlight.object(gid(start.button), ATTR#Normal); /* turn off start button */         if (newbits & b#ff) <> 0         then call highlight.object(gid(ff.button), ATTR#AltIntensity\ATTR#Reverse);         else if not(from.restore)          then call highlight.object(gid(ff.button), ATTR#Normal);      end;      if (((oldbits xor newbits) & b#rew) <> 0) then do;         if not(from.restore)          then call highlight.object(gid(start.button), ATTR#Normal); /* turn off start button */         if (newbits & b#rew) <> 0         then call highlight.object(gid(rew.button), ATTR#AltIntensity\ATTR#Reverse);         else if not(from.restore)         then call highlight.object(gid(rew.button), ATTR#Normal);      end;      if (((oldbits xor newbits) & b#eras) <> 0) then do;         if (newbits & b#eras) <> 0         then call highlight.object(gid(erase.button), ATTR#AltIntensity\ATTR#Reverse);         else if not(from.restore)          then call highlight.object(gid(erase.button), ATTR#Normal);      end;      call pid(dispbits, newbits); /* store the current state */   end;end UPDATE.BUTTONS;/* define individual recorder buttons */DEFINE.RECORDER.CONTROLS: PROC SWAPABLE;END DEFINE.RECORDER.CONTROLS;/* define all buttons in this group */DEFINE.BUTTON.GROUP: proc public swapable;   Set.Auto.Allocation.Id(button.base);  /* reset where auto-allocation begins */	/*** NOTE: KEEP THESE DEFINITIONS IN ORDER !! ***/	pid(start.button,			Define.Button.Icon(S#AA,	 0, 100, 0, 'START',			0));	pid(stop.button,			Define.Button.Icon(S#AA,  700, 100, 5, 'STOP',			0));	pid(rec.button,			Define.Button.Icon(S#AA, 1400, 100, 5, 'RECD',			1));	pid(punch.button,			Define.Button.Icon(S#AA, 2100, 100, 0, 'PUNCH',			1));	pid(cont.button,			Define.Button.Icon(S#AA, 2800, 100, 5, 'CONT',			0));	pid(rew.button,			Define.Button.Icon(S#AA, 3500, 100, 4, '<<',				0));	pid(ff.button,				Define.Button.Icon(S#AA, 4100, 100, 4, '>>',				0));	pid(erase.button,			Define.Button.Icon(S#AA, 4700, 100, 0, 'ERASE',			1));	pid(clear.solos.button,	Define.Button.Icon(S#AA, 5400, 100, 0, 'CLR SOLOS',	0));   button.grp = Group.Objects(S#AA, gid(start.button), gid(clear.solos.button), Get#Screen.Event\Get#New.Seq.Info);   Activate.Group.Objects(button.grp);   Update.Group.Objects  (button.grp);end DEFINE.BUTTON.GROUP;dcl toggle.info.button  proc recursive;/* handles various button presses */HANDLE.REC.BUTTONS: proc swapable;   dcl (msw,lsw) fixed;   dcl time (1)  fixed;	dcl Stop.DTD.Playback	proc external;	if (info.on == 0)   then do case (Screen.Event.Id - gid(start.button));		//	CASE 0:	START      call start.sequencer;       		//	CASE 1:	STOP		{			if (Play != 0) {				if (SLOCKED != 0) DISABLE.SMPTE.START = true;	//	for the love of God, just STOP				stop.sequencer();			//	stop seq			}			else Stop.DTD.Playback();	//	stifle any playing cues		}		//	CASE 2:	RECD      call process.record.button; 		//	CASE 3:	PUNCH      call process.punch.button;  		//	CASE 4:	CONT      call continue.sequencer;     		//	CASE 5:	<<      do;         call rewind.sequencer;                IF ((HELD.REWIND.BUTTON=1)        /* JUST PRESSED REWIND BUTTON */         AND (MOVE.SPEED        =2000))    /* WANT SEQUENCER TO STOP     */         OR ((HELD.REWIND.BUTTON=0)        /* JUST RELEASED BUTTON       */         AND (MOVE.SPEED        =0))       /* AND WE ARE NOT MOVING      */         THEN DO;            CALL STOP.SEQUENCER;         END;      end;		//	CASE 6:	>>      do;         call fast.forward.sequencer;          IF ((HELD.FF.BUTTON= 1)           /* JUST PRESSED FF BUTTON */         AND (MOVE.SPEED    =-2000))       /* WANT TO STOP SEQUENCER */         OR ((HELD.FF.BUTTON=0)            /* JUST RELEASED BUTTON       */         AND (MOVE.SPEED    =0))           /* AND WE ARE NOT MOVING      */         THEN DO;            CALL STOP.SEQUENCER;         END;      end;		//	CASE 7:	ERASE      call process.erase.button;		//	CASE 8:	CLR SOLOS      do;                                          /* clear solos     */         call flash.object(Screen.Event.Id);       /* visual feedback */	//	this appears to have no effect on termulator         call CLEAR.TRACK.SOLO.STATES();           call update.trk.mgr(true, false);      end;	end;	//	end of do case	else	// if (info.on=1) then do;	{      if (Screen.Event.Id = gid(start.button))       then do;  /* display number of notes left */         /* display on screen */         call cpos(0,1);         time(0) = notes.left.msb; time(1) = notes.left.lsb;         call conv.32bit.int.to.str(time, misc.buf);         call ps(misc.buf); call ps(' Notes Left');         /* display on keyboard window */         call clear.upper;         call emit.string(0, 'RECORDER STATUS');         call display.numb.left;         both.display = 1;      end;      else call toggle.info.button;   }   call display.sequencer.status;   call update.buttons(false);end HANDLE.REC.BUTTONS;GET.BUTTON.EVENT: proc(event) returns (fixed) public swapable;   dcl event fixed;   do while 1;      if event <> Get.Null.Event then do;         if (Screen.Event.Group <> button.grp) then return event;         if (Screen.Event.Code = get.screen.event) then do;            if  (Screen.Event.Id >= gid(start.button))             and (Screen.Event.Id <= gid(clear.solos.button))            then do;               if ((Screen.Event.Info=S#MouseSelect)        /* first selection */               or  (Screen.Event.Info=S#MouseActivate))     /* clicked a second time */               then call Handle.Rec.Buttons;            end;         end;         else if (Screen.Event.Code = get.new.seq.info)          and     ((Screen.Event.Info & (1\8\128)) <> 0)    /* sequencer constant change happened */         then call update.buttons(false);      end;      event = Get.Next.Edit.Screen.Event;   end;end GET.BUTTON.EVENT;