   /* SINF0 AND DINFO WORDS:      0 - 1  ==>  SEC AND WRD TRACK PTR      2 - 3  ==>  MSB AND LSB OF TRACK TIME      4 - 7  ==>  WORDS OF NOTE RECORD */   UNLINK.NLS.FROM.TRACK: PROC (SEC); /* REMOVES NLS FROM TRACK AND PUTS ONTO FREE LIST */      DCL SEC     FIXED;             /* RELATIVE PTR TO NLS TO FREE UP */      DCL (FP,RP) FIXED;      DCL TRK     FIXED;      WRITE(MAM)=NAH.PTR+SEC;        /* POINT AT NLS TO FREE UP */      FP=READ(MDI);                  /* GET ITS NLS.FOR PTR     */      RP=READ(MDI);                  /* AND ITS NLS.REV PTR     */      TRK=READ(MD );                 /* AND ITS NLS.TRK #       */      CALL DEALLOCATE.NAH.BLOCK(SEC); /* PUT NLS ONTO FREE LIST */      WRITE(MAM)=NAH.PTR+RP;         /* BACK UP TO NLS.REV - MAY POINT TO TRACK HEAD */      WRITE(MD )=FP;                 /* NEW FP (MAY BE 0)   (MAY BE STORING IN THD HERE) */      IF FP<>0 THEN DO;              /* UPDATE BACK POINTER */         WRITE(MAM)=NAH.PTR+FP;         WRITE(MAL)=NLS.REV;         WRITE(MD )=RP;              /* RP MAY  POINT TO THD        */      END;      WRITE(MAM)=TRK.HEAD;           /* POINT AT OUR TRK HEAD       */      WRITE(MAL)=TRK;      WRITE(MAM)=READ(MD);      WRITE(MAL)=THD.NUM.NLS;        /* AND DECREMENT THE NUMBER OF */      WRITE(MD )=READ(MD)-1;         /* NOTE SEGMENTS ON OUR TRK    */   END UNLINK.NLS.FROM.TRACK;   ADVANCE.TO.NEXT.NOTE:  PROC (INFO);      DCL INFO       ARRAY; /* 8 WORDS OF TRK INFO */      DCL I          FIXED;      /* INF0 WORDS:         0 - 1  ==>  SEC AND WRD TRACK PTR         2 - 3  ==>  MSB AND LSB OF TRACK TIME         4 - 7  ==>  WORDS OF NOTE RECORD */      WRITE(MAM)=NAH.PTR+INFO(0);        /* POINT TO CURRENT LOC  */      WRITE(MAL)=INFO(1);      IF READ(MD)<>NLS.EOS               /* NOT AT END OF NLS  */      THEN DO;                           /* STEP TO NEXT NOTE  */         IF READ(MD)                     /* ADVANCE PTR        */         THEN WRITE(MAL)=READ(MAL)+4;    /* OVER 4-WD NOTE     */         ELSE WRITE(MAL)=READ(MAL)+2;    /* OVER 2-WD NOTE     */         INFO(1)=READ(MAL);      END;      DO WHILE (READ(MD)=NLS.EOS);       /* HAVE HIT END OF NLS   */         WRITE(MAL)=NLS.FOR;             /* LOOK UP FORWARD PTR   */         I=READ(MD);                     /* SAVE NLS.FOR IN TEMP  */         CALL UNLINK.NLS.FROM.TRACK(INFO(0)); /* FREE UP CURRENT NLS   */         INFO(0)=I;                      /* NOW POINT TO NEXT NLS */         IF I=0 THEN RETURN;             /* ALL DONE WITH TRACK   */         WRITE(MAM)=NAH.PTR+I;           /* POINT TO NEXT NLS     */         WRITE(MAL)=NLS.FP;              /* GET PTR TO FIRST WORD */         INFO(1)=READ(MD);               /* SET PTR TO START OF NEW NLS */         WRITE(MAL)=READ(MD);      END;      WRITE("313")=ADDR(INFO(4));        /* DO IN REGISTER FOR SPEED */      WRITE("300")=READ(MD );            /* SAVE IN REG           */      WRITE("373")=READ(MDI);            /* SET INFO(4)           */      WRITE("373")=READ(MDI);            /* SET INFO(5)           */      IF READ("300") THEN DO;            /* 4-WORD NOTE RECORD    */         WRITE("373")=READ(MDI);         /* SET INFO(6)           */         WRITE("353")=READ(MDI);         /* SET INFO(7)           */      END;      I=SHR(INFO(4),1)&1023;             /* EXTRACT DELTA         */      INFO(3)=INFO(3)+I;      IF INFO(3) ILT I THEN INFO(2)=INFO(2)+1;   END ADVANCE.TO.NEXT.NOTE;   GET.NEXT.NOTE.TO.BOUNCE:  PROC (INFO); /* FINDS NEXT NOTE TO BOUNCE ON TRK */      DCL INFO       ARRAY; /* 8 WORDS OF TRK INFO */      /* INF0 WORDS:         0 - 1  ==>  SEC AND WRD TRACK PTR         2 - 3  ==>  MSB AND LSB OF TRACK TIME         4 - 7  ==>  WORDS OF NOTE RECORD */      DO WHILE (INFO(0)<>0)         /* LOOP WHILE NOT AT TRK END */         AND   ((INFO(4)<0)         /* AND NOTE IS ALT. FORMAT   */         OR     (((INFO(4)&1)=0)    /* OR NOTE IS A 2-WORD REST  */         AND     ((INFO(5)&"77")=REST.NOTE)));         /* TEST TO SEE IF NOTE IS AN ILP, RETURN IF IT IS */         IF (INFO(4)&"174001")="104001" /* ILP START */         OR (INFO(4)&"174001")="110001" /* ILP END   */         THEN RETURN;         /* JUST SKIP OVER NOTE - DON'T BOUNCE IT */         IF (INFO(4)&"174001")="100001" /* NOTE IS LONG REST */         THEN DO;                       /* ADD IN ITS DELTA  */            INFO(2)=INFO(2)+INFO(5);            INFO(3)=INFO(3)+INFO(6);            IF INFO(3) ILT INFO(6)            THEN INFO(2)=INFO(2)+1;         END;         CALL ADVANCE.TO.NEXT.NOTE(INFO); /* GET NEXT NOTE, ACCOUNT FOR START DELTA */      END;   END GET.NEXT.NOTE.TO.BOUNCE;   BOUNCE.NOTE:  PROC (INFO);     /* BOUNCE NOTE TO END OF BOUNCE TRK */      DCL INFO ARRAY;             /* 8 WORDS OF TRK INFO */      WRITE("313")=ADDR(INFO(4)); /* LOAD NOTE INFO INTO #W1-#W4 */      WRITE("353")=READ("353")&"174001"; /* MASK OFF DELTA FROM INFO(4) */      WRITE("300")=ADDR(#W1);      WRITE("360")=READ("373"); WRITE("360")=READ("373");      WRITE("360")=READ("373"); WRITE("360")=READ("373");      CALL APPEND.NOTE.DURING.PLAY(INFO(2),INFO(3));      IF INFO(4)                  /* ADVANCE PAST NOTE JUST APPENDED */      THEN #WRD=#WRD+4;      ELSE #WRD=#WRD+2;      #LMSB=#NMSB; #LLSB=#NLSB;   /* LAST TIME = TIME OF APPENDED NOTE */      #ANYF=0; #ANYR=1;           /* NOW AT END OF TRK                 */   END BOUNCE.NOTE;   INIT.INFO.FOR.BOUNCE:  PROC (PTR,INFO);      DCL PTR        FIXED; /* ABS PTR TO TRK HEAD */      DCL INFO       ARRAY; /* 8 WORDS OF TRK INFO */      /* INF0 WORDS:         0 - 1  ==>  SEC AND WRD TRACK PTR         2 - 3  ==>  MSB AND LSB OF TRACK TIME         4 - 7  ==>  WORDS OF NOTE RECORD */      INFO(2)=0; INFO(3)=0;              /* INIT TIME VARS FOR SOU TRK */      WRITE(MAM)=PTR;                    /* FIND FIRST NLS             */      INFO(0)=READ(MD);                  /* INIT PTR TO TRK            */      IF READ(MD)<>0 THEN DO;            /* HAVE AN NLS            */         WRITE(MAM)=NAH.PTR+READ(MD);    /* POINT TO FIRST NLS     */         WRITE(MAL)=NLS.FP;              /* GET PTR TO FIRST WRD   */         INFO(1)=READ(MD);               /* INIT PTR TO FIRST NOTE */         WRITE(MAL)=READ(MD);         IF READ(MD)=NLS.EOS             /* AT END OF THIS NLS     */         THEN CALL ADVANCE.TO.NEXT.NOTE(INFO);         ELSE DO;            WRITE("313")=ADDR(INFO(3));  /* SET UP REG FOR SPEED   */            WRITE("373")=SHR(READ(MD),1)&1023; /* INIT TRK TIME    */            WRITE("300")=READ(MD );      /* SAVE IN REG            */            WRITE("373")=READ(MDI);      /* READ NOTE RECORD WORDS */            WRITE("373")=READ(MDI);            IF READ("300") THEN DO;      /* HAVE A 4-WD RECORD     */               WRITE("373")=READ(MDI);               WRITE("353")=READ(MDI);            END;         END;      END;   END INIT.INFO.FOR.BOUNCE;   ENOUGH.MEMORY.FOR.BOUNCE:  PROC FIXED; /* SEES IF ROOM TO DO BOUNCE */      DCL (I,J)            FIXED;      /* 'I' WILL CONTAIN THE NUMBER OF SECTORS WE NEED  */      /* TO COMPLETE THE BOUNCE OPERATION. 'J' WILL HOLD */      /* THE TOTAL SECTORS AVAILABLE.                    */      I=5;       /* MAKE SURE WE HAVE AT LEAST 5 SECTORS LEFT IN ANY CASE */      J=NAH.#FREE+((BNK.PTR+BNK.LEN)-(NAH.PTR+NAH.LEN)); /* NUMBER OF EASILY OBTAINED SECTORS LEFT */      IF I IGT J                        /* NOT ENOUGH MEMORY RIGHT NOW  */      THEN DO;                          /* DO SHUFFLE TO COLLECT MEMORY */         CALL MAXIMIZE.MEMORY.FOR.RECORD; /* HEAVY DUTY GARBAGE COLLECT */         J=NAH.#FREE+((BNK.PTR+BNK.LEN)-(NAH.PTR+NAH.LEN)); /* TOTAL SECTORS AVAILABLE */         IF I IGT J THEN RETURN 0;      /* STILL NOT ENOUGH MEMORY - QUIT */         WRITE(MAM)=TRK.HEAD;           /* GET PTR TO SOU THD AGAIN */         WRITE(MAL)=SOU; SPTR=READ(MD); /* SINCE SHUFFLE MIGHT HAVE MOVED IT */      END;      RETURN 1;                         /* BOUNCE WILL SUCCEED */   END ENOUGH.MEMORY.FOR.BOUNCE;