/* monomod - Winchester to DAC Play Routine (interrupt driven) - for mono sampling playback *//*   09/29/88 - CJ - REMOVED D107 INTERRUPT   01/09/87 - CJ - SPEEDED UP WHEN D107 FOR IMI   01/08/87 - CJ - ADDED INT.CHECK*//*  The winchester output routines are interrupt drivens.   As such,  theycan conflict with the note starting routines which are activated bythe real time clock interrupt routine.   Basic sequence of events for mono sampling note start:      t3=time of note start   (off of play.time.lsb    for seq notes)                              (off of kbd.milliseconds for kbd notes)      t2=time of dac load     (t3-5 mseconds)      t1=time of down ramp    (t3-10 mseconds for kdb notes)                              (t3-15 mseconds for seq notes)   At t1,  a zero is written to the volume register and mono.state is   set to 1.   We then wait 5 msecs (kbd) or 10 msecs (seq) for the   volume register to reach 0.   We do this so we do not get a click   when the dac buffer is reloaded.   At t2,  the dac is initialize and new samples are loaded into it.   If a zero millisecond attack time is desired,  we set the volume   register here so the front of the sound is not chopped off.   At t3,  the dac output is actually started.   The following variables control the assorted states during theprogress of a note:      1. MONO.STATE   -   begins as 0.   When a splice downramp is                          started,  mono.state is set to 1.                                                       If mono.state is <> 0,  then the software                          envelope generator is suppressed.  This will                          keep the volume register at zero during                          the splice.      2. OUTPUT.ACTIVE -  This is set by the routine 'START.W.DISK'.                          If output is =1,  then the dac has been all                          set up for output to start.   The first w. disk                          io command has been issued.  The D66 has been                          loaded with data,  but has not been started.                          Output.active is set to 2 when the dac                          is actually started                          States:      1. mono.state=0,    Your basic inactive state before any         output.active=0  sampling has started.      2. mono.state=1     Means note splice has started (volume register         output.active=0  has been set to zero).  Software envelope generator is                          suspended.   Volume dac is at zero.   Other                          variables will be set as required if output                          is currently going on (i.e. disk io command                          may be outstanding)      3. mono.state=1     The dac buffer has been loaded and the first         output.active=1  W. disk command has been issued,  but the                          dac itself has not been started      4. mono.state=0     interrupt driven w. disk to dac output is         output.active=2  occurring.                                 5. mono.state=1     a second down splice has started to construct         output.active=2  another splice */                          /* $PAGE - W. DISK SAMPLING VARIABLES */MODULE MONOMOD;INSERT ':SYNLITS:COMLITS';   /* ALL MODULES MUST INSERT COMLITS    */INSERT ':SYNLITS:GLOBLITS';  /* PRACTICALLY ALL WILL WANT GLOBLITS */INSERT ':SYNLITS:SAMPLITS';  /* BL.START LITS NEEDED HERE          */INSERT ':SYNMODS:GLOBDCL';   /* WE NEED TO USE WITHIN.SCAN         */INSERT ':SYNMODS:GETVDCL';   /* FOR WINCHESTER.ERROR               */insert ':-xpl:scsirout';     /* scsiconnect                        */insert ':-xpl:syslits';      /* for config table info              */insert ':-xpl:intrprtr';DCL D66.SUSPENDED    FIXED PUBLIC;DCL STOP.MONO.IO     FIXED PUBLIC;DCL OUTPUT.ACTIVE    FIXED PUBLIC;DCL STOP.OUTPUT      FIXED PUBLIC;DCL ABUF.INDEX       FIXED PUBLIC;DCL ABUF.DATA        DATA  PUBLIC  /* LIST OF AVAILABLE ATTACK BUFFER SIZES - SECTORS */(100,75,50,40,35,30,25,22,20,18,16,14,13,12,11,10,9,8,7,6,5,0);DCL MONO.SEC         FIXED PUBLIC; /* sector of external memory that contains information describing the sound file to play */DCL MONO.CVAL        FIXED PUBLIC; /* current value of envelope limit  */DCL MONO.VOL         FIXED PUBLIC; /* volume to play at                */DCL MONO.PD          FIXED PUBLIC; /* pitch period to start playing at */begin;                             /* simplifies stop.disk problems  */dcl (info.pt)     lit    'bl.start';     dcl (abuf.ptr,abuf.len) fixed;     /* attack buffer pointers, length */dcl (rbuf.ptr)          fixed;     /* rotary buffer in ext memory    */dcl (rbuf.len)    lit   '24';      /* rotary buffer length (sectors) */dcl (in.ptr,out.ptr)    fixed;     /* pointers for rotary buffer - word pointers */dcl (room.left,numb.in) fixed;     /* used to manage rotary buffer - word counters */dcl (dac.amt)     lit  '512+256';  /* amount of data stored in dac - MUST BE MULTIPLE OF 256 */dcl output.zeroes       fixed;     /* used to output trailing zerores */dcl ignore.data         fixed;     /* set to skip over sector on new note */dcl winchester.busy     fixed;     /* set true when disk is active    */dcl d107.suspended      fixed;     /* set true when disk op suspended *//* notes on winchester.busy, d107.suspended:   winchester.busy = 0   d107.suspended = 0: idle. no commands outstanding.   winchester.busy = 1   d107.suspended = 0: disk io outstanding, interrupts enabled.   winchester.busy = 0   d107.suspended = 1: no disk io outstanding.  issue disk command when room in buffer (d107 only)   winchester.busy = 1   d107.suspended = 1: disk io outstanding.  just re-enable intterupts */dcl d67.bits.with.interrupts    lit '"1002"'; /* control register bit word with interrupt bits on */dcl d67.bits.without.interrupts lit '"0002"'; /* same word,  but with interrupts off */dcl scsicount        fixed;        /* number of sectors read from SCSI this command */dcl sampling.device            fixed; /* logical device to sample from */dcl sampling.start.sector      fixed; /* starting sector number to sample to/from */dcl sampling.number.of.sectors fixed; /* number of sectors to sample for */dcl sampling.leftover          fixed; /* to compute partial last sector *//* D66 REGISTER LITERALS */dcl data.reg    lit '0';      /* data reg. */dcl control.reg lit '1';      /* control reg. */dcl divisor.reg lit '2';      /* time base divisor reg. */dcl volume.reg  lit '3';      /* DAC volume reg. */dcl outptr.reg  lit '4';      /* output buffer pointer reg. */dcl inptr.reg   lit '5';      /* input  buffer pointer reg. */dcl outlim.reg  lit '6';      /* output buffer limit reg. */dcl inlim.reg   lit '7';      /* input  buffer limit reg. */dcl rconverter  lit 'read ("67")';dcl wconverter  lit 'write("67")';dcl select      lit 'write("66")';dcl card0       lit '8';/* $PAGE - SELECT INTERFACE, DRIVE, AND SECTOR FOR DISK/IO */dcl interface.number fixed;   /* interface selection (0-7) - selects d107 card/D24 card */dcl drive.number     fixed;   /* drive     selection (0-x) - selects drive on one d107 or on one scsi target (loon #) */dcl scsi.controller  fixed;   /* scsi target ID      (0-6) - selects SCSI controller */dcl sector.msb       fixed;   /* sector number             - sector number for next disk read command */dcl sector.lsb       fixed;      dcl sectors.left     fixed;   /* number of sectors left on this drive */dcl use.scsi         fixed;   /* Winchester type                      */dcl d24bits data (256,512,1024,2048);       /* select bits for d24 */interface.drive.and.sector:proc(device, sector); /* determine drive and controller for given sector */   dcl device     fixed;    /* desired device */   dcl sector     fixed;    /* desired sector (only 16-bit sector numbers) */   dcl totsec.msb fixed;    /* total sectors on drive */   dcl totsec.lsb fixed;   dcl devtyp     fixed;    /* device ID code */   dcl config.ptr fixed;    /* ptr into configuration area */   if inc.mono=0 then return;   config.ptr=find_device(shr(device,8));    /* get ptr to device configuration */   if config.ptr=0 then do;                  /* device not configured */      interface.number=-1; drive.number=-1; sector.msb=-1; sector.lsb=-1;      sectors.left=0;                        /* set so next call will look up */      return;   end;      sector.msb=device & 255;                  /* init sector # */   sector.lsb=sector;   devtyp=core(config.ptr+s#devtyp)&"377"; /* save type of this device */   load core(config.ptr+s#seccyl);   /* total sectors = secs per cyl * cyl */   mul  core(config.ptr+s#totcyl);   totsec.msb=ures; totsec.lsb=res;   do while  ((sector.msb igt totsec.msb))   or        ((sector.msb  =  totsec.msb)   and        (sector.lsb ige totsec.lsb));      /* sector not on this drive -- step to next configured drive */      if sector.lsb ilt totsec.lsb      then sector.msb=sector.msb-1;      sector.msb=sector.msb-totsec.msb;      sector.lsb=sector.lsb-totsec.lsb;      config.ptr =config.ptr+s#blklen;  /* step to next config block */      if (config.ptr IGE (c#contab+c#strend)) /* at end of config table */      or (devtyp<>(core(config.ptr+s#devtyp)&"377")) /* no longer on same logical device */      then do;                          /* this sector is out of range -- bomb out */         interface.number=-1; drive.number=-1; sector.msb =-1; sector.lsb=-1;         sectors.left=0; /* set so next call will look up */         return;      end;      load core(config.ptr+s#seccyl);   /* total sectors = secs per cyl * cyl */      mul  core(config.ptr+s#totcyl);      totsec.msb=ures; totsec.lsb=res;   end;   /* successful search -- set global vars */   use.scsi          =(shr(core(config.ptr+s#devtyp),8)&"03"); /* Winchester type - 0=IMI; 1=SCSI */   interface.number  =core(config.ptr+s#devadr)&"377";         /* controller in low byte */   drive.number      =(shr(core(config.ptr+s#devadr),8)&"17"); /* drive in high byte */   if use.scsi<>0 then do; /* if SCSI */      scsi.controller  =interface.number&"17";    /* the controller number is stored where the IMI interfce number is */      interface.number =shr(interface.number,4);  /* pick up D24 number */   end;   if totsec.lsb ilt sector.lsb          /* compute # of sectors left on */   then totsec.msb=totsec.msb-1;         /* on drive into totsec.msb,lsb */   totsec.msb=totsec.msb-sector.msb;   totsec.lsb=totsec.lsb-sector.lsb;   if totsec.msb<>0 then sectors.left=(-1);       /* 32 mb sound files for now */   else                  sectors.left=totsec.lsb;end interface.drive.and.sector;/* $PAGE - INTERRUPT CHECK *//* Routine is called with interrupts off while we must temporarily wait   for disk activity.  d03, d16, & ttiints are checked. */int.check:proc;   if (read(1)&128)<>0 then do;      /* d16       */      write("300")=read(d16);      within.scan=within.scan+1;      invoke d16int;      within.scan=within.scan-1;   end;end int.check;/* $PAGE - ABORT.IO, STOP.DISK *//* abort.io - called with interrupts off *//*            if output.active<>0        *//*            or winchester.busy<>0      *//*          - called fr main loop        *//*            either directly or via     *//*            stop.disk.  also called    *//*            at end of dac output       *//*            if end of sound file       *//*            reached                    */abort.io:proc PUBLIC;      /* called from main code at end of final decay */   dcl (i)     fixed;      /* also called to clean up stolen then aborted channel */   dcl nop     lit         'write("300")=read("300")';    dcl saved.d105 fixed;   if inc.mono=0 then return;   stop.output=1;                  /* in case w. disk is going - till him to quit */   d66.suspended=0;                /* make sure he does not re-enable d66 too */   select=card0+outptr.reg;        /* select output pointers       */   wconverter=0;                   /* clear output buffer pointers */   nop;    select=card0+data.reg;          /* make sure one zero goes out  */   wconverter=0;                   /* provide a zero               */   nop;    select=card0+control.reg;   wconverter="200";               /* stop output running,  stop clock in case of splice */   nop;    wconverter="370";               /* glom any output happening now,  since vol reg is at zero */   nop;    wconverter="200";               /* remove clearing bits,  but keep clock stopped */   nop;    if  (winchester.busy<>0)            /* winchester io outstanding */   and (d107.suspended <>0)            /* but interrupts suspended  */   then do;                            /* re-enable disk interrupts to catch the ball */     d107.suspended=0;     if use.scsi=0 then do;           /* if IMI */       saved.d105=read("105");        /* since we know there is room in rotary buffer */       write("105")=interface.number;       write("106")=1;                /* re-enable disk interrupts */       write("105")=saved.d105;     end;                             /* of IMI */     else do;                         /* SCSI  - NOTE - winchester.busy is always <> 0 for scsi */	    interp_set_scsi_id(interp_set_scsi_id_device, interface.number, scsi.controller);       saved.d105=read(ScsiSel)&S$SelMask; /* get current D24 number */       write(ScsiSel)=(S$SelectEnable or d24bits(interface.number)); /* select desired D24 */       write(ScsiBus)=shl(4,S$IntShift); /* re-enable REQ interrupt */       write(ScsiSel)=(S$SelectEnable or saved.d105);     end;                             /* of SCSI */   end;                               /* of interrupts suspended from d107 */   else d107.suspended=0;             /* clean flag if output aborted      */   output.active=0;                   /* no longer doing output            */end abort.io;stop.disk:proc PUBLIC;                /* procedure to stop disk output so main program can use w. disk */   if inc.mono=0 then return;   stop.mono.io=1;                    /* this flag keeps qued-up mono notes from starting */   disable;                           /* momentarily      */   if (output.active  <>0)            /* output is active */   or (winchester.busy<>0)            /* or winchester is still pending */   then call abort.io;                /* turn of d66. re-enable d107 ints if d107.suspended */   enable;   do while winchester.busy<>0; end;  /* wait for w. disk to stop if it was going */end stop.disk;/* $SUBTITLE  Routine to Process Interrupts from D66 Converter */when d66int then begin;                /* process input from D66 */  dcl a lit 'wconverter=read(mdi)';    /* MDI to D67 - used for de-sampling */  dcl b lit 'a;a;a;a;a;a;a;a;a;a;a;a;a;a;a;a';  dcl e lit 'wconverter=0';            /* write out final zeroes */  dcl f lit 'e;e;e;e;e;e;e;e;e;e;e;e;e;e;e;e';  dcl (saved.d66,saved.d105,i,j,k) fixed;  dcl (smam,smal)                  fixed;  if inc.mono=0 then return;  saved.d66=read("66");                   /* save d66 word so user can use it */  if (numb.in\abuf.len)=0 then do;        /* no samples in rotary buffer or attack buffer - must wait for disk */    if output.zeroes<>0 then do;          /* output a sector of zeroes */      output.zeroes=output.zeroes-1;      /* indicate one block about to be sent */      if output.zeroes=0 then do;         /* indicates final end of output */        call abort.io;                    /* done with output for good     */        select=saved.d66;                 /* restore user's d66 register   */        return;                           /* done with sampling */      end;      select=card0+data.reg;      do k=0 to 7;                        /* write out 128 zeroes at end of sound file */         f;                               /* remember interrupts are off here */      end;      select=saved.d66;                   /* restore d66 */      return;                             /* wait for next interrupt */    end;      /* must suspend d66 interrupts */    /* if there is no data in      */    /* rotary buffer.   means      */    /* winchester disk has fallen  */    /* behind.                     */    select=card0+control.reg;    wconverter=d67.bits.without.interrupts; /* disable further d67 interrupts */    d66.suspended=1;          /* oops - nothing in memory - must suspend interrupts until w. disk catches up */    select=saved.d66;         /* restore d66 register */    return;                   /* let's hope winchester disk catches up before underrun */  end;                        /* of nothing in attack or rotary buffer */  /* data in abuf or rbuf - put more out to dac */  select=card0+control.reg;  wconverter=d67.bits.without.interrupts; /* disable further d67 interrupts */  within.scan=within.scan+1;              /* keep note starts */  enable;                                 /* from happening   */  if (read("66")&2048)=0 then output.underrun=1; /* disk did not keep up */  disable;                                  /* while we check abuf.len, etc. */  smam=read(mam); smal=read(mal);           /* save info from from other user */  if abuf.len<>0 then write(mam)=abuf.ptr;  /* select attack buffer sector */  else write(mam)=rbuf.ptr+shr(out.ptr,8);  /* select rotary buffer sector */  if (numb.in+abuf.len=256) and (output.zeroes<>0) then do; /* see if we are about to emit last sector from file */    enable;                                 /* after check in previous line */    select=card0+data.reg;    do i=0 to sampling.leftover;     /* copy out desired part of last sector */      wconverter=read(mdi);    end;  end;  else do;                           /* copy 256 words via high speed loop */    enable;                          /* we can allow disk interrupts here. unfortunately,  d3 could interrupt us too */    select=card0+data.reg;    do k=0 to 7;       b;b;                          /* write out 256 samples to dac */    end;  end;  write(mam)=smam; write(mal)=smal;  /* restore mem pointers */  /* $PAGE - ACCOUNT FOR DATA TRANSFER */  disable;  within.scan=within.scan-1;  if abuf.len<>0 then do;            /* data came from attack buffer */     abuf.ptr=abuf.ptr+1;            /* next sector of attack buffer for next time */     abuf.len=abuf.len-256;          /* reduce word count */  end;  else do;                           /* data came out of rotary buffer - update pointers */    out.ptr=out.ptr+256;     numb.in=numb.in-256;     room.left=room.left+256;         /* indicate 256 words removed from buffer */    if out.ptr=shl(rbuf.len,8) then out.ptr=0; /* reset rotary pointer */    if d107.suspended then do;       /* if interrupts suspended from d107, re-enable now */      d107.suspended=0;      if use.scsi=0 then do;         /* if IMI */        saved.d105=read("105");      /* since we know there is room in rotary buffer */        write("105")=interface.number;           if winchester.busy=0        then do;                     /* issue disk command here */          do while read("106")<>0;              call int.check;          end;              write("107")=2+shl(drive.number,8); /* issue read command */          do while read("106")<>0;              call int.check;          end;              do while read("106")<>0;              call int.check;          end;              write("107")=sector.lsb;          winchester.busy=1;        end;        write("106")=1;                /* re-enable disk interrupts here */        write("105")=saved.d105;      end;                             /* of IMI */      else do;                         /* SCSI   */		interp_set_scsi_id(interp_set_scsi_id_device, interface.number, scsi.controller);        saved.d105=read(ScsiSel)&S$SelMask; /* get current D24 number */        write(ScsiSel)=(S$SelectEnable or D24bits(interface.number)); /* select desired D24 */        write(ScsiBus)=shl(4,S$IntShift); /* re-enable REQ interrupt */        write(ScsiSel)=(S$SelectEnable or saved.d105);      end;                             /* of SCSI */    end;                               /* of interrupts suspended from d107 */  end;  select=card0+control.reg;  wconverter=d67.bits.with.interrupts; /* allow more d66 interrupts only if we have not begun a new note */  write("300")=read("300");            /* delay */  select=saved.d66;                    /* restore d66 for user */end;                                   /* end of d66 interrupt routine *//* $SUBTITLE  Routine to Process Interrupt from Winchester Disk */when d24int then begin;                    /* process interrupts */  dcl c   lit 'write(mdi)=read("107")';    /* d107 to mdi - used for reading disk into external memory */  dcl d   lit 'c;c;c;c;c;c;c;c;c;c;c;c;c;c;c;c';  dcl s.c lit 'write(mdi)=read(ScsiWord)'; /* d27 to mdi - used for reading disk into external memory */  dcl s.d lit 's.c;s.c;s.c;s.c;s.c;s.c;s.c;s.c;s.c;s.c;s.c;s.c;s.c;s.c;s.c;s.c';  dcl (i,j,k,saved.d66) fixed;  dcl (smam,smal)       fixed;  dcl (saved.d105)      fixed;           /* used to restore 105 register for user convenience */  dcl (call.interface.drive.and.sector)  fixed;  dcl (issue.disk.read.command)          fixed;  if inc.mono=0 then return;  if use.scsi=0 then do;                   /* IMI */    saved.d105=read("105");                /* save winchester disk interface number register */    write("105")=interface.number;         /* select current interface number */    write("106")=0;                        /* disable further d107 interrupts */    i=read("107")&255;                     /* get return code from winchester disk */    if i<>0 then winchester.error=1;       /* print error message      */    if i>=128 then do;                     /* fatal error - terminate  */      ignore.data=1;                       /* set flag to ignore data read */      sampling.number.of.sectors=0;        /* indicate no more to read */    end;    else do;                               /* read d107 into rotary buffer */      smam=read(mam); smal=read(mal);      /* save current location */      write(mam)=rbuf.ptr+shr(in.ptr,8);   /* set up pointer to sector of rotary buffer in ext memory */      do k=0 to 15;         d;                                /* 16 instructions d107 to ext memory */      end;      write(mam)=smam; write(mal)=smal;    /* restore for interrupt return */    end;    winchester.busy=0;                     /* IMI goes not busy after reading data */  end;                                     /* of IMI       */  else do;                                 /* SCSI         */	interp_set_scsi_id(interp_set_scsi_id_device, interface.number, scsi.controller);    saved.d105=read(ScsiSel)&S$SelMask;    /* get current D24 number */    write(ScsiSel)=(S$SelectEnable or D24bits(interface.number)); /* select desired D24 */    write(ScsiBus)=0;                      /* disable d24interrupt to acknowledge */    scsicount=scsicount-1;                 /* count 1 more scsi interrupt */    if scsicount<0 then do;                /* means status from last read command has finally arrived */       i=read(ScsiWord);                   /* get status from diskread */       if i<>S$good then winchester.error=1;       winchester.busy=0;                  /* not busy now */    end;    else do;                               /* read data    */      if (read(ScsiBus) and S$SigMask)<>S$DataIn then do; /* if not in data phase,  must be status - indicates error */        winchester.error=1;                  /* set flag for error message */        i=read(ScsiWord);                    /* toss out READ status     */        ignore.data=1;                       /* set flag to ignore data read */        sampling.number.of.sectors=0;        /* indicate no more to read */        winchester.busy=0;                   /* not busy now             */      end;      else do;                               /* read D27 into rotary buffer */        smam=read(mam); smal=read(mal);      /* save current location */        write(mam)=rbuf.ptr+shr(in.ptr,8);   /* set up pointer to sector of rotary buffer in ext memory */        do k=0 to 15;           s.d;                              /* 16 instructions d27 to ext memory */        end;        write(mam)=smam; write(mal)=smal;    /* restore for interrupt return */                                             /* note - winchester.busy is still <> 0 */      end;    end;  end;                                   /* of SCSI */  if  (stop.output<>0) then do;            /* end of note             */  end;                                     /* handled by w.busy below */  else if (ignore.data<>0) then do;        /* skipped sector - wait for previous operation to finish */    if (winchester.busy=0) then do;        /* winchester now free     */      ignore.data=0;                       /* reset flag              */      if sampling.number.of.sectors=0 then do; /* but no more disk io */        stop.output=1; output.zeroes=20;       /* zero fill - stop output after what is in memory */      end;      else do;        call.interface.drive.and.sector=1;   /* compute new disk info   */        issue.disk.read.command=1;           /* issue new read command  */      end;    end;  end;  else do;                                 /* normal data xfer       */    if  (use.scsi=0)                       /* if using IMI           */    or  (scsicount<>0)                     /* or data was read       */    then do;                               /* then account           */      in.ptr    = in.ptr+256;              /* advance in pointer     */      numb.in   = numb.in+256;             /* more in buffer         */      room.left = room.left-256;           /* less room left         */      if in.ptr=shl(rbuf.len,8) then in.ptr=0;    /* compute rotary pointer */      sector.lsb=sector.lsb+1;             /* advance internal sec#  */      if sector.lsb=0 then sector.msb=sector.msb+1;      sectors.left=sectors.left-1;         /* fewer left on drive    */      sampling.start.sector=sampling.start.sector+1;    /* we have successfully read one sector */      if sampling.start.sector=0      then sampling.device=sampling.device+1;      sampling.number.of.sectors=sampling.number.of.sectors-1;      if sampling.number.of.sectors=0 then do; /* but no more disk io */        stop.output=1; output.zeroes=20;       /* zero fill - stop output after what is in memory */      end;                                     /* winchester.busy will by zero here */      else do;                                 /* more data to read */        if sectors.left=0                         /* if no left on drive */        then CALL.INTERFACE.DRIVE.AND.SECTOR=1;   /* then compute next   */        if winchester.busy=0                      /* if end of winch op  */        then ISSUE.DISK.READ.COMMAND=1;           /* then issue next     */      end;    end;  end;  if call.interface.drive.and.sector<>0 then do;    call.interface.drive.and.sector=0;    call interface.drive.and.sector(sampling.device, sampling.start.sector); /* get info for new diskread */  end;  if issue.disk.read.command<>0 then do;    issue.disk.read.command=0;    if use.scsi=0 then do;      if (room.left<>0)                /* if room in buffer          */      or (stop.output<>0)              /* or data will be tossed     */      or (ignore.data<>0)              /* or data will be ignored    */      then do;                         /* issue disk command here    */         do while read("106")<>0;             call int.check;         end;             write("105")=interface.number;   /* may be different */         do while read("106")<>0;             call int.check;         end;             write("107")=2+shl(drive.number,8); /* issue read command */         write("107")=sector.lsb;         winchester.busy=1;      end;      else do;                         /* just suspend operation */         d107.suspended=1;             /* winchester.busy=0, d107.suspended=1 */      end;    end;                               /* of IMI */    else do;                           /* SCSI   */      i = ScsiConnect(interface.number, S.Initiator, scsi.controller, drive.number);      if i <> S$GoodConnect then do;         winchester.busy=0;         stop.output=1;                /* set flag to stop output after attack buffer */         output.zeroes=20;             /* output final zeroes */         winchester.error=1;           /* set flag for error message */      end;      /* Send SCSI Command */      else do;        scsicount=sampling.number.of.sectors;   /* number of sectors   */        if scsicount igt sectors.left        then scsicount=sectors.left;            /* limit to size of drive */        if scsicount igt 8 then scsicount=8;    /* limit to 8            */        write(ScsiByte) = S$ExtendedRead;       /* SCSI Operation Code */        write(ScsiByte) = shr(drive.number,8 - 5); /* Target LUN */        write(ScsiWord) = sector.msb;      /* Logical Block Address (MSW) */        write(ScsiWord) = sector.lsb;      /* Logical Block Address (LSW) */        write(ScsiByte) = 0;               /* Reserved         */        write(ScsiWord) = scsicount;       /* this many blocks */        write(ScsiByte) = 0;               /* Control byte     */        winchester.busy=1;      end;    end;  end;  if winchester.busy<>0 then do;          /* disk is busy doing command */    if (room.left<>0)                     /* if room in buffer          */    or (stop.output<>0)                   /* or data will be tossed     */    or (ignore.data<>0)                   /* or data will be ignored    */    then do;                              /* re-enable interrupts       */      if use.scsi=0 then do;              /* IMI  */        write("106")=1;                   /* enable IMI interrupts */      end;      else do;                            /* SCSI */        write(ScsiBus)=shl(4,S$IntShift); /* enable REQ interrupt */      end;    end;    else do;      d107.suspended=1;                   /* set flag to enable d107 interrupts once d66 has cought up */    end;  end;  else do;                                /* winchester not busy - must be end of command */     if use.scsi=0 then do;               /* wait for IMI here to avoid later crash */        do while read("106")<>0;            call int.check;        end;     end;  end;  if  (d66.suspended)                 /* re-enable d66 interrupts        */  and ((numb.in\output.zeroes)<>0)    /* but only if anything in buffer  */  then do;                            /* IE we may have ignored the data */    saved.d66=read("66");             /* preserve d66 register */    select=card0+control.reg;    wconverter=d67.bits.with.interrupts; /* re-enable interrupts from d66 */    d66.suspended=0;    select=saved.d66;  end;  if use.scsi=0 then do;    write("105")=saved.d105;         /* restore 105 register */  end;  else do;	interp_set_scsi_id(interp_set_scsi_id_device, saved.d105, scsi.controller);    write(ScsiSel)=(S$SelectEnable or saved.d105);  end;end; /* of winchester disk interrupt routine *//* $SUBTITLE  Procedure to Start W. Disk I/O */start.w.disk.output:proc PUBLIC;  dcl  (smam,smal)  fixed;  dcl  (sd66)       fixed;  dcl a lit   'wconverter=read(mdi)';    /* ext mem to converter */  dcl b lit   'a;a;a;a;a;a;a;a;a;a;a;a;a;a;a;a';  dcl nop lit 'write("300")=read("300")';  dcl (i,k,l)      fixed;  dcl (abufwrd)  fixed;         /* word of that sector (0-255) which is first desired sample */  if inc.mono=0 then return;  smam=read(mam); smal=read(mal);/* save xmem pointers */  sd66=read("66");               /* save d66 on general principles */  /* send a zero out to output latch - make sure signal starts from zero */  select=card0+outptr.reg;       /* select output pointers       */  wconverter=0;                  /* clear output buffer pointers */  nop;   select=card0+data.reg;         /* make sure one zero goes out  */  wconverter=0;                  /* provide a zero               */  nop;   select=card0+control.reg;  wconverter="200";              /* stop output running,  stop clock in case of splice */  nop;   wconverter="370";              /* glom any output happening now,  since vol reg is at zero */  nop;   wconverter="200";              /* remove clearing bits,  but keep clock stopped */  nop;   disable;                       /* interrupts temporarily */  if (winchester.busy<>0)        /* suspend d107 interrupts for a moment */  then do;                 if use.scsi=0 then do;        write("105")=interface.number;        write("106")=0;     end;     else do;                    /* disable interrupts from scsi board */		interp_set_scsi_id(interp_set_scsi_id_device, interface.number, scsi.controller);        write(ScsiSel)=(S$SelectEnable or D24bits(interface.number)); /* select desired D24 */        write(ScsiBus)=0;        /* no more interrupts */     end;  end;                           /* but leave set for check below */  enable;                        /* allow interrupts from d3 for the moment */  write(mam)=mono.sec;                  /* get file info first */  write(mal)=info.pt;                   /* set up for read of file info */  abuf.ptr=mono.sec+1;                  /* get pointer to attack buffer - starts on next sector */  abufwrd =read(mdi);                   /* BL.START - get word offset of first desired sample */  abuf.len=read(mdi);                   /* BL.ABUFL - get length of attack buffer (words, mult of 256) */  sampling.device=read(mdi);            /* BL.WDD   - get device we're reading from */  sampling.start.sector=read(mdi);      /* BL.WDS   - get starting sector to continue reading at */  sampling.number.of.sectors=read(mdi); /* BL.WDN   - number to read from there */  sampling.leftover=read(mdi);          /* BL.FWRDS - and location within last sector of last desired word */    /* $PAGE - initiate the new sound: */  select=card0+outptr.reg;  wconverter=0;                  /* empty output buffer again */  nop;   select=card0+outlim.reg;  wconverter=dac.amt-256;        /* generate interrupt when less than this amount in buffer */  nop;   select=card0+volume.reg;        /* prepare for new volume */  write(5)=mono.vol; write(6)=mono.cval;  wconverter=read(4);             /* set up for initial volume */  nop;   select=card0+divisor.reg;  wconverter=mono.pd-2;           /* set up for new pitch */  nop;   in.ptr=0; out.ptr=0; numb.in=0; /* init rot buffer to empty */  room.left=shl(rbuf.len,8);      /* initialize variables */  k=0;                            /* copy first part of attack buffer into dac */  l=abuf.len;                     /* assume we can load whole attack buffer */  if l igt dac.amt then l=dac.amt;/* basically only this many in dac, however */  l=l-abufwrd;                    /* reduce by offset in first sector */  select=card0+data.reg;          /* prepare for emit of attack buffer segment */  write(mam)=abuf.ptr;            /* start from attack buffer */  write(mal)=abufwrd;             /* this word in it */  do while (k ile (l-32));        /* copy words to dac in 32 word blocks */    b;b;                          /* 32 samples to dac */    k=k+32;  end;  do while k ilt l;               /* write out remainder to dac */     wconverter=read(mdi);     k=k+1;  end;  l=l+abufwrd;                    /* restore l to complete sectors of attack buffer accounted for */  abuf.ptr=abuf.ptr+shr(l,8);  abuf.len=abuf.len-l;            /* this much remains in attack buffer - is multiple of 256 */  /* start winchester disk now */  disable;                           /* disable interrupts now that we have loaded dac */  output.active=1;                   /* set flag indicating new state */  d107.suspended=0; d66.suspended=0; /* indicate neither are suspended */  if winchester.busy<>0 then do;     /* disk still busy from last op */    ignore.data=1;    stop.output=0; output.zeroes=0;  /* make sure flags are clear - will be set by d107 code if no more sectors to read */    if use.scsi=0 then do;      write("105")=interface.number;      write("106")=1;                /* re-enable interrupts from that unit */    end;    else do;                         /* disable interrupts from scsi board */	interp_set_scsi_id(interp_set_scsi_id_device, interface.number, scsi.controller);      write(ScsiSel)=(S$SelectEnable or D24bits(interface.number)); /* select desired D24 */      write(ScsiBus)=shl(4,S$IntShift);  /* re-enable REQ interrupt */    end;  end;  else do;                          /* starting new sound - set up for w. disk interrupts */    ignore.data=0;                  /* make sure flag cleared */    if sampling.number.of.sectors=0 then do; /* no disk sectors to do - attack buffer had all */      stop.output=1;                /* set flag for consistency */      output.zeroes=20;             /* output final zeroes */    end;    else do;   /* some sectors to sample - start first disk read */      stop.output=0; output.zeroes=0;   /* in case we were doing zero writing before */      call interface.drive.and.sector(sampling.device, sampling.start.sector); /* compute info */      winchester.busy=1;                    /* assume following code will issue command */      if use.scsi=0 then do;        write("105")=interface.number;        enable;                             /* in case different IMI drive */        do while read("106")<>0; end;        write("107")=2+shl(drive.number,8); /* read command */        do while read("106")<>0; end;       /* check twice in case bounce */        do while read("106")<>0; end;       /* after first byte           */        disable;        write("107")=sector.lsb;        write("106")=1;                     /* enable winchester interrupts */      end;      else do;                              /* !!!! SCSI !!!! */        enable;                             /* in case reset needed */        i = ScsiConnect(interface.number, S.Initiator, scsi.controller, drive.number);        disable;        if i <> S$GoodConnect then do;           winchester.busy=0;           stop.output=1;                /* set flag to stop output after attack buffer */           output.zeroes=20;             /* output final zeroes */           winchester.error=1;           /* set flag for error message */        end;        /* Send SCSI Command */        else do;          scsicount=sampling.number.of.sectors;   /* number of sectors   */          if scsicount igt (sectors.left)                then scsicount=sectors.left;            /* limit to size of drive */          if scsicount igt 8 then scsicount=8;    /* limit to 8            */          write(ScsiByte) = S$ExtendedRead;       /* SCSI Operation Code */          write(ScsiByte) = shr(drive.number,8 - 5); /* Target LUN */          write(ScsiWord) = sector.msb;           /* Logical Block Address (MSW) */          write(ScsiWord) = sector.lsb;           /* Logical Block Address (LSW) */          write(ScsiByte) = 0;                    /* Reserved         */          write(ScsiWord) = scsicount;            /* this many blocks */          write(ScsiByte) = 0;                    /* Control byte     */          /* enable d24 interrupts */          write(ScsiBus)=shl(4,S$IntShift); /* enable REQ interrupt */        end;      end;    end;  end;  enable;                              /* start the ball rolling.  d66 interrupts will be started later. */  write(mam)=smam; write(mal)=smal;    /* restore memory pointers */  select=sd66;                         /* restore d66 pointer */end start.w.disk.output;mono.init:proc swapable;   rbuf.ptr=alloc.examount(rbuf.len);  /* allocate rotary buffer */END MONO.INIT;IF INC.MONO THEN CALL MONO.INIT;end;                                   /* of begin               */end MONOMOD;