/* This program makes an index of all the keywords in the .HELP file,   and stores this index in the file .HINDEX. Each index entry consists   of the name of the keyword preceeded by a '$$', followed by the   word location of this keyword in the file .HELP. */insert ':-xpl:literals';insert ':-xpl:asciilit';insert ':-xpl:catrtns';insert ':-xpl:scsi';dcl key.marker  lit '(a.dollar or shl(a.dollar,8))'; /* marks keyword */dcl key.buf.max lit '32*256'; /* length of buffer holding keywords */dcl cbuf(C#Dir_Max) fixed; /* catalog buffer */dcl key.buf(key.buf.max - 1) fixed; /* keyword buffer */dcl kptr       fixed; /* pointer into keyword buffer */dcl key.count  fixed; /* number of keywords found */dcl largest    fixed; /* size of largest keyword in words */get.keys:  proc returns (boolean); /* get keywords from file */   dcl fptr  fixed; /* pointer into file buffer */   dcl index fixed; /* location of keyword in file */   dcl chunk fixed; /* index of the 1024-word chunk of file in buffer */   dcl size  fixed; /* size of a keyword in words */   dcl done  boolean; /* TRUE when keyword has been copied into buffer */   get.word:  proc(i) returns (fixed); /* get specified word from file */      dcl i       fixed; /* word in file to get */      dcl (MS,LS) fixed;      if shr(i,10) <> chunk then do; /* divide index by 1024 to find chunk this word is in */         chunk = shr(i,10); /* new chunk needed */         MS = F#MS_Sector; /* calculate sector address of new chunk */         LS = F#LS_Sector + shl(chunk,2); /* NOTE: each chunk is 4 sectors long */         if LS ilt F#LS_Sector then MS = MS + 1;         call readdata(MS,LS,cbuf,1024); /* read in new chunk */      end;      return (cbuf(i and "H3FF")); /* return word */   end;   chunk = -1; /* kludge to force first chunk to be read in */   fptr = 0; /* start at first word of file */   kptr = 0; /* start at first word of buffer */   key.count = 0; /* no keywords found yet */   do while (fptr ilt F#Words) and (kptr ilt key.buf.max); /* repeat until EOF reached */      do while (fptr ilt F#Words) and (get.word(fptr) <> key.marker); /* search for key word marker */         fptr = fptr + 1;      end;      if (fptr ilt F#Words) and (kptr ilt key.buf.max) then do; /* found a keyword */         index = fptr; /* store location of keyword in file */         key.count = key.count + 1; /* another keyword found */         done = FALSE; /* not transferred yet */         size = 0; /* set keyword length to zero */         do while (kptr ilt key.buf.max) and (not done); /* copy keyword into keyword buffer */            key.buf(kptr) = get.word(fptr); /* store this word */            if key.buf(kptr) <> 0 then size = size + 1; /* another word in keyword */            if shr(key.buf(kptr),8) = 0 then done = true; /* eoln found */            kptr = kptr + 1; /* next word in buffer */            fptr = fptr + 1; /* next word in file */         end; /* of copying keyword */         if size > largest then largest = size; /* store size of largest keyword */         if (kptr ilt key.buf.max) then do; /* put keyword location into buffer */            key.buf(kptr) = index;            kptr = kptr + 1;         end;      end; /* of key marker found */   end; /* of while keyword not found */   return (kptr ilt key.buf.max); /* returns TRUE if keyword buffer is not full */end get.keys;call set_catbuf (addr(cbuf (0)), 0); /* set the catalog buffer */largest = 0;if locate(':.SYSTEM:.HELP',0) then do; /* make sure help text file is there */   if get.keys then do; /* find keywords */      if replace('.HINDEX',t#data,0,shr(kptr + 255,8),kptr,1) then do; /* try to save */         call writedata(F#MS_Sector,F#LS_Sector,key.buf,kptr); /* write out data */         print key.count,' keywords save in file .HINDEX';         print 'Largest keyword is ',largest,' words';      end;      else print 'Error replacing .HINDEX: ',C#Status;   end;   else print 'Error: keyword buffer full';end;else print '.HELP file not found';