/* 06-BUFFR  $TITLE  Text Buffering and Editing Routines *//* ROUTINE 'FILL':..  THE FILL ROUTINE IS CALLED TO MAKE SURE THAT THE LARGEST AMOUNT POSSIBLE.  OF THE CURRENT FILE IS IN THE ARRAY 'FBUF'.  OFTEN CALLED AFTER CALLS.  TO 'DELETE'.*//* 10/5/96 - CJ - ADDED EXPORTLIN */FILL:PROC; /* NO ARGUMENTS - JUST CHECK */   DCL I FIXED;   I=FILNG-BLEN-BSTRT; /* NUMBER OF WORDS LEFT ON DISK */   IF (BLEN+I) IGT FBUFSZ THEN DO; /* MAX POSSIBLE */      I=(FBUFSZ-BLEN) and "177400";   END;   IF I=0 THEN RETURN; /* CAN NOT ADD ANY MORE TO BUFFER */   CALL WORKREAD(SHR(FSTRT,8),LOCATION(ADDR(FBUF(BLEN))),I); /* FILL REST OF BUFFER */   BLEN=BLEN+I;   FSTRT=FSTRT+I; /* MORE IN BUFFER */END FILL;/* PROCEDURE 'PRIME':..  THIS PROCEDURE IS USED TO PRIME THE INPUT BUFFER*/PRIME:PROC; /* CALL TO SET PTR=0, GET FIRST BUFFER INTO MEMORY */   PTR=0;   IF BSTRT<>0 THEN DO; /* IF NOT THERE, GET IT */      BSTRT=0; BLEN=0; FSTRT=0; BALT=0;      CALL FILL;   END;END PRIME;/* PROCEDURE MOVBPTRUP:..  THIS PROCEDURE IS CALLED TO MOVE 'BPTR' FORWARD IN THE FILE. IT IS.  CALLED DURING SEQUENTIAL READS OF THE FILE.*/MOVEBPTRUP:PROC(PT); /* PASS POINTER. IF = FILNG, THEN FORCE OCCURS */  DCL (PT,I,J) FIXED;  IF PT IGT FILNG THEN PT=FILNG; /* MUST NEVER BE PAST EOF */  IF PT <>  FILNG THEN PT=(PT and "177400"); /* ON SECTOR BOUNDARY IF NOT AT EOF */  DO WHILE BSTRT ILT PT; /* AND WAIT UNTIL EQUAL TO THIS */    IF BSTRT+BLEN=FILNG THEN DO; /* IF ALL IN MEMORY (REST OF FILE) THEN WRITE ALL */      I=PT-BSTRT; /* AMOUNT TO SAVE */      IF BALT THEN DO;        CALL WORKWRITE(SHR(BSTRT,8),FBUF,BLEN);        BALT=0; /* INDICATE NOT ALTERED */        FSTRT=FILNG; /* STARTS HERE */      END;    END;    ELSE DO; /* SECTION IN BUFFER IS NOT AT END OF FILE: */      I=BLEN and "177400"; /* WRITE OUT FULL SECTORS IF NOT AT END OF FILE */      IF I IGT FSTRT-BSTRT THEN I=FSTRT-BSTRT; /* BUT DO NOT CLOBBER SAVED INFO */      IF I IGT PT-BSTRT    THEN I=PT-BSTRT; /* BUT DO NOT WRITE PAST POINTER */      IF (BALT) and (I<>0) THEN CALL WORKWRITE(SHR(BSTRT,8),FBUF,I); /* WRITE OUT DATA */      IF (I=BLEN) and (I=(FSTRT-BSTRT)) THEN BALT=0; /* NO ALTERS LEFT */    END;    IF (BALT=0) AND (PT IGE BSTRT+BLEN) THEN DO; /* UNALTERED BUFFER, OUTSIDE OF IT */      BSTRT=PT; BLEN=0; FSTRT=BSTRT;    END;    ELSE DO; /* FILE LENGTH HAS CHANGED - MOVE UP & DOWN */      DO J=0 TO BLEN-I-1; FBUF(J)=FBUF(I+J); END; /* COPY DOWN NON-WRITTEN OUT INFO */      BSTRT=BSTRT+I; /* CURRENT BUFFER LOAD GOES THERE */      BLEN=BLEN-I; /* THERE ARE THIS MANY LEFT */    END;    CALL FILL; /* FILL UP BUFFER WITH AS MUCH OF FILE AS POSSIBLE */  END; /* OF DO WHILE */END MOVEBPTRUP;/* $SUBTITLE  Line Output Procedure, Search Routine */PLIN:PROC(PT); /* PRINT LINE OF FILE TO CURRENT DEVICE, GIVEN START PTR */  DCL (PT,I,J) FIXED;  IF OUTDEV=0 THEN DO; /* PAGE CRT OUTPUT */    IF LINEC=(SCREEN-2) THEN DO; /* CRT SCREEN IS FULL */      I=RCHAR; /* GET CHAR FROM USER */      IF I=0 THEN RETURN 1; /* ABORT */      IF I=a.LF THEN LINEC=(SCREEN-3); /* PRINT ONE MORE LINE ON LF */      ELSE           CALL CLEARSCREEN; /* CLEAR SCREEN AND RESET */    END;    LINEC=LINEC+1;  END; /* OF PAGE CRT OUTPUT */  PT=PT+ADDR(FBUF(0))-BSTRT; /* COMPUTE ADDRESS IN FILE BUFFER */  IF CORE(PT)<>0 THEN DO; /* LINE NUMBER EXISTS */    IF BRKC THEN RETURN 1; /* CHECK FOR BREAK */    CALL PDEC(0,CORE(PT),0); CALL PCHAR(a.SP); /* PRINT LINE NUMBER, ONE SPACE */  END;  I=1;  DO WHILE I; /* LOOP OVER LINE CHARS */    PT=PT+1; /* POINT TO NEXT WORD */    J=CORE(PT); /* GET WORD */    IF (J and "377")=0 THEN I=0; /* OUT OF LOOP */    ELSE DO;      IF BRKC THEN RETURN 1; /* INDICATES BREAK */      CALL PCHAR(J); /* PRINT FIRST CHAR */      IF (J and "177400")=0 THEN I=0; /* GET OUT OF LOOP */      ELSE                   CALL PCHAR(SHR(J,8)); /* PRINT SECOND */    END;  END; /* OF LOOP OVER LINE CHARS */  CALL NEWLINE;  RETURN 0; /* INDICATES NO BREAK */END PLIN;EXPORTLIN:PROC(PT);  DCL (PT,I,J) FIXED;  PT=PT+ADDR(FBUF(0))-BSTRT; /* COMPUTE ADDRESS IN FILE BUFFER */  I=1;  DO WHILE I; /* LOOP OVER LINE CHARS */    PT=PT+1; /* POINT TO NEXT WORD */    J=CORE(PT); /* GET WORD */    IF (J and "377")=0 THEN I=0; /* OUT OF LOOP */    ELSE DO;      IF BRKC THEN RETURN 1; /* INDICATES BREAK */      CALL PCHAR(J); /* PRINT FIRST CHAR */      IF (J and "177400")=0 THEN I=0; /* GET OUT OF LOOP */      ELSE                   CALL PCHAR(SHR(J,8)); /* PRINT SECOND */    END;  END; /* OF LOOP OVER LINE CHARS */  CALL NEWLINE;  RETURN 0; /* INDICATES NO BREAK */END EXPORTLIN;/* POS ROUTINE:  CALLED TO SEARCH FOR STRING IN CURRENT FILE..    RETURNS A -1 IF THE STRING IS NOT IN THE CURRENT LINE OF THE BUFFER..    OTHERWISE A BYTE POINTER TO THE START OF THE STRING IS RETURNED.  */POS:PROC(STR,BPT) FIXED; /* PASS STRING, BYTE POINTER */  DCL STR             ARRAY; /* TARGET STRING */  DCL BPT             FIXED; /* STARTING LOC */  DCL (CHR1,CHR2,CHR) FIXED;  DCL (I,J,K,L)       FIXED;  IF (FILNG ILT 2) OR (STR(0)=0) THEN RETURN (-1); /* FILE OR STRING EMPTY */  CHR1=STR(1) and "377"; CHR2=SHL(CHR1,8); /* CONSTRUCT BYTE TESTS FOR QUICK COMPARE */  I=SHR(BPT,1)+1; /* WORD POINTER TO WORD CONTAINING BYTE */  DO FOREVER; /* LOOP UNTIL END OR MATCH */    J=FBUF(I); /* GET WORD FROM FILE */    K=0; /* ASSUME NO MATCH */    IF (BPT) THEN DO; /* IS IN UPPER HALF */      CHR=J and "177400"; /* EXTRACT UPPER BYTE */      IF CHR=CHR2 THEN K=1; /* MATCH FIRST CHAR */    END;    ELSE DO; /* LOWER BYTE */      CHR=J and "377"; /* EXTRACT LOWER BYTE */      IF CHR=CHR1 THEN K=1; /* MATCH FIRST CHAR */    END;    IF CHR=0 THEN RETURN (-1); /* IF END OF MAIN STRING, THEN RETURN NOT FOUND */    IF (K) THEN DO; /* IF FIRST LETTER MATCHES */      L=STR(0); /* GET LENGTH OF TARGET STRING */      DO WHILE L>1; /* LOOP OVER CHARS */        L=L-1;        IF BYTE(FBUF,BPT+L)<>BYTE(STR,L) THEN GOTO BREAK.OUT; /* FAIL */      END;      RETURN BPT; /* COMPLETE MATCH - RETURN OK */    END; /* OF IF FIRST LETTER MATCHES */    BREAK.OUT:    IF (BPT) THEN I=I+1; /* NEXT WORD */    BPT=BPT+1; /* INCREMENT BYTE POINTER */  END; /* OF DO FOREVER */END POS;/* $SUBTITLE  More File Editing Routines *//*  IN ALL CASES OF FILE EDITING:.      'PTR'  IS USED AS THE READ   POINTER.      'PTR1' IS USED AS THE OUTPUT POINTER */MOVEPTR:PROC; /* CALLED TO MOVEPTR TO START OF NEXT LINE */  IF PTR=FILNG THEN RETURN; /* DONE */  PTR=PTR+1; /* SKIP THIS LINE NUMBER */  IF PTR=FILNG THEN RETURN; /* DONE */  DO WHILE ((FBUF(PTR-BSTRT) and "377")<>0) AND ((FBUF(PTR-BSTRT) and "177400")<>0);    PTR=PTR+1;    IF PTR=FILNG THEN RETURN;  END;  PTR=PTR+1;END MOVEPTR;BFORCE:PROC; /* CALLED TO FORCE BUFFER IF LARGE FILE */  IF FILNG IGT FBUFSZ   THEN CALL MOVEBPTRUP(FILNG); /* FORCE LARGE FILES */END BFORCE;LCHK:PROC(PT,SPT);  DCL (PT,SPT) FIXED;  IF BSTRT+BLEN        =  FILNG THEN RETURN; /* RETURN IF ALL OF FILE IS IN MEMORY */  IF BSTRT+BLEN-LINSZ IGE PT    THEN RETURN; /* RETURN IF ALL OF LINE IS IN MEMORY */  CALL MOVEBPTRUP(SPT and "177400"); /* MOVE UP TO THAT SECTOR BOUNDARY */END LCHK;STEPPTR:PROC; /* CALLED TO ADVANCE POINTER */  DCL SAVE.P FIXED;  SAVE.P=PTR; /* SAVE POINTER */  CALL MOVEPTR; /* MOVE TO END OF NEXT LINE */  CALL LCHK(PTR,SAVE.P); /* IF NOT ALL OF PTR LINE IS IN, MOVE BPTR UP TO SAVE.P */END STEPPTR;COPYDOWN:PROC(PT1,PT2,PT3); /* USED IN EDITING - COPY A FILE SECTION DOWN */  DCL (PT1,PT2,PT3,I) FIXED;  PT1=PT1-BSTRT; PT2=PT2-BSTRT; PT3=PT3-BSTRT; /* MOVE POINTER TO RELATIVE POS */  DO I=0 TO PT2-PT1-1; /* COPY DOWN THE DATA */    FBUF(PT3+I)=FBUF(PT1+I);  END;  BALT=1; /* INDICATE ALTERED */END COPYDOWN;EDITPTR:PROC; /* SUBROUTINE TO MOVE A LINE DOWN - USES GLOBAL PTR,PTR1,PTR2 */  PTR2=PTR;  CALL MOVEPTR; /* FIND END OF THIS LINE */  IF PTR2<>PTR1 THEN CALL COPYDOWN(PTR2,PTR,PTR1); /* COPY DATA DOWN TO OUTPUT POINTER */  PTR1=PTR1+PTR-PTR2; /* UPDATE OUTPUT POINTER */  CALL LCHK(PTR,PTR1); /* AND MAKE SURE IS IN MEMORY */END EDITPTR;LNCHK:PROC; /* CALLED AFTER EDIT MOVE TO CHECK FOR CONSECUTIVE LINE NUMBERS */  DCL LINE FIXED;  CALL PRIME;  LINE=0; /* START HERE */  DO WHILE PTR ILT FILNG; /* SEARCH THE WHOLE FILE */    IF FBUF(PTR-BSTRT) ILE LINE THEN DO;      FBUF(PTR-BSTRT)=LINE+1; /* UPDATE LINE */      BALT=1; /* INDICATE ALTERED */    END;    LINE=FBUF(PTR-BSTRT); /* GET IT */    CALL STEPPTR; /* STEP AHEAD */  END;  IF (FILNG IGT FBUFSZ) AND (BALT=1)  /* IF LARGE FILE, */  THEN CALL MOVEBPTRUP(FILNG); /* THEN FORCE BUFFER */END LNCHK;/**/SKIPTOLINE:PROC(LINE); /* SKIP POINTER TO LINE NUMBER */  DCL LINE FIXED;  DO WHILE (PTR ILT FILNG) AND (FBUF(PTR-BSTRT) ILT LINE); /* UP TO >= */    CALL STEPPTR;  END;END SKIPTOLINE;/* WHEN LINES ARE TYPED IN FROM THE TERMINAL THAT ARE ALTER LINES,.  THEY ARE MERGED INTO THE ALTER FILE IMMEDIATELY...  THE FOLLOWING ROUTINES ASSIST IN THE MERGING : ..  FORMAT OF ALTER FILE BUFFER (DIFFERENT FROM FILE) :..  LINE # (16-BIT CODED).  # OF WORDS IN LINE OF TEXTUAL MATERIAL (DOES NOT INCLUDE .-1,.) .  TEXTUAL MATERIAL, + ONE OR TWO BYTES OF ZEROES*/SKIPLN:PROCEDURE; /* TO ADVANCE POINTER ONE PAST */   AFPTR=AFPTR+ABUF(AFPTR+1)+2; /* MOVE AHEAD BY # OF DATA WORDS + 2 */END SKIPLN;/* DELETE ROUTINE - USED TO MOVE DOWN (DELETE) A FEW WORDS IN THE FILE .  PASSED THE LENGTH TO DELETE.  THE ROUTINE DELETES THE WORDS (PTR1).  THROUGH (PTR1+LEN-1).  SAVED DATA IS COPIED DOWN ON TOP OF OTHER.  DATA.  THE GLOBALS PTR, PTR1 ARE USED FOR REFERENCE */DELETE.WORDS:PROC(LEN); /* PASS LENGTH TO DELETE */  DCL (LEN,I,J) FIXED;  IF LEN=0 THEN RETURN; /* NOTHING TO MOVE IF ZERO */  I=PTR1+LEN-BSTRT; /* FIRST SAVED WORD */  J=PTR1-BSTRT; /* FIRST DELETED WORD */  DO WHILE I < BLEN; /* SAVE REMAINDER OF BUFFER */    FBUF(J)=FBUF(I); /* COPY DOWN */    J=J+1; I=I+1;  END;  FILNG=FILNG-LEN; FILNS=SHR(FILNG+255,8);  BLEN=BLEN-LEN;  PTR=PTR-LEN; /* INFO IS COPIED DOWN */  BALT=1; /* INDICATE ALTERED */  IF FILNG ILE FBUFSZ THEN DO; /* IF SHORT FILE, MAKE SURE ALL IN MEMORY */    IF BSTRT<>0 THEN DO; /* IF NOT AT START, READ BACK IN */      I=BLEN;      DO WHILE I>0; I=I-1; FBUF(BSTRT+I)=FBUF(I); END;      CALL WORKREAD(0,FBUF,BSTRT); /* READ IN FROM OF FILE FROM DISK */      BLEN=BLEN+BSTRT;      BSTRT=0; /* AND BUFFER NOW STARTS AT ZERO */    END;    CALL FILL; /* MAKE SURE ALL OF FILE IS IN MEMORY */  END; /* OF MAKE SURE ALL IN MEM */END DELETE.WORDS;NONCOMCHK:PROC; /* CALLED TO MAKE SURE NON EMPTY, NON-COMPILED FILE AND SMALL ENOUGH */   IF   FILNG=0 /* EMPTY FILE */   THEN CALL PSTRINGR (EMPMS);   ELSE IF FILTP<>T#TEXT /* NOT A TEXT FILE */   THEN DO; CALL PSTR (NTXTMS); CALL PSTRINGR (' - it may not be listed or edited'); END;   ELSE IF FILNS IGE 256 /* MUCH TOO LARGE */   THEN CALL PSTRINGR (BIGMS);   ELSE RETURN 0; /* OK */   RETURN 1; /* NOT OK */END NONCOMCHK;/* $SUBTITLE  Editing Procedures *//* ISERT-- USED TO INSERT SOME DATA INTO A FILE BEFORE THE PASSED VARIABLE..  THE INSERT ROUTINE IS PASSED THE NUMBER OF WORDS TO INSERT IN THE.  CURRENT FILE..  THE INSERTION IS DONE BETWEEN (PTR-1) AND PTR..  THE GLOBAL VARIABLE 'PTR' IS UPDATED TO INDICATE THE EFFECTS OF THE.  INSERT..  IF THE BUFFER MUST BE RE-SET DUE TO BOUNDARY CONDITIONS, .  THE GLOBAL VARIABLE 'PTR1' IS USED AS THE RESET POINTER. */ISERT:PROC(LEN); /* PASS THE NUMBER OF WORDS TO INSERT */  DCL LEN   FIXED;  DCL (I,J) FIXED;  IF LEN=0 THEN RETURN; /* NO MODIFICATION IF NO LENGTH CHANGE */  IF FILNG+LEN IGT FBUFSZ THEN DO; /* IF LARGE RESULT FILE, CHECK FOR SMALL START FILE */  IF FILNG ILE FBUFSZ THEN DO;  CALL WORKWRITE(0,FBUF,FILNG); /* FORCE OUT FILE */  BALT=0;  FSTRT=FILNG; /* AND INDICATE DATA STARTS/ENDS HERE */  CALL MOVEBPTRUP(PTR1 and "177400"); /* MOVE PTR TO HERE - NOT FILNG! */  END;  END;  IF FSTRT-BSTRT ILT 2048 THEN DO; /* SEE IF CROWDED */  IF BLEN+LEN IGT FBUFSZ THEN DO; /* IF SHRINKING BACK, THEN FORCE THINGS OUT */  CALL MOVEBPTRUP(FILNG); /* FORCE OUT THE FILE IF CROWDED */  BSTRT=PTR1 and "177400"; /* START HERE */  BLEN=0;FSTRT=BSTRT;BALT=0;  CALL FILL;  END;  END;  IF BLEN+LEN IGT FBUFSZ THEN DO; /* IF NOT ROOM IN BUFFER, THEN MOVE IT */  IF (BSTRT+BLEN=FILNG) THEN DO; /* END OF FILE IN MEMORY - REDUCE IT */  BLEN=BLEN-(FSTRT-(FSTRT and "177400"));  FSTRT=FSTRT and "177400";  END;  DO WHILE (BLEN+LEN IGT FBUFSZ);  BLEN=BLEN-256;FSTRT=FSTRT-256;  END;  END;  I=PTR-BSTRT; /* INSERT BEFORE HERE */  J=BLEN-1; /* AND START HERE */  DO WHILE J >= I; /* COPY UP */    FBUF(J+LEN)=FBUF(J);    J=J-1;  END;  BALT=1; /* INDICATE ALTERED */  FILNG=FILNG+LEN; FILNS=SHR(FILNG+255,8);  BLEN=BLEN+LEN;  PTR=PTR+LEN; /* INCREMENT READ POINTER AT THIS TIME */  CALL LCHK(PTR,PTR1); /* MAKE SURE ALL OF LINE WILL BE IN MEMORY - FILL UP AT PTR1 */END ISERT;/* $SUBTITLE  Line Number Sorting and Processing */SORT:PROC; /* SORT ROUTINE */  IF AFLNG=0 THEN RETURN; /* NO ALTERS */  CALL PRIME;  AFPTR=0; /* INITIALIZE ALTER LIST POINTER */  PTR1=0; /* AND INITIALIZE OUTPUT POINTER */  DO WHILE AFPTR ILT AFLNG; /* AND RUN THROUGH ALTER FILE */    ARG=ABUF(AFPTR); /* GET LINE # */    DO WHILE (PTR ILT FILNG) and (FBUF(PTR-BSTRT) ILT ARG); /* AX IT */      CALL EDITPTR; /* MOVE PTR AHEAD, COPY LINE DOWN, MOVE PTR1 AHEAD */    END;    IF (PTR ILT FILNG) and (FBUF(PTR-BSTRT)=ARG) THEN DO; /* DELETE THIS LINE IF NEW ONE */      CALL MOVEPTR; /* MOVE PTR UP TO NEW LINE */      CALL LCHK(PTR,PTR1); /* AND MAKE SURE NEXT LINE IS IN MEMORY - IF NOT MOVEBPTR TO PTR1 */    END;    NEWLINLEN=ABUF(AFPTR+1); /* AMOUNT OF ASCII DATA IN NEW LINE */    IF NEWLINLEN<>0 THEN NEWLINLEN=NEWLINLEN+1; /* INCR IT TO INCL L# */    PTR3=PTR1+NEWLINLEN; /* END OF WHERE NEW LINE WILL GO */    DO WHILE PTR3 IGT PTR; /* AND MOVE POINTER UP */      CALL ISERT(256); /* ISERT 256 WORDS BEFORE PTR, PRESERVING PTR1 */    END;    IF NEWLINLEN<>0 THEN DO; /* INSERT LINE */      FBUF(PTR1-BSTRT)=ABUF(AFPTR); /* NEW LINE # */      DO PTR4=1 TO ABUF(AFPTR+1); /* AND COPY DATA */        FBUF(PTR1-BSTRT+PTR4)=ABUF(AFPTR+1+PTR4); /* COPY */      END;    BALT=1; /* INDICATE ALTERED */    END;    PTR1=PTR3; /* AND THIS IS WHERE OUTPUT CONTINUES */    IF PTR-PTR1 IGT 1024 THEN CALL DELETE.WORDS(1024-256); /* WHEN GAP GETS TOO BIG, DELETE SOME */    CALL SKIPLN; /* SKIP THIS ALTER LINE */  END; /* OF LOOP */  IF PTR IGT PTR1 THEN CALL DELETE.WORDS(PTR-PTR1); /* AND TRUNCATE FILE TO EXACT LENGTH */  CALL BFORCE; /* FORCE BUFFER OUT TO DISK IF LARGE FILE */  AFLNG=0; /* AND CLEAN OUT ALTER BUFFER */END SORT;RESEQ:PROC(LINE,STEP) BOOLEAN; /* RESEQUENCE A FILE, GIVEN FIRST AND INCREMENT */  DCL (LINE,STEP) FIXED;  DCL SAVEDLINE   FIXED;  CALL SORT; /* SORT ALTERS INTO FILE */  IF NONCOMCHK THEN RETURN 1; /* NOT A TEXT FILE */  SAVEDLINE=LINE; /* SAVE IN CASE OF ERROR */  RESEQERR:; /* RESTART HERE IF TOO BIG */  CALL PRIME; /* SET PTR TO START OF FILE */  DO WHILE PTR ILT FILNG; /* LOOP OVER WHOLE FILE */    IF (LINE IGT (-1-STEP)) AND (STEP<>1) THEN DO; /* TOO BIG - RETRY */      STEP=SHR(STEP,1); /* REDUCE STEP */      LINE=SAVEDLINE; /* RECOVER LINE NUMBER */      GOTO RESEQERR; /* TRY AGAIN */    END;    FBUF(PTR-BSTRT)=LINE; /* STORE LINE NUMBER */    BALT=1; /* INDICATE ALTERED */    LINE=LINE+STEP;    CALL STEPPTR; /* POSITION PTR TO START OF NEXT LINE */  END; /* OF DO WHILE */  SAVED=0; STORED=0; /* FILE IS NOT SAVED */  CALL BFORCE; /* FORCE BUFFER HERE IF LARGE FILE */  RETURN 0; /* OK */END RESEQ;/* $SUBTITLE  Merge Procedure *//* THE MERGE PROCEDURE IS CALLED TO MERGE A LINE TYPED IN FROM.  THE TERMINAL INTO THE CURRENT FILE..  THE CURRENT FILE (IN MEMORY OR DISK-RESIDENT) IS SEARCHED UNTIL THE.  SPECIFIED LINE NUMBER IS FOUND, A MATCHING ONE IS DELETED,.  AND THE NEW LINE IS INSERTED, AND DATA MOVED ACCORDINGLY. */MERGE:PROCEDURE; /* WHEN A LINE TYPED IN, JUST MERGE */  DCL (I,J) FIXED;  IF FILNG<>0 THEN DO; /* IF NONEMPTY, CHECK FOR COMPILED */    IF NONCOMCHK THEN DO; /* IF COMPILED, PRINT MESSAGE, RETURN */      CALL SKIPEOL;      RETURN;    END;  END;  AFPTR=0; /* RESET POINTER TO START OF ALTER FILE BUFFER */  SAVED=0; STORED=0; /* NOT SAVED ANY MORE AFTER NEW LINE INSERTED */  DO WHILE (AFPTR ILT AFLNG) and (ABUF(AFPTR) ILT ARG); /* SKIP UNTIL LINE FOUND */    CALL SKIPLN; /* GET NEXT ONE */  END;  PTR1=AFPTR; /* THIS IS WHERE IT GOES */  DO WHILE (AFPTR ILT AFLNG) and (ABUF(AFPTR)=ARG); CALL SKIPLN; END; /* DONE */  PTR2=AFPTR; /* SAVE THAT POINTER */  NEWLINLEN=4; /* ASSUME EMPTY LINE - JUST INSERT L#, 0 */  IF INCH<>a.CR THEN DO; /* FIND LENGTH OF NEW LINE */    IF INCH=a.SP THEN CALL GET.CHAR; /* SKIP ONE SPACE, GET LOWER CASE LETTER */    NEWLINLEN=6; /* AT LEAST 6 BYTES - LN, # OF WORDS, ZEROES */    PTR3=TYBP; PTR4=INCH; /* SAVE POINTER AND CUR CHAR */    DO WHILE INCH<>a.CR; NEWLINLEN=NEWLINLEN+1; CALL GET.CHAR; END;    TYBP=PTR3; INCH=PTR4; /* RESTORE POINTER AND CUR CHAR */  END; /* OF FIND LINE LENGTH */  /* WE HAVE FOUND OUT THE LENGTH OF THE NEW LINE (NEWLINLEN), */  /* WHERE IN THE FILE IT SHOULD START (PTR1), WHAT DATA IN    */  /* THE FILE SHOULD BE SAVED (NEWLINLEN), AND SO FORTH.       */  /* NOW MOVE THE DATA AROUND AS REQD, AND INSERT THE NEW LINE */  PTR3=PTR1+SHR(NEWLINLEN,1); /* SHIFT RIGHT - GET POINTER TO AFTER NEW DATA */  IF PTR3 IGT PTR2 THEN DO; /* MUST MOVE UP THE LINE */    I=SHR(AFLNG+PTR3-PTR2+FILNG+255,8); /* COMPUTE NEW # OF SECTORS IN FILE */    IF (I IGE 256) OR (I IGT WORKNS) THEN DO; /* FILE TOO BIG */      CALL PSTRINGR ('File too big--can not add more lines');      CALL SKIPEOL;      RETURN;    END;    I=AFLNG-1; J=AFLNG+PTR3-PTR2-1;    DO WHILE I >= PTR2;      ABUF(J)=ABUF(I); J=J-1; I=I-1; /* COPY UPWARDS */    END;    AFLNG=AFLNG+PTR3-PTR2; /* NEW LENGTH */    PTR2=PTR3; /* NOW INFO IS UP HERE */  END;  ABUF(PTR1)=ARG; /* STORE NEW LINE NUM,BER */  ABUF(PTR1+1)=SHR(NEWLINLEN-4,1); /* # OF ASCII WORDS OF DATA */  PTR1=SHL(PTR1+1,1); /* BYTE POINTER TO FOLLOWING WORD */  DO WHILE INCH<>a.CR;    CALL PBYTE(ABUF,PTR1,INCH); /* STORE CHARACTER */    CALL GET.CHAR;    PTR1=PTR1+1;  END;  IF NEWLINLEN<>4 THEN DO; /* ZERO FILL ASCII INFO */    CALL PBYTE(ABUF,PTR1,0); /* NULL AT END */    IF (PTR1+1) THEN CALL PBYTE(ABUF,PTR1+1,0);  END;  IF PTR2 IGT PTR3 THEN DO; /* SEE IF EMPTY SPACE */    I=PTR2; J=PTR3;    DO WHILE I ILT AFLNG; /* COPY UPWARDS */      ABUF(J)=ABUF(I);      I=I+1; J=J+1;    END;    AFLNG=AFLNG+PTR3-PTR2; /* REDUCE FILE LENGTH */  END;  IF AFLNG+100 IGT ABUFSZ THEN CALL SORT; /* SORT IN ALTERS IF BUFFER NEARLY FULL */END MERGE;