/* 02-REMD  $TITLE  Remote Disk Subroutines */  /*  THE FOLLOWING PROCEDURES (WRITTEN IN XPL) ARE USED TO READ.   AND WRITE DATA FROM A REMOTE MINIFLOPPY DISK SUBSYSTEM. */DCL (D110.DRV,D110.TRK,D110.SEC) FIXED; /* DRIVE, TRACK, SECTOR */DCL D110.POS(1) FIXED; /* CURRENT HEAD POSITION */DCL D110.SPD(1) FIXED;D110.SPD(0)=3; D110.SPD(1)=3; /* ASSUME SINGLE DENSITY - CHECKED LATER */DCL D.STS LIT '"110"'; /* STATUS/COMMAND REGISTER */DCL D.TRK LIT '"111"'; /* D110.TRK REGISTER */DCL D.SEC LIT '"112"'; /* D110.SEC REGISTER */DCL D.DAT LIT '"113"'; /* DATA REGISTER     */DCL D.MOT LIT '"114"'; /* MOTOR ON ADDRESS  */D110SEEK:PROC(DRIVE,SNUM); /* PASS D110.SEC NUMBER - 0-999 */  DCL (DRIVE,SNUM) FIXED;  D110.DRV=SHR(DRIVE,8)&1; /* EXTRACT DRIVE NUMBER */  D110.SEC=SNUM; /* STORE SNUM IN D110.SEC */  D110.TRK=0; /* COMPUTE D110.TRK # */  DO WHILE D110.SEC>=5;    D110.SEC=D110.SEC-5;    D110.TRK=D110.TRK+1;  END;  D110.SEC=D110.SEC+1; /* AND 0 BECOMES 1 */    /* SEEK */    DO WHILE READ(D.STS); END; /* WAIT FOR PREVIOUS RESTORE TO FINISH */  WRITE(D.TRK)=D110.POS(D110.DRV); /* LOAD TRK REG WITH CURRENT POS(D110.DRV) */  WRITE(D.DAT)=D110.TRK; /* LOAD DATA REG WITH TRAK */  WRITE(D.MOT)=D110.DRV; /* SELECT DRIVE 0 */  WRITE(D.STS)="20"+D110.SPD(D110.DRV); /* AND DO IT - PERFORM SEEK */  DO WHILE READ(D.STS); /* WAIT FOR SEEK TO COMPLETE */    IF (READ(D.STS)&"200")=0 THEN WRITE(D.MOT)=D110.DRV; /* KEEP LOADED */  END;  D110.POS(D110.DRV)=READ(D.TRK); /* SAVE CURRENT POS */END D110SEEK;/**/ /* REMOTE DISK READ: */REMDISKREAD:PROC(DRIVE,SNUM,BUF,LEN); /* READ D110 FLOPPY */  DCL (DRIVE,SNUM,LEN) FIXED;  DCL BUF     ARRAY;    DCL PTR     FIXED; /* USED AS POINTER INTO BUF */  DCL CMD     FIXED; /* HOLDS COMMAND */  DCL (I,J,K) FIXED;    PTR=0; /* INITIALIZE */    RESTART:; /* RE-ENTER FOR RETRY */  CALL D110SEEK(DRIVE,SNUM); /* D110SEEK & COMPUTE D110.TRK,  D110.SEC */  CMD="214"; /* WAIT 10 MS AFTER SEEKING */  DO WHILE READ(D.STS)>=128; END; /* WAIT FOR READY */  MOREREAD:; /* RE-ENTER FOR MORE READ ON SAME D110.TRK */  WRITE(D.SEC)=D110.SEC; /* INITIALIZE D110.SEC */  WRITE(D.STS)=CMD; /* START READ COMMAND */    I=PTR;  J=LEN; /* AND LENGTH */  K=0; /* INITIALIZE */    L1:;  IF (READ(D.STS)&1)=0 THEN GOTO L2; /* DONE */  IF (READ(D.STS)&2)=0 THEN GOTO L1; /* LOOP CHECKING FINAL */  K=READ(D.DAT); /* READ DATA ROM DISK */  DO WHILE (READ(D.STS)&2)=0; END; /* WAIT FOR NEXT */  IF J<>0 THEN DO;    BUF(I)=K\SHL1(SHL1(SHL1(SHL1(SHL1(SHL1(SHL1(SHL1(READ(D.DAT)))))))));    J=J-1; I=I+1;  END;  ELSE K=READ(D.DAT); /* JUST THROW AWAY IF AFTER END */  GOTO L1;  L2:; /* EXIT */  IF (READ(D.STS)&"214")<>0 THEN DO; /* CRC OR DATA LATE OR BECAME UNREADY ERROR */    WRITE("50")=7;    WRITE(D.MOT)=D110.DRV;    CMD="210"; /* NO DELAY HERE */    GOTO MOREREAD;  END;  IF (READ(D.STS)&"20")<>0 THEN DO; /* SEEK ERROR */    WRITE("50")=7;    WRITE(D.STS)=D110.SPD(D110.DRV); /* RESTORE */    D110.POS(D110.DRV)=0; /* RESET POSITION */    GOTO RESTART;  END;  LEN=J; PTR=I; /* OK - UPDATE POINTER */  IF LEN=0 THEN RETURN; /* DONE */  WRITE(D.MOT)=D110.DRV; /* KEEP MOTOR GOING FOR NEXT LOOP */  CMD="210";  SNUM=SNUM+1; /* INCREMENT */  D110.SEC=D110.SEC+1;  IF D110.SEC<6 THEN GOTO MOREREAD; /* MORE */  GOTO RESTART; /* ELSE RESEEK TOO */END REMDISKREAD;/**//* REMOTE DISK WRITE: */REMDISKWRITE:PROC(DRIVE,SNUM,BUF,LEN); /* READ D110 FLOPPY */  DCL (DRIVE,SNUM,LEN) FIXED;  DCL BUF     ARRAY;    DCL PTR     FIXED; /* USED AS POINTER INTO BUF */  DCL CMD     FIXED; /* HOLDS COMMAND */  DCL (I,J,K) FIXED;    PTR=0; /* INITIALIZE */    RESTART:; /* RE-ENTER FOR RETRY */  CALL D110SEEK(DRIVE,SNUM); /* D110SEEK & COMPUTE D110.TRK,  D110.SEC */  CMD="254"; /* WAIT 10 MS AFTER SEEKING */  DO WHILE READ(D.STS)>=128; END; /* WAIT FOR READY */  MOREWRITE:; /* RE-ENTER FOR MORE READ ON SAME D110.TRK */  WRITE(D.SEC)=D110.SEC; /* INITIALIZE D110.SEC */  WRITE(D.STS)=CMD; /* START READ COMMAND */    I=PTR;  J=LEN; /* AND LENGTH */  K=BUF(I);  IF J=0 THEN K=0; /* WRITE ZEROS */    L1:;  IF (READ(D.STS)&1)=0 THEN GOTO L2; /* DONE */  IF (READ(D.STS)&2)=0 THEN GOTO L1; /* LOOP CHECKING FINAL */  WRITE(D.DAT)=K;  K=ROT(ROT(ROT(ROT(ROT(ROT(ROT(ROT(K,1),1),1),1),1),1),1),1);  IF J<>0 THEN DO;/* DIVIDE UP WORK LOAD */    I=I+1; J=J-1;  END;  DO WHILE (READ(D.STS)&2)=0; END; /* WAIT FOR NEXT */  WRITE(D.DAT)=K;  IF J=0 THEN K=0;   ELSE        K=BUF(I); /* GET NEXT */  GOTO L1;  L2:; /* EXIT */  IF (READ(D.STS)&"214")<>0 THEN DO;    WRITE("50")=7;    CMD="250"; /* NO DELAY REQUIRED */    WRITE(D.MOT)=D110.DRV; /* KEEP MOTOR RUNNING/HEAD LOADED */    GOTO MOREWRITE;  END;  IF (READ(D.STS)&"20")<>0 THEN DO; /* SEEK ERROR */    WRITE("50")=7; /* BEEP */    WRITE(D.STS)=D110.SPD(D110.DRV); /* RESTORE */    D110.POS(D110.DRV)=0; /* INDICATES RESTORED */    GOTO RESTART;  END;  LEN=J; PTR=I; /* OK - UPDATE POINTER */  IF LEN=0 THEN RETURN; /* DONE */  WRITE(D.MOT)=D110.DRV; /* KEEP MOTOR ON FOR RETRY */  CMD="250";  SNUM=SNUM+1; /* INCREMENT */  D110.SEC=D110.SEC+1;  IF D110.SEC<6 THEN GOTO MOREWRITE; /* MORE */  GOTO RESTART; /* ELSE RESEEK TOO */END REMDISKWRITE;