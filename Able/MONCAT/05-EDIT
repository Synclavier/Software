/* 05-EDIT  $TITLE  Command editing, history saving, and macro routines   Modified:   02/28/89 - MWH - Merge in with the "real" monitor for release 2.0   06/03/88 - MWH - Merge with new O-Beta monitor; remove nested DO's here   04/14/88 - MWH - Add nested, long indirect command files   01/20/88 - MWH - Add .MONSAVE and .MONPRO   01/05/88 - MWH - Merge in a version with the MONITOR code   12/22/87 - MWH - Add version; don't bump "oldest" on exit   12/11/87 - MWH - Change "fixed array" syntax to proper XPL   12/08/87 - MWH - Author (from experimental code 08/87)   */dcl show_history  proc external;  /* Make these visible to everyone */dcl show_macros   proc external;begin;                   /* Scope all to this file only */dcl MAGIC lit '"7072"';  /* Uses this to know valid history stored in history file *//* Local literals */dcl MARKER  lit '''~+~''';  /* Marker string for replace */dcl BLNG    lit '41';       /* Buffer length for each command saved (in words) */dcl BSUB    lit '(BLNG-1)'; /* Maximum subscript for declaring buffers */dcl BCHARS  lit '(2 * BSUB)';  /* Max chars in a buffer */dcl history_file data (':user:.history'); /* History file treename */dcl macro_file   data (':user:macros');   /* Macro file treename */dcl buf (100)   fixed;    /* Command buffer; extra big */dcl tbuf(100)   fixed;    /* Temp buffer               */dcl fbuf (64)   fixed;    /* Buffer used by fast cmds  */dcl f#m         fixed;    /* Location of history file  */dcl f#l         fixed;/* STARTING HERE, THIS BLOCK IS SAVED TO DISK BETWEEN OVERLAYS    */dcl magic_num    fixed;        /* First word of saved block       */dcl oldest       fixed;        /* Oldest in history buffer        */dcl mode         fixed;        /* 0 = insert; 1 = overstrike mode */dcl a_buf (BSUB) fixed;        /* Command history buffers         */dcl b_buf (BSUB) fixed;        /* (must be dcl'd in order)        */dcl c_buf (BSUB) fixed;     dcl d_buf (BSUB) fixed;dcl e_buf (BSUB) fixed;dcl f_buf (BSUB) fixed;dcl g_buf (BSUB) fixed;dcl h_buf (BSUB) fixed;dcl i_buf (BSUB) fixed;dcl j_buf (BSUB) fixed;dcl k_buf (BSUB) fixed;dcl l_buf (BSUB) fixed;dcl m_buf (BSUB) fixed;dcl n_buf (BSUB) fixed;dcl o_buf (BSUB) fixed;dcl p_buf (BSUB) fixed;dcl q_buf (BSUB) fixed;dcl r_buf (BSUB) fixed;dcl s_buf (BSUB) fixed;dcl t_buf (BSUB) fixed;dcl u_buf (BSUB) fixed;dcl v_buf (BSUB) fixed;dcl w_buf (BSUB) fixed;dcl x_buf (BSUB) fixed;dcl y_buf (BSUB) fixed;dcl z_buf (BSUB) fixed;dcl olds  (BSUB) fixed;   /* Old string for replace    */dcl news  (BSUB) fixed;   /* New string for replace    */dcl sstr  (BSUB) fixed;   /* Search string             *//* Words above to save in history file (general + BSUB arrays) */dcl SAVE_WDS lit '(3) + (29*BLNG)';/* Print user's prompt plus history recall letter */prompt: proc;   if (core(loc.monbits) & m#log) <> 0 then do;      write("50") = a.a + oldest;      call pstr('! ');   end;   call pstr(loc(loc.prmt));end prompt;/* Find the history file (or create it) -- for saving monitor history */setup_history: proc;   dcl length fixed;   dcl i      fixed;   if magic_num = MAGIC then return;  /* We haven't overlayed; save time */   length = shr(SAVE_WDS,8)+1;        /* Length needed for history file */      if (systyp == 0)						  /* skip history on floppy systems */   {		f#m = 0;   	f#l = 0;		return;	}   	   i = locate(history_file,0);    	if i = FALSE                       /* No history file exists */   OR F#LS_Length <> length           /* OR it's the wrong size */   OR F#Words <> SAVE_WDS   then do;      if replace(history_file,T#Data,0,length,SAVE_WDS,0) = false then do;         f#m = 0;         f#l = 0;         return;      end;      else do;         if locate(history_file,0) = false then do;            f#m = 0;            f#l = 0;            return;         end;      end;   end;   	f#m = F#MS_Sector;  /* One of the locates worked, remember where found */   f#l = F#LS_Sector;end setup_history;/* Reads command history in from disk */read_history: proc;   if (systyp == 0)						  /* skip history on floppy systems */   	return;   if magic_num <> MAGIC         /* We have overlayed; need to read */   AND (f#m <> 0 OR f#l <> 0)    /* and we have a history file available */   then do;      /* Read magic number, see if ok */      call readdata(f#m,f#l,loc(addr(magic_num)),SAVE_WDS);      /* If file data not valid, ZERO OUT entire save area */      if magic_num <> MAGIC then do;         call blockset(loc(addr(magic_num)),SAVE_WDS,0);      end;   end;end read_history;/* Writes current command history back to disk */write_history: proc;   if (systyp == 0)						  		/* skip history on floppy systems */   	return;   if f#m = 0 and f#l = 0 then return;		/* Don't have a history file */   if (locate(history_file,0) == false)	/* check for removable media by locating file again */  		return;			if (f#m != F#MS_Sector || f#l != F#LS_Sector)		return;   magic_num = MAGIC;   call strcpy(loc(addr(a_buf(0)) + oldest*BLNG),buf);   oldest = oldest + 1;   if oldest >= 26 then oldest = 0;   /* Write out magic number, oldest, command history buffers */   call writedata(f#m,f#l,loc(addr(magic_num)),SAVE_WDS);end write_history;/* Start of package to read lines from a file, once found with "locate" */dcl start_buf (0)  fixed;  /* Dummy word so "byte" operators may be used on sect_buf */dcl sect_buf (255) fixed;  /* Read in buffer: MUST follow "start_buf" */dcl msb_in_buf     fixed;  /* Current disk sector in sect_buf */dcl lsb_in_buf     fixed;  /* LSB of above */dcl in_ptr         fixed;  /* Pointer within sect_buf */dcl out_ptr        fixed;  /* Pointer to line_buf */dcl tot_wds        fixed;  /* Save total word length of the file here */dcl sect_m         fixed;  /* Current pointer into the file */dcl sect_l         fixed;dcl sect_offset    fixed;  /* How many sectors have been read past 1st *//* Read a sector into sect_buf, if it's not already in there */read_sect:proc(msb,lsb);   dcl msb fixed;   dcl lsb fixed;   if msb <> msb_in_buf   OR lsb <> lsb_in_buf   then do;      call readdata(msb,lsb,sect_buf,256);      msb_in_buf = msb;      lsb_in_buf = lsb;   end;end read_sect;/* Initialize for reading; call with (F#MS_Sector,F#LS_Sector,F#Words) */init_line:proc(fm,fl,fw);   dcl fm fixed;   dcl fl fixed;   dcl fw fixed;   tot_wds = fw;   sect_m = fm;   sect_l = fl;   sect_offset = 0;   in_ptr = -1;   /* So we start at start of sector, not string */   call read_sect(sect_m,sect_l);end init_line;/* Fetch a line from the file; returns 1 normally, or zero for EOF */read_line: proc(buf,len);   dcl buf fixed array;  /* Output buffer */   dcl len fixed;        /* Length in words of the output buffer (-1) */   dcl ch  fixed;        /* Character read from the file */   /* Get the next character from the input file */   gc: proc fixed;      in_ptr = in_ptr + 1;      if in_ptr > 511 then do;  /* If all 512 chars read, get next sector */         sect_l = sect_l + 1;         if sect_l = 0 then sect_m = sect_m + 1;         call read_sect(sect_m,sect_l);         sect_offset = sect_offset + 1;         in_ptr = 0;      end;      return byte(start_buf,in_ptr);   end gc;   out_ptr = 0;                     /* Zero output buffer */   call gc;                         /* Toss line number */   call gc;   ch = gc;   do while ch <> 0;      call pbyte(buf,out_ptr,ch);      out_ptr = out_ptr + 1;      if shr(out_ptr,1) >= len then ch = 0;  /* Line is too long */      else ch = gc;   end;   buf(0) = out_ptr;           /* Put string length in 1st word */   if not (in_ptr) then call gc;    /* End on word boundary */   if shr(in_ptr,1) + (sect_offset * 256) >= tot_wds then return(0);   else return(1);end read_line;/* See if user is requesting a command history recall type command */check_hist_recall: proc;   dcl ch fixed;   if (buf(0) <= 0) then return;       /* Nothing in command buffer */   ch = buf(1) & "377";   if ch = a.period then do;            /* History recall; execute  */      ch = shr(buf(1),8) & "137";      if ch < a.a or ch > a.z then return;      call blockmove(loc(addr(a_buf(0)))+BLNG*(ch-a.a),buf,BLNG);      call pstr('!: ');      call pstringr(buf);   end;end check_hist_recall;/* Reads macro file and translates the contents of the passed command.  *//* Puts the results in buffer, if translation is found.  Uses fbuf      *//* Returns 1 if translation occurs, 0 otherwise.                        */get_macro_cmd: proc(ch,buffer);   dcl ch        fixed;   dcl buffer    fixed array;   dcl (i,j)     fixed;   if (locate(macro_file,0)) = 0   then return 0;                      /* No local commands to translate */   call init_line(F#MS_Sector,F#LS_Sector,F#Words);   i = 0;   j = 1;                              /* Not at EOF yet */   do while i = 0;      if j = 0 then return 0;          /* Didn't find a translation */      j = read_line(fbuf,64);          /* Returns 0 at EOF */      if ch = toupper(fbuf(1) & "377")      then i = 1;                      /* Break loop; found it */   end;   i = strcspn(fbuf,'= ',1);         /* Skip white space and = */   if i <> -1 then call strncpy(buffer,fbuf,i,strlen(fbuf));   return 1;                         /* Found it */end get_macro_cmd;/* macro_cmd = translates fast single character macros */ /*            returns 1 if command should not be passed back to the monitor */macro_cmd: proc;   dcl ch        fixed;   if buf(0) <= 0 then return 1;        /* To ignore single <CR>          */   ch = toupper(buf(1) & "377");        /* Non null; Look at first char   */   if buf(0) > 1 then return 0;         /* Not a single char fast command */   if ch > a.space                      /* Ignore ctrl characters */   AND (ch < a.0                        /* Digits are line numbers... */   OR   ch > a.9)                       /* ...so ignore them too */   then do;                             /* Char OK, see if macro exists */      if get_macro_cmd(ch,buf) <> 0 then do;         call pstr('@: ');         call pstringr(buf);               /* Show translated command  */      end;   end;   return 0;end macro_cmd;wait_for_char: proc;   call pstr('Press any key to continue...');   call rchar;   write("50") = a.cr;   call pstr('                            ');   write("50") = a.cr;end;show_history: proc public;   dcl (i,j,k) fixed;   j = oldest;                       /* Start command offset     */   k = 0;   do i=1 to 26;      ptr = addr(a_buf(0)) + j*BLNG; /* First command to list    */      if core(ptr) > 0 then do;         write("50") = a.a+j;         call pstr(': ');         call pstringr(loc(addr(core(ptr))));         k = k + 1;         if (k mod 23) = 0 then call wait_for_char;      end;      j = j + 1;      if j >= 26 then j = 0;   end;end show_history;show_macros: proc public;   dcl (i,j) fixed;   i = locate(macro_file,0);   if i = 0 then do;      call pstringr('No MACROS are defined in the file :MACROS');      call pstringr('Type HELP MONITOR to learn how to define some');      return;   end;   call pstringr('MACROS available:');   call init_line(F#MS_Sector,F#LS_Sector,F#Words);   i = 1;                              /* Lines printed so far */   j = read_line(fbuf,64);             /* Returns 0 at EOF */   do while j <> 0;      call pstringr(fbuf);      i = i + 1;      if (i mod 23) = 0 then call wait_for_char;      j = read_line(fbuf,64);   end;end show_macros;/* Allow fancy editing of a user command */editcmd: proc;   dcl char_pos  fixed;   /* Which character we're pointing at in buf */   dcl up_down   fixed;   /* Pointer into history for up/down arrows  */   dcl searching fixed;   dcl ch        fixed;   /* New character typed in                   */   dcl (i,j)     fixed;   up_down = oldest;                        /* Point at oldest cmd   */   searching = 0;                           /* Not searching back    */   call pstr(buf);                          /* Show existing command */   char_pos = buf(0);                       /* Currently at end      */   do while 1;                              /* Loop until <CR>       */      ch = rchar;                           /* Get input character   */      searching = searching - 1;            /* Decrement indicator   */      do while ch = a.esc;                  /* Skip escape sequences */         i = 1;                             /* Could be PF1          */         j = 1;                             /* Could be arrow key    */         ch = rchar;                        /* 3 Chars in seq        */         if ch <> a.o then i=0;             /* If not "O", not PF1   */         if ch <> a.lbracket then j=0;      /* If not "[", not arrow */         ch = rchar;         if ch <> a.p then i=0;             /* If not "P", not PF1   */         if i = 1 then ch = pf.1;           /* It was PF1            */         else if j = 1 then do;             /* Might still be arrow  */            if      ch = a.a then ch = cur.up;            else if ch = a.b then ch = cur.down;            else if ch = a.c then ch = cur.right;            else if ch = a.d then ch = cur.left;            else if ch = a.e then ch = a.cr;  /* Turn MAC refresh into return */            else                  ch = rchar;         end;         else ch = rchar;                   /* Not PF1 or arrow      */      end;      if ch = a.delete                      /* <DEL> or ^Z              */      or ch = c.z then do;         mode = 0;                          /* Force insert mode        */         if buf(0) > 0                      /* Char there to delete?    */         and char_pos > 0 then do;            call strncpy(tbuf,buf,char_pos,strlen(buf));            char_pos = char_pos - 1;        /* Back one character       */            buf(0) = char_pos;              /* First half of buffer     */            call strncat(buf,tbuf,char_pos);/* Second half of buffer    */            write("50") = a.bs;             /* Echo rest of line        */            call pstr(tbuf);            write("50") = a.space;            do i=0 to strlen(tbuf);               write("50") = a.bs;          /* Backup to char_pos       */            end;         end;      end;      else if ch = a.cr then do;            /* Carriage return = end */         dcl ch1 fixed;         ch1 = byte(buf,1) & "137";         if char_pos = 2         and byte(buf,0) = a.comma          /* comma                    */         and ch1 >= a.a                     /* A...                     */         and ch1 <= a.z                     /* ...to Z                  */         then do;                           /* History recall; edit     */            call blockmove(loc(addr(a_buf(0)))+BLNG*(ch1-a.a),buf,BLNG);            call newline;            call prompt;            call pstr(buf);                 /* Show existing command */            char_pos = buf(0);              /* Currently at end         */         end;         else do;            if buf(0) > BCHARS            then buf(0) = BCHARS;           /* Restrict buf length   */            call newline;                   /* Echo it               */            return;                         /* Command is in "buf"   */         end;      end;      else if ch = c.a then do;             /* Toggle insert/overstrike */         mode = mode xor 1;      end;      else if ch = c.d then do;             /* '^D' - delete to right   */         if buf(0) > 0          and char_pos < buf(0) then do;     /* Char there to delete?    */            call strncpy(tbuf,buf,char_pos+1,strlen(buf));            buf(0) = char_pos;              /* First half of buffer     */            call strncat(buf,tbuf,char_pos);/* Second half of buffer    */            call pstr(tbuf);                /* Echo rest of line        */            write("50") = a.space;            do i=0 to strlen(tbuf);               write("50") = a.bs;          /* Backup to char_pos       */            end;         end;      end;      else if ch = c.e then do;             /* '^E' - delete to eol     */         if buf(0) > 0          and char_pos < buf(0) then do;     /* Chars there to delete?   */            do i=char_pos to strlen(buf)-1; /* Erase rest of line       */               write("50")=a.sp;            end;            do i=char_pos to strlen(buf)-1;               write("50")=a.bs;            end;            buf(0) = char_pos;              /* Keep left part of buffer */         end;      end;      else if ch = c.g then do;             /* '^G' - global replace    */         call strcpy(tbuf,olds);            /* Save previous (if any)   */         call newline;         call pstr('*> Enter original string [');         call pstr(tbuf);         call pstr(']: ');         linput olds;         olds(0) = olds(0) - 1;             /* Remove <CR>              */         if strlen(olds) = 0 then call strcpy(olds,tbuf);         if strlen(olds) > 0 then do;       /* Must have something to find */            call strcpy(tbuf,news);         /* Save previous (if any)   */            call pstr('*> Enter replacement string [');            call pstr(tbuf);            call pstr(']: ');            linput news;            news(0) = news(0) - 1;            if strlen(news) = 0 then call strcpy(news,tbuf);            i = index(buf,olds,0);            do while i <> -1;               /* Put in marker string */               call strncpy(tbuf,buf,i+strlen(olds),strlen(buf));   /* Get part 2 */               buf(0) = i;                                     /* Part 1     */               call strcat(buf,MARKER);                        /* Insert marker */               call strcat(buf,tbuf);                          /* Part 2     */               i = index(buf,olds,0);            end;            i = index(buf,MARKER,0);            do while i <> -1;               /* Replace marker with new */               call strncpy(tbuf,buf,i+strlen(MARKER),strlen(buf));   /* Get part 2 */               buf(0) = i;                                     /* Part 1     */               call strcat(buf,news);                          /* Insert new */               call strcat(buf,tbuf);                          /* Part 2     */               i = index(buf,MARKER,0);            end;         end;                /* of old string non zero */         if buf(0) > BCHARS then buf(0) = BCHARS;         call prompt;        /* Redraw command line    */         call pstr(buf);         char_pos = buf(0);  /* Currently at end       */      end;                   /* of control-g           */      else if ch = c.h                      /* '^H' - backspace cursor  */      or      ch = cur.left then do;        /* '<--' too                */         if char_pos > 0 then do;            write("50") = a.bs;             /* Backup cursor            */            char_pos = char_pos - 1;        /* Backup in buffer         */         end;         else do;                           /* At start; wrap to end    */            call pstr(buf);            char_pos = buf(0);         end;      end;      else if ch = c.i then do;             /* TAB - forward word       */         if char_pos = buf(0) then do;      /* At end, wrap around      */            do i=1 to char_pos;               write("50") = a.bs;          /* Move cursor back         */            end;            char_pos = 0;                   /* Reset to start of line   */         end;         else do;            i = 1;                          /* Until we find next space */            do while i <> 0 and char_pos < buf(0);               j = byte(buf,char_pos);               if j = a.space OR j = a.semicolon then i = 0;               write("50") = byte(buf,char_pos);               char_pos = char_pos + 1;     /* Forward in buffer        */            end;         end;      end;      else if ch = c.j                      /* '^J' - Next cmd in hist  */      or      ch = cur.down then do;        /* Down arrow too           */         up_down = up_down + 1;             /* Move down                */         if up_down > 25 then up_down = 0;         call blockmove(loc(addr(a_buf(0))) + BLNG*up_down,buf,BLNG);         call newline;                      /* Include where in history */         write("50") = a.a + up_down;         call pstr(') ');         call pstr(loc(loc.prmt));         call pstr(buf);                    /* Show existing command    */         char_pos = buf(0);                 /* Currently at end         */      end;      else if ch = c.k                      /* '^K' - Last cmd in hist  */      or      ch = cur.up then do;          /* Up arrow too             */         up_down = up_down - 1;             /* Move up                  */         if up_down < 0 then up_down = 25;         call blockmove(loc(addr(a_buf(0))) + BLNG*up_down,buf,BLNG);         call newline;                      /* Include where in history */         write("50") = a.a + up_down;         call pstr(') ');         call pstr(loc(loc.prmt));         call pstr(buf);                    /* Show existing command    */         char_pos = buf(0);                 /* Currently at end         */      end;      else if ch = c.l                      /* '^L' - forward one char  */      or      ch = cur.right then do;       /* '-->' too                */         if char_pos < buf(0) then do;            write("50") = byte(buf,char_pos); /* Echo char under cursor   */            char_pos = char_pos + 1;        /* Forward in buffer        */         end;         else do;                           /* Wrap around              */            do i=1 to char_pos;               write("50") = a.bs;          /* Move cursor back         */            end;            char_pos = 0;                   /* Reset to start of line   */         end;      end;      else if ch = c.p then do;             /* '^P' - fast cmd in line  */         ch = toupper(rchar);               /* Get input char (upcase)  */         if get_macro_cmd(ch,tbuf) <> 0 then do;            if char_pos <> 0            then call strncat(tbuf,';',0);  /* Put in ';' before cmd    */            call strncat(buf,tbuf,char_pos);            call pstr(tbuf);                /* Echo new characters      */            char_pos = char_pos + strlen(tbuf);            call strncpy(tbuf,buf,char_pos,strlen(buf));            call pstr(tbuf);                /* Echo rest of line        */            do i=1 to strlen(tbuf);               write("50") = a.bs;          /* Backup to char_pos       */            end;            if buf(0) > BCHARS then buf(0) = BCHARS;         end;      end;      else if ch = c.r                      /* '^R' - recall or start   */      or      ch = pf.1 then do;            /* PF1 too                  */         if buf(0) = 0 then do;             /* buf empty - recall last  */            dcl last_cmd   fixed;            last_cmd = oldest - 1;            if last_cmd < 0 then last_cmd = 25;            call blockmove(loc(addr(a_buf(0))) + BLNG*last_cmd,buf,BLNG);            call pstr(buf);                 /* Show existing command    */            char_pos = buf(0);              /* Currently at end         */         end;         else do;                           /* cmd there; to line start */            do i=1 to char_pos;               write("50") = a.bs;          /* Move cursor back         */            end;            char_pos = 0;                   /* Reset to start of line   */         end;      end;      else if ch = c.t then do;             /* '^T'  was toggle do echo */      end;      else if ch = c.w then do;             /* '^W' - recall in line    */         ch = rchar & "137";                /* Get input char (upcase)  */         if ch >= a.a AND ch <= a.z then do;            if char_pos <> 0            then call strcpy(tbuf,';');     /* Add in cmd after ';'     */            call strcat(tbuf,loc(addr(a_buf(0)))+BLNG*(ch-a.a));            call strncat(buf,tbuf,char_pos);            call pstr(tbuf);                /* Echo new characters      */            char_pos = char_pos + strlen(tbuf);            call strncpy(tbuf,buf,char_pos,strlen(buf));            call pstr(tbuf);                /* Echo rest of line        */            do i=1 to strlen(tbuf);               write("50") = a.bs;          /* Backup to char_pos       */            end;            if buf(0) > BCHARS then buf(0) = BCHARS;         end;      end;      else if ch = c.x then do;             /* '^X' - delete cmd line   */         buf(0) = 0;                        /* Get rid of current cmd   */         call pstringr('');         call prompt;         char_pos = 0;                      /* Currently at end         */      end;      else if ch = c.y then do;             /* '^Y' - single replace    */         call strcpy(tbuf,olds);            /* Save previous (if any)   */         call newline;         call pstr('1> Enter original string [');         call pstr(tbuf);         call pstr(']: ');         linput olds;         olds(0) = olds(0) - 1;             /* Remove <CR>              */         if strlen(olds) = 0 then call strcpy(olds,tbuf);         if strlen(olds) > 0 then do;       /* Must have something to find */            call strcpy(tbuf,news);         /* Save previous (if any)   */            call pstr('1> Enter replacement string [');            call pstr(tbuf);            call pstr(']: ');            linput news;            news(0) = news(0) - 1;            if strlen(news) = 0 then call strcpy(news,tbuf);            i = index(buf,olds,0);            if i <> -1 then do;               call strncpy(tbuf,buf,i+strlen(olds),strlen(buf));   /* Get part 2 */               buf(0) = i;                                     /* Part 1     */               call strcat(buf,news);                          /* Insert new */               call strcat(buf,tbuf);                          /* Part 2     */            end;         end;                /* of old string non zero */         if buf(0) > BCHARS then buf(0) = BCHARS;         call prompt;        /* Redraw command line    */         call pstr(buf);         char_pos = buf(0);  /* Currently at end       */      end;                   /* of control-y           */      else if ch = a.us then begin;         /* '^/' - search for cmd     */         dcl position fixed;         call strcpy(tbuf,sstr);            /* Save previous (if any)    */         call newline;         call pstr('Enter search string [');         call pstr(tbuf);         call pstr(']: ');         linput sstr;         sstr(0) = sstr(0) - 1;             /* Remove <CR>               */         if strlen(sstr) = 0 then call strcpy(sstr,tbuf);         if searching > 0                   /* Did '^/' twice in a row   */         then i = position;                 /* Continue where left off   */         else i = oldest - 1;               /* Else start with recent    */         if i<0 then i=25;         do while i <> oldest;            call blockmove(loc(addr(a_buf(0))) + BLNG*i,tbuf,BLNG);            i = i - 1;            if i<0 then i=25;            if index(tbuf,sstr,0) <> -1 then do;  /* Is found */               call strcpy(buf,tbuf);    /* Get it */               position = i;             /* Remember where we left off */               i = oldest;               /* Force end of search */            end;         end;         call prompt;              /* Redraw command line */         call pstr(buf);         char_pos = buf(0);        /* Currently at end */         searching = 2;            /* Decremented in large do while loop */      end;                /* of control-/           */      else if ch >= a.space                 /* Just insert character...*/      AND buf(0) < BCHARS then do;          /* ...if there's room      */         if mode = 0 then do;               /* Insert mode             */            tbuf(0) = 1;                    /* Make new char a string   */            tbuf(1) = ch;            call strncat(buf,tbuf,char_pos);/* Insert char in buffer    */            call strncpy(tbuf,buf,char_pos,strlen(buf));								do i = 0 to tbuf(0)-1;					write("50") = byte(tbuf, i);				end;				            do i=2 to strlen(tbuf);               write("50") = a.bs;          /* Backup to char_pos       */            end;         end;         else do;                           /* Overstrike mode          */            call pbyte(buf,char_pos,ch);    /* Overwrite current char   */            write("50") = ch;               /* Echo it                  */            if buf(0) = char_pos then do;   /* If at end of line        */               buf(0) = buf(0) + 1;         /* Then one longer          */            end;         end;         char_pos = char_pos + 1;           /* Ahead one in buffer      */      end;  /* of just insert character */   end;     /* of while 1 */end editcmd;/* MAIN ENTRY POINT:  Edit next command and save history */edit.line:proc public; dcl going fixed;     /* True while looping here */   call setup_history;   call read_history;   going = 1;   do while going <> 0;      call blockset(buf,BLNG,0);               /* Initialize cmd buffer */      call pcn;                                /* Print command number */      cnum = 0;                                /* Reset command number */      call prompt;                             /* Prompt for command   */      call editcmd;                            /* Get user command     */      call check_hist_recall;                  /* History recall?      */      if macro_cmd = 0 then do;                /* Send to MONITOR      */         going = 0;                            /* Break out of loop    */         call write_history;                   /* Remember all history */         call strcpy(loc(tyb.base),buf);       /* Send cmd to MONITOR  */         call pbyte(loc(tyb.base),core(tyb.base),a.cr);         core(tyb.base) = core(tyb.base) + 1;  /* Append <CR> to it    */      end;   end;                                        /* Of going <> 0        */end edit.line;end;                           /* Of BEGIN to limit scope to this file */