/* 01-DEFS  $TITLE  Global Variable Definitions *//* THE USER'S CURRENT FILE MAY BE STORED IN SEVERAL PLACES:        A)  IN MEMORY,  OR        B)  ON THE DISK (IN A FILE CALLED '.WORK').    IF THE FILE IS ON DISK,  IT MAY ACTUALLY BE IN UP TWO THREE PIECES:        FIRST  SECTION OF THE FILE ON DISK        MIDDLE SECTION OF THE FILE IN IN-CORE BUFFER        FINAL  SECTION OF THE FILE ON DISK    THE FOLLOWING VARIABLES PROCESS THE CURRENT FILE:  */DCL LINSZ        LIT '1024'; /* RESERVED FOR LINE */DCL ABUF(ABUFSZ) FIXED; /* ALTER FILE BUFFER */DCL BSTRT        FIXED; /* BUFFER START - FILE POS OF IN-CORE BUFFER */DCL BLEN         FIXED; /* NUMBER OF WORDS IN BUFFER        */DCL FSTRT        FIXED; /* FILE POS OF DATA THAT GOES AFTER */DCL BALT         FIXED; /* INDICATES ALTERED IN-CORE BUFFER */DCL PBUFSZ          LIT '256'; /* SIZE OF PERFORM BUFFER (HARDCODED AS 256 IN GET.LINE!) */DCL PBUFFER(PBUFSZ) FIXED; /* PERFORM FILE BUFFER *//* GENERAL VARIABLES: */DCL CBUF(C#DIR_MAX - 1) FIXED; /* CATALOG BUFFER */DCL CACHE.NUM   FIXED; /* NUMBER OF CACHED CATALOG BUFFER */DCL LINEC       FIXED; /* LINE COUNT FOR CRT */DCL TYB.BASE    FIXED; /* POINTER TO BASE OF CURRENT INPUT BUFFER */DCL STRING.MAX  LIT '50';DCL STR1(STRING.MAX / 2) FIXED; /* TEMPORARY STRINGS FOR TEXT LOCATE AND REPLACE */DCL STR2(STRING.MAX / 2) FIXED;DCL BREAK.RECEIVED FIXED;DCL NO_OVERLAY     FIXED; /* SET TO 1 IF WE CAN'T OVERLAY TO OTHER FILES */DCL RESUME_MULTI   BOOLEAN; /* TRUE IF WE'RE RESUMING A MULTICOMMAND LINE AFTER A DO *//* CURRENT FILE PROCESSING: */DCL ARG         FIXED; /* ARGUMENT VALUE SCANNED */DCL (ARGMSW,ARGLSW) FIXED; /* 32-BIT ARGUMENT SCANNED */DCL NPTR1       FIXED;DCL AFPTR       FIXED; /* POINTER USED FOR ALTER BUFFER */DCL AFLNG       FIXED; /* NUMBER OF WORDS IN ALTER FILE */DCL BPTR        FIXED; /* USED IN TEXREP */DCL (ARG1,ARG2) FIXED; /* USED IN CHANGE PROCESSING */DCL NEWLINLEN   FIXED; /* LENGTH OF NEW LINE */DCL (PTR,PTR1,PTR2,PTR3,PTR4,PTR5) FIXED; /* POINTERS FOR LINE NUMBER MERGE *//* DEVICES: */DCL TTY      LIT '"50"';DCL LNK      LIT '"40"';DCL PRI      LIT '"40"';/* EXTERNAL MEMORY CONFIGURATION: */DCL EMSIZE   LIT 'CORE(LOC.EMSIZE)';DCL EMAREA   LIT 'CORE(LOC.EMAREA)'; /* START OF STATE VARS IN EXTERNAL MEMORY *//* TERMINAL INPUT: */DCL TYB      LIT 'LOCATION(TYB.BASE)'; /* CURRENT INPUT BUFFER */DCL TYBP     LIT 'CORE(LOC.TYBP)';DCL TYBMAX   LIT '110'; /* MAX NUMBER OF CHARACTERS IN INPUT BUFFER (SEE SYSLITS) */DCL INCH     LIT 'CORE(LOC.INCH)';DCL CNUM     LIT 'CORE(LOC.CNUM)';DCL SCREEN   LIT 'CORE(LOC.SCREEN)';/* $PAGE *//* CURRENT FILE: */DCL CNAM(F#NAME_LEN) FIXED; /* CURRENT NAME */DCL FILTP    LIT 'CORE(LOC.FTYP)';DCL SAVED    LIT 'CORE(LOC.SVD)'; /* TRUE IF FILE IS SAVED  SOMEWHERE */DCL STORED   LIT 'CORE(LOC.STRD)'; /* TRUE IF FILE IS STORED SOMEWHERE */DCL FILMED   LIT 'CORE(LOC.CMED)';DCL FILDEV   LIT 'CORE(LOC.CSEC+1)';DCL FILSEC   LIT 'CORE(LOC.CSEC)';DCL FILNS    LIT 'CORE(LOC.CSLN)'; /* # OF SECTORS */DCL FILNG    LIT 'CORE(LOC.CLEN)'; /* FILE LENGTH MOD 64K */ /* CATALOGS: */DCL UDEV     LIT 'CORE(LOC.UCAT+1)';  /* USER CATALOG DEVICE */DCL UCAT     LIT 'CORE(LOC.UCAT)';    /* USER CATALOG SECTOR */DCL ULEN     LIT 'CORE(LOC.UCTL)';    /* USER CATALOG LENGTH */DCL UMAX     LIT 'CORE(LOC.UMAX)';    /* USER CATALOG SIZE (LS) */DCL UMAXMS   LIT 'CORE(LOC.UMAX+1)';  /* USER CATALOG SIZE (MS) */DCL SDEV     LIT 'CORE(LOC.SCAT+1)';  /* SYSTEM CATALOG DEVICE */DCL SCAT     LIT 'CORE(LOC.SCAT)';    /* SYSTEM CATALOG SECTOR */DCL SLEN     LIT 'CORE(LOC.SCTL)';    /* SYSTEM CATALOG LENGTH */DCL SMAX     LIT 'CORE(LOC.SMAX)';    /* SYSTEM CATALOG SIZE (LS) */DCL SMAXMS   LIT 'CORE(LOC.SMAX+1)';  /* SYSTEM CATALOG SIZE (MS) */DCL PDEV     LIT 'CORE(LOC.PCAT+1)';  /* PATH CATALOG DEVICE */DCL PCAT     LIT 'CORE(LOC.PCAT)';    /* PATH CATALOG SECTOR */DCL PLEN     LIT 'CORE(LOC.PCTL)';    /* PATH CATALOG LENGTH */DCL PMAX     LIT 'CORE(LOC.PMAX)';    /* PATH CATALOG SIZE (LS) */DCL PMAXMS   LIT 'CORE(LOC.PMAX+1)';  /* PATH CATALOG SIZE (MS) *//* WORK FILE: */DCL WORKMED  LIT 'CORE(LOC.WMED)';DCL WORKDEV  LIT 'CORE(LOC.WSEC+1)';DCL WORKSEC  LIT 'CORE(LOC.WSEC)';DCL WORKNS   LIT 'CORE(LOC.WSLN)';DCL WORKLEN  LIT 'CORE(LOC.WLEN)';/* COMMAND FILE: */DCL PERFORMING  LIT 'CORE(LOC.PERFORM)';DCL PERPTR      LIT 'CORE(LOC.PERPTR)';DCL PERFDEV     LIT 'CORE(LOC.PERFSEC+1)';DCL PERFSEC     LIT 'CORE(LOC.PERFSEC)';DCL PERFLEN     LIT 'CORE(LOC.PERFLEN)';/* BITS IN PERFORMING */DCL PERF_LEVEL   LIT '"377"'; /* PERFORM LEVEL MASK (MUST BE IN LS OF PERFORMING) */DCL PERF_ECHO    LIT '"400"'; /* ECHO DO FILE BIT *//* NESTED COMMAND FILE STRUCTURE (STARTING AT EM.PERFORMING) */DCL DO_SEC      LIT '0'; /* LS SECTOR OFFSET */DCL DO_DEV      LIT '1'; /* MS SECTOR OFFSET */DCL DO_LEN      LIT '2'; /* LENGTH OFFSET */DCL DO_PTR      LIT '3'; /* BYTE POINTER OFFSET */DCL DO_CNUM     LIT '4'; /* COMMAND NUMBER OFFSET */DCL DO_SIZE     LIT '5'; /* LENGTH OF RECORD */DCL DO_LEVELS   LIT '10'; /* NUMBER OF LEVELS ALLOWED (CANNOT BE LARGER THAN 10) */DCL DO_CLINE    LIT '(DO_SIZE*DO_LEVELS)'; /* STARTING LOCATION OF INITIAL COMMAND LINE *//* SYSTEM FILE NAMES: */DCL MONNM       DATA ('MONITOR');DCL SYS_DUMMY   DATA (':USER:.CURRENT');DCL DO_FILE     DATA (':USER:.DO0');DCL SQDT        DATA ('.SQ0DATA');/* ERROR MESSAGES: */DCL PTLMS        DATA ('Program is too large to process');DCL FORMS        DATA ('Format error in command');DCL EMPMS        DATA ('Your current file is empty');DCL BIGMS        DATA ('File is too big to list, run, or edit');DCL NTXTMS       DATA ('Current file is not a text file');DCL ICFMS        DATA ('Invalid character in filename');DCL FNMMS        DATA ('Filename must be specified after ');DCL NDSMS        DATA ('No disk space available to hold ');DCL CONF_ERR     DATA ('You do not have the correct configuration for ');DCL SNFMS        DATA ('Sequence not available on this disk');DCL PARTIAL_EDIT DATA ('Partial edit made - please LIST file to check');/* The overlay procedures MUST be early in the object code to ensure that   they don't overwrite themselves when they write the memory size into   every 1K block of memory. */OVERLAY:  PROC(DEVICE,SEC,LEN); /* PERFORM OVERLAY OF DISK OBJECT */   DCL (DEVICE,SEC,LEN) FIXED;   DCL I FIXED;   I = (16*1024) - MEM.OFFS; /* STORE MEMORY SIZE POINTERS HERE */   DO WHILE I ILT LOC.LOAD; /* STORE POINTER EVERY 1K */      CORE(I) = MEM.SIZ; I = I + 1024;   END;   CORE(LOC.PSYS) = SYSTYP; /* SET PREVIOUS SYSTEM TYPE */   I = LOC.LOAD + 1; /* ENTER WORD 1 OF LOADER MEMORY (LOOK UP ADDRESS BEFORE SETTING ACCUMULATORS) */   WRITE("300") = DEVICE; /* R0/R1 FORM WORD PAIR TO SOURCE */   WRITE("301") = SEC;   WRITE("302") = 0;     /* R1 POINTS TO DESTINATION     */   WRITE("303") = LEN;   /* NUMBER OF WORDS TO COPY OVER */   WRITE("320") = I;     /* ENTER UPPER MEMORY           */END OVERLAY;OBJOVERLAY:  PROC(FBUF,FBUFSZ); /* CALLED TO OVERLAY THE 'WORK' FILE */   DCL FBUF   FIXED ARRAY; /* MEMORY BUFFER */   DCL FBUFSZ FIXED; /* SIZE OF MEMORY BUFFER */   DCL (I,J)  FIXED;   IF (WORKMED = 1) OR ((FILNS ILT 256) AND (FILNG ILE FBUFSZ)) THEN DO; /* FILE IS IN MEMORY */      IF FILNG ILE FBUFSZ   /* IF FITS IN CURRENT FILE BUFFER */      THEN J = ADDR(FBUF(0)); /* THEN POINT TO CURRENT FILE BUF */      ELSE J = WORKSEC;       /* ELSE POINT TO .WORK IN MEMORY */      /* THIS CODE APPROXIMATES THE WRITING OF THE MEMORY SIZE AT EVERY 1K         BY STORING IT EVERYWHERE BUT WHERE THE CURRENT FILE IS */      I = (16*1024) - MEM.OFFS; /* STORE MEMORY SIZE POINTERS HERE */      DO WHILE (I ILT J); /* STORE POINTER EVERY 1K UP TO OBJECT CODE */         CORE(I) = MEM.SIZ; I = I + 1024;      END;      I = I + ((FILNG + 1023) AND (NOT 1023)); /* CONTINUE AT NEXT SECTOR BDY ABOVE FILE */      DO WHILE (I ILT LOC.LOAD); /* STORE POINTER EVERY 1K UP TO LOADER */         CORE(I) = MEM.SIZ; I = I + 1024;      END;      CORE(LOC.PSYS) = SYSTYP; /* SET PREVIOUS SYSTEM TYPE */      I = LOC.LOAD + 3; /* ENTER ROM LOCATION 3 FOR CORE TO CORE COPY */      WRITE("300") = J; /* POINT TO START OF FILE */      WRITE("301") = 0; /* CORE LOCATION */      WRITE("302") = FILNG; /* LENGTH OF FILE */      WRITE("320") = I; /* ENTER CORE TO CORE COPY ROM */   END; /* OF WORKFILE IN MEMORY */   ELSE CALL OVERLAY(WORKDEV, WORKSEC, FILNG); /* OVERLAY THE WORK FILE ON DISK */END OBJOVERLAY;