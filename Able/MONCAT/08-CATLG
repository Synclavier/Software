/* 08-CATLG  $TITLE  Module to Print Catalog Contents *//* PRINTS A LISTING OF THE CURRENT USER CATALOG ON TERMINAL.  SEVERAL   OPTIONS ARE AVAILABLE, WHICH DEFAULT AS FOLLOWS:      DIRECTORY FLAGS         'CAT' DEFAULT       'DIR' DEFAULT        ALL FILES               0                   1        LENGTH                  0                   1        FILE                    0                   0        SORT                    0                   NAME        XTENDED INFO            0                   0*/                      Print_Type:  proc(Type); /* print the name of the given file type */   dcl Type fixed;   if Type <= T#Max then do case Type; /* valid types */      call pstr('Text '); /* 0 */      call pstr('Exec '); /* 1 */      call pstr('Reloc'); /* 2 */      call pstr('Data '); /* 3 */      call pstr('Sync '); /* 4 */      call pstr('Sound'); /* 5 */      call pstr('Subc '); /* 6 */      call pstr('LSubc'); /* 7 */      call pstr('Dump '); /* 8 */      call pstr('Spect'); /* 9 */      call pstr('Index'); /* 10 */      call pstr('Timb '); /* 11 */   end;   else do; /* unknown types */      call pstr('Typ');      call pdec(0,Type,2);   end;end Print_Type;Cat:  proc(Default,TreeName) returns (boolean); /* print out catalog */   dcl Default   fixed; /* Default flags */   dcl TreeName  fixed array; /* Array for treename */   dcl Last_FCB  fixed; /* index of last FCB in catalog */   dcl FCB_Index(C#Dir_Max/C#Len - 1)  fixed; /* FCB index numbers */   dcl (Xflag,Aflag,Lflag,Oflag,Fflag,Stype,Ltype) fixed; /* sort flags */   dcl (fcb1,fcb2)(F#Len - 1) fixed; /* temporary FCB's */   Get_Options:  proc returns (boolean); /* get arguments to CAT command and set flags */      dcl NeedName boolean; /* TRUE when name needed for a command */      dcl i        fixed;      NeedName = FALSE;      do while (not.end()); /* process catalog arguments */         inch = upcase(inch); /* uppercase inch */         /* check for keywords */         		 if      (inch = a.A)	{Aflag = TRUE; Lflag = TRUE;}	/* cat ALL					*/         else if (inch = a.L)   {Lflag = TRUE; 				}	/* LEN */         else if (inch = a.F)   {Fflag = TRUE; 				}	/* FILE */         else if (inch = a.X)   {Xflag = TRUE; Lflag = TRUE; Aflag = TRUE; end; /* EXTENDED */         else if (inch = a.S) then do; /* SORT */            call get.char.upcase; /* get next character */            if      inch = a.O then Stype = 2; /* sort by origin */            else if inch = a.L then Stype = 3; /* sort by length */            else if inch = a.T then Stype = 4; /* sort by type   */			else if inch = a.E then do; Ltype = 1; Lflag = TRUE; end; /* length sectors */            else Stype = 1; /* otherwise sort by name */         end;         else if ((inch = a.O) or (inch = a.slash)) then do; /* other device/catalog - need name */            Oflag = TRUE; NeedName = TRUE;         end;         do while (not.end()) and (inch <> a.slash) and (inch <> a.SP); /* skip over rest of keyword */            call get.char.upcase;         end;         call skipspa; /* skip to next field */         if NeedName then do; /* get subcatalog name */            if not get.treename(TreeName,'CAT OF',FALSE,FALSE) then return (FALSE); /* bad name */            if not read_catalog(TreeName,1) then do; /* could not read catalog */               call cat.error;               return (FALSE);            end;            NeedName = FALSE; /* have name now */         end;      end; /* of processing catalog arguments */      if not Oflag then do; /* not "cat of", so read current catalog */         if not read_catalog('',1) then do; /* could not read catalog */            call cat.error;            return (FALSE);         end;      end;      return (TRUE); /* success */   end Get_Options;   Sort_Cat: proc(FCB_Index,Sort_Type,Sort_Null) returns (fixed); /* sort catalog buffer, return index of last entry */      dcl FCB_Index  fixed array; /* array of FCB indexes */      dcl Sort_Type  fixed; /* determines how comparisons are made */      dcl Sort_Null  boolean; /* TRUE to sort FCB entries with a sector length but no name */      dcl Last_FCB   fixed; /* index of last FCB in catalog */      dcl Less       boolean; /* TRUE if fcb2 < fcb1 */      dcl Small      fixed; /* smallest index found so far */      dcl (i,j,k)    fixed;                        /* scan catalog backwards from end until a non-zero name is found */      Less = TRUE; /* entry not found yet */      Last_FCB = C#Dir_Size / C#Len; /* start at last entry in catalog */      do while (Last_FCB > 0) and (Less); /* search for non-zero name or non-null entry */         Last_FCB = Last_FCB - 1; /* next FCB */         call Get_FCB (Last_FCB, fcb1); /* Get this FCB */         Less = (fcb1(F#NM) = 0); /* TRUE when file name is null */         if (Less) and (Sort_Null) /* Null file name and sorting null file lengths */         then Less = ((fcb1(F#ML) = 0) and (fcb1(F#LL) = 0)); /* TRUE when file length is null */      end;      if Less then Last_FCB = -1; /* all entries in catalog are null, so set flag */      do i = 0 to Last_FCB; /* prime FCB index table */         FCB_Index(i) = i;      end;      if Sort_Type <> 0 then do; /* sort if needed */         /* Selection Sort by FCB index pointers */         do i = 0 to Last_FCB; /* sort all known FCB's in catalog */            Small = i; /* assume FCB at index I is the smallest */            call Get_FCB(FCB_Index(Small),fcb1); /* get this FCB */            do j = i + 1 to Last_FCB; /* check the rest of the FCB's */               call Get_FCB(FCB_Index(j),fcb2); /* get FCB at index J */               do case Sort_Type; /* make different comparisons depending on flag */                  ;   /* 0 = no sort */                  do; /* 1 = sort by file name */                     /* if fcb1(F#NM) = 0   is first name blank? */                     /* then Less = false;  yes, so fcb1 > fcb2 */                     /* else if fcb2(F#NM) = 0 is second name blank? */                     /* then Less = true;   yes, so fcb1 < fcb2 */                     k = f#nm; /* start at first word in name */                     do while (k < f#nm + f#name_len - 1) and (fcb1(k) = fcb2(k)); k = k + 1; end; /* advance until inequality found */                     Less = (rot(fcb2(k), 8) ilt rot(fcb1(k), 8)); /* TRUE if fcb1 < fcb2 */                  end; /* of sort by name */                  do; /* 2 = sort by origin */                     Less = ( ( fcb2(F#MS) ilt fcb1(F#MS) ) or                              ((fcb2(F#MS)  =  fcb1(F#MS)) and (fcb2(F#LS) ilt fcb1(F#LS))) ); /* compare by sector origin */                  end; /* of sort by file origin */                  do; /* 3 = sort by file length */                     if (fcb1(F#ML) = fcb2(F#ML)) and (fcb1(F#LL) = fcb2(F#LL)) /* sector lengths equal */                     then Less = ( fcb2(F#WD) ilt fcb1(F#WD) ); /* compare by word length */                     else Less = ( ( fcb2(F#ML) ilt fcb1(F#ML) ) or                                   ((fcb2(F#ML)  =  fcb1(F#ML)) and (fcb2(F#LL) ilt fcb1(F#LL))) ); /* compare by sector length */                  end; /* of sort by file length */                  do; /* 4 = sort by file type */                     Less = ( fcb2(F#TY) ilt fcb1(F#TY) ); /* compare file types */                  end; /* of sort by file type */               end; /* of comparison do case */               if Less then do; /* new FCB is smaller than smallest FCB */                  Small = j; /* save new smallest entry */                  call BlockMove(fcb2,fcb1,F#Len); /* save smallest FCB */               end;            end; /* of inner sort for-loop */            j = FCB_Index(Small); /* swap fcb indexes */            FCB_Index(Small) = FCB_Index(i);            FCB_Index(i) = j;         end; /* of outer sort for-loop */      end; /* of sorting needed */      return (Last_FCB); /* return index of last non-null FCB */   end Sort_Cat;   Print_Cat:  proc(use_sectors) returns (boolean); /* print catalog */   	  dcl (use_sectors)     fixed;      dcl (MS_Secs,LS_Secs) fixed; /* no. sectors used up by files */      dcl (MS_Acct,LS_Acct) fixed; /* no. sectors accounted for in catalog */      dcl Total_Entries     fixed; /* no. files in catalog */      dcl Printed_Entries   fixed; /* no. entries printed */      dcl Columns           fixed; /* no. columns of information to display */      dcl Print_Name        boolean; /* TRUE if a name should be printed */      dcl (i,j)             fixed;      dcl use_megs          fixed;      call newline;      call pstr('Catalog of ');      if ((C#MS_Sector and "HFF") = 0) and (C#LS_Sector = 0) then do; /* cat of a device */         call print.device(C#MS_Sector); call pchar(a.colon); /* print device name */      end;      else do; /* cat of a subcatalog */         if Oflag then call pstr(F#Name); /* show catalog name entered */         else call pstr(location(LOC.CCNM)); /* show current catalog name */      end;      call pstr(', size ');      if (((C#MS_Length !=     0)      or   (C#LS_Length IGT 3000))	  &&  (!use_sectors))      then do;          call pmeg(C#MS_Length,C#LS_Length,0);          call pstr(' megabytes');          use_megs = 1;      end;      else do;          call pdec(C#MS_Length,C#LS_Length,0);          call pstr(' sectors');          use_megs = 0;      end;      call newline; call newline;      if (Fflag) or (Xflag) then Columns = 1; /* determine the number of columns to display */      else if (Lflag) then Columns = 2;      else Columns = 4;      do i = 1 to Columns; /* print header */         if (Xflag) then call pstr('Addr  ');         call pstr('--Name--  Type ');         if (Lflag) then do;            if (use_megs) then call pstr(' Words Megabytes Origin'); /* add length info */            else               call pstr(' Words Sectors   Origin'); /* add length info */         end;         if (Xflag) then call pstr('  Secs(8)   Orig(8)'); /* add octal info */         if i <> Columns then call pstr('  ');      end;      call newline;      MS_Secs = 0; LS_Secs = shr(C#Dir_Size,8); /* initialize sector count to size of catalog */      MS_Acct = 0; LS_Acct = LS_Secs; /* initialize sectors accounted for to zero */      Total_Entries = 0; /* no total entries yet */      Printed_Entries = 0; /* no printed entries yet */      do i = 0 to Last_FCB; /* loop over entries */         call Get_FCB(FCB_Index(i),fcb1); /* get FCB */         if ( fcb1(F#NM) <> 0 ) /* non-zero name */         or ( (Xflag) and ((fcb1(F#ML) <> 0) or (fcb1(F#LL) <> 0)) ) then do; /* CAT X option and non-zero sector length */            call Clean_FCBname(fcb1,TreeName); /* get file name */            if Aflag then Print_Name = TRUE; /* always print names if Aflag is set */            else if byte(TreeName,0) = a.period then Print_Name = FALSE; /* don't print name if it begins with a period */            else if TreeName(0) = MonNm(0) then do; /* see if this file has the same name as the monitor */               j = 0;               do while (j < TreeName(0) - 1) and (byte(TreeName,j) = byte(MonNm,j));                  j = j + 1;               end;               Print_Name = (byte(TreeName,j) <> byte(MonNm,j)); /* TRUE if this name is not equal to the monitor name */            end;            else Print_Name = TRUE; /* OK to print this name */            if Print_Name then do; /* this name OK to print */               if Xflag then do; /* print address */                  j = FCB_Index(i) * C#Len; /* calculate sector address */                  call poct(0,shr(j,8),1); call pchar(a.SP); /* print sector */                  call poct(0,j and "HFF",3); call pchar(a.SP); /* print word in that sector */               end;               TreeName(0) = shl(F#Name_Len,1); /* print file name */               call pstr(TreeName);               call pstr('  ');               call Print_Type(fcb1(F#TY)); /* print file type */               if Lflag then do; /* print length and starting sector */                  if (fcb1(F#ML) = 0) and (fcb1(F#LL) ilt 256) /* print length in words, if possible */                  then call pdec(0,fcb1(F#WD),6);                  else call pstr('      ');                  if (use_megs) then call pmeg(fcb1(F#ML),fcb1(F#LL),8); /* print length in megabytes */                  else               call pdec(fcb1(F#ML),fcb1(F#LL),8); /* print length in sectors */                  call pdec(fcb1(F#MS),fcb1(F#LS),9); /* print starting sector */                  if Xflag then do; /* print in octal */                     call pstr('  '); call poct(fcb1(F#ML),fcb1(F#LL),7); /* print length in sectors */                     call pstr('  '); call poct(fcb1(F#MS),fcb1(F#LS),8); /* print starting sector */                  end;               end;               Printed_Entries = Printed_Entries + 1; /* another entry printed */               if (Printed_Entries mod Columns) = 0 then call newline; /* start new line if needed */               else call pstr('  '); /* space to next column */            end; /* of printing a name */            if fcb1(F#NM) <> 0 then do; /* file has a name */               MS_Secs = MS_Secs + fcb1(F#ML); /* add to number of sectors used */               LS_Secs = LS_Secs + fcb1(F#LL);               if LS_Secs ilt fcb1(F#LL) then MS_Secs = MS_Secs + 1;               Total_Entries = Total_Entries + 1; /* another entry found */            end;         end; /* of non-null entry */         MS_Acct = MS_Acct + fcb1(F#ML); /* add to number of sectors accounted for */         LS_Acct = LS_Acct + fcb1(F#LL);         if LS_Acct ilt fcb1(F#LL) then MS_Acct = MS_Acct + 1;         if BRKC then return (FALSE); /* check for break after every entry */      end; /* of looping over entries */      if (Printed_Entries mod Columns) <> 0 then call newline; /* end last line */      call newline;      if Total_Entries > 0 then do; /* if real entries exist */        call pstr('Catalog contains ');        call pdec(0,Total_Entries,0); call pstr(' entries, ');        if (use_megs) then do; call pmeg(MS_Secs,LS_Secs,0); call pstr(' megabytes used, '); end;        else               do; call pdec(MS_Secs,LS_Secs,0); call pstr(' sectors used, '); end;        j = C#MS_Length - MS_Secs; /* subtract sectors used from total sectors */        if C#LS_Length ilt LS_Secs then j = j - 1;        i = C#LS_Length - LS_Secs;        if (use_megs) then do; call pmeg(j,i,0); call pstr(' megabytes remaining'); end;        else               do; call pdec(j,i,0); call pstr(' sectors remaining'); end;      end;      else call pstr('No entries in catalog');      call newline;      if Xflag then do; /* print extended information */         call pstr('   '); call pdec(MS_Acct,LS_Acct,0); call pstr(' sectors accounted for, ');         call pdec(0,Printed_Entries - Total_Entries,0); call pstr(' free space markers');         call newline;      end;      return (TRUE); /* catalog printed successfully */   end Print_Cat;   /*** Main Code ***/   Aflag = Default;    Fflag = FALSE; /* set flags for startup */   Lflag = Default;    Oflag = FALSE;   Stype = Default;    Xflag = FALSE;   Ltype = 0;   if Get_Options then do; /* catalog arguments received correctly */      Last_FCB = Sort_Cat(FCB_Index,Stype,XFlag); /* sort catalog */      if Fflag then do; /* file output */         filng = 0; filns = 0; bstrt = 0; blen = 0; filtp = 0; fstrt = 0; /* set up current file variables */         stored = 0; saved = 0; aflng = 0;         call move.name('-CAT',CNAM); /* make this the current name */         call store.name(CNAM); /* store in upper memory */         bytep = 0;         outdev = 2; /* select file output */         call pchar(0); call pchar(0); /* create first line */      end;      if Print_Cat(Ltype) then do; /* catalog printed successfully */         if outdev = 0  /* output to terminal */         then call newline; /* output a blank line */         else do; /* output to file */           call pchar(0); call pchar(0); /* terminate line */           print 'Current File is now called ',string(CNAM);         end;         outdev = 0; /* restore normal output */         return (TRUE); /* catalog printed successfully */      end; /* of printing catalog */      else outdev = 0; /* restore normal output */   end; /* of options OK */   return (FALSE); /* something went wrong */end Cat;