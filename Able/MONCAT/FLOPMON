/* $title Floppy-Based Monitor *//* This MONITOR only exists to set up highcore and overlay to the  file called .MONITOR [usually the Synclavier (r) RTP].  By:  Karim J. Chichakly on 28 June 1985 from 0-MONITR  Modification history:    24 Oct 86:  Updated to -7 catalog structure [KJC]    15 Jan 88:  Updated for M64K memory board [KJO]*/CONFIGURATION MODELB,SMINI,NOMULDIV,MEMORY 60*1024;DCL ABUFSZ LIT '0';  /* ALTERS BUFFER SIZE (FOR 01-DEFS) */DCL EMRSVD LIT '32'; /* NUMBER OF SECTORS RESERVED TO MONITOR */INSERT ':-XPL:LITERALS'; /* LITERALS */INSERT ':-XPL:ASCIILIT'; /* ASCII LITERALS */INSERT ':-XPL:SCSILITS'; /* SCSI LITERALS */INSERT ':-XPL:CATRTNS';  /* CATALOG ROUTINES */INSERT ':-XPL:DEVUTIL';  /* DEVICE UTILITIES */INSERT '01-DEFS';        /* GLOBAL VARIABLES */INSERT '03-DISK';        /* DISK SUBROUTINES */CHECK.MEM.SIZ: PROC; /* MAKE SURE HARDWARE IS AVAILABLE FOR CONFIGURED MEMORY SIZE */   IF MEM.SIZ IGE (63*1024) THEN DO; /* CONFIGURED FOR 63K */      IF (READ("51") AND "100000") <> 0 THEN DO; /* THERE ARE EXTENDED BITS */         IF  ((READ("57") AND "4") <> 0) /* M64K BOARD IN SYSTEM */         AND ((READ("57") AND "2") <> 0) /* D40Q BOARD IN SYSTEM */         THEN RETURN; /* HARDWARE IS AVAILABLE FOR 63K */      END;      MEM.SIZ = (60*1024); /* LIMIT MEMORY SIZE TO 60 K */      MEMORY_SECTORS = SHR(MEM.SIZ,8); /* SIZE IN SECTORS */   END;END CHECK.MEM.SIZ;POLL:  PROC RETURNS (FIXED); /* DETERMINE THE AMOUNT OF M128K MEMORY AVAILABLE */   DCL AMOUNT FIXED;   IF (READ("51") and "1000") = 0 THEN RETURN (0); /* NO D60'S AT ALL */   WRITE("60") = 1; /* SELECT PAGE 1 */   IF READ("60") <> 1 THEN RETURN (0); /* FIRST BOARD NOT PRESENT */   WRITE("62") = 0; /* SELECT HALF */   IF READ("62") <> 0 THEN RETURN (0); /* FIRST HALF IS NOT STUFFED */   AMOUNT = 256; /* FIRST HALF IS PRESENT */   DO WHILE (AMOUNT <> 0); /* can have 65536 sectors */   print 'polling ',amount;      WRITE("60") = AMOUNT; /* SELECT MEMORY PAGE */      IF READ("60") <> AMOUNT THEN DO; WRITE("60") = 0; RETURN (AMOUNT); END;      WRITE("62") = 0; /* STORE A ZERO THERE */      IF READ("62") <> 0 THEN DO; WRITE("60") = 0; RETURN (AMOUNT); END;      AMOUNT = AMOUNT + 256; /* ADVANCE TO NEXT HALF A CARD */   END;   WRITE("60") = 0; /* RESET D60 REGISTER TO VALID ADDR */   RETURN (-1); /* FULL 32 MBYTES */END POLL;OPENFILE:  PROC(NAM,LOC,ERR); /* OPEN A SYSTEM FILE (IF ERR DIFFERENT FROM MONITOR) */   DCL NAM   FIXED ARRAY; /* NAME OF FILE TO OPEN */   DCL LOC   FIXED; /* CORE LOCATION TO STORE INFORMATION IF FILE IS FOUND */   DCL ERR   BOOLEAN; /* TRUE TO PRINT AN ERROR MESSAGE WHEN FILE NOT FOUND */   DCL FOUND BOOLEAN; /* TRUE IF A FILE IS FOUND */   DCL I     FIXED;   FOUND = FALSE; I = 0; /* START SEARCH ON PATH CATALOG */   DO WHILE (I < 3) AND (NOT FOUND); /* SEARCH CATALOGS UNTIL FILE IS FOUND */      DO CASE I;         FOUND = LOCATE(NAM,-2); /* SEARCH PATH CATALOG */         FOUND = LOCATE(NAM,0);  /* SEARCH SYSTEM CATALOG */         FOUND = LOCATE(NAM,1); /* SEARCH USER CATALOG */      END;      I = I + 1;   END;   IF FOUND THEN DO; /* FILE FOUND, SO STORE INFORMATION */      CORE(LOC + 1) = F#MS_SECTOR;      CORE(LOC    ) = F#LS_SECTOR;      CORE(LOC - 1) = F#WORDS;   END;   ELSE DO; /* FILE NOT FOUND */      CORE(LOC + 1) = 0; /* SET STARTING SECTOR TO ZERO */      CORE(LOC    ) = 0;      CORE(LOC - 1) = 0; /* SET LENGTH TO ZERO */      IF ERR THEN DO; /* IF WE SHOULD PRINT AN ERROR MESSAGE */         PRINT; PRINT 'System Error:  ', STRING(NAM), ' file missing.'; STOP;      END;   END;END OPENFILE;Set_Win_Size: proc(dev); /* set size of specified winchester(s) in config tabbble */   dcl dev         fixed; /* device to confirm */   dcl ptr         fixed; /* pointer into configuration table for this device */   dcl win_type    fixed; /* device type found */   dcl zero_config boolean; /* TRUE to zero out remaining drives */   dcl (totsecMSW,totsecLSW) fixed; /* total sectors on this device */   dcl (msw,lsw)   fixed;   dcl done        boolean;   dcl i           fixed;   ptr = find_device(dev); /* get device */   if ptr = 0 then return; /* not configured */   win_type = core(ptr + s#devtyp); /* get winchester type */   if (shr(win_type,8) and "17") <> 1 then return; /* only set configuratin for SCSI drives */   win_type = win_type and "377"; /* ignore winchester drive type */   zero_config = false; /* allow configuration to be set */   totsecMSW = 0; totsecLSW = 0; /* no sectors allocated yet */   do while (core(ptr + s#devtyp) and "377") = win_type; /* loop until device type changes (not W0 or W1 anymore) */      if (shr(core(ptr + s#devtyp),8) and "17") <> 1 then do; /* not a SCSI drive */         return; /* die */      end;      i = Find_Win_Size(core(ptr + s#devadr),ptr); /* get capacity information */	  need major work here & Find_Win_Size status if code is ever used again	        if i <> S$Good /* error occurred */      then zero_config = true; /* zero-out the size field on all remaining drives */      if zero_config then do; /* zero out the size field for this drive */         core(ptr + s#seccyl) = 0;         core(ptr + s#totcyl) = 0;      end;      else do; /* truncate the size field, if need be */         done = false; /* not done yet */         do while not done; /* make sure this drive will not cause device to exceed 2^24 sectors */            write("5") = core(ptr + s#totcyl); /* calculate the number of sectors on this drive: */            write("6") = core(ptr + s#seccyl); /* sectors = cylinders * sectors/cylinder */            msw = read("4"); /* store this sector total */            lsw = read("5");            msw = totsecMSW + msw; /* add the new sectors to the current sector total for this device */            lsw = totsecLSW + lsw;            if lsw ilt totsecLSW then msw = msw + 1;            /* if new sector total is greater than 2^23, this drive must be truncated */            if (msw igt "H80") or ( (msw = "H80") and (lsw igt 0) ) then do;               msw = "H80" - totsecMSW; /* calculate sectors allowed on this drive: */               if 0 ilt totsecLSW then msw = msw - 1; /* sectors allowed = 2^23 - sectors used */               lsw = 0 - totsecLSW;               write("5") = lsw; /* new sector total for this drive */               write("4") = msw;               write("7") = core(ptr + s#seccyl); /* divide by sectors/cylinder */               core(ptr + s#totcyl) = read("5"); /* store the new number of cylinders */               done = false; /* must do it again */               zero_config = true; /* zero-out the size on the rest of the drives */            end;            else done = true; /* no problem */         end; /* while */         totsecMSW = msw; /* store the new sector total on this device */         totsecLSW = lsw;      end;      ptr = ptr + s#blklen; /* next configuration entry */   end; /* looping over drives */end Set_Win_Size;DCL TIMBRE LIT '40'; /* STORE .NEWDATA AT THIS SECTOR OF EXTERNAL MEMORY */DCL EXTBUF (3) FIXED; /* EXTREAD PARAMETER BUFFER */DCL I          FIXED;CALL CHECK.MEM.SIZ; /* MAKE SURE CONFIGURED MEMORY SIZE IS VALID */CALL SET_CATBUF (ADDR(CBUF (0)), 0);  /* SET THE CATALOG BUFFER */DO I = -256 TO -1; CORE(MEM.SIZ + I) = 0; END; /* ZERO OUT UPPER MEMORY TO INITIALIZE */CORE(C#CONTAB + C#CURTRK) = LOC.HEADPOS; /* SET LOWCORE HEAD POSITION POINTER TO POINT TO HIGHCORE */CALL RESTORE.HEAD (SHL(2, 8));  CALL RESTORE.HEAD (SHL(3, 8)); /* RESTORE F0 & F1 */CORE(LOC.MAGIC) = 12345; /* SET MAGIC NUMBER */CALL READ_CATALOG ('', 2); /* READ IN SYSTEM CATALOG F0 */SDEV = C#MS_SECTOR; SCAT = C#LS_SECTOR; SLEN = C#DIR_SIZE; /* SET UP SYSTEM CATALOG */SMAXMS = C#MS_LENGTH; SMAX = C#LS_LENGTH;UDEV = C#MS_SECTOR; UCAT = C#LS_SECTOR; ULEN = C#DIR_SIZE; /* USER CATALOG IS SAME AS SYSTEM */UMAXMS = C#MS_LENGTH; UMAX = C#LS_LENGTH;PDEV = C#MS_SECTOR; PCAT = C#LS_SECTOR; PLEN = C#DIR_SIZE; /* PATH DEFAULT IS SYSTEM DEVICE */PMAXMS = C#MS_LENGTH; PMAX = C#LS_LENGTH;CALL SET_CURDEV(SHR(UDEV,8)); /* SET UP USER CURRENT DEVICE IN LOW CORE */DO I = C#OFFSET TO C#CONLEN - 1; CORE(LOC.CTAB + I - C#OFFSET) = CORE(C#CONTAB + I); END; /* COPY CONFIG INFO INTO HIGH-CORE (DO IT NOW TO CATCH CURDEV) */EMSIZE = POLL; /* DETERMINE EXTERNAL MEM SIZE AVAIL IN SECTORS */IF EMSIZE <> 0 THEN DO; /* IF WE HAVE EXTERNAL MEMORY */   IF EMSIZE = -1 /* IF ALL OF MEMORY */   THEN EMSIZE = -EMRSVD; /* SUBTRACT FROM 0 */   ELSE EMSIZE = EMSIZE - EMRSVD; /* SUBTRACT OFF RESERVED SECTORS */   CALL EXTSET(CORE(LOC.EMAREA),0,SHL(EMRSVD,8),0); /* ZERO OUT RESERVED AREA */END; /* OF WE HAVE EXTERNAL MEMORY */IF TERMINAL.TYPE > T#HARDCOPY THEN SCREEN = 24; /* SET UP TERM DEFAULT AS 24 LINES */CALL SET_WIN_SIZE(6); /* SET SIZE OF SCSI DRIVES ON W0: */CALL SET_WIN_SIZE(7); /* SET SIZE OF SCSI DRIVES ON W1: */CALL OPENFILE ('.LD-7', LOC.MON, 1); /* TRY TO OPEN LOADER */CALL READDATA(CORE(LOC.MON + 1), CORE(LOC.MON), LOCATION(LOC.LOAD), 768); /* READ IN FLOPPy LOADER */CALL OPENFILE ('.MONITOR', LOC.P2, 1); /* TRY TO OPEN RTP */CALL OPENFILE ('.NEWDATA', LOC.MON, 0); /* LOOK FOR .NEWDATA */IF ((CORE(LOC.MON) <> 0) AND (EMSIZE <> 0)) THEN DO; /* MAKE SURE WE GOT IT */   IF F#LS_LENGTH IGT 256 THEN F#LS_LENGTH = 256; /* RESTRICT LENGTH */   EXTBUF (0) = TIMBRE;       EXTBUF (1) = 0; /* START WRITING AT SECTOR TIMBRE */   EXTBUF (2) = F#LS_LENGTH;  EXTBUF (3) = 0; /* COPY THIS MANY SECTORS */   CALL EXTREAD (CORE(LOC.MON + 1), CORE(LOC.MON), EXTBUF); /* READ IN .NEWDATA */   CORE(LOC.SYNTIMB) = TIMBRE; /* TIMBRE STARTS AT SECTOR TIMBRE */   CORE(LOC.SYNMED) = 1; /* IN EXTERNAL MEMORY */   CORE(LOC.RST) = 3; /* PRETEND WE'RE THE ANALYSIS PROGRAM */END;CALL OPENFILE ('MONITOR', LOC.MON,  FALSE); /* LOOK FOR MONITOR */CALL OPENFILE ('.STAB-7', LOC.P3,   FALSE); /* LOOK FOR STAB */CALL OPENFILE ('.SPLT-7', LOC.MPLT, FALSE); /* LOOK FOR MUSIC PRINTING */CORE(LOC.SYNRET) = LOC.MON; /* SET OVERLAYING MODULE */CALL OVERLAY (CORE(LOC.P2 + 1), CORE(LOC.P2), CORE(LOC.P2 - 1)); /* OVERLAY */