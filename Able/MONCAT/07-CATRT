/* 07-CATRT  $TITLE  Catalog Processing Subroutines */upcase: proc(ch) returns (fixed); /* set CH to upper case */   dcl ch fixed;   if (ch >= l.a) and (ch <= l.z) then ch = ch - "40";   return(ch);end upcase;str.insert:  proc(s,d,index); /* insert string s into string d starting at index */   dcl s     fixed array; /* source string */   dcl d     fixed array; /* destination string */   dcl index fixed; /* insertion point */   dcl i     fixed;   if index igt d(0) then return; /* insertion point out of range */   if d(0) + s(0) igt string.max then return; /* string overflow would result */   do i = d(0) - 1 to index by -1; /* make room for source string in destination */      call pbyte(d,i + s(0),byte(d,i));   end;   do i = 0 to s(0) - 1; /* put source string into proper location in destination string */      call pbyte(d,index + i,byte(s,i));   end;   d(0) = d(0) + s(0); /* adjust destination size accordingly */end str.insert;/* This procedure is called when a file is called up with the OLD command   or when a file is saved with SAVE or REPLACE.  Else if the file   has been called up from the system device, then the saved   flag is set to speed up the sequence 'OLD XYZ;COM'.*/setup.stored:  proc(file.name,ms_sec,ls_sec); /* set saved flag as required */   dcl file.name       fixed array; /* name of file */   dcl (ms_sec,ls_sec) fixed; /* starting sector of file */   dcl dev             fixed;   dev = shr(ms_sec,8); /* get device */   stored = 0; /* assume file is not stored on system device */   if (dev = 6) or (dev = 7) /* stored on W0 or W1 */   or ((systyp = 0) and ((dev = 2) or (dev = 3))) then do; /* F0 or F1 of floppy-based system */      stored = 1; /* set stored */      call move.name(file.name,location(loc.strn)); /* save file name */   end;   saved = 1; /* if called up from somewhere, then can't lose source file */   filmed = 0; /* stored on disk */   fildev = ms_sec; /* indicate where it is stored */   filsec = ls_sec;end setup.stored;/* $SUBTITLE  Device Handling Routines */scandev:  proc returns (fixed); /* scans off a trailing device and returns device number */   dcl dev    fixed;   dcl (d,n)  fixed; /* characters */   call get.char.upcase; d = inch; /* get device type */   call get.char.upcase; n = inch; /* get logical unit */   dev = -1;   if      d = a.F then dev = 2;  /* floppy */   else if d = a.R then dev = 4;  /* remote */   else if d = a.W then dev = 6;  /* winchester */   else if d = a.O then dev = 10; /* optical */   if dev <> -1 then do;      if (n = a.0) or (n = a.1) then do; /* zero or one */         dev = dev + (n - a.0); /* add in the logical unit */         if find_device(dev) <> 0 then do; /* look up device in configuration */            call get.char.upcase;            call skipspa;            inch = upcase(inch);            return (dev); /* return device found */         end;      end;   end;   call pcn; call pstringr ('Invalid device name'); /* scan error */   return (-1); /* invalid device number */end scandev;/* $SUBTITLE  File Name Handling Routines */compute.seq.name:  proc(treename) returns (boolean); /* returns TRUE if a valid sequence name was entered */   dcl treename fixed array; /* name to use */   dcl ch       fixed;   ch = byte(treename,treename(0) - 1); /* get last character */   if (ch < a.1) or (ch > a.8) then do;     call pcn; call pstringr ('Invalid Sequence Name');     return (FALSE);   end;   treename(0) = treename(0) - 1; /* nuke last character */   call pbyte(sqdt,3,ch - 1); /* drop in byte */   call str.insert(sqdt,treename,treename(0)); /* add sequence name to tree name */   return (TRUE);end compute.seq.name;read.name:  proc(nam,one_name) returns (boolean); /* if TRUE returned, a valid file name is in NAM */   dcl nam      fixed array; /* return name in this array */   dcl one_name boolean;     /* TRUE if we just want one filename, no devices */   dcl valid    boolean;     /* TRUE if valid file name found */   dcl delimiters data ('?;, :/'); call pbyte(delimiters,0,a.CR); /* file name delimiters (including carriage return) */   delimiter.pos:  proc(ch) returns (fixed); /* returns position of delimter found */      dcl ch fixed; /* character to check */      dcl i  fixed;      do i = 0 to delimiters(0) - 1; /* search delimiters */         if byte(delimiters,i) = ch then return (i); /* delimiter found */      end;      return (-1); /* delimiter not found */   end delimiter.pos;   nam(0) = 0; /* zero out name */   call skipspa; /* skip over leading spaces */   inch = upcase(inch); /* make upper case */   valid = TRUE; /* no invalid characters found yet */   do while delimiter.pos(inch) = -1; /* loop until a delimiter is found */      if Valid_FileChar(inch) then do; /* character is valid */         if nam(0) < shl(F#Name_Len,1) then do; /* enough room in buffer */            call pbyte(nam,nam(0),inch); /* insert this character into array */            nam(0) = nam(0) + 1;         end;      end;      else if inch > a.SP then valid = FALSE; /* invalid character found */      call get.char.upcase; /* get next character */   end;   if (one_name) and (delimiter.pos(inch) > 3) then valid = FALSE; /* illegal characters after name */   if not valid then do;      call pcn; call pstringr (icfms);   end;   if inch = a.sp then call skipspa; /* skip spaces at end */   return (valid); /* got a valid name */end read.name;/* $Page */get.treename:  proc(treename,cmdmsg,use.current,file.needed) returns (boolean); /* get a treename from the input buffer */   dcl treename    fixed array; /* array to return tree name in */   dcl cmdmsg      fixed array; /* command name for error message */   dcl use.current boolean; /* TRUE to use current name as default for last file */   dcl file.needed boolean; /* TRUE if a trailing file name is required */   dcl temp(F#Name_Len) fixed; /* temporary name array */   treename(0) = 0; /* clear treename */   call skipspa; /* skip leading spaces */   inch = upcase(inch);   do while (not.end and (inch <> a.comma) and (inch <> a.sp)); /* loop until delimiter is reached */      if inch = a.slash then do; /* move trailing device to beginning of string */         call get.char.upcase; /* skip over slash */         if not read.name(temp,false) then return (false); /* invalid characters */         if (treename(0) = 0) or (byte(treename,0) <> a.colon) /* no leading colon */         then call str.insert(':',treename,0); /* put colon at beginning */                  call str.insert(temp,treename,0); /* put device at beginning of treename */      end; /* of scan off device */      else do; /* get next treename character */         call pbyte(treename, treename (0), inch); /* append this character to treename */         treename (0) = treename (0) + 1;         call get.char.upcase; /* get next character */      end; /* of get next treename character */   end; /* loop until delimiter is reached */   if (treename(0) = 0) or (byte(treename,treename(0) - 1) = a.colon) then do; /* no file given */      if (use.current) and (cnam(0) > 0) /* ok to use default */      then call str.insert(cnam,treename,treename(0)); /* concatenate current file to end of treename */      else if (treename(0) = 0) or (file.needed) then do; /* trailing file name required */         call pcn; call pstr (fnmms); call pstr (cmdmsg); call pstringr (' command');         return (false); /* die */      end;   end;   if inch = a.sp then call skipspa; /* skip spaces before returning */   return (true); /* got a good treename */end get.treename;/* $SUBTITLE Current File I/O Routines */READIN:PROC(DEVICE,SECTOR,LEN.W,LEN.S); /* READ IN CURRENT FILE FROM DISK */   DCL (DEVICE,SECTOR,LEN.W,LEN.S) FIXED;   DCL (MS,LS) FIXED;   FILNG=LEN.W; FILNS=LEN.S; /* SET WORD AND SECTOR LENGTH */   BSTRT=0; BLEN=0; FSTRT=0; BALT=0; /* INITIALIZE FLAGS FOR NULL FILE */   IF FILNS=0 THEN RETURN; /* EMPTY FILE */   IF ((WORKDEV AND "HFF") = 0) AND (WORKSEC = 0) THEN CALL TRAP('WORKSEC=0 at READIN routine');   IF (FILNS ILT 256) AND (FILNG ILE FBUFSZ) THEN DO; /* WILL ALL FIT IN BUFFER */      BSTRT=0; FSTRT=FILNG; BLEN=FILNG; BALT=1;      CALL SDREAD(DEVICE,SECTOR,FBUF,BLEN);   END;   ELSE IF FILNS ILT 256 THEN DO; /* MULTIPLE BUFFER LOADS, BUT LESS THAN 64K */      IF (SHR(DEVICE,8)=0) AND (WORKMED=0) AND (SYSTYP=0) THEN DO; /* MUST START DRIVE 0 */         DO WHILE READ("100"); END; /* WAIT FOR RESTORE TO STOP */         WRITE("104")=0; /* TURN ON BOTH DRIVES TO SPEED UP LOAD */      END;      DO WHILE (BSTRT+BLEN) ILT FILNG; /* READ IN & WRITE OUT */         BSTRT=FSTRT;         BLEN=FILNG-BSTRT;         IF BLEN IGT FBUFSZ THEN BLEN=FBUFSZ;         MS = DEVICE;         LS = SECTOR + SHR(BSTRT,8);         IF LS ILT SECTOR THEN MS = MS + 1;         CALL SDREAD(MS,LS,FBUF,BLEN); /* READ IN   */         CALL WORKWRITE(SHR(BSTRT,8),FBUF,BLEN); /* WRITE OUT */         FSTRT=BSTRT+BLEN;		 interp_run_host_250();      END; /* OF DO WHILE */   END; /* OF MULTIPLE, BUT LESS THAN 64K */   ELSE DO; /* WILL NOT FIT IN 64K */      IF (SHR(DEVICE,8)=0) AND (SYSTYP=0) THEN DO; /* MUST START DRIVE 0 */         DO WHILE READ("100"); END; /* WAIT FOR RESTORE TO STOP */         WRITE("104")=0; /* TURN ON BOTH DRIVES TO SPEED UP LOAD */      END;      /* IN THE CODE BELOW, BSTRT,FSTRT,BLEN ARE ALL IN SECTORS */      FSTRT=0;      DO WHILE FSTRT ILT FILNS; /* READ IN & WRITE OUT */         BSTRT=FSTRT;         BLEN=FILNS-BSTRT;         IF BLEN IGT SHR(FBUFSZ,8) THEN BLEN=SHR(FBUFSZ,8);         MS = DEVICE;         LS = SECTOR + BSTRT;         IF LS ILT SECTOR THEN MS = MS + 1;         CALL SDREAD(MS,LS,FBUF,SHL(BLEN,8)); /* READ IN   */         CALL WORKWRITE(BSTRT,FBUF,SHL(BLEN,8)); /* WRITE OUT */         FSTRT=BSTRT+BLEN;		 interp_run_host_250();      END;      BSTRT=(-1); FSTRT=(-1); /* MAKE SURE NO ONE WILL USE IT */   END; /* WILL NOT FIT IN 64K */   CALL RESTORE.HEAD(DEVICE);END READIN;/* $Page */WRITEOUT:PROC(DEVICE,SECTOR); /* WRITE OUT CURRENT FILE */   DCL (DEVICE,SECTOR) FIXED;   DCL (MS,LS) FIXED;   IF FILNS=0 THEN RETURN; /* EMPTY CURRENT FILE */   IF ((DEVICE AND "HFF") = 0) AND (SECTOR = 0) THEN CALL TRAP('SECTOR=0 with FILNS<>0 in WRITEOUT');   IF (FILNS ILT 256) AND (FILNG ILE FBUFSZ) /* FILE IS SMALL */   THEN CALL SDWRITE(DEVICE,SECTOR,FBUF,FILNG); /* WRITE OUT FILE */   ELSE IF (FILNS ILT 256) THEN DO; /* MULTIPLE LOADS, BUT LESS THAN 64K */      CALL PRIME; /* GET FIRST SECTOR */      CALL SDWRITE(DEVICE,SECTOR,FBUF,BLEN); /* WRITE OUT FIRST BUFFER LOAD */      DO WHILE (BSTRT+BLEN) ILT FILNG; /* LOOP OVER SECTIONS */         BSTRT=FSTRT; BLEN=FILNG-BSTRT;         IF BLEN IGT FBUFSZ THEN BLEN=FBUFSZ; /* TRY TO READ IT ALL IN */         CALL WORKREAD(SHR(BSTRT,8),FBUF,BLEN);         MS = DEVICE;         LS = SECTOR + SHR(BSTRT,8);         IF LS ILT SECTOR THEN MS = MS + 1;         CALL SDWRITE(MS,LS,FBUF,BLEN);         FSTRT=BSTRT+BLEN;		 interp_run_host_250();      END;   END; /* OF MULTIPLE LOADS, BUT LESS THAN 64K */   ELSE DO; /* TOO LARGE TO FIT INTO 64K */      FSTRT=0;      DO WHILE FSTRT ILT FILNS; /* LOOP OVER SECTIONS */         BSTRT=FSTRT; BLEN=FILNS-BSTRT;         IF BLEN IGT SHR(FBUFSZ,8) THEN BLEN=SHR(FBUFSZ,8); /* TRY TO READ IT ALL IN */         CALL WORKREAD(BSTRT,FBUF,SHL(BLEN,8));         MS = DEVICE;         LS = SECTOR + BSTRT;         IF LS ILT SECTOR THEN MS = MS + 1;         CALL SDWRITE(MS,LS,FBUF,SHL(BLEN,8));         FSTRT=BSTRT+BLEN;		 interp_run_host_250();      END;      FSTRT=(-1); BSTRT=(-1); /* MAKE SURE NO ONE USES IT */   END; /* TOO LARGE TO FIT INTO 64K */END WRITEOUT;/* $SUBTITLE File Unsave and Save Routines */unsave:  proc(treename) returns (boolean); /* UNSAVE FILE */   dcl treename  fixed array; /* name of file to delete */   if locate(treename,1) then do; /* file found */      if (F#Type = T#Subc) or (F#Type = T#LSubc) then do; /* verify if deleting a subcatalog */         call pcn; call pstr ('You are UNSAVing a catalog [Confirm with Return key]');         if rchar <> a.CR then do; /* abort if they don't hit a carriage return */            call newline; call pcn; call pstr ('Command Aborted');            return (FALSE);         end;         call newline;      end;      if delete(treename,1) then return (TRUE); /* delete file */   end;   call cat.error; /* display error message */   return (FALSE); /* unsave not performed */end unsave;/* SAVE IS CALLED TO SAVE THE CONTENTS OF THE CURRENT FILE UNDER THE NAME   THAT IS PASSED IN AN ARRAY.  IT WILL SCAN OFF THE OPTIONAL SECTOR LENGTH   SPECIFIER AND SAVE THE FILE.  EXAMPLES OF SAVE COMMAND:      SAVE      SAVE FILENAME      SAVE,32      SAVE FILENAME,32    SAVE DOES NOT AFFECT THE CONTENTS OF 'BUF'. */save:  proc(treename,saving) returns (boolean); /* save buffer contents with given name on given catalog */   dcl treename fixed array; /* file name to use */   dcl saving   boolean; /* TRUE if file is to be saved (does not already exist) */   dcl numsecs  fixed; /* number of sectors to allocate */   dcl numwrds  fixed; /* number of words mod 64K in file */   dcl size     fixed; /* catalog size in sectors */   dcl size_too_large data ('Size value too large');   if locate(treename,1) then do; /* file already in catalog */      if saving then do; /* SAVE: error if file already exists */         call pcn; call pstr ('File '); call pstr (f#name); call pstringr (' is already saved');         return (FALSE); /* save failed */      end;   end;   else if not ( (C#Status = E#No_File) and (saving) ) then do; /* not an error if file not found while saving */      call cat.error; /* display the error */      return (FALSE); /* save failed */   end;   numsecs = filns;  /* assume no user specified max */   numwrds = filng;   if inch = a.comma then do; /* if comma, scan off sector length field */      call get.char.upcase; call skipspa;      call scanarg; /* scan arg */      if argMSW <> 0 then do; /* argument too large */         call pcn; call pstringr (size_too_large);         return (FALSE);      end;      else do; /* argument OK */         if      filtp = T#Subc  then size = 1; /* add 1 sector for short catalogs */         else if filtp = T#LSubc then size = 4; /* add 4 sectors for long catalogs */         else size = 0; /* not a subcat, so no extra sectors needed */         arg = arg + size; /* add on any extra sectors */         if arg ilt size then do; /* overflow error */            call pcn; call pstringr (size_too_large);            return (FALSE);         end;         else if arg ige numsecs then do; /* change values if necessary */            numsecs = arg; /* save given number of sectors */            numwrds = shl(arg,8); /* length mod 64K */         end;      end;   end; /* of comma */   else if not.end then do; /* better be the end of the command */      call pcn; call pstringr (forms);      return (FALSE); /* didn't save it */   end;   if replace(treename,filtp,0,numsecs,numwrds,1) then do; /* try to replace */      call writeout(F#MS_Sector,F#LS_Sector); /* write out current file to this location */      return (TRUE); /* saved successfully */   end;   else do; /* replace failed */      call cat.error; /* display the error */      return (FALSE); /* save failed */   end;end save;