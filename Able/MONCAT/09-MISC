/* 09-MISC  $TITLE  Common Command Handlers *//* 10/05/96 - CJ - ADDED EXPORTSUB */SCANO:PROC FIXED; /* SCAN OCTAL NUMBERS FROM INPUT */     ARGMSW=0; ARGLSW=0; /* USED TO RETURN 32-BIT ARGUMENT */   DO WHILE ((INCH-a.0) ILT 8);      ARGMSW=SHL(ARGMSW,3) OR SHR(ARGLSW,13); /* PUT TOP 3 BITS OF LSW INTO FIRST THREE BITS OF MSW */      ARGLSW=SHL(ARGLSW,3) OR (INCH AND "7");      CALL GET.CHAR.UPCASE;   END;   CALL SKIPSPA;   RETURN (ARGLSW);END SCANO;GETARG:PROC FIXED; /* TEST FOR NUMERIC ARGUMENT, SCAN IT IF PRESENT */   IF (INCH-a.0) ILT 10 THEN DO; /* ITS A DIGIT */      CALL SCANARG; /* READ IT INTO 'ARG' */      CALL SKIPSPA; /* SKIP FOLLOWING SPACES */      RETURN 1;   END;   RETURN 0; /* NO ARG */END GETARG;/* LIST PROCEDURE (OUTPUT) */LISTSUB:PROC; /* LIST LINES ON CURRENT DEVICE */   /* PROCEDURE RETURNS A 1 IF A BREAK IS DETECTED WHILE PRINTING */   CALL SORT; /* SORT IN ANY ALTER LINES HERE */   IF NONCOMCHK THEN RETURN 1; /* ERROR IF COMPILED FILE */   IF (SCREEN>0) AND (OUTDEV=0) THEN DO;      CALL CLEARSCREEN; /* CLEAR CRT */      LINEC=0;   END;   CALL PRIME; /* INIT FILE BUFFERING */   IF (GETARG) THEN DO; /* LIST XXX - START FROM SPECIFIED LINE NUMBER */      CALL SKIPTOLINE(ARG); /* FIND THAT LINE */      IF (NOT.END) THEN DO; /* PROCESS LINE NUMBER CLAUSES */         NEXTLIST:; /* RE-ENTER FROM BELOW, WE SCANNED */         IF ARG=FBUF(PTR-BSTRT) THEN DO; /* PRINT FIRST LINE */            IF PLIN(PTR) THEN RETURN 1;            CALL STEPPTR;         END;         IF INCH=a.minus THEN DO; /* THROUGH ANOTHER LINE */            CALL GET.CHAR.UPCASE; /* SKIP OVER MINUS SIGN */            CALL SKIPSPA; CALL SCANARG; CALL SKIPSPA; /* GET ENDING VALUE */            DO WHILE (PTR ILT FILNG) AND (FBUF(PTR-BSTRT) ILE ARG);               IF PLIN(PTR) THEN RETURN 1;               CALL STEPPTR;            END;         END; /* OF MINUS */         IF INCH<>a.CR THEN CALL GET.CHAR.UPCASE; /* SKIP OVER DELIMITER */         CALL SKIPSPA;         IF (GETARG) THEN DO; /* -CONTINUED */            CALL SKIPTOLINE(ARG); /* JUMP TO NEXT LINE NUMBER */            GOTO NEXTLIST; /* AND RE-ENTER */         END;         RETURN 0; /* NORMAL PRINT */      END; /* OF LINE NUMBER CLAUSE PROCESSING */   END; /* OF DIGIT */   DO WHILE PTR ILT FILNG; /* LIST OUT TO END */      IF PLIN(PTR) THEN RETURN 1;      CALL STEPPTR;   END;   RETURN 0; /* NORMAL PRINT */END LISTSUB;EXPORTSUB:PROC;   /* PROCEDURE RETURNS A 1 IF A BREAK IS DETECTED WHILE PRINTING */   CALL SORT; /* SORT IN ANY ALTER LINES HERE */   IF NONCOMCHK THEN RETURN 1; /* ERROR IF COMPILED FILE */   CALL PRIME; /* INIT FILE BUFFERING */   DO WHILE PTR ILT FILNG; /* LIST OUT TO END */      IF EXPORTLIN(PTR) THEN RETURN 1;      CALL STEPPTR;   END;   RETURN 0; /* NORMAL PRINT */END EXPORTSUB;/* $SUBTITLE  Routine to Join Files Together *//*  CALLED TO APPEND A FILE TO THE END OF THE CURRENT FILE.  AT CALL    TIME, THE CURRENT FILE NAME STARTS WITH THE NEXT CHARACTER. */JOINPROC:  PROC(TREENAME) RETURNS (FIXED); /* FILENAME IS CURRENT CHARACTER */  DCL TREENAME FIXED ARRAY;  DCL (I,J,K)  FIXED;  DCL (MS,LS)  FIXED;  CALL SORT; /* SORT ALTERS INTO CURRENT FILE */  JOINNEXT:;  IF NOT GET.TREENAME(TREENAME,'JOIN or APPEND',FALSE,TRUE) THEN RETURN 1; /* NO NAME SPECIFIED */  IF NOT LOCATE(TREENAME,1) THEN DO;     CALL CAT.ERROR; /* SOME OTHER ERROR */     RETURN 1;  END;  MS = F#MS_LENGTH;  LS = F#LS_LENGTH + FILNS;  IF LS ILT FILNS THEN MS = MS + 1;  IF (MS <> 0) OR ((MS = 0) AND ((LS IGT WORKNS) OR (LS IGT 255))) THEN DO;    CALL PCN; CALL PSTRINGR (PTLMS);    RETURN 1;  END;  IF FILNG + F#WORDS ILE FBUFSZ THEN DO; /* NEW FILE WILL FIT IN MEMORY */    CALL SDREAD(F#MS_SECTOR,F#LS_SECTOR,LOCATION(ADDR(FBUF(FILNG))),F#WORDS); /* AND INDICATE DRIVE */    BLEN = BLEN + F#WORDS; /* MORE IN BUFFER */    FSTRT = FSTRT + F#WORDS; /* AND THIS */  END;  ELSE DO; /* WILL NOT ALL FIT */    IF (FILNG <> 0) AND (FILNG ILE FBUFSZ) THEN CALL WORKWRITE(0,FBUF,FILNG);    BSTRT = FILNG and "177400"; /* GET SOMEONE IN MEMORY */    IF BSTRT <> FILNG THEN CALL WORKREAD(SHR(BSTRT,8),FBUF,FILNG - BSTRT);    BLEN = FILNG - BSTRT; /* AMOUNT OF PREVIOUS FILE IN MEMORY */    MS = F#MS_SECTOR; /* START AT FIRST SECTOR OF FILE */    LS = F#LS_SECTOR;    DO WHILE BSTRT + BLEN ILT FILNG + F#WORDS; /* AND COPY OVER WHOLE FILE */      I = FILNG + F#WORDS - BSTRT - BLEN; /* # TO READ STARTING AT FSTRT */      IF I + BLEN IGT FBUFSZ THEN DO; /* CAN NOT FIT REST OF FILE */        I = ((FBUFSZ - BLEN) and "177400"); /* IT */        J = (BLEN + I) and "177400"; /* WRITE OUT EVEN LENGTH TO IF MORE */      END;      ELSE J = BLEN + I; /* WRITE OUT ALL OF REST OF FILE */      CALL SDREAD(MS,LS,LOCATION(ADDR(FBUF(BLEN))),I); /* READ NEW DATA */      CALL WORKWRITE(SHR(BSTRT,8),FBUF,J); /* WRITE OUT DESIRED EMT */      BLEN = BLEN + I; /* THAT MUCH MORE READ IN */      LS = LS + SHR(I,8); /* AND NEXT BUFFER LOAD */      IF LS ILT SHR(I,8) THEN MS = MS + 1;      IF BSTRT + BLEN <> FILNG + F#WORDS THEN DO; /* MORE TO GO */        IF BLEN <> J THEN DO; /* COPY DOWN IN LOOP */          DO K = 0 TO (BLEN - J - 1); FBUF(K) = FBUF(J + K); END;        END;        BLEN = BLEN - J;        BSTRT = BSTRT + J;      END;    END; /* OF COPY LOOP */    FSTRT = BSTRT + BLEN; /* END HERE */    BALT = 0; /* BUFFER IS NOT ALTERED NOW */  END; /* OF WILL NOT ALL FIT */  IF FILNS = 0 THEN FILTP = F#TYPE; /* USE FILE TYPE OF JOINED FILE IF ORIGINAL FILE LENGTH IS ZERO */  FILNG = FILNG + F#WORDS; FILNS = SHR(FILNG+255,8); /* CAN WORK BECAUSE IT WILL ALWAYS BE < 64K */  SAVED = 0; STORED = 0; /* IS NOT SAVED */  IF INCH = a.comma THEN DO; /* DETECT COMMA */    CALL GET.CHAR.UPCASE;    CALL SKIPSPA; /* SKIP SPACES */    IF NOT.END THEN GOTO JOINNEXT;  END;  ELSE IF NOT.END THEN DO; /* IF NOT AT END, BETTER HAVE A COMMA */     CALL PSTRINGR (FORMS);     CALL PSTRINGR (PARTIAL_EDIT);     RETURN 1;  END;  RETURN 0; /* NO ERRORS */END JOINPROC;/* $SUBTITLE  Common Routine for Line Extract and Delete */EXT.DEL:PROC(CODE) FIXED; /* ROUTINE TO HANDLE LINE EXTRACT AND DELETE */  DCL CODE FIXED; /* 0=EXTRACT, 1=DELETE */  CALL SORT; /* SORT IN ALTERS IF ANY */  IF NONCOMCHK THEN RETURN 1; /* GIVE ERROR IF EMPTY OR COMPILED FILE */  CALL PRIME; /* PRIME INPUT BUFFER */  STORED=0; SAVED=0; /* NOT SAVED */  PTR1=0; /* INITIALIZE OUTPUT POINTER TO ZERO */  IF (INCH-a.0) IGE 10 THEN DO; CALL PSTRINGR (FORMS); RETURN 1; END; /* NOT LINE NUMBER */  DO WHILE GETARG; /* LOOP OVER WHILE LINE NUMBERS ARE BEING READ */    DO WHILE (PTR ILT FILNG) AND (FBUF(PTR-BSTRT) ILT ARG); /* LOOP UP TO SPECIFIED LINE */      IF CODE=0 THEN DO; /* EXTRACT- DELETE UP TO THIS LINE */        CALL MOVEPTR; /* SKIP OVER LINE TO DELETE */        IF (PTR-PTR1) IGT 512 THEN CALL DELETE.WORDS(PTR-PTR1); /* FREE UP MEM USAGE */        CALL LCHK(PTR,PTR1); /* AND MAKE SURE LINE IS IN MEMORY */      END;      ELSE DO; /* DELETE- SAVE LINES NOT TO BE DELETED */        CALL EDITPTR; /* COPY DOWN, ADVANCE PTR1 & PTR */      END;    END; /* OF LOOP THROUGH LINES */    IF INCH=a.minus THEN DO; /* IF MINUS SIGN, GET SECOND ARGUMENT */      CALL GET.CHAR.UPCASE;      CALL SKIPSPA; CALL SCANARG; CALL SKIPSPA; /* SCAN ARGUMENT */    END;    DO WHILE (PTR ILT FILNG) AND (FBUF(PTR-BSTRT) ILE ARG); /* LOOP THROUGH SPECIFIED LINES */      IF CODE=0 THEN CALL EDITPTR; /* EXTRACT- SAVE THOSE LINES */      ELSE DO; /* DELETE UP THROUGH SPECIFIED LINES */        CALL MOVEPTR; /* SKIP OVER LINE TO DELETE */        IF (PTR-PTR1) IGT 512 THEN CALL DELETE.WORDS(PTR-PTR1); /* FREE UP MEM USAGE */        CALL LCHK(PTR,PTR1); /* AND CHECK MEM */      END;    END; /* OF DO WHILE */    IF INCH=a.comma THEN DO; /* SKIP COMMA IF ONE */      CALL GET.CHAR.UPCASE; CALL SKIPSPA;    END;  END; /* OF DIGIT LOOP */  IF CODE=0 THEN DO; /* CLEAN UP AFTER EXTRACT */    IF FILNG<>PTR1 THEN DO; /* SOME MORE OF FILE EXISTS */      PTR=BSTRT+BLEN;      FILNG=PTR; FILNS=SHR(FILNG+255,8);      FSTRT=PTR;      CALL DELETE.WORDS(PTR-PTR1); /* TRUNCATE END OF FILE HERE */    END;  END;  ELSE DO; /* CLEAN UP AFTER DELETE */    DO WHILE (PTR ILT FILNG); CALL EDITPTR; END; /* MOVE LINE & SAVE IT */    IF PTR1<>PTR THEN CALL DELETE.WORDS(PTR-PTR1); /* DELETE FINAL GAP */  END;  CALL BFORCE; /* FORCE BUFFER IF LOTS OF IT */  IF (NOT.END) THEN DO; CALL PSTRINGR (FORMS); RETURN 1; END;  RETURN 0; /* OK */END EXT.DEL;/* $SUBTITLE  Routine to handle global file ops, such as Locate and Replace */GLOBAL:PROC(CODE) BOOLEAN; /* HANDLER FOR LOCATE AND REPLACE COMMANDS */  DCL (CODE,COUNT) FIXED; /* 0=LOCATE, 1=REPLACE */  DCL (I,J)  FIXED;  CALL SORT;  IF NONCOMCHK THEN RETURN 1; /* ERROR IF COMPILED OR EMPTY */  CALL SCANSTR(STR1,50,0); /* SCAN A STRING INTO AN ARRAY */  IF CODE<>0 THEN DO; /* GET SECOND STRING */    IF INCH<>a.comma THEN DO; CALL PSTRINGR (FORMS); RETURN 1; END; /* SECOND STRING MISSING */    CALL GET.CHAR; /* SKIP THE COMMA */    CALL SCANSTR(STR2,50,0); /* SCAN THE SECOND STRING */    IF STR1(0)=0 THEN DO; CALL PSTRINGR (FORMS); RETURN 1; END; /* FIRST STRING CAN NOT BE NULL */  END;  COUNT=0; /* INITIALIZE COUNT OF LINES PRINTED */  CALL PRIME; /* INIT FILE PTR */  PTR1=0; /* INIT OUTPUT PTR */  /* LOOP FOR EACH ARGUMENT CLAUSE:        FOR ',ALL'    ARG1=0     ARG2=-1        FOR ',80'     ARG1=80    ARG2=80        FOR ',80-90'  ARG1=80    ARG2=90        FOR ',80-END' ARG1=80    ARG2=-1        FOR ''        ARG1=-1    ARG2=-1  */  NEXTARG:; /* RE-ENTER FROM BELOW FOR CONTINUED ARGUMENT FIELD */  ARG1 = (-1); ARG2 = (-1); /* ASSUME NO ARGUMENT FIELD */  IF (NOT.END) THEN DO; /* SCAN ARGUMENT FIELD */    CALL GET.CHAR.UPCASE; CALL SKIPSPA; /* SKIP OVER THE COMMA AFTER STR2, SPACES */    IF INCH=a.A THEN DO; /* ASCII A - MEANS 'ALL' */      ARG1=0; ARG2=(-1);      CALL SKIPEND; /* SKIP REST OF COMMAND LINE */    END;    ELSE IF (GETARG) THEN DO; /* DIGIT - SCAN NUMERIC ARGUMENT */      ARG1=ARG; ARG2=ARG; /* ASSUME A COMMA */      IF INCH=a.minus THEN DO; /* MINUS SIGN - SCAN SECOND ARG */        CALL GET.CHAR.UPCASE; CALL SKIPSPA;        IF INCH=a.E THEN DO; /* E DENOTES 'END' */          ARG2=(-1);          CALL SKIPEND;        END;        ELSE DO; /* SCAN SECOND NUMERIC ARGUMENT */          CALL SCANARG; CALL SKIPSPA;          ARG2=ARG; /* SAVE IT */        END;      END; /* OF SECOND ARG SCAN */    END; /* OF DIGIT */    ELSE DO; /* NOT ALL OR DIGIT - MUST BE ERROR */      IF CODE<>0 THEN DO; /* CLEAN UP IF REPLACE */        IF PTR IGT PTR1 THEN CALL DELETE.WORDS(PTR-PTR1); /* FIX UP FILE */        CALL BFORCE; /* FORCE IF REQD */      END;      CALL PSTRINGR (FORMS);      RETURN 1;    END; /* OF ERROR */  END; /* OF SCAN ARGUMENT FIELD */  /* PROCESS CLAUSE:  ARG1,ARG2 = STARTING & ENDING LINE NUMBERS                      STR1= SEARCH STRING                      STR2= REPLACEMENT STRING                      PTR = CURRENT FILE POINTER */  IF ARG1<>(-1) THEN  DO WHILE (PTR ILT FILNG) AND (FBUF(PTR-BSTRT) ILT ARG1); /* FIND FIRST LINE */    CALL EDITPTR; /* COPY DOWN THE LINE */  END;  DO WHILE (PTR ILT FILNG) AND (FBUF(PTR-BSTRT) ILE ARG2) AND (ARG2<>(-2)); /* LOOP UNTIL SECOND LINE */    PTR2=PTR; /* SAVE POINTER TO START */    CALL MOVEPTR; /* FIND END OF LINE */    IF PTR2<>PTR1 THEN CALL COPYDOWN(PTR2,PTR,PTR1); /* COPY LINE DOWN */    CALL LCHK(PTR,PTR1); /* MAKE SURE EVERYTHING IS IN MEMORY */    BPTR=SHL(PTR1-BSTRT,1); /* COMPUTE BYTE PTR */    NPTR1=PTR1+PTR-PTR2; /* SAVE NEW POINTER1 */    PTR2=POS(STR1,BPTR); /* SEARCH FOR STRING */    IF (CODE=0) AND (PTR2<>(-1)) THEN DO; /* LOCATE MODE AND FOUND */      IF PLIN(PTR1) THEN RETURN 1; /* PRINT IT */      COUNT=COUNT+1; /* COUNT IT */      IF ARG1=(-1) THEN ARG2=(-2); /* FORCE TERMINATION */    END;    ELSE DO WHILE PTR2<>(-1); /* LOOP OVER OCCURRENCES IN LINE */      IF STR2(0)>STR1(0) THEN DO; /* REPL STRING IS LONGER - MOVEUP */        I=STR2(0)-STR1(0); /* GET NUMBER OF BYTES WE MUST INSERT */        PTR3=SHL(NPTR1-2-BSTRT,1); /* BYTE PTR TO WORD OF LINE WITH NULL */        DO WHILE BYTE(FBUF,PTR3)<>0; PTR3=PTR3+1; END; /* FIND END OF LINE */        IF (I and PTR3) THEN J=SHR(I+1,1); /* ROUND UP IF ODD & ODD */        ELSE             J=SHR(I,1);   /* ELSE CAN FIT IN EXTRA BYTE IF NEEDED */        IF NPTR1+J IGT PTR THEN DO; /* MUST INSERT */          IF ((FILNS+1) IGT WORKNS) OR ((FILNS+1) IGT 255) THEN DO; /* TOO BIG */            PTR1=NPTR1; /* SALVAGE WHAT WE CAN */            IF PTR IGT PTR1 THEN CALL DELETE.WORDS(PTR-PTR1);            CALL BFORCE;            CALL PSTRINGR ('File too big - cannot insert new string');            CALL PSTRINGR (PARTIAL_EDIT);            RETURN 1;          END;          PTR4=BSTRT; /* SAVE STARTING BUFFER POSITION IN CASE OF MOVE */          CALL ISERT(256);          PTR4=SHL(BSTRT-PTR4,1); PTR2=PTR2-PTR4; PTR3=PTR3-PTR4;        END;        PTR4=PTR3; /* BYTE POINTER HERE */        PTR5=PTR2+STR1(0); /* POINTS TO AREA THAT MUST BE COPIED UPWARDS */        DO WHILE PTR4 IGT PTR5;          PTR4=PTR4-1; /* DECR */          CALL PBYTE(FBUF,PTR4+I,BYTE(FBUF,PTR4)); /* MOVE UP */        END;        NPTR1=NPTR1+J; PTR3=PTR3+I; /* UPDATE POINTERS */      END; /* OF REP STRING IS LONGER */      ELSE IF STR2(0)<STR1(0) THEN DO; /* REPL STR IS SHORTER - MOVEDOWN */        I=STR1(0)-STR2(0); /* # OF BYTES TO REMOVE */        PTR3=SHL(NPTR1-2-BSTRT,1); /* BYTE POINTER TO LAST WORD OF LINE */        DO WHILE BYTE(FBUF,PTR3)<>0; PTR3=PTR3+1; END;        PTR4=PTR2+STR1(0); /* POINTER TO FIRST BYTE TO SAVE */        DO WHILE PTR4 ILT PTR3; /* COPY REST OF STRING DOWNWARD */          CALL PBYTE(FBUF,PTR4-I,BYTE(FBUF,PTR4)); /* MOVE DOWN */          PTR4=PTR4+1;        END;        IF (I and PTR3) THEN J=SHR(I,1);   /* IF ODD, THEN ROUND DOWN - CAN REMOVE */        ELSE             J=SHR(I+1,1); /* ELSE MUST REMOVE 1 WORD FOR 1 BYTE */        NPTR1=NPTR1-J; PTR3=PTR3-I; /* UPDATE POINTERS */      END; /* OF SHORTER STRING */      DO I=0 TO STR2(0)-1; CALL PBYTE(FBUF,PTR2+I,BYTE(STR2,I)); END; /* COPY IN NEW STRING */      IF STR1(0)<>STR2(0) THEN DO; /* IF FILE LENGTH CHANGED, UPDATE NULLS */        CALL PBYTE(FBUF,PTR3,0); /* STORE FINAL ZERO */        IF (PTR3+1) THEN CALL PBYTE(FBUF,PTR3+1,0); /* ZERO UPPER HALF IF SO */      END;      COUNT=COUNT+1; /* COUNT IT */      SAVED=0; STORED=0; /* INDICATE FILE ALTERED */      BPTR=PTR2+STR2(0); /* SET BYTE PTR AFTER REP STRING */      IF ARG1=(-1) THEN DO; PTR2=(-1); ARG2=(-2); END; /* FORCE TERMINATION */      ELSE              PTR2=POS(STR1,BPTR); /* CHECK FOR NEXT OCCURRENCE */    END; /* OF LOOP OVER OCCURRENCES IN LINE */    PTR1=NPTR1; /* MOVE PTR1 AHEAD TO NEXT LINE */    IF CODE<>0 THEN DO; /* IF REPLACE */      BALT=1; /* INDICATE FILE ALTERED */      IF (PTR-PTR1) IGT 512 THEN CALL DELETE.WORDS(PTR-PTR1); /* CLEAR UP MEM USAGE */    END;  END; /* OF LOOP UNTIL SECOND LINE */  IF (NOT.END) THEN GOTO NEXTARG; /* LOOP BACK IF MORE ARG CLAUSES */  IF CODE<>0 THEN DO; /* CLEAN UP IF REPLACE */    IF PTR IGT PTR1 THEN CALL DELETE.WORDS(PTR-PTR1); /* FIX UP FILE */    CALL BFORCE; /* FORCE IF REQUIRED */  END;  CALL NEWLINE;  IF COUNT=0 THEN DO; /* NO OCCURRENCES FOUND */    CALL PSTRINGR ('String not found'); RETURN 1;  END;  ELSE DO; /* PRINT NUMBER FOUND */    CALL PDEC(0,COUNT,0);    IF CODE=0 THEN CALL PSTRINGR (' lines found');    ELSE           CALL PSTRINGR (' changes made');  END;  RETURN 0; /* OK */END GLOBAL;/* $SUBTITLE Help Routine */help:  proc(str) returns (boolean);   dcl str   fixed array; /* contains key word to search for */   dcl (ms_sec,ls_sec) fixed; /* starting sector location of a file */   dcl flen  fixed; /* length of a file in words */   dcl chunk fixed; /* index of a 1024-word chunk of a file */   dcl key.marker  lit '(a.dollar or shl(a.dollar,8))'; /* marks keyword */   dcl page.marker lit '(a.dollar or shl(a.P,8))'; /* marks page break */   get.word:  proc(i) returns (fixed); /* get specified word from file */      dcl i       fixed; /* word in file to get */      dcl (MS,LS) fixed;      if shr(i,10) <> chunk then do; /* divide index by 1024 to find chunk this word is in */         chunk = shr(i,10); /* new chunk needed */         MS = ms_sec; /* calculate sector address of new chunk */         LS = ls_sec + shl(chunk,2); /* NOTE: each chunk is 4 sectors long */         if LS ilt ls_sec then MS = MS + 1;         call readdata(MS,LS,cbuf,1024); /* read in new chunk */      end;      return (cbuf(i and "H3FF")); /* return word */   end get.word;   find.keyword:  proc(target) returns (fixed); /* searches index file for keyword and returns location of keyword in help text file */      dcl target fixed array; /* target string to search for */      dcl tlen   fixed; /* length of target string in words */      dcl index  fixed; /* index of keyword in .HELP file */      dcl found  boolean; /* TRUE if target keyword found */      dcl (i,j)  fixed;         /* Set global file variables */      ms_sec = core(loc.p2 + 1); /* beginning sector of index file */      ls_sec = core(loc.p2);      flen   = core(loc.p2 - 1); /* length of index file in words */      chunk  = -1; /* force first chunk to be read */      tlen = shr(target(0) + 1,1); /* length of target in words (rounded up) */      index = -1; /* index not found yet */      i = 0; /* start at first word of file */      found = FALSE; /* have not found keyword yet */      do while (i ilt flen) and (not found); /* search for keyword until found or end of file reached */         do while (i ilt flen) and (get.word(i) <> key.marker); /* search for key word marker */            i = i + 1;         end;         if (i ilt flen) then do; /* found a keyword */            if (i + tlen) ilt flen then do; /* not at end of file */               j = 1; /* start at first word in pattern */               do while (j < tlen) and (get.word(i + j) = target(j)); /* see if this keyword matches target */                  j = j + 1; /* next word in pattern */               end;               if j = tlen then do; /* possible match */                  if (target(0) and "1") = 0 /* even number of characters in pattern */                  then found = (get.word(i + j) = target(j));                  else found = ( (get.word(i + j) and "HFF") = (target(j) and "HFF") );                  if found then do; /* keyword found, so get word location in .HELP file */                     do while shr(get.word(i + j),8) <> 0; /* search for EOLN marker */                        j = j + 1;                     end;                     index = get.word(i + j + 1); /* word location of keyword in .HELP file */                  end;               end; /* of possible match */            end; /* of not at EOF */         end; /* of keyword found */         i = i + 1; /* skip keyword marker */      end; /* of while keyword not found */      return (index); /* return index of keyword in help text file */   end find.keyword;   print.info:  proc(keyword,index); /* print the help information for this keyword */      dcl keyword fixed array; /* keyword for help */      dcl index   fixed; /* location of this keyword in the .HELP file */      dcl first   fixed; /* location of first page of help text */      dcl done    boolean; /* TRUE to continue showing text */      dcl (j,ch)  fixed;      continue:  proc returns (boolean); /* returns TRUE to continue displaying text */         dcl ch fixed;         ch = rchar; /* get a character */         if (ch = a.DEL) or (ch = a.rs) then do; /* go back to first page */            index = first - 1; /* set pointer back to first page */            return (FALSE); /* don't display next page */         end;         else if ch = 0 then do; /* hit break - stop listing */            done = TRUE; /* quit listing */            return (FALSE); /* don't display next page */         end;         else return(TRUE); /* display next page */      end continue;      /* set global file variables */      ms_sec = core(loc.p1 + 1); /* beginning sector of .HELP file */      ls_sec = core(loc.p1);       flen   = core(loc.p1 - 1); /* length of .HELP file in words */      chunk  = -1; /* force first chunk to be read */      keyword(0) = 0; /* zero-out keyword */      j = 0; done = FALSE;      do while not done; /* store keyword */         j = j + 1;         keyword(j) = get.word(index + j); /* get word from file */         if keyword(j) = 0 then done = TRUE; /* eoln */         else if shr(keyword(j),8) = 0 then do;            keyword(0) = keyword(0) + 1; /* one byte */            done = TRUE; /* eoln */         end;         else keyword(0) = keyword(0) + 2; /* two bytes */      end; /* of while keyword not stored */      index = index + j + 1; /* skip over keymarker and keyword */      first = index; /* save index location of first page */      done = false; /* not done yet */      do while (index ilt flen) and (not done); /* print out details for this command */         ch = get.word(index); /* get word */         if index = first then do; /* print header for first page */            call clearscreen;            call pstr (keyword); /* print keyword */            do j = keyword(0) + 1 to 74; call pchar(a.score); end; /* print dividing line */            call newline; linec = 1;         end;         else if ch = page.marker then do; /* start a new page */            do j = linec to 21; call newline; end; /* output remaining lines */            do j = 1 TO (74 - 25 - keyword(0)); call pchar(a.score); end; /* print bottom divider */            call pstr ('press RETURN for more on '); call pstr (keyword);            if continue then do; /* print header for next page if user wishes to continue */               call clearscreen; /* clear the screen */               call pstr ('more on '); call pstr (keyword);               do j = (9 + keyword(0)) to 74; call pchar(a.score); end; /* print top divider */            end;         end;         else if ch = key.marker then do; /* print last page */            do j = 1 to (74 - 22 - keyword(0)); call pchar(a.score); end;            call pstr ('end of information on '); call pstr (keyword);            if continue then done = TRUE; /* quit listing if they want */         end;         else do; /* print out character */            call pchar(ch); /* print first character */            ch = shr(ch,8); /* get second character */            if ch = 0 then do; /* end of line reached */               call newline; /* output a carriage return */               linec = linec + 1;               index = index + 1; /* skip line number on next line */            end;            else call pchar(ch); /* print second character */         end;         index = index + 1; /* next word */         if brkc then done = TRUE; /* TRUE if break key hit */      end;  /* of while not done displaying information */      call newline;   end print.info;   /**** Main Help Code ****/   if str(0) = 0 /* null keyword */   then chunk = find.keyword('HELP'); /* find help message */   else chunk = find.keyword(str); /* try to find this keyword in index file */   if chunk = -1 then return (FALSE); /* keyword not found */   call print.info(str,chunk); /* print the help information */   return (TRUE); /* success */end help;