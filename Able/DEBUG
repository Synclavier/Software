/* DEBUG   $TITLE  This is an XPL debugger!   Modified:   01/19/90 - MWH/CJ - Integrated with WHEN BREAK and new XPL compiler   03/24/89 - MWH - Author   */BEGIN;      /* PUT THIS WHOLE FILE IN A BLOCK! *//* $z Tell the XPL compiler to generate DEBUG-able model-D function calls *//* This routine is called on EVERY swap proc ENTRY and EXIT, when compiled   with the proper version of XPL, using the debug version of .RTD-7   On call, the registers contain:      R2 = Swap proc number      R3 = 0 if calling, 1 if returning from the proc      R12 points to a stack frame which looks like:          R4    <- first  arg, or return value          R5    <- second arg  or second return word          R6    <- third  arg          R7    <- fourth arg          R10          R11          [a low-level return address]          R4          R5          R6          R7          R10          R11   R12-> [free]*/insert ':-xpl:asciilit';dcl hop_breakpoint fixed;/* Some routines here are borrowed from :SYNSOU:DBUGMOD:DBUGSOU *//* (but made non-swapping!)                                     */INPUT.OCTAL: PROC RECURSIVE;          /* RETURNS OCTAL NUMBER */   DCL CH    FIXED;   DCL NUM   FIXED;   DCL SIGN  FIXED;   DCL FIRST BOOLEAN;   DCL ECHO  BOOLEAN;   PRINT '> ',;  /* NEED A STRING CONSTANT TO KEEP US IN INTERNAL MEMORY! */   NUM = 0;   SIGN = 1;   FIRST = TRUE;   CH = READ("050");                  /* GET A CHARACTER */   DO WHILE CH <> A.CR;      ECHO = TRUE;                    /* ASSUME WE ECHO IT */      IF      CH = A.MINUS AND FIRST = TRUE THEN SIGN = -1;      ELSE IF CH = A.PLUS  AND FIRST = TRUE THEN SIGN =  1;      ELSE IF CH >= A.0 AND CH <= A.7      THEN NUM = SHL(NUM,3) + (CH - A.0);      ELSE IF CH = A.DEL              /* DELETE A DIGIT */      AND NUM <> 0 THEN DO;         NUM = SHR(NUM,3);         WRITE("050") = A.BS;         WRITE("050") = A.SP;         WRITE("050") = A.BS;      END;      ELSE ECHO = FALSE;      FIRST = FALSE;      IF ECHO = TRUE      THEN WRITE("050") =CH;          /* ECHO CHARACTER */      CH = READ("050");               /* GET NEXT CHARACTER */   END;   PRINT;                             /* ECHO THE NEWLINE */   RETURN (NUM * SIGN);   END INPUT.OCTAL;ZAP.MEMORY: PROC RECURSIVE;           /* CHANGE ABLE MEMORY */   dcl format fixed;                  /* Zap format 0=OCTAL, 1=DECIMAL */   DCL I      FIXED;   DCL VAL    FIXED;   print 'ZAP format (0=Octal, 1=Decimal) [Octal]: ',;   input format;   PRINT 'ADDR(8): ',; I = INPUT.OCTAL;   PRINT OCTAL(I),' => ',;   IF FORMAT <> 0 THEN DO;      PRINT CORE(I),'(10)',;      PRINT '  NEW VALUE(10): ',;      INPUT VAL;   END;   ELSE DO;      PRINT OCTAL(CORE(I)),'(8)',;      PRINT '  NEW VALUE(8): ',;      VAL = INPUT.OCTAL;   END;      CORE(I) = VAL;   PRINT OCTAL(I),' => ',CORE(I),'(10), ',OCTAL(CORE(I)),'(8)';END ZAP.MEMORY;/* Borrowed from :mwh:sou:polydump and xmemdump tools */dump: proc recursive;   /* Literals, borrowed from :SYNLITS:GLOBLITS */   dcl MAM   lit '"60"';   dcl MAL   lit '"61"';   dcl MD    lit '"62"';   dcl MDI   lit '"63"';   /* Literals, borrowed from :SYNLITS:FCODLITS */   dcl PSRMA    lit '20';   dcl PSADEVSM lit '59';    /*  FC 59 - even stereo master           */   dcl PSC      lit '"155"';   dcl PSF      lit '"156"';   dcl PSD      lit '"157"';   dcl which      fixed;      /* Which memory to dump: 0=int, 1=ext, 2=poly */   dcl channel    fixed;      /* Poly bin number * 64 */   dcl page       fixed;      /* 4 bit page number; selects which 32 mb */   dcl first      fixed;      /* First sector to dump in "page" */   dcl last       fixed;      /* Last sector to dump */   dcl format     fixed;      /* Dump format 0=OCTAL, 1=DECIMAL */   dcl (i,j,k,w)  fixed;   dcl string (8) fixed;      /* Save characters to write out */   print;   which = 3;   do while which < 0 OR which > 2;      print 'Dump sector(s) of memory from (0=int, 1=ext, 2=poly): ',;      input which;   end;   print 'Dump format (0=Octal, 1=Decimal) [Octal]: ',;   input format;   if which = 2 then do;      i = -1;      do while (i < 0 OR i > 3);         print 'Enter bin number, 0-3 [0]: ',;         input i;      end;      channel = 64 * i;      page = -1;      do while (page < 0 OR page > 15);         print 'Enter page number, 0-15 [0]: ',;         input page;      end;   end;   if which = 0 then do;      print 'Location (8): ',;      first = input.octal;      last = first;   end;   else do;      print 'Starting sector:',;      if format = 0 then do;         first = input.octal;         print 'Ending sector [',octal(FIRST),']: ',;         last = input.octal;      end;      else do;         input first;         print 'Ending sector [',FIRST,']: ',;         input last;      end;      if last = 0 then last = first;   end;   if which = 1 then do;      /* Set up external memory hardware to start dumping where specified */      write(MAM) = first;        /* Sector */      write(MAL) = 0;            /* No offset */   end;   else if which = 2 then do;      /* Set up poly hardware to start dumping where specified */      write(PSC) = channel;      /* This PSC,PSF and next loop are critical! */      write(PSF) = PSADEVSM;     /* PSADC must be reset, or memory errors occur! */      do i=channel to channel+30 by 2;         write(PSC) = i;         write(PSD) = 0;         /* Reset stereo masters */      end;      write(PSC) = channel;      /* Which bin - 64 * bin number */      write(PSF) = PSRMA;        /* Read function code */      write(PSD) = first;        /* Sector */      write(PSD) = shl(page,8);  /* Starting page in upper byte */   end;   string(0) = 16;            /* 16 characters to print out */   do i=first to last;        /* PRINT IT OUT */      print;      if which = 0 then do;         print 'Location #',octal(i);      end;      else do;         print 'Sector #',;         if format = 0 then print octal(i);                       else print i;      end;      do j=0 to 255 by 8;         if which = 0 then do;            print octal(first+j),': ',;         end;         else do;            if format = 0 then print octal(j),': ',;                          else print j,': ',;         end;         do k=1 to 8;            if      which = 0 then w = core(i+(k-1)+j);            else if which = 1 then w = read(MDI);            else                   w = read(PSD);            if format = 0 then print octal(w),' ',;                          else print w,' ',;            string(k) = w;         end;         do k=0 to 15;            if byte(string,k) > "37" & byte(string,k) < "177"            then print chr(byte(string,k)),;            else print '.',;         end;         print;         /* Allow user to halt here */         begin;            dcl xpl.trap fixed external;    /* Break out if this is set */            dcl (i,j) fixed;            xpl.trap = 0;            enable;            do i=1 to 5000;               j = i + 1;            end;            disable;            if xpl.trap <> 0 then do;               xpl.trap = 0;               return;                      /* Bail out! */            end;         end;      end;   end;     /* END OF PRINT IT OUT */end dump;/* Interact with the user */debug_prompt: proc recursive;   dcl xpl.trap      fixed external;    /* Halt if this is set */   dcl ch            fixed;   dcl i             fixed;   dcl arg(10)       fixed;   print 'Enter command (? for help)';   print '=]> ',;   linput arg;                        /* So get it if none on command line */   arg(0) = arg(0) - 1;               /* Remove <CR> at end of line */   ch = arg(1) & "137";               /* Get first character in upper case */   if ch = "37" then do;              /* ? */      print;      print 'Commands:';      print 'B = Set Breakpoint (-1 halts at ALL, -2 logs calls/returns)';      print 'C = Clear Breakpoint';      print 'D = Dump memory';      print 'H = Break on HOP only';      print 'I = Info';      print 'P = Proceed';      print 'S = Single Step';      print 'T = Break on terminal';      print 'X = Exit';      print 'Z = Zap memory';      return(0);   end;   else if ch = a.b then do;          /* B */      print 'Swap proc # (octal) for breakpoint:';      i = input.octal;      core(0) = i;      if hop_breakpoint = 1 then print 'on HOP only';      return(0);   end;   else if ch = a.c then do;          /* C */      print 'CLR';      core(0) = 0;      return(0);   end;   else if ch = a.d then do;          /* D */      call dump;      return(0);   end;   else if ch = a.p then do;          /* P */      return(1);   end;   else if ch = a.h then do;          /* H */      print 'HOP';      hop_breakpoint = 1;      return(0);   end;   else if ch = a.i then do;          /* I */      return(-1);   end;   else if ch = a.s then do;          /* S */      xpl.trap = 1;      return(1);   end;   else if ch = a.t then do;          /* T */      print 'TTY';      hop_breakpoint = 0;      return(0);   end;   else if ch = a.x then do;          /* X */      call exit(-1);   end;   else if ch = a.z then do;          /* Z */      call zap.memory;      return(0);   end;   return(0);end debug_prompt;when break then begin;   dcl xpl.trap  fixed external;    /* Halt if this is set */   dcl proc_num   fixed static;     /* MUST be static */   dcl returning  fixed static;     /* MUST be static */   dcl i          fixed;   dcl arg1       fixed;            /* Function calling arguments */   dcl arg2       fixed;   dcl arg3       fixed;   dcl arg4       fixed;   dcl ret1       lit 'arg1';       /* Function return value */   dcl ret2       lit 'arg2';   disable;   proc_num  = read("302");   returning = read("303");   /* This is necessary to make the compiler unsure of how many registers */   /* to save, so it will save all of them.  We do this to know how the   */   /* stack will look as we go back after the function args/return value. */   goto xxxxzzzz;xxxxzzzz:;   arg1 = core(read("312") + 13);   arg2 = core(read("312") + 12);   arg3 = core(read("312") + 11);   arg4 = core(read("312") + 10);   /*****************************************************************/   /* Now that we have the values we need, the debugger begins here */   /*****************************************************************/   if (returning = 0) then do;     /* Entering the procedure */      if (core(0) = proc_num)      /* Halt on this call */      OR (core(0) = -1)            /* Halt on all calls */      then do;         if (hop_breakpoint = 1) then do;            write("300") = arg1;            write("301") = arg2;            write("302") = arg3;            write("303") = arg4;            write("000") = proc_num;       /* HALT!  proc number on HOP */         end;         else xpl.trap = 1;      end;      else if (core(0) = -2) then do;   /* Log all calls on the screen */         print;         print 'I@',octal(proc_num),arg1,arg2,arg3,arg4,;      end;   end;   else do;                        /* Exiting the procedure */      if (core(0) = proc_num)      /* Halt on this call */      OR (core(0) = -1)            /* Halt on all calls */      then do;         if (hop_breakpoint = 1) then do;            write("300") = ret1;            write("313") = ret2;            write("000") = proc_num | "100000";  /* HALT!  proc number on HOP */         end;         else xpl.trap = 1;      end;      else if (core(0) = -2) then do;   /* Log all returns on the screen */         print;         print 'O@',octal(proc_num),ret1,;      end;   end;   if (xpl.trap <> 0) then do;     /* This is the user interaction section */      xpl.trap = 0;                /* Clear flag so we don't always stop   */      i = -1;      do while i <= 0;         if i = -1 then do;            print;            print 'XPL breakpoint at proc #',octal(proc_num),;            if returning = 0 then print '   Entry: ',arg1,arg2,arg3,arg4;            else                  print '   Exit:  ',ret1;            print 'Current breakpoint at proc #',octal(core(0)),;            if hop_breakpoint = 0 then print '   On TTY';            else                       print '   On HOP only';         end;         i = debug_prompt;      end;   end;   enable;end;END;  /* OF WHOLE BLOCK */