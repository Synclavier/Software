/* 61-FILTR  $TITLE  Main Program for Fast Convolution *//* Copyright 1985 by New England Digital Corporation *//* Based on FASTFILT ("Programs for Digital Signal Processing",   IEEE Press, 1979.  This main program is overlayed by the Signal    File Manager (.SFM-4) and is located in .FIL-4.   Upper memory location LOC.RST is used to pass status information   between the programs; SFM will place a 4 there if convolution is    desired, a 5 for correlation; otherwise the program will stop    (for example, if it is run by the monitor).   On return LOC.RST will be 4 if the run is successful, 3 if an   overflow error occurred, 4 if BREAK pressed, and -1 if a system   error occurred.   Calls to the catalog routines are not made by Convolve; 3 files   are passed by SFM, an input file (file1), an output file (file2)    and the impulse response file (file3).  The program first checks   that the files are there. */dcl in.main.module lit '0';dcl sector.size    lit '256';dcl buf1.len       lit '0'; /* not used - needed by compiler */dcl fscale         fixed; 	/* scale factor for filter */insert ':-xpl:literals'; 	/* system literals */insert ':-xpl:asciilit'; 	/* ASCII literals */insert ':-xpl:catrtns';  	/* catalog routines */insert ':-xpl:scsi';     	/* SCSI device drivers */insert ':-xpl:strings'; 	/* string functions */insert ':-xpl:intrprtr';	/* interpreter interface */insert ':sfmcat:00-sfm';   /* SFM upper memory definitions and overlay routine */insert ':sfmcat:01-io';insert ':sfmcat:02-plot';insert ':sfmcat:04-angle'; /* fast sine/cosine routine */ insert ':sfmcat:04-ifast';insert ':sfmcat:05-ifsst';insert ':sfmcat:06-globl'; insert ':sfmcat:07-util';insert ':sfmcat:60-rfilt';dcl i fixed;mem.siz=memory.size; /* look up configured memory size */enable;if (core(loc.rst)<>4) and (core(loc.rst)<>5) then do; /* invalid invocation */   psr('Filtering may only be invoked through SFM');    call tty_wait; /* allow chars to be printed before quitting */   call exit(-1);end;i=core(c#contab+c#vstart)+core(c#contab+c#vlngth)+core(c#contab+c#stklen);if i IGE ((60*1024)-1928) then do;   /* this check will catch errors where the program is too large for 60K systems */   clear;   ps('SYSTEM PROGRAMMING ERROR:  This module of SFM is too large to run.');   call tty_wait; call exit(-1); /* quit with stop status */end;/* nmax, the fft length, is declared in 06-globl */ dcl nmaxd2       lit '(nmax/2)'; /* max impulse length */dcl fmsb(nmax+1) fixed; dcl flsb(nmax+1) fixed;dcl rmsb(nmax+1) fixed;dcl rlsb(nmax+1) fixed;dcl smsb(nmaxd2) fixed;dcl slsb(nmaxd2) fixed;dcl np              fixed; /* impulse response length */dcl (fftlen,fftd2)  fixed;dcl pointr(2)       fixed; /* point to input file location */dcl disk.pointer(2) fixed; /* point to sector on disk */dcl length(2)       fixed; dcl (j,temp,n)      fixed;file1;   if f.name.bytes=0 then error.flag=-1; /* system error; input file missing */file2;if compare(f.name,recordfile.name)<>1 then error.flag=-1; /* system error; output file missing */file3; /* impulse response file */if f.name.bytes=0 then error.flag=-1; /* system error *//* NOTE: This check blows up if VALID.DATA(1) > 255 !!! */np=core(valid.data+1)*sector.size+core(valid.data+2); /* compute length */if np IGT nmaxd2 then do; /* impulse too long */   np=nmaxd2;   ps('Impulse response truncated to '); pnum(nmaxd2); psr(' points');end;fftd2=256;do while (fftd2<nmaxd2) and (fftd2<np); fftd2=shl(fftd2,1); end;fftlen=shl(fftd2,1);length(0)=0; length(1)=shr(fftd2,8); length(2)=0;call readdata(core(sintable.dev),core(sintable.loc),location(sintable),sintable.len+intpol.len+1); /* read sine table */if error.flag=0 then do; /* read in impulse response */        psr('Computing filter frequency response');   call readdata(core(f.data.index),core(f.data.index+1),fmsb,np);   do i=np to fftlen+1;      fmsb(i)=0; /* zero most significant bits beyond np */      rmsb(i)=0;   end;   do i=0 to fftlen+1;      flsb(i)=0;  /* zero all least sig. bits */      rlsb(i)=0;   end;end;if core(loc.rst)=5 then do i=0 to np/2-1; /* reverse impulse response to correlate */   j=np-i-1;   temp=fmsb(j);   fmsb(j)=fmsb(i);   fmsb(i)=temp;end;/* now actually compute impulse response of filter in frequency domain */rescale=0;call normalize1(fmsb,flsb,fftlen,15);if error.flag=0 then if ifast(fmsb,flsb,fftlen) then error.flag=-1; call normalize1(fmsb,flsb,fftlen+1,15);fscale=rescale+gain.exponent;      file1;call print_digits(core(valid.data),3);call pc(a.sp);call print_digits(core(valid.data+1),5);psr(' sectors to filter');nl;psr('Filtering sector:');call tty_wait; /* let all of message print before continuing */call copy_vector(pointr,zero.vector,3); /* initialize */do while (compare_vectors(pointr,location(valid.data),3)<0)and (break.rcvd=0); /* main filter loop */   /* keep something happening on screen */   call pc(a.cr); call print_digits(pointr(0),3); call pc(a.sp);   call print_digits(pointr(1),5);   call tty_wait; /* let all of message print before continuing */   call sub_len_from_len(location(valid.data),pointr,disk.pointer);   if   compare_vectors(disk.pointer,length,3)>0 then n=fftd2; /* haven't reached end */   else n=disk.pointer(1)*sector.size+disk.pointer(2); /* actual length of data */   call add_len_to_addr(pointr,location(f.data.index),disk.pointer); /* starting sectors */   if n>0 then do;        call readdata(disk.pointer(0),disk.pointer(1),rmsb,n); /* read in data */      do i=n to fftd2-1; /* zero rest of buffer if at end of file */         rmsb(i)=0;       end;      do i=0 to fftd2-1; /* zero lsb's */         rlsb(i)=0;      end;         if rfilt(rmsb,rlsb,fmsb,flsb,smsb,slsb,fftd2) then do;         psr(' OVERFLOW (press BREAK to quit filtering)');         call tty_wait; /* let all of message print before continuing */         error.flag=4; /* overflow */      end;      file2; /* output file */         call add_len_to_addr(pointr,location(f.data.index),disk.pointer);      if n=fftd2      then call writedata(disk.pointer(0),disk.pointer(1),rmsb,fftd2); /* write data */      else call writedata(disk.pointer(0),disk.pointer(1),rmsb,n+np);   end;     else do; /* end of data, just append tail */      file2;      call add_len_to_addr(pointr,location(f.data.index),disk.pointer);      call writedata(disk.pointer(0),disk.pointer(1),location(addr(rmsb(np))),np);   end;   call add_len_to_len(length,pointr,pointr); /* increment pointer */   file1;end; /* of main file loop */if (error.flag=0) or (error.flag=4) then core(loc.rst)=3; /* success */else                                     core(loc.rst)=error.flag;disable;sfm.intact=1; /* means high-core info is still valid */ovl.error=error.flag;call overlay(core(loc.p1+1),core(loc.p1),core(loc.p1-1)); /* return to main module of SFM */