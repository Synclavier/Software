/* 24-MODUL  $TITLE  Routine to Modulate by a Sine Wave *//* Copyright 1985 by New England Digital Corporation */modulate: proc fixed; /* perform modulation */   dcl freq    floating; /* given frequency */   dcl temp(2) fixed;   dcl (t1,t2) fixed;   mod:proc; /* subproc for actual data updates */      dcl in.start  (2)     fixed; /* starting sector */      dcl out.start (2)     fixed;      dcl sectors   (2)     fixed;      dcl (inc.msb,inc.lsb) fixed;      dcl (msb,lsb)         fixed;      dcl (count,new.count) fixed;      dcl (min,max)         fixed;      dcl (lim,base,i,j,k)  fixed;      dcl mul1     lit 'write(5)=imsb1;write(6)=imsb2;omsb=read(4);olsb=read(5);';      dcl mul2     lit 'if imsb1<0 then omsb=omsb-imsb2;';      dcl mul3     lit 'if imsb2<0 then omsb=omsb-imsb1;';      dcl multiply lit 'mul1;mul2;mul3;';                      freq=freq*65.536*period.index/clock.rate; /* compute phase increment */      inc.msb=int(freq);      inc.lsb=int(65536.*(freq-inc.msb));      /* copy file offsets into appropriate vars */      file2;      call copy_vector(out.start,location(f.data.index),3);      file1;      call copy_vector(in.start, location(f.data.index),3);      msb=0; lsb=0; /* start phase at zero */      call copy_vector(sectors,location(valid.data),3);      count=0; /* count of sectors processed */      max=(-32768); min=32767; /* preset max check limits */      if sectors(2)>0 then call add_len_to_len(zero.one.zero,sectors,sectors); /* add fractional part */      sectors(2)=0; /* remove fractional part */            do while (not break.rcvd)      and (compare_vectors(sectors,zero.vector,3)>0); /* loop over sectors */         lim=sectors(1); /* get length to process */         if lim>buf1.len then lim=buf1.len; /* limit to buffer size */         call readdata(in.start(0),in.start(1),databuf1,shl(lim,8));         do i=0 to lim*sector.size-1; /* loop over samples in buffer */            k=databuf1(i); /* get input sample */            call angle(msb); /* get sine of current phase adder */            lsb=inc.lsb+lsb; /* update phase adder */            msb=inc.msb+msb;            if lsb ILT inc.lsb then msb=msb+1;            begin; /* multiply sine value by data value */               dcl (omsb,olsb) fixed;               dcl imsb1       lit 'sine';               dcl imsb2       lit 'k';               multiply;               k=shl(omsb,1)\((olsb&"100000")<>0); /* form modulated result */            end;            if (i&"3")=0 then do; /* check min & max every 4 samples */               if #greater(k,max) then max=k; /* update the max */               if #greater(min,k) then min=k; /* update the min */            end;            if (i&"377")="377" then do; /* at end of sector */               count=count+1; /* count sectors */               if (count&"3")=0 then do; /* time for plot */                  call plot_env(min,max); /* plot the envelope segment */                  max=(-32768); min=32767; /* reset limits */               end;            end; /* of sector end processing */            databuf1(i)=k; /* store modulated result */         end; /* of loop over samples */         call writedata(out.start(0),out.start(1),databuf1,shl(lim,8));         temp(0)=0; temp(1)=lim; temp(2)=0; /* number of sectors read */         call add_len_to_addr(temp,in.start ,in.start ); /* incr file pointers */         call add_len_to_addr(temp,out.start,out.start);         if sub_len_from_len(sectors,temp,temp) then do; /* decr sectors left */            temp(0)=0; temp(1)=0; temp(2)=0;            error.flag=0; /* suppress error flag */         end;         call copy_vector(sectors,temp,3);      end; /* of loop over sectors */   end mod;   /* main code of MODULATE */   file1;   call copy_vector(temp,location(valid.data),3);   t1=file.data.type; /* get parameters of input file */   t2=period.index;   file2;   if new_file(temp) then return 1; /* open file to hold the extracted data */   file.data.type=t1\modulated.data; /* store parameters into output file */   period.index=t2;   call copy_vector(location(valid.data),temp,3);   call sub_len_from_len(location(valid.data),zero.zero.one,location(data.end));    call index_to_time(location(data.end),location(data.end),period.index);   call add_symbol(zero.vector,'Origin'); /* create basic symbols of output file */   call add_symbol(location(data.end),'End');   call copy_vector(mark.start,zero.vector,3);   call copy_vector(mark.end,location(data.end),3);   call caption_assign('Modulated data');   clear; /* clear screen and print prompt */   call pos(5,1);   ps('Input modulation frequency ');    call tty_wait; /* wait for ps to finish */   input freq;      call initialize_env(location(data.end),0); /* prepare for envelope display */   call mod; /* perform modulation operation */   call pixel_and_port(cursor.time); /* find cursor position */   call env_cursor(x.pixel,port.number); /* put cursor on plot */   break.rcvd=0;   transparent_mode;   record.flag=0;   call old(recordfile.name); /* call up the file */   call set_scale; /* load attack buffer */end modulate;