/* 41-GEN  $TITLE  Function Generation Routines *//* Copyright 1985 by New England Digital Corporation */dcl (randomlsb,randommsb) fixed; /* seed for random number generator */randomgen:proc fixed; /* returns random deviate -32768 to 32767 */  /*  A linear congruential generator with multiplier 16807 and modulus      2**31-1.  These are the same values as the IMSL routine GGUBS,      and the same logic is used, but RANDOMGEN is implemented in       fixed point.  RANDOMMSB and RANDOMLSB are the most and least       significant bits of the seed. */   dcl root lit '16807';   dcl msb  lit 'randommsb';   dcl lsb  lit 'randomlsb';   dcl x    fixed;   write(5)=root;   write(6)=lsb;   x=read(4);   lsb=read(5);   write(5)=root;   write(6)=msb;   msb=x+read(5);   if msb ilt read(5) then x=shl(read(4)+1,1); /* carry */   else                    x=shl(read(4),1);  /* no carry */   x=x+((msb&"100000")<>0); /* add most sig. bit of msb */   lsb=lsb+x; /* adjust modulus by multiple of 2**31-1 */   if lsb ilt x then msb=msb+1; /* carry */   msb=msb&"077777"; /* mod 2**31 */   return (shl(msb,1)+((lsb&"100000")<>0));end randomgen;/* initialize seed to 123457 */randommsb=1;randomlsb=57921;add_spectrum:proc(name,imp) fixed; /* convert from freq domain to time domain file */   dcl name      fixed array; /* file with the spectrum */   dcl imp       fixed; /* 1=impulse response; 0=autocorrelation, 2=cepstrum */   dcl temp(2)   fixed;   dcl (len,i)   fixed;   dcl ms.st.sec fixed;   dcl ls.st.sec fixed;   convert:proc(buf1msb,buf1lsb,buf2,len); /* convert fixed array to floating */      dcl buf2    floating array;      dcl buf1msb fixed array;      dcl buf1lsb fixed array;      dcl len     fixed;      dcl i       fixed;      dcl fp      floating;            do i=0 to len+1; buf1msb(i)=0; buf1lsb(i)=0; end;      do i=0 to len/2; /* convert to block floating point; there are len/2+1 fp words  */        do case imp;           do; /* 0:  autocorrelation */              fp=32767.*buf2(i);              rescale=0;           end;           do; /* 1:  generate impulse response, take magnitude, center */              rescale=1;              fp=16384.*sqr(buf2(i));              if i then fp=-fp; /* to center */           end;           do;  /* 2:  cepstrum */              rescale=0;              fp=buf2(i);               if fp=0. then fp=-32768.;              else          fp=100.*log(fp);           end;        end; /* do case imp */        buf1msb(2*i)=int(fp);        buf1lsb(2*i)=int(65536.*(fp-buf1msb(2*i)));      end; /* of loop over samples */   end convert;   file1;   if name(0)=0 then call assign(name,'.SPECTRU');   if not locate(name,1) then do;      error.flag=e.not.saved;      return 1;   end;   ms.st.sec=f#ms_sector;   ls.st.sec=f#ls_sector;   if f#type<>t#spect then do;      error.flag=e.not.spec.file;      return 1;   end;   call readdata(ms.st.sec,ls.st.sec,databuf1,256);   if compatibility.number<>databuf1(0) then do;      error.flag=e.sys.error;      return 1;   end;   len=databuf1(1);   temp(0)=0;   temp(1)=len/256;   temp(2)=0;   if len igt 8192 then do; error.flag=e.window.length; return 1; end;    if new_file(temp) then return 1; /* open file to put data in not enough room */   clear;   call pos(10,1);   psr('Computing inverse spectrum');   if ls.st.sec+1=0 then i=1; else i=0; /* carry if necessary */   call readdata(ms.st.sec+i,ls.st.sec+1,databuf2,len);   databuf2(len)=databuf1(254);   databuf2(len+1)=databuf1(255); /* last fp word in file */   file.data.type=created.data;   period.index=current.per.index;   call copy_vector(location(valid.data),temp,3);   call sub_len_from_len(location(valid.data),zero.zero.one,location(data.end));    call index_to_time(location(data.end),location(data.end),period.index);   call add_symbol(zero.vector,'Origin');   call add_symbol(location(data.end),'End');   call copy_vector(mark.start,zero.vector,3);   call copy_vector(mark.end,location(data.end),3);   do case imp;      call caption_assign('Autocorrelation');      call caption_assign('Impulse response from spectrum');      call caption_assign('Cepstrum');   end;   call convert(databuf1,location(addr(databuf1(len+2))),location(addr(databuf2(0))),len);   call ifsst(databuf1,location(addr(databuf1(len+2))),len);   call normalize1(databuf1,location(addr(databuf1(len+2))),len,15);   gain.exponent=rescale;   if imp=1 then do; /* apply data window */      ps('Select spectral window:  0=boxcar, 1=hanning, 2=hamming');      call tty_wait;      disable;      input i;      call data_window(databuf1,location(addr(databuf1(len+2))),len,i,len);      enable;   end;   call writedata(core(f.data.index),core(f.data.index+1),databuf1,len);   return 0;end add_spectrum;design:proc(len); /* design filter in freq domain */   dcl len         fixed; /* length of impulse response, a power of 2 */                     dcl (lim0,mag0) fixed;   dcl (lim1,mag1) fixed;   dcl lim3        fixed;   dcl width       fixed;   dcl notch       fixed;   dcl (in1,in2)   floating;   dcl flag        fixed;   dcl type        fixed; /* type of filter */   dcl (i,j)       fixed;   call set_scroll(1,24);   restore.flag=0;   clear;   psr('FIR linear-phase filter design program');   psr('Enter:');   psr('  0 for general transfer function');    psr('  1 for pass bands');    psr('  2 for stop bands');    psr('  3 for comb ');   call tty_wait;   disable;    input type;   enable;   do case type; /* do the right thing */      do; /* 0:  general transfer function */         ps('Type 0 for linear magnitudes (0 to 1.0) or 1 for log (0 to -100 db)');         call tty_wait;         disable;          input flag;         enable;         psr('type frequency (0 to 20000 Hz) and magnitude ');         psr('type negative frequency to stop ');         call tty_wait;         do i=0 to len-1; /* zero buffers */            databuf1(i)=0;            databuf1(i+len+2)=0; /* lsb's */         end;         in1=0; lim0=0; mag0=0;         do while in1>=0; /* loop over range */            disable;            input in1,in2;            enable;            lim1=int(in1*len*period.index/clock.rate/1000.+0.5);            if (lim1>0) and (lim1<=len/2) then do; /* if point within limits */               if flag then do;                  if in2>0. then in2=-in2; /* don't allow positive attenuation */                  in2=32768.*exp(in2*log(10.)/20.);               end;                 else in2=32768.*in2;               if in2>=32768. then in2=32767;               if in2<-32768. then in2=-32768;               mag1=int(in2);               do i=lim0 to lim1;                  databuf1(2*i)=mag0+(i-lim0)*(mag1-mag0)/(lim1-lim0);               end;            end; /* of point within limits */            mag0=mag1;            lim0=lim1;         end; /* of loop over range */      end; /* of general transfer function */      do; /* 1:  pass band */         psr('Type lower and upper edge frequencies of pass bands');         psr('type "0,0" to  stop ');         call tty_wait;         do i=0 to len-1; /* zero buffers */            databuf1(i)=0;            databuf1(i+len+2)=0; /* lsb's */         end;         disable;          input in1,in2;         enable;         do while (in1<>0) or (in2<>0); /* loop while points in range */            lim0=int(in1*len*period.index/clock.rate/1000.+0.5);            lim1=int(in2*len*period.index/clock.rate/1000.+0.5);            if (lim0<0)\(lim1<0)\(lim1<=lim0)\(lim1>len/2) then psr('ERROR - repeat');            else do i=lim0 to lim1;               databuf1(2*i)=32767;            end;            disable;            input in1,in2;            enable;         end; /* of do while */      end; /* of pass band */      do; /* 2:  stop bands */         psr('Type lower and upper edge frequencies of stop bands');         psr('type "0,0" to  stop ');         call tty_wait;         do i=0 to len-1; /* initialize buffers */            databuf1(i)=0;            databuf1(i+len+2)=0; /* lsb's */         end;         do i=0 to 4*len/5-1;             databuf1(2*i)=32767;         end;         disable;         input in1,in2;         enable;         do while (in1<>0) or (in2<>0); /* loop while in range */            lim1=int(in2*len*period.index/clock.rate/1000.+0.5);            lim0=int(in1*len*period.index/clock.rate/1000.+0.5);            if (lim0<0)\(lim1<0)\(lim1<=lim0)\(lim1>len/2) then do;               psr('ERROR - repeat'); call tty_wait;            end;            else do i=lim0 to lim1;               databuf1(2*i)=0;            end;            disable;            input in1,in2;            enable;         end; /* of do while */      end; /* of stop bands */      do; /* 3:  comb filter */         do i=0 to len-1; /* zero buffers */            databuf1(i)=0;            databuf1(i+len+2)=0; /* lsb's */         end;         ps('Total Bandwidth');         call tty_wait;         disable;         input in1;         enable;         lim3=int(in1*len*period.index/clock.rate/1000.+0.5);         ps('Enter 0 for passbands, 1 for notches');         call tty_wait;         disable;         input notch;         enable;         in2=in1+1; /* preset condition */         do while in2>in1; /* loop until valid entry */            ps('Fundamental center frequency and Band width');            call tty_wait;            disable;            input in1,in2;            enable;            in2=in2/2;            if in2>in1 then do;                psr('Bandwidth cannot be greater than center frequency.  Try again.');                call tty_wait;            end;         end;         if notch then do i=0 to lim3-1; databuf1(2*i)=32767; end;         lim0=int((in1-in2)*len*period.index/clock.rate/1000.+0.5);         i=1;                      do while lim0 ilt lim3;            lim1=int((in1*i+in2)*len*period.index/clock.rate/1000.+.5);            if lim1 ile lim3 then do j=lim0 to lim1;              if notch then databuf1(2*j)=0;                 else          databuf1(2*j)=32767;              end;                       i=i+1;                     lim0=int((in1*i-in2)*len*period.index/clock.rate/1000.+0.5);         end;      end; /* of comb filter */   end; /* of do case */   do i=0 to len+1; /* alternate signs */      if i/2 then databuf1(i)=-databuf1(i);   end;   rescale=0;   call ifsst(databuf1,location(addr(databuf1(len+2))),len);   call normalize1(databuf1,location(addr(databuf1(len+2))),len,15);   gain.exponent=rescale;   ps('Input spectral window type:  0=boxcar, 1=hanning, 2=hamming ');   call tty_wait;   disable;   input i;   enable;   call data_window(databuf1,location(addr(databuf1(len+2))),len,i,len);end design;add_function:proc(start,stop,function) fixed; /* add a wave form into sound file */  dcl start       fixed array; /* start time vector */  dcl stop        fixed array; /* end   time vector */  dcl function    fixed; /* function code  */  dcl (len,lim)   fixed;    dcl last        fixed;  dcl length(2)   fixed;  dcl origin(2)   fixed; /* points to disk sector */  dcl coeff(25)   fixed; /* coeffs for fourier */  dcl nharms      fixed; /* count of highest non-zero harmonic */  dcl (mag,phase) floating;  dcl (phasemsb,phaselsb) fixed; /* accumulated phase (mod 65536) */  dcl (deltamsb,deltalsb) fixed; /* phase increment per sample */  dcl start.sector(2)     fixed; /* current time */  dcl i                   fixed;  add_random:proc(a,b); /* add in random noise */     dcl (a,b) fixed;     dcl i     fixed;     randomlsb=randomlsb xor milliseconds; /* reset seed */     do i=a to b-1;        databuf2(i)=databuf2(i)+2*(amplitude%randomgen);     end;  end add_random;  add_sine:proc(a,b); /* add in a sine wave */     dcl (a,b) fixed;     dcl i     fixed;     do i=a to b-1; /* loop over samples */        call angle(phasemsb);        databuf2(i) = databuf2(i) + 2*(sine%amplitude);        begin;           dcl omsb  lit 'phasemsb';           dcl olsb  lit 'phaselsb';           dcl imsb1 lit 'deltamsb';           dcl ilsb1 lit 'deltalsb';           dcl imsb2 lit 'phasemsb';           dcl ilsb2 lit 'phaselsb';           add;        end;     end;  end add_sine;  add_sqr:proc(a,b); /* add in a square wave */     dcl (a,b) fixed;     dcl i fixed;     do i=a to b-1; /* loop over samples */       begin;          dcl omsb lit 'phasemsb';          dcl olsb lit 'phaselsb';          dcl imsb1 lit 'deltamsb';          dcl ilsb1 lit 'deltalsb';          dcl imsb2 lit 'phasemsb';          dcl ilsb2 lit 'phaselsb';          add;       end;       if phasemsb>0 then databuf2(i)=databuf2(i)+amplitude;       else               databuf2(i)=databuf2(i)-amplitude;     end;  end add_sqr;  add_saw:proc(a,b); /* add in a sawtooth wave */     dcl (a,b) fixed;     dcl i     fixed;     do i=a to b-1; /* loop over samples */       begin;          dcl omsb  lit 'phasemsb';          dcl olsb  lit 'phaselsb';          dcl imsb1 lit 'deltamsb';          dcl ilsb1 lit 'deltalsb';          dcl imsb2 lit 'phasemsb';          dcl ilsb2 lit 'phaselsb';          add;       end;       databuf2(i)=databuf2(i)+2*(phasemsb%amplitude);     end;  end add_saw;  add_impulse:proc(a,b);     dcl (a,b)        fixed;     dcl (y,s)        floating;     dcl pi           lit '3.14159265';     dcl savesine     fixed;     dcl (delta,temp) fixed;     dcl i            fixed;     do i=a to b-1; /* loop over samples */        /* each time the phase accumulator carries, we compute the phase of the           numerator (sine(x)) of the sinc function; then for each sample,           pi radians is added to x, and the sign of sine(x) reverses.  */           if (phasemsb ilt deltamsb)        or ((phasemsb=deltamsb) and (phaselsb ilt deltalsb)) then do;           phase=(phasemsb-32768)+phaselsb/65536.;           if phaselsb<0 then phase=phase+1. ;           y=deltamsb +deltalsb/65536.;           if deltalsb<0 then y=y+1.;           phase=phase*pi/y;           s=sin(phase);        end;         else phase=phase+pi; /* add pi radians */        if abs(phase)<0.03 then databuf2(i)=databuf2(i)+amplitude;        else do; /* hanning windowed sinc */           temp=int(amplitude*s/phase);           call angle(phasemsb);                 cosine=32767-cosine;            write(5)=cosine;           write(6)=temp;           if temp<0 then databuf2(i)=databuf2(i)+read(4)-cosine;           else           databuf2(i)=databuf2(i)+read(4);         end;        s=-s; /* add pi radians */        begin; /* increment phase */           dcl omsb  lit 'phasemsb';           dcl olsb  lit 'phaselsb';           dcl imsb1 lit 'deltamsb';           dcl ilsb1 lit 'deltalsb';           dcl imsb2 lit 'phasemsb';           dcl ilsb2 lit 'phaselsb';           add;        end;     end; /* of loop over samples */  end add_impulse;  add_fourier:proc(a,b); /* add Fourier function */     dcl (a,b)     fixed;     dcl (msb,lsb) fixed;     dcl temp      fixed;     dcl (i,j)     fixed;     do i=a to b-1; /* loop over samples */        msb=phasemsb; /* store present phase */        lsb=phaselsb;        do j=0 to nharms-1; /* loop over harmonics */           if coeff(j)<>0 then do; /* non-zero harmonic */              call angle(msb);              write(5)=sine;              write(6)=coeff(j);              temp=read(4);              if sine<0 then temp=temp-coeff(j);              databuf2(i)=databuf2(i)+temp; /* add in to sum for this harmonic */           end; /* of non-zero harmonic */           begin; /* update phase */              dcl omsb  lit 'msb';              dcl olsb  lit 'lsb';              dcl imsb1 lit 'phasemsb';              dcl ilsb1 lit 'phaselsb';              dcl imsb2 lit 'msb';              dcl ilsb2 lit 'lsb';              add;          end;        end; /* if loop over harmonics */        begin;           dcl omsb  lit 'phasemsb';           dcl olsb  lit 'phaselsb';           dcl imsb1 lit 'deltamsb';           dcl ilsb1 lit 'deltalsb';           dcl imsb2 lit 'phasemsb';           dcl ilsb2 lit 'phaselsb';           add; /* add in to signal */        end;     end; /* of loop over samples */  end add_fourier;  /* $SUBTITLE  Main Code of ADD_FUNCTION */  file1;  if f.name.bytes=0 then do; /* no display file */     error.flag=e.no.file;     return 1;  end;  call time_to_index(start,start,period.index); /* cnvrt start and stop to index */  call time_to_index(stop,stop,period.index);    if (compare_vectors(stop,location(valid.data),3)>0) then call copy_vector(stop,location(valid.data),3);  if function=6 then do; /* prepare fourier series coefficients */     call set_scroll(1,24); /* use full screen for entry */     restore.flag=0;     clear;     psr('Create Fourier Series Function');     nl;     psr('Input harmonic number (1 to 25), magnitude (0.0 to 5.0 volts)');     psr('Enter negative harmonic number and magnitude to complete entry');     call tty_wait;     disable;     do i=0 to 25; coeff(i)=0; end; /* clear coeffs */     nharms=0; /* assume no non-zero harms */     input i,mag;      do while i>0; /* loop over input data pairs */        if (i>25) or (mag<0.) or (mag>5.0) then do; /* print error msg */           print 'Harmonic number or magnitude is out of range - try again';           /* since interrupts are off here, must use print */        end;        else do;           coeff(i-1)=int(mag*65535./5.0); /* store it */           if (mag>0) and (i>nharms) then nharms=i; /* update last non-zero */        end;        input i,mag;     end; /* of loop over input data */  end; /* of prepare fourier series coeffs */  else if function=7 then do; /* prepare for filter design */     call sub_len_from_len(stop,start,origin);     i=origin(1)*sector.size+origin(2);     if i IGT nmax/2 then i=nmax/2;     len=1;     do while len<i; len=len*2; end;     i=len/sector.size;     do while len IGT buf2.len*sector.size; len=len/2; end;     call design(len);  end; /* of prepare for filter design */    enable;  call copy_vector(location(addr(phase)),location(frequency),2);  phase=phase*65.536*current.per.index/clock.rate;  deltamsb=int(phase);  deltalsb=int(65536.*(phase-deltamsb));  phasemsb=0;  phaselsb=0;  restore.flag=0; /* call for screen rewrite after overlay */  clear;  ps('ADDING ');  do case function;     ; /* 0: not used */     ps('RANDOM DATA');      ps('A SINE WAVE');      ps('A SQUARE WAVE');     ps('A SAWTOOTH WAVE');      ps('IMPULSE FUNCTION');      ps('FOURIER SERIES FUNCTION');      ps('FREQUENCY FUNCTION');   end;  call pos(5,1);  psr('Please wait');  call tty_wait;  call print_digits(core(valid.data),3);  call pc(A.SP);  call print_digits(core(valid.data+1),5);  psr(' sectors to process');  nl;  psr('Processing sector:');  call copy_vector(origin,start,3); /* copy start to origin */  i=start(2); /* first sample to process */  do while (compare_vectors(stop,origin,3)>0); /* loop while there are sectors to process */     /* keep something happening on screen */     call pc(A.CR);     call print_digits(origin(0),3);     call pc(A.SP);     call print_digits(origin(1),5);     call sub_len_from_len(stop,origin,length); /* compute sectors left */     lim=length(1); /* determine size to read */     if length(2)>0  then lim=lim+1; /* account for fractional sectors */     if (lim>buf2.len) then lim=buf2.len; /* limit to buffer size */     last=lim*sector.size; /* number of samples to read */     call add_len_to_addr(origin,location(f.data.index),start.sector); /* add in file origin */     call readdata(start.sector(0),start.sector(1),databuf2,last); /* read into buffer */     do case function; /* branch to process function */        ; /* 0:  impossible */        call add_random (i,last); /* 1:  add uniform random data */        call add_sine   (i,last); /* 2:  sine */        call add_sqr    (i,last); /* 3:  square */        call add_saw    (i,last); /* 4:  sawtooth wave */        call add_impulse(i,last); /* 5:  impulse */        call add_fourier(i,last); /* 6:  fourier series */        do; /* 7:  add in frequency domain function */           do last=0 to len-1;              databuf2(i+last)=databuf1(last)+databuf2(i+last);           end;              call copy_vector(origin,stop,3); /* origin <- stop (for exit) */        end;     end; /* of do case */     call writedata(start.sector(0),start.sector(1),databuf2,last); /* write buffer */     length(0)=0; length(1)=0; length(2)=last; /* number of samples processed */     call add_len_to_len(length,origin,origin); /* incr origin by amount processed  */     i=0;  end; /* of loop while there are sectors to process */  call index_to_time(start,start,period.index); /* restore start and stop times */  call index_to_time(stop,stop,period.index);end add_function;