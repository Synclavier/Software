/* $SUBTITLE  32-Bit Square Root and 32-Bit Complex Square Routines */sqr_root:  proc(msb,lsb) fixed; /* returns the square root of 32 bit number */   dcl (msb,lsb) fixed;   dcl (a,b,i)   fixed;   dcl root      data ("04000","14000","40200","42132","132462","133232","140052","140600");   if (msb=0) and (lsb ILT 2) then return lsb;   i=shr(msb,13);   a=root(i); /* trial root */   do i=1 to 15; /* be sure we don't loop forever */      write(5)=lsb;      write(4)=msb;      write(7)=a;      b=a+read(5);      if b ILT read(5) then b=shr(b,1)\"100000";      else                  b=shr(b,1);      if a=b then return b;      a=b;   end;   return b;end sqr_root;square:  proc(b,blsb); /* squares complex elements */  dcl b           fixed array;  dcl blsb        fixed array;  dcl (i,msb,lsb) fixed;  dcl (real,imag) fixed;  dcl (tmsb,tlsb) fixed;  do i=0 to fft.len/2; /* loop over points up to nyquist */    real=shl(i,1); imag=real+1;    if b(real)<0 then do;       b(real)=-b(real);       if blsb(real)<>0 then b(real)=b(real)-1;       blsb(real)=-blsb(real);    end;    write(5)=b(real);    write(6)=b(real);    msb=read(4);    lsb=read(5);    write(5)=b(real);    write(6)=blsb(real);    lsb=lsb+read(4);    if lsb ilt read(4) then msb=msb+1;    lsb=lsb+read(4);    if lsb ilt read(4) then msb=msb+1;    if b(imag)<0 then do;       b(imag)=-b(imag);       if blsb(imag)<>0 then b(imag)=b(imag)-1;       blsb(imag)=-blsb(imag);    end;    write(5)=b(imag);    write(6)=b(imag);    msb=msb+read(4);    lsb=lsb+read(5);    if lsb ilt read(5) then msb=msb+1;    write(5)=b(imag);    write(6)=blsb(imag);    lsb=lsb+read(4);    if lsb ilt read(4) then msb=msb+1;    lsb=lsb+read(4);    if lsb ilt read(4) then msb=msb+1;    b(i)=msb; blsb(i)=lsb;  end; /* of loop over points */end square;  /* $SUBTITLE  Frame Amplitude and Spectral Analysis Routine */analyze.data:  proc(index); /* prepares analysis frame data for given index */   dcl index             fixed array;   dcl temp(3)           fixed;   dcl (min,max)         fixed;   dcl (compress,sum)    fixed;   dcl (binmsb,binlsb)   fixed;   dcl (sum1,sum2,sum3)  fixed;   dcl (g1,g2)           fixed;   dcl (up,low)          fixed; /* temps for swindow.upper and swindow.lower */   dcl width             fixed; /* temp for swindow.width */   dcl offset            fixed;   dcl (tmax,tmin)       fixed;   dcl (lowbin,bins)     fixed;   dcl bin.temp(max.swindow.width) fixed; /* temp for freq line extract */   dcl (sum.count,count) fixed;   dcl quotient.msb      fixed;   dcl quotient.lsb      fixed;   dcl (w16,w32,w48)     fixed; /* 48-bit accumulator variables */   dcl (i,j,k,n,w,x)     fixed;   call add_len_to_addr(index,location(f.data.index),temp);   call readdata(temp(0),temp(1),data.msb,window.length+256);   compress=window.length/pixels.frame; /* number of samples per frame pixel */   if compress=0 then compress=1; /* at least one sample */   w16=0; w32=0; w48=0; /* initialize 48-bit accumulator */   j=0; /* init compressed point count */   k=0; /* point to first frame pixel amp */   do i=0 to (window.length-1); /* loop over samples in frame */      x=data.msb(i+temp(2)); /* get data, shuffling if needed */      /* compute envelope shape */      if j=0 then do; /* first point - use value as max and min */         max=x; min=max;      end;      else do; /* not first point - update max and min */         g1=((x  &"100000")=0);         g2=((max&"100000")=0);         if g1 xor g2 then do; if g1 then max=x; end;         else              if x>max then max=x;         g2=((min&"100000")=0);         if g1 xor g2 then do; if g2 then min=x; end;         else              if x<min then min=x;      end; /* update max and min */      /* accumulate sums of squares to get short-time energy */      if x<0 then n=abs(x);      write(5)=n; write(6)=n; /* square voltage value */      w32=w32+read(4); /* add to middle 16 bits of product */      if w32 ILT read(4) then w48=w48+1; /* carry into highest 16 bits */      w16=w16+read(5); /* add to lowest 16 bits of product */      if w16 ILT read(5) then do; /* add carry to middle 16 bits */         w32=w32+1;         if w32=0 then w48=w48+1; /* add carry into highest 16 bits */      end;      data.msb(i)=x; /* store data back into correct spot in array */      j=j+1; /* bump compressed point count */      if j=compress then do; /* end of compresion segment - store envelope limits */         anal_pos_amp(k)=max;  anal_neg_amp(k)=min;         k=k+1; /* move to next frame pixel */         j=0; /* clear compressed point counter */      end; /* of store */   end; /* of loop over samples */   /* divide the 48-bit squared sum of the data by the number of data values */   write(5)=w32; write(4)=w48; write(7)=window.length; /* divide highest 32 bits */   quotient.msb=read(5); k=read(4); /* get quotient and remainder */   write(5)=w16; write(4)=k;   write(7)=window.length; /* divide remainder and low 16 bits */   quotient.lsb=read(5); /* get quotient */   if read(4) IGE shr(window.length,1) then do; /* round up */      quotient.lsb=quotient.lsb+1;      if quotient.lsb=0 then quotient.msb=quotient.msb+1; /* carry into upper quotient word */   end;   /* power=20*log10(energy)  3402=1024*log2(10) 9633=dB range of 16-bit num*100 */   anal_power=(1000*fastlog(quotient.msb,quotient.lsb)/3402)-9633;   if any_spectra then do; /* compute spectral properties of signal over current frame */      call data_window(data.msb,data.lsb,fft.len,window.type,window.length);      rescale=0;      call normalize1(data.msb,data.lsb,fft.len,15); /* rescale to within 1 bit of full scale */      call ifast(data.msb,data.lsb,fft.len); /* do fourier transform */      call normalize1(data.msb,data.lsb,fft.len+1,15); /* rescale to within 1 bit of full scale */      rescale=rescale*2;      call square(data.msb,data.lsb); /* get density from complex terms */   end;   /* $PAGE */   do w=0 to n.swindows-1; /* loop over windows */      width=swindow.width(w);      up   =swindow.upper(w);      low  =swindow.lower(w);      offset=max.swindow.width*w; /* offset into threshold array for this window */      if (width>0) and (swindow.type(w)<>AMP_TYPE) then do; /* window exists */         tmax = -32768;  tmin = 32767; /* init threshold checks */         do i = 0 to width-1; /* loop over pixels to compute thresholds */            lowbin=lowbin.table(offset+i); /* lookup bin references */            bins  =bins.table  (offset+i);            sum.count=0;            sum1=0; sum2=0; sum3=0; /* init 48-bit accumulator */            do j=0 to bins-1; /* loop over bins to map into this threshold */               k=j+lowbin;               if k<=shr(fft.len,1) then do; /* have a valid bin index */                  /* bin=sqr_root(data.msb(k),data.lsb(k)); */ /* magnitude */                  binmsb=data.msb(k); /* spectral density */                  binlsb=data.lsb(k);                  if swindow.type(w)=SPEC_TYPE then do; /* transform bin to log spectral density */                     binmsb=fastlog(binmsb,binlsb);                     binlsb=0; /* only keep a 16-bit log value */                  end; /* of transform bin to log spectral density */                  count=j+1;                  if j>(bins-1)/2 then count=bins-j;                  do n=1 to count; /* add this bin COUNT times */                     /* do a 48-bit add of the 32-bit spectral bin values */                     sum1=sum1+binlsb; /* add lower 16 bits of bin value */                     if sum1 ILT binlsb then do; /* carry set in lowest 16 bits */                        sum2=sum2+1; /* add carry into middle 16 bits */                        if sum2=0 then sum3=sum3+1; /* if carry then add carry into highest 16 bits */                     end;                     sum2=sum2+binmsb; /* add upper 16 bits of bin value */                     if sum2 ILT binmsb then sum3=sum3+1; /* if carry then add carry into highest 16 bits */                  end; /* of add this bin COUNT times */                  sum.count=sum.count+count;               end; /* of have a valid bin index */            end; /* of loop over bins to map into this threshold */            sum=0; /* initialize for division */            if (sum1<>0) or (sum2<>0) or (sum3<>0) then do; /* have non-zero sum */               if sum1 IGT 32767 then do; /* round 48-bit num to most sig. 32-bits */                  sum2=sum2+1;                  if sum2=0 then sum3=sum3+1; /* if carry then add carry to highest 16 bits */               end;               write(5)=sum2; write(4)=sum3; write(7)=sum.count; /* divide sum by number of bins */               sum=read(5); /* get quotient */               if read(4) IGE shr(sum.count,1) then sum=sum+1; /* round */            end; /* of have non-zero sum */            if #greater(sum,tmax) then tmax = sum; /* update min and max */            if #greater(tmin,sum) then tmin = sum;            threshold(offset+i)= sum; /* store result */         end; /* of loop over pixels to compute thresholds */         /* $PAGE */         tmax=tmax-tmin; /* remove minimum */         if tmax=0 then tmax=1; /* avoid divide by zero */         do i = 0 to width-1; /* loop over pixels to scale threshold */            threshold(offset+i) = shl(32767*(threshold(offset+i)-tmin)/tmax,1);         end; /* of loop over pixels to scale threshold */         if swindow.type(w) = FREQ_TYPE then do; /* extract frequency lines */            do i=0 to swindow.width(w)-1; /* clear working array */               bin.temp(i)=0;            end;            do n=1 to 16; /* extract up to 16 features */               tmax = 0; /* scan for peak */               do i=0 to swindow.width(w)-1; /* check all bins */                  if threshold(offset+i) IGT tmax then do;                     tmax=threshold(offset+i);                     j=i; /* store position */                  end;               end;               if tmax ILE 150 then goto BREAK.OUT; /* break when peak is more than 53 db down */               if n=1 then bin.temp(j)=43000; /* mark strongest */               else        bin.temp(j)=65535; /* mark others */               threshold(offset+j)=0; /* remove center */               i=j;               x=tmax;               do while (x IGE threshold(offset+i+1)) /* reduce to right */                  and (i<swindow.width(w)-1) and (x<>0);                  i=i+1; /* move one to right */                  x=threshold(offset+i);                  threshold(offset+i)=0; /* remove */               end;               i=j;               x=tmax;               do while (x IGE threshold(offset+i-1)) and (i>0) and (x<>0); /* reduce to left */                  i=i-1; /* move one to left */                  x=threshold(offset+i);                  threshold(offset+i)=0; /* remove */               end;            end; /* of loop over features */            BREAK.OUT:            do i=0 to swindow.width(w)-1; /* copy bin.temp back to threshold */               threshold(offset+i)=bin.temp(i);            end;         end; /* of extract frequency lines */      end; /* of active non-amp window */   end; /* of loop over windows */end analyze.data;