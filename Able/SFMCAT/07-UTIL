/* 07-UTIL  $TITLE  Utility and I/O Formatting Routines Used by SFM *//* Copyright 1985 by New England Digital Corporation */add_len_to_addr:proc(len,in.addr,out.addr) fixed; /* adds LEN to IN.ADDR, puts result in OUT.ADDR */   dcl len      fixed array; /* 24-bit sector, 8-bit word length */   dcl in.addr  fixed array; /* 24-bit sector, 8-bit word disk addr */   dcl out.addr fixed array; /* 24-bit sector, 8-bit word disk addr */   dcl carry   fixed;   /* NOTE: IN.ADDR can be the same as OUT.ADDR */   out.addr(2)=len(2)+in.addr(2);     /* add words fields */   carry=shr(out.addr(2),8);          /* compute full sectors */   out.addr(2)=out.addr(2)&"377";     /* make sure OUT.ADDR(2)<256 */   out.addr(1)=in.addr(1)+carry;          /* now add carry from above to output sectors */   if out.addr(1) ILT carry then carry=1; /* handle carry into high 8 bits of sector len */   else                          carry=0;   out.addr(1)=out.addr(1)+len(1);   if (out.addr(1) ILT len(1)) then carry=carry+1;   out.addr(0)=(in.addr(0)&"177400")\((in.addr(0)+carry)&"377");   if (out.addr(0)&"377") ILT carry then carry=1;         else                                  carry=0;   out.addr(0)=(out.addr(0)&"177400")\((out.addr(0)+(len(0)&"377"))&"377");   if ((out.addr(0)&"377") ILT (len(0)&"377"))   or (carry<>0) then do;            /* 24 bit overflow */      error.flag=e.overflow; return 1;   end;      return 0;end add_len_to_addr;add_len_to_len:proc(in.len1,in.len2,out.len) fixed; /* adds IN.LEN1 to IN.LEN2, puts result in OUT.LEN */   dcl in.len1 fixed array; /* 24-bit sector, 8-bit word length */   dcl in.len2 fixed array; /* 24-bit sector, 8-bit word length */   dcl out.len fixed array; /* 24-bit sector, 8-bit word length */   dcl carry   fixed;   /* NOTE:  IN.LEN2 can be same array as OUT.LEN */   out.len(2)=in.len1(2)+in.len2(2); /* add words fields */   carry=shr(out.len(2),8);          /* compute full sectors */   out.len(2)=out.len(2)&"377";      /* make sure OUT.LEN(2)<256 */   out.len(1)=in.len2(1)+carry;      /* now add carry from above to output sectors */   if out.len(1) ILT carry then carry=1; /* handle carry into high 8 bits of sector len */   else                         carry=0;   out.len(1)=out.len(1)+in.len1(1);   if (out.len(1) ILT in.len1(1)) then carry=carry+1;   out.len(0)=(in.len2(0)+carry)&"377";   if out.len(0) ILT carry then carry=1;         else                         carry=0;   out.len(0)=(out.len(0)+(in.len1(0)&"377"))&"377";   if (out.len(0) ILT (in.len1(0)&"377"))   or (carry<>0) then do;     /* 24 bit overflow */      error.flag=e.overflow; return 1;   end;      else return 0;end add_len_to_len;/* $PAGE */sub_len_from_addr:  proc(in.addr,len,out.addr) fixed; /* subtracts LEN from IN.ADDR, puts result in OUT.ADDR */   dcl in.addr  fixed array; /* 24-bit sector, 8-bit word disk addr */   dcl len      fixed array; /* 24-bit sector, 8-bit word length */   dcl out.addr fixed array; /* 24-bit sector, 8-bit word disk addr */   dcl carry    fixed;   /* NOTE:  IN.ADDR(2) must be normalized to be less than 256 */                                               out.addr(2)=in.addr(2)-len(2);   carry=shr(-(out.addr(2)&"177400"),8);   out.addr(2)=out.addr(2)&"377";   out.addr(1)=len(1)+carry;   if out.addr(1) ILT carry then carry=1;   else                          carry=0;   out.addr(1)=in.addr(1)-out.addr(1);   if (out.addr(1) IGT in.addr(1)) then carry=carry+1;   out.addr(0)=(len(0)+carry)&"377";   if out.addr(0) ILT carry then carry=1;               else                          carry=0;   out.addr(0)=(in.addr(0)&"177400")\(((in.addr(0)&"377")-out.addr(0))&"377");   if ((out.addr(0)&"377") IGT (in.addr(0)&"377"))   or (carry<>0) then do; /* 24 bit overflow */      error.flag=e.overflow;      return 1;   end;      return 0;end sub_len_from_addr;sub_len_from_len:  proc(in.len1,in.len2,out.len) fixed; /* subtracts IN.LEN2 from IN.LEN1, puts result in OUT.LEN */   dcl in.len1 fixed array; /* 24-bit sector, 8-bit word length */   dcl in.len2 fixed array; /* 24-bit sector, 8-bit word length */   dcl out.len fixed array; /* 24-bit sector, 8-bit word length */   dcl carry   fixed;   /* NOTE:  IN.LEN1(2) must be normalized it is less than 256.      IN.LEN2 and OUT.LEN can be the same arrays. */   out.len(2)=in.len1(2)-in.len2(2);   carry=shr(-(out.len(2)&"177400"),8);   out.len(2)=out.len(2)&"377";   out.len(1)=in.len2(1)+carry;   if out.len(1) ILT carry then carry=1;   else                         carry=0;   out.len(1)=in.len1(1)-out.len(1);   if (out.len(1) IGT in.len1(1)) then  carry=carry+1;   out.len(0)=(in.len2(0)+carry)&"377";   if out.len(0) ILT carry then carry=1;               else                         carry=0;   out.len(0)=((in.len1(0)&"377")-out.len(0))&"377";   if (out.len(0) IGT (in.len1(0)&"377"))   or (carry<>0) then do; /* 24 bit overflow */      error.flag=e.overflow;      return 1;   end;      else return 0;end sub_len_from_len;/* $PAGE */copy_vector:proc(dest,sour,len); /* copy SOUR to DEST */   dcl dest fixed array;   dcl sour fixed array;   dcl len  fixed;   dcl i    fixed;   do i=0 to len-1; dest(i)=sour(i); end;end copy_vector;compare_addrs:proc(a,b) fixed; /* compares two 24-bit disk addresses, return 0 if equal, 1 if a>b, -1 if a<b  */    dcl (a,b) fixed array;   /* ignores differences in device address byte */   if (a(0)&255) IGT (b(0)&255) then return +1;   if (a(0)&255) ILT (b(0)&255) then return -1;   if  a(1)      IGT  b(1)      then return +1;   if  a(1)      ILT  b(1)      then return -1;   if  a(2)      IGT  b(2)      then return +1;   if  a(2)      ILT  b(2)      then return -1;   return 0; /* equal */end compare_addrs;compare_vectors:proc(a,b,len) fixed; /* compares two vectors, return 0 if equal, 1 if a>b, -1 if a<b  */    dcl (a,b) fixed array;   dcl len   fixed;   dcl i     fixed;   do i=0 to len-1;      if a(i) IGT b(i) then return 1;      if a(i) ILT b(i) then return -1;   end;   return 0; /* equal */end compare_vectors;compute.best.period.index:  proc fixed swap; /* returns appropriate clock period */   /* In some situations, it is best to use the clock period of the current      sound file, rather than the clock period defined by SAMPLE RATE.      If, however, there is no current file, then the clock period      corresponding to SAMPLE RATE must be used. This routine makes the      decision of which period to use. */   if (f.name.bytes=0) or (f.sector ILT 4)   then return current.per.index; /* no current file */   else return period.index; /* have a current file */end compute.best.period.index;/* $SUBTITLE  General Disk Read Routine for Use in SFM *//* Pass READ_WORDS the absolute disk starting address you want to begin   reading at and the length you want to read, and BUF will be filled   with that many words.   */read_words:  proc(s.ptr,l.ptr,buf) swap; /* reads in desired words from disk */   dcl s.ptr         fixed array; /* absolute disk addr of start point (index format) */   dcl l.ptr         fixed array; /* words to read (index format) */   dcl buf           fixed array; /* output buf (at least 256 words long) */   dcl c.ptr     (2) fixed;       /* current disk addr (index format) */   dcl temp      (2) fixed;   dcl (i,j)         fixed;    call add_len_to_addr  (l.ptr,s.ptr,c.ptr); /* compute addr of last word to read */   call sub_len_from_addr(c.ptr,zero.zero.one,temp);   do i=0 to 2; c.ptr(i)=s.ptr(i); temp(i)=0; end;   if c.ptr(2)<>0 then do; /* not starting read on sector boundary */      call readdata(c.ptr(0),c.ptr(1),buf,256);      j=256-c.ptr(2); /* words from offset to end of sector */      if (l.ptr(2)<j) and (l.ptr(1)=0) then j=l.ptr(2); /* special case for short reads */      do i=0 to j-1; buf(i)=buf(i+c.ptr(2)); end; /* copy down */      temp(2)=j; /* words read so far */      c.ptr(2)=0; c.ptr(1)=c.ptr(1)+1; /* update current disk addr */   end;   /**** we should now be on a sector boundary ****/   call sub_len_from_len(l.ptr,temp,temp); /* words left to read */   if (temp(1)=0) and (temp(2)=0) then return 1; /* done with read */   if s.ptr(2)<>0 then i=addr(buf(j));   else                i=addr(buf(0));   call readdata(c.ptr(0),c.ptr(1),location(i),shl(temp(1),8)+temp(2));   return 1; /* successful read */end read_words;/* $SUBTITLE  General Disk Write Routine for Use in SFM *//* Pass WRITE_WORDS the absolute disk starting address you want to begin   writing to and the length you want to write, and the contents of BUF   will be written to the disk.  You need to pass a small (1 sector) temp   buffer, TBUF, for the routine to work.  This routine will not let you   overwrite your catalog. */write_words:  proc(s.ptr,l.ptr,buf,tbuf) swap; /* writes desired words to disk */   dcl s.ptr         fixed array; /* absolute disk addr of start point (index format) */   dcl l.ptr         fixed array; /* words to write (index format) */   dcl buf           fixed array; /* output buf */   dcl tbuf          fixed array; /* temporary buf (must be 256 words long) */   dcl c.ptr     (2) fixed; /* current disk addr (index format) */   dcl temp      (2) fixed;   dcl (i,j)         fixed;    /* do some address bounds checking first */   call add_len_to_addr  (l.ptr,s.ptr,c.ptr); /* compute addr of last word to write */   call sub_len_from_addr(c.ptr,zero.zero.one,temp);   if s.ptr(1)=0 then return 0; /* address too low - can't overwrite catalog */   do i=0 to 2; c.ptr(i)=s.ptr(i); temp(i)=0; end;   if c.ptr(2)<>0 then do; /* not starting write on sector boundary */      call readdata(c.ptr(0),c.ptr(1),tbuf,256); /* read in sector */      j=256-c.ptr(2); /* words left in sector */      if (l.ptr(2)<j) and (l.ptr(1)=0) then j=l.ptr(2); /* special case for short writes */      do i=0 to j-1; tbuf(i+c.ptr(2))=buf(i); end;      call writedata(c.ptr(0),c.ptr(1),tbuf,256); /* rewrite sector */      temp(2)=j; /* words written so far */      c.ptr(2)=0; c.ptr(1)=c.ptr(1)+1; /* update current disk addr */   end;   else j=0;   /**** we should now be on a sector boundary ****/   call sub_len_from_len(l.ptr,temp,temp); /* words left to write */   if (temp(1)=0) and (temp(2)=0) then return 1; /* done with write */   i=addr(buf(j));   call writedata(c.ptr(0),c.ptr(1),location(i),shl(temp(1),8)); /* write even sectors */   c.ptr(1)=c.ptr(1)+temp(1); /* update current disk addr */   if temp(2)<>0 then do; /* write odd words at end */      call readdata(c.ptr(0),c.ptr(1),tbuf,256); /* read in last sector */      j=j+shl(temp(1),8); /* base index into BUF for last write */      do i=0 to temp(2)-1; tbuf(i)=buf(j+i); end;      call writedata(c.ptr(0),c.ptr(1),tbuf,256); /* rewrite modified sector */   end;   return 1; /* successful write */end write_words;/* $SUBTITLE  Convert Index Format to Time Format */index_to_time:proc(time.vector,index.vector,periods);   /* convert sectors to time:  works for sector numbers up to 24 bits,      sampling periods up to 29,999, and times up to 32 bits of milliseconds. */   dcl time.vector  fixed array;   dcl index.vector fixed array;   dcl periods      fixed;    dcl msb          lit 'index.vector(0)';   dcl lsb          lit 'index.vector(1)';   dcl offset       lit 'index.vector(2)';   dcl seconds      lit 'time.vector(0)';   dcl milliseconds lit 'time.vector(1)';   dcl microseconds lit 'time.vector(2)';   dcl (a,b,c,d,e,f,i,x,y) fixed;   /* compute xy. sample # */   x=shl(msb,8)\shr(lsb,8); /* upper 16 bits of sample # */   y=shl(lsb,8)\offset; /* lower 32 bits of sample # */   /* compute .abc milliseconds/sample */   write(5)=0; write(4)=periods; write(7)=clock.rate; /* compute microseconds/sample */   a=read(5);   i=read(4); write(5)=0; write(4)=i; write(7)=clock.rate;   b=read(5);   i=read(4); write(5)=0; write(4)=i; write(7)=clock.rate; /* to 48 bit accuracy */   c=read(5);   /* multiply xy. (sample #) times .abc (ms./sample) to get de.f milliseconds */   d=0;e=0;f=0;   write(5)=c; write(6)=x;   f=read(4);   write(5)=b; write(6)=y;   f=f+read(4); if f ILT read(4) then e=e+1;   write(5)=b; write(6)=x;   f=f+read(5); if f ILT read(5) then e=e+1;   e=e+read(4); if e ILT read(4) then d=d+1;   write(5)=a; write(6)=y;   f=f+read(5); if f ILT read(5) then do; e=e+1; if e=0 then d=d+1; end;   e=e+read(4); if e ILT read(4) then d=d+1;   write(5)=a; write(6)=x;   e=e+read(5); if e ILT read(5) then d=d+1;   d=d+read(4);   /* round up to nearest microsecond */   f=f+32; /* add 1/2000 of a millisecond */   if f ILT 32 then do; e=e+1; if e=0 then d=d+1; end;   /* compute answer: */   write(5)=e; write(4)=d; /* milliseconds */   write(7)=1000; /* to get seconds */   seconds=read(5); milliseconds=read(4);   write(5)=f; write(6)=1000; /* and microseconds */   microseconds=read(4); /* fractional multiply result */end index_to_time;/* $SUBTITLE  Convert Time Format to Index Format */time_to_index:proc(time.vector,index.vector,periods); /* convert time to sectors & offset: */   dcl time.vector  fixed array;   dcl index.vector fixed array;   dcl periods      fixed;    dcl msb          lit 'index.vector(0)';   dcl lsb          lit 'index.vector(1)';   dcl offset       lit 'index.vector(2)';   dcl seconds      lit 'time.vector(0)';   dcl milliseconds lit 'time.vector(1)';   dcl microseconds lit 'time.vector(2)';   dcl (a,b,c,d,e,f,i,x,y,z) fixed;   /* compute de.f milliseconds */   write(5)=seconds; write(6)=1000;   d=read(4);   e=read(5);   e=e+milliseconds;   if e ILT milliseconds then d=d+1;   write(5)=0; write(4)=microseconds; write(7)=1000; /* fractional divide */   f=read(5);   /* compute a.bc samples/millisecond */   write(5)=clock.rate; write(7)=periods; /* compute microseconds/sample */   a=read(5);   i=read(4); write(5)=0; write(4)=i; write(7)=periods;   b=read(5);   i=read(4); write(5)=0; write(4)=i; write(7)=periods; /* to 48 bit accuracy */   c=read(5);   /* multiply de.f milliseconds times a.bc (samples/ms) to get xy.z sample # */   x=0; y=0; z=0;   write(5)=c; write(6)=e;   z=read(4);   write(5)=c; write(6)=d;   z=z+read(5); if z ILT read(5) then y=y+1;   y=y+read(4); if y ILT read(4) then x=x+1;   write(5)=b; write(6)=f;   z=z+read(4); if z ILT read(4) then do; y=y+1; if y=0 then x=x+1; end;   write(5)=b; write(6)=e;   z=z+read(5); if z ILT read(5) then do; y=y+1; if y=0 then x=x+1; end;   y=y+read(4); if y ILT read(4) then x=x+1;   write(5)=b; write(6)=d;   y=y+read(5); if y ILT read(5) then x=x+1;   x=x+read(4);   write(5)=a; write(6)=f;   z=z+read(5); if z ILT read(5) then do; y=y+1; if y=0 then x=x+1; end;   y=y+read(4); if y ILT read(4) then x=x+1;   write(5)=a; write(6)=e;   y=y+read(5); if y ILT read(5) then x=x+1;   x=x+read(4);   write(5)=a; write(6)=d;   x=x+read(5);   /* round up to nearest sample number */   if z<0 then do; y=y+1; if y=0 then x=x+1; end;   /* compute answer: */   msb=shr(x,8);   lsb=shl(x,8)\shr(y,8);   offset=y&255;end time_to_index;/* $SUBTITLE */freq_to_pitch:proc(freq) floating swap; /* convert Hz to octave.cents */   dcl freq floating;     freq=log2(freq/440.)+3.7500005; /* round */   return int(freq)+0.12*(freq-int(freq));end freq_to_pitch;pitch_to_freq:proc(pitch) floating swap;   dcl pitch floating;   pitch=(pitch-.88*int(pitch))/.12;   return (440.*exp(log.of.2*(pitch-3.75)));end pitch_to_freq;convert_to_abs:proc(vector) fixed; /* converts from (volts, millivolts) to absolute (-32768 to 32767) */   dcl vector fixed array;     if (vector(0)=>scale.factor) then do;vector(0)=scale.factor;vector(1)=0; end;   if  (vector(0)<=-scale.factor) then do; vector(0)=-scale.factor;vector(1)=0; end;   if vector(0)=scale.factor then return 32767;   return (vector(0)*1000+vector(1)) fdiv (2000*scale.factor);end convert_to_abs;DCL P.STRING LIT 'FIXED ARRAY';SUBSTR:PROC(RESULT,A,LOWER,UPPER);   DCL RESULT P.STRING; /* THE RESULTANT STRING             */   DCL A      P.STRING; /* THE SOURCE STRING                */   DCL LOWER  FIXED;    /* FIRST CHARACTER POSITION TO COPY */   DCL UPPER  FIXED;    /* LAST  CHARACTER POSITION TO COPY */   DCL (I,J)  FIXED;     J=0;   DO I=LOWER TO UPPER;      CALL PBYTE(RESULT,J,BYTE(A,I));      J=J+1; /* ADVANCE TO NEXT BYTE */   END;   RESULT(0)=J; /* SET LENGTH */END SUBSTR; ASSIGN:PROC(A,B); /*    A <-  B */   DCL A  P.STRING; /* RESULTANT STRING */   DCL B  P.STRING; /* SOURCE    STRING */   DCL I  FIXED;    IF ADDR(A(0))<>ADDR(B(0)) THEN DO; /* NOT THE SAME STRING - COPY */      DO I=0 TO B(0)-1; /* COPY B INTO A */         CALL PBYTE(A,I,BYTE(B,I));      END;   END;   A(0)=B(0); /* ASSIGN LENGTH */END ASSIGN;MAX_CAPTION_BYTES: PROC FIXED; /* RETURNS MAX NUMBER OF CHARS ALLOWED IN CAPTION */   DCL I       FIXED;   I=SF.INDEX.BASE;  /* GET PTR TO START OF CATEGORY INDEX AREA (OR ZERO) */   IF I=0 THEN I=256;   RETURN SHL(I-128,1); /* NUMBER OF BYTES AVAILABLE FOR CAPTION */END MAX_CAPTION_BYTES;CAPTION_ASSIGN: PROC(CAPTION);   DCL CAPTION FIXED ARRAY;   IF CAPTION(0) IGT MAX_CAPTION_BYTES /* CAPTION IS TOO LONG */   THEN CAPTION(0)=MAX_CAPTION_BYTES;  /* TRUNCATE IT SO YOU DON'T TRASH CATEGORY INDEX DATA */   CALL ASSIGN(ID.FIELD,CAPTION);END CAPTION_ASSIGN;strip_blanks:proc(buf); /* advances byte.ptr past leading blanks */   dcl buf fixed array;   do while (byte(buf,byte.ptr)=A.SP) and (byte.ptr<buf(0)); /* strip leading blanks */      byte.ptr=byte.ptr+1;   end;end strip_blanks;/* $SUBTITLE */get_word:proc(buf,word,len) swap; /* get word, pad with spaces */   /* current pointer within buf is byte.ptr */   dcl buf        fixed array;   dcl word       fixed array;   dcl len        fixed; /* number of characters in word */   dcl (ptr,char) fixed;     alpha:proc(chr) fixed; /* true if chr is alphanumeric, else false */      dcl chr fixed;      if (chr>=A.0) and (chr<=A.9) then return 1; /* digits */      if (chr>=(A.A+"40")) and (chr<=(A.Z+"40")) then return 1; /* upper case letters */      if (chr>= A.A      ) and (chr<= A.Z      ) then return 1; /* lower case letters */      if (chr=A.PERIOD) or (chr=A.SCORE) then return 1; /* period or underline */      return 0; /* all else is non-alphanumeric */   end alpha;   call strip_blanks(buf); /* skip over blanks */   ptr=0;   char=byte(buf,byte.ptr); /* get first char */   do while (byte.ptr<buf(0)) and alpha(char) and (ptr<len);      if (char=>l.a) and (char<=l.z) then char=char-"40"; /* convert to uppercase */      call pbyte(word,ptr,char);                      ptr=ptr+1;      byte.ptr=byte.ptr+1;      char=byte(buf,byte.ptr); /* get next char */   end;   word(0)=ptr; /* store resulting string length */   do while (byte.ptr<buf(0)) and alpha(byte(buf,byte.ptr)); /* skip rest of command */      byte.ptr=byte.ptr+1;   end;   call strip_blanks(buf); /* skip over blanks */end get_word;get_filename:proc(buf,word,type) swap; /* get word, pad with spaces */   /* current pointer within buf is byte.ptr */   dcl buf        fixed array;   dcl word       fixed array;   dcl type       fixed; /* 0=regular filename, 1=catalog name */   dcl (ptr,char) fixed;     call strip_blanks(buf); /* skip over blanks */   ptr=0;   char=byte(buf,byte.ptr); /* get first char */   do while (byte.ptr<buf(0)) and valid_filechar(char) and (ptr<8);      if (char>"140") and (char<"173") then char=char-"40"; /* convert to uppercase */      call pbyte(word,ptr,char);                      ptr=ptr+1;      byte.ptr=byte.ptr+1;      char=byte(buf,byte.ptr); /* get next char */   end;   word(0)=ptr; /* store resulting string length */   do while (byte.ptr<buf(0)) and valid_filechar(byte(buf,byte.ptr)); /* skip rest of command */      byte.ptr=byte.ptr+1;   end;   call strip_blanks(buf); /* skip over blanks */end get_filename;/* SCAN_NUMBER scans an input string and extracts a three field vector in the    format t(1) = integer portion, t(2) = first 3 digits to right of decimal   pt., if any, t(3) = last 3 digits to right of decimal pt., if any.   error codes: 0  ->  no error                1  ->  no digits found in string                2  ->  missing decimal point in number string                3  ->  non-numeric char found in 2nd field                4  ->  non-numeric char found in 3rd field  */scan_number:proc(string,time) fixed swap;  /* scans string to return numeric value in vector */   dcl string fixed array;   dcl time   fixed array;   dcl stop   fixed;   dcl sign   fixed;   dcl char   fixed;   scan_digits:proc(len) fixed; /* returns numeric value */     dcl len   fixed; /* max number of digits to scan */          dcl value fixed;     stop =byte.ptr + len; /* compute end */     value=0;     char =byte(string,byte.ptr); /* get first char */     do while (byte.ptr<stop) and (byte.ptr < string(0))          and (char>=A.0)   and (char<=(A.0+9));        value   =value*10 + (char-A.0); /* add in digit */        byte.ptr=byte.ptr + 1; /* advance pointer */        char    =byte(string,byte.ptr); /* get next char */     end; /* of do while */        return value;   end scan_digits;   /* $PAGE */   time(0)=0; time(1)=0; time(2)=0; /* init all fields to zero */   call strip_blanks(string);   if byte.ptr=string(0) then return 1; /* end of string; no digits */   sign=1; /* assume positive */   if byte(string,byte.ptr)=a.minus then do; /* check for negative */      sign=(-1);      byte.ptr=byte.ptr+1; /* skip over minus sign */   end;   else if byte(string,byte.ptr)=a.plus then byte.ptr=byte.ptr+1; /* skip over plus sign */         time(0)=sign*scan_digits(5); /* process integer portion */   if byte.ptr=string(0) then return 0; /* exit if at string end */   if      char=A.SP then      return 0; /* scan complete */   else if char<>A.PERIOD then return 2; /* error - missing decimal point */   byte.ptr=byte.ptr+1; /* skip over dot */   if byte.ptr=string(0) then return 0; /* exit if at string end */   time(1)=sign*scan_digits(3); /* scan for milliseconds */   if      byte.ptr=(stop-1) then time(1)=time(1)*10; /* adjust milliseconds - got two digits */   else if byte.ptr=(stop-2) then time(1)=time(1)*100; /* got one digit */   else if byte.ptr=(stop-3) then if char<>A.SP then return 3; /* non-numeric in milliseconds field */   time(2)=sign*scan_digits(3); /* scan for microseconds */   if      byte.ptr=(stop-1) then time(2)=time(2)*10; /* adjust microseconds field */   else if byte.ptr=(stop-2) then time(2)=time(2)*100;   if (byte.ptr<string(0)) and (char<>A.SP) then return 4; /* non-numeric in microseconds field */   return 0;end scan_number;print_vertical:proc(string) swap; /* print a string vertically */   dcl string fixed array;                                  dcl i      fixed;   do i=0 to string(0);      vector_mode;      call #transmit_coords(#lastx,#lasty);      alpha_mode;      call pc(byte(string,i));      if #lasty>=12 then #lasty=#lasty-12;      else               return;   end;end print_vertical;print_digits:proc(num,n) swap; /* prints positive number in n places with leading zeros */   dcl (num,n) fixed;    dcl (i,k)   fixed;   if (num ILT 0) then return;   k=1;   do i=1 to n-1;     k=k*10;     if num ILT k then call pc(A.0);   end;     if num=0 then call pc(A.0);   else          pint(num);end print_digits;/* $SUBTITLE */#unum:  proc(n,field) public; /* output an unsigned number (0 to 65535) */   dcl (n,i,r)    fixed; /* n:  value to print */   dcl (field,go) fixed; /* field:  field size */   dcl #divisors  data (10000,1000,100,10,1); /* powers of ten */   do i=1 to field-5; /* print out any necessary leading spaces */      call pc(A.SP);   end;   go=false; /* suppress leading zeroes */   do i=0 to 4; /* loop over 5 digits */      r=0; /* assume digit is zero */      do while n IGE #divisors(i); n=n-#divisors(i); r=r+1; end; /* must simulate unsigned divide */      if r<>0 then go=true; /* turn on printing */      if (go) or (i=4)        then call pc(A.0+r); /* print digit */      else if field-(4-i) > 0 then call pc(A.SP); /* or print space */   end; /* of digits loop */end #unum;dcl UNUM lit 'call #unum';num_count:proc(n) fixed; /* count characters in a number */   dcl n fixed;                 if n IGT 10000     then return (5); /* return number of digits */   else if n IGT 1000 then return (4);   else if n IGT 100  then return (3);   else if n IGT 10   then return (2);   else                    return (1);end num_count;print_time:proc(time,n,msec) swap; /* print a time value */   dcl time fixed array; /* sec, msec, usec */   dcl n    fixed; /* number of spaces before decimal point */   dcl msec fixed; /* flag, =1 to print usec */   dcl i    fixed;   alpha_mode;   do i=1 to n-num_count(time(0)); call pc(A.SP); end;   pnum(time(0));   call pc(A.PERIOD);   call print_digits(time(1),3);   if ^msec then return;   call pc(A.SP);   call print_digits(time(2),3);end print_time;    print_vector:proc(vector,str) swap; /* prints a 3 word vector and a descriptor string */   dcl vector fixed array;   dcl str    fixed array;      ps(str); /* print prompt */   call pc(A.SP);   pnum(vector(0));   call pc(A.SP);   pnum(vector(1));   call pc(A.SP);   pnum(vector(2));end print_vector;print_value:proc(value,scale,lead,trail) swap; /* prints value*scale as n+1 digit decimal fraction */   dcl (value,scale,lead,trail) fixed;   dcl (i,int,fract,k)          fixed;   alpha_mode;   k=1;   do i=1 to trail; k=k*10; end;   if scale=0 then return;   write(5)=2;   write(6)=scale;   if value<0 then write(6)=-value;   else            write(6)=value;   int=read(4);   write(5)=read(5);   write(6)=k;   if read(5)<0 then fract=read(4)+1;   else              fract=read(4);   if fract=k then do; int=int+1; fract=0; end;       do i=1 to lead-1-num_count(int);call pc(A.SP); end;   if value<0 then call pc(a.minus);   else            call pc(A.SP);   pnum(int);   call pc(A.PERIOD);   call print_digits(fract,trail);end print_value;/* $SUBTITLE */set_scroll:proc(top,bot); /* establish scrolling limits on screen */   dcl (top,bot) fixed; /* lines to scroll between */      if top<1  then top= 1; /* apply limits */   if top>24 then top=24;   if bot>24 then bot=24;   if bot<1  then bot= 1;   call pc(a.esc); call pc(a.lbracket);   if bot>top then do; /* send limits if valid, else scroll whole screen */      call pc(a.0+top/10);      call pc(a.0+(top mod 10));      call pc(a.semicolon);      call pc(a.0+bot/10);      call pc(a.0+(bot mod 10));   end;   call pc(a.r+"40"); /* lowercase r */end set_scroll;restore:proc; /* called after screen is cleared to restore command lines */   if restore.flag=0 then return; /* set false for final exit */                                    call set_scroll(1,2); /* in case SETUP-0 was pressed */   keypad_application;   if core(old.buf)<>0 then do;     ps(prompt);     ps(location(old.buf));   end;     nl;   ps(prompt);   ps(in.buf);   call dump_hold;   vector_mode; /* draw line under command line */   call #transmit_coords(0,430);   call #transmit_coords(#px,430);   transparent_mode;   call tty_wait;end restore;#psr:  proc(str); /* print a string, then CRLF */   dcl str fixed array;   ps(str); /* print the string */   nl; /* CRLF */end #psr;dcl psr lit 'call #psr';cursor_restore:proc; /* restore cursor to command line */   dcl ptr fixed;                   ptr=shold-rhold; /* restore cursor to command line */   if ptr<0 then ptr=holdbuf1.len-ptr;   call pos(2,5+in.buf(0)-ptr); /* restore cursor to command line */end cursor_restore; /* $SUBTITLE */replace_head:proc fixed; /* replaces heading and symbols area of file */   if (f.name.bytes=0) or (f.sector=0) then return 1; /* make sure there is a current file */   /* NOTE:  SFM.MAGIC is incremented each time a file's header is      rewritten to the disk.  This enables other programs to detect      possible changes to a file which might otherwise be difficult      to detect. */   sfm.magic=sfm.magic+1; /* increments any time header is rewritten to disk */   call writedata(f.drive,f.sector,location(f.headptr),shl((heading.length+symbol.sectors),8));   return 0;end replace_head;get_head:proc fixed; /* replaces heading and symbols area of file */   if (f.name.bytes=0) or (f.sector=0) then return 1; /* make sure there is a current file */             call readdata(f.drive,f.sector,location(f.headptr),shl((heading.length+symbol.sectors),8));   return 0;end get_head;file:proc(number,flag) fixed swap; /* to change file */  dcl number fixed;  dcl flag   fixed; /* =1 to replace heading */  if number > max.file.blocks then do; /* not in valid range */    error.flag=e.sys.error;    return 1;   end;  if flag then do; /* rewrite the header info area */     if replace_head then do;        if f.sector ILE 3 then error.flag=e.sfm.write;        return 1;     end;  end;  fcb.ptr=(number-1)*file.block.len+file.block.loc; /* set up the FCB pointer */  compute_f.data.index; /* compute starting sector of data */  if get_head then return 1; /* get header area of new file */  return 0;end file;    dcl file1 lit 'call file(1,1)';dcl file2 lit 'call file(2,1)';dcl file3 lit 'call file(3,1)';/* $SUBTITLE *//* FPRINT --  USED TO PRINT A FLOATING POINT NUMBER ON THE TERMINAL.    IT IS PASSED THREE ARGUMENTS:     1.  THE FLOATING POINT NUMBER TO PRINT     2.  THE NUMBER OF DIGITS TO PRINT TO THE LEFT OF THE DECIMAL POINT     3.  THE NUMBER OF DIGITS TO PRINT TO THE RIGHT OF THE DP.     FPRINT ALSO PRINTS A SPACE (IF POSITIVE) OR A MINUS SIGN (IF NEGATIVE)   BEFORE THE FIRST DIGIT.   ROUTINE WILL ALSO ROUND THE NUMBER JUST LIKE FORTRAN (F) FORMAT */FPRINT:PROC(NUM,LEFT,RIGHT) swap; /* floating point print */  DCL NUM          FLOATING;  DCL (LEFT,RIGHT) FIXED;  DCL I            FLOATING;  DCL (J,K,PK,L,M) FIXED;  M=A.SP; /* ASSUME POSITIVE NUMBER */  IF NUM<0 THEN DO; NUM=-NUM; M=A.MINUS; END; /* IF MINUS */  /* FIRST - ROUND THE NUMBER UP */  I=.5; /* START WITH .5 */  DO J=1 TO RIGHT; I=I/10; END; /* GET .5 TO THE RIGHT OF LAST DIGIT */  IF NUM<I THEN DO; NUM=0; M=A.SP; END; /* IF ZERO, PRINT POSITIVE ZERO */  ELSE          NUM=NUM+I;  I=1; /* NOW FIND POWER OF TEN */  IF LEFT=0 THEN NUM=NUM*10;  ELSE           DO J=2 TO LEFT; I=I*10; END;  K=0; /* CLEAR LEADING ZERO FLAG */  DO J=0 TO LEFT+RIGHT; /* LOOP OVER POSITIONS */    PK=K;    IF J=LEFT-1 THEN K=1; /* PRINT ONE DIGIT BEFORE DECIMAL POINT */    IF J=LEFT THEN DO;      L=A.PERIOD; /* CHARACTER TO PRINT IS DOT */      K=1;    END;    ELSE DO; /* PRINT DIGIT */      L=INT(NUM/I); /* GET DIGIT TO PRINT */      IF (L<0) OR (L>9) THEN DO; K=1; L=A.STAR; END;      ELSE DO; /* IS IN RANGE - PRINT IT */        K=K\L; /* SET SIGN */        IF K<>0 THEN DO; NUM=NUM-(L*I); L=L+"60"; END; /* DIGIT */        ELSE         L=A.SP; /* ELSE PRINT A SPACE */        NUM=NUM*10; /* AND MULTIPLY BY 10 FOR CONTINUATION */      END;    END;    IF (PK=0) AND (K<>0) THEN CALL PC(M); /* PRINT SIGN BEFORE FIRST ONE */    CALL PC(L); /* PRINT CHARACTER - SPACE, PERIOD, OR STAR OR DIGIT */  END; /* OF LOOP OVER POSITIONS */END FPRINT;/* $PAGE *//*  PROCEDURES TO CONVERT NUMBERS INTO FORMATTED STRINGS AND VICE-VERSA    release date: 4 dec 1979  Routines:  STR.TO.FLT(N.STRING) FLOATING             --Returns the floating point representation of a string               as passed in N.STRING            STR.TO.FIX(N.STRING) FIXED             --Returns the fixed point representation of a string as               passed in N.STRING            NUM.TO.STR(NUM,N.STRING,FORMAT)             --A floating point number (NUM) is converted to its string               representation (N.STRING) as governed by the format passed               in FORMAT.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ STR.TO.FLT:PROC(N.STRING) FLOATING swap;   /* Converts a string (N.STRING) to a floating point number.  The     exponential convention is allowed, and spaces are allowed before,     after and around the exponential sign. */   DCL N.STRING FIXED ARRAY;  DCL (NUM,J1) FLOATING;  DCL (PM.FLAG,PM.EXP,PTR,CHAR,EXPMAG) FIXED;     GETCHAR:PROC FIXED; /* RETURN NEXT CHAR IN STRING */    DCL CHAR FIXED;         IF PTR=N.STRING(0) THEN RETURN (0);         CHAR=BYTE(N.STRING,PTR);    PTR=PTR+1;    RETURN (CHAR);  END GETCHAR;     PM.FLAG=1; /* PLUS-MINUS FLAG */  PTR=0; /* CHARACTER PTR. */  NUM=0; /* INITIALIZE THE NUMBER */     CHAR="040"; /* INITIALIZE TO GET INTO 'DO WHILE' */  DO WHILE (CHAR="040"); /* DROP LEADING SPACES */    CHAR=GETCHAR;  END;  IF CHAR=0 THEN GOTO F.ERROR; /* NO DIGITS */     IF (CHAR="053")\(CHAR="055") THEN DO; /* PLUS OR MINUS? */    IF CHAR="055" THEN PM.FLAG=-1;    CHAR=GETCHAR;    DO WHILE (CHAR="040"); /* IGNORE SPACES */      CHAR=GETCHAR;    END;    IF CHAR=0 THEN GOTO F.ERROR; /* NO DIGITS */  END;     IF CHAR="056" THEN DO; /* DECIMAL POINT */    CHAR=GETCHAR;    IF CHAR=0 THEN GOTO F.ERROR; /* NO DIGITS */    GOTO DECIMAL;  END;     IF (CHAR>"057")&(CHAR<"072") THEN DO;    NUM=NUM*10. + (CHAR-"060"); /* UPDATE NUMBER */    CHAR=GETCHAR;    IF CHAR=0 THEN GOTO DONE; /* RETURN THE NO. */  END;     ELSE GOTO F.ERROR; /* HAD TO HAVE A DIGIT */     /* $PAGE */  /* DO SECOND CHARACTER AFTER SPACES */     GET3:  IF CHAR="040" THEN DO; /* TAKE SPACES IF E IS NEXT */    DO WHILE (CHAR="040"); CHAR=GETCHAR; END;    IF (CHAR<>"105")&(CHAR<>"145") THEN GOTO F.ERROR;    ELSE DO; /* GO TO EXPONENT ROUTINE */      CHAR=GETCHAR;      IF CHAR=0 THEN GOTO F.ERROR; /* NOTHING AFTER 'E' */      GOTO EXPONENT;    END;  END;     IF (CHAR="105")\(CHAR="145") THEN DO; /* EXPONENT */    CHAR=GETCHAR;    IF CHAR=0 THEN GOTO F.ERROR;    GOTO EXPONENT;  END;     IF CHAR="056" THEN DO; /* DECIMAL POINT */    CHAR=GETCHAR;    IF CHAR=0 THEN GOTO F.ERROR;    GOTO DECIMAL;  END;     IF (CHAR>"057")&(CHAR<"072") THEN DO; /* A DIGIT */    NUM=NUM*10. + (CHAR-"060"); /* UPDATE NO. */    CHAR=GETCHAR;    IF CHAR=0 THEN GOTO DONE;    GOTO GET3; /* PROCESS NEXT CHARACTER */  END;     GOTO F.ERROR; /* ILLEGAL CHARACTER */     /* DECIMAL HANDLING */     DECIMAL:J1=.1;  DECIMAL1:IF (CHAR<>"040") THEN GOTO GET5;  DO WHILE (CHAR="040"); /* ACCEPT SPACES IF 'E' IS NEXT */  CHAR=GETCHAR;  END;  IF CHAR=0 THEN GOTO F.ERROR;     IF (CHAR="105") OR (CHAR="145") THEN DO; /* EXPONENT */    CHAR=GETCHAR;    IF CHAR=0 THEN GOTO F.ERROR; /* NOTHING AFTER 'E' */    GOTO EXPONENT;  END;     GOTO F.ERROR; /* NO 'E' AFTER SPACES */     GET5:  IF (CHAR="105") OR (CHAR="145") THEN DO; /* EXPONENT */    CHAR=GETCHAR;    IF CHAR=0 THEN GOTO F.ERROR;    GOTO EXPONENT;  END;     IF (CHAR>"057") AND (CHAR<"072") THEN DO; /* A DIGIT */    NUM=NUM + (CHAR-"060")*J1;    J1=J1*.1;    CHAR=GETCHAR;    IF CHAR=0 THEN GOTO DONE;    GOTO DECIMAL1;  END;     GOTO F.ERROR; /* ILLEGAL CHARACTER */     /* $PAGE */  /* EXPONENT HANDLING ROUTINE */     EXPONENT:PM.EXP=1; /* DEFAULT EXPONENT SIGN */  EXPMAG=0; /* EXPONENT MAGNITUDE */  DO WHILE (CHAR="040"); /* IGNORE LEADING SPACES */    CHAR=GETCHAR;  END;  IF CHAR=0 THEN GOTO F.ERROR;     IF (CHAR="053")\(CHAR="055") THEN DO; /* PLUS OR MINUS? */    IF CHAR="055" THEN PM.EXP=-1;    CHAR=GETCHAR;    DO WHILE (CHAR="040"); /* IGNORE SPACES */      CHAR=GETCHAR;    END;    IF CHAR=0 THEN GOTO F.ERROR; /* NO DIGITS */  END;     IF (CHAR>"057")&(CHAR<"072") THEN DO; /* 1ST DIGIT */    EXPMAG=CHAR-"060";    CHAR=GETCHAR;    IF CHAR=0 THEN GOTO EXPCALC;         IF (CHAR>"057")&(CHAR<"072") THEN DO; /* 2ND DIGIT */      EXPMAG=EXPMAG*10 + (CHAR-"060");      CHAR=GETCHAR;      IF CHAR=0 THEN GOTO EXPCALC;    END;         DO WHILE (CHAR="040"); /* IGNORE TRAILING BLANKS */      CHAR=GETCHAR;      IF CHAR=0 THEN GOTO EXPCALC;    END;         GOTO F.ERROR; /* NOTHING BUT SPACES ALLOWED AT END */  END;     GOTO F.ERROR; /* ILLEGAL CHARACTER */     /* MULTIPLY IN THE EXPONENT */     EXPCALC:  IF EXPMAG>18 THEN GOTO F.ERROR; /* OVERFLOW */  DO WHILE (EXPMAG>=4);    IF PM.EXP=+1 THEN NUM=NUM*10000;    ELSE              NUM=NUM*.0001;    EXPMAG=EXPMAG-4;  END;     DO WHILE (EXPMAG>0);    IF PM.EXP=+1 THEN NUM=NUM*10.;    ELSE              NUM=NUM*.1;    EXPMAG=EXPMAG-1;  END;     DONE:  IF PM.FLAG=-1 THEN NUM=-NUM; /* MINUS SIGN */  RETURN (NUM);     /* ALL F.ERRORS COME HERE.  FLAG F.ERROR BY RETURNING -1E-19 */     F.ERROR:  error.flag=e.format;  NUM=-.0001*.00001*.00001*.00001; /* -1E-19 */  RETURN (NUM);END STR.TO.FLT;/* $PAGE */STR.TO.FIX:PROC(N.STRING) FIXED swap;   /* Converts a string to a fixed point number.  The string must be an  integer (leading and trailing blanks OK) with an optional decimal  point at end.  Zeroes are also allowed after decimal point.  */     DCL N.STRING FIXED ARRAY;  DCL (NUM,PTR,CHAR,PM.FLAG) FIXED;     GETCHAR:PROC FIXED; /* GET NEXT CHAR */    DCL CHAR FIXED;         IF PTR=N.STRING(0) THEN RETURN (0);         CHAR=BYTE(N.STRING,PTR);    PTR=PTR+1;    RETURN (CHAR);  END GETCHAR;     PM.FLAG=+1; /* PLUS-MINUS FLAG */  PTR=0; /* CHARACTER POINTER */  NUM=0;     /* STRIP OFF LEADING SPACES */     CHAR="040"; /* INITIALIZE TO GET INTO LOOP */  DO WHILE (CHAR="040");    CHAR=GETCHAR;  END;  IF CHAR=0 THEN GOTO F.ERROR; /* NO DIGITS */     IF (CHAR="053")\(CHAR="055") THEN DO; /* PLUS OR MINUS? */    IF CHAR="055" THEN PM.FLAG=-1;    CHAR=GETCHAR;    DO WHILE (CHAR="040"); /* IGNORE SPACES */      CHAR=GETCHAR;    END;    IF CHAR=0 THEN GOTO F.ERROR; /* NO DIGITS */  END;     DO WHILE (CHAR>"057")&(CHAR<"072"); /* DIGIT? */    NUM=NUM*10 + (CHAR-"060"); /* ADD IN DIGIT */    CHAR=GETCHAR;  END;  IF CHAR=0 THEN GOTO DONE; /* RETURN THE NO. */     IF (CHAR="056") THEN DO; /* DECIMAL POINT */    CHAR=GETCHAR;    IF CHAR=0 THEN GOTO DONE; /* RETURN THE NO. */  END;     DO WHILE (CHAR="060"); /* ZEROES CAN BE NEXT */    CHAR=GETCHAR;  END;  IF CHAR=0 THEN GOTO DONE; /* RETURN THE NO. */     DO WHILE (CHAR="040");  /* TRAILING SPACES OK */    CHAR=GETCHAR;  END;  IF CHAR=0 THEN GOTO DONE;   F.ERROR: error.flag=e.format;   DONE:  IF PM.FLAG=-1 THEN NUM=-NUM; /* INCLUDE MINUS SIGN */  RETURN (NUM);END STR.TO.FIX;/* $PAGE */ NUM.TO.STR:PROC(NUM,N.STRING,FORMAT) swap; /* CONVERT A NUMBER TO STRING */   /* This routine accepts a floating point number and converts it to  a string governed by the format passed in FORMAT. */     DCL NUM      FLOATING;  DCL FORMAT   FIXED ARRAY;  DCL N.STRING FIXED ARRAY;     DCL (LO.LIM,HI.LIM) FLOATING;  DCL (EXP.FLAG,DEC.PT,N.LEFT,N.RIGHT,LEAD.SP,TRAIL.SP) FIXED;  DCL (PTR,CHAR,PM.FLAG,SIG.DIG,NORM,N.SIGN) FIXED;  DCL (DP,ZS,I,N,DIG,EXP) FIXED;     DCL ASC.UPAR LIT '"136"';  GETCHAR:PROC FIXED; /* GET NEXT CHAR */    DCL CHAR FIXED;         IF PTR=FORMAT(0) THEN RETURN(0);         CHAR=BYTE(FORMAT,PTR);    PTR=PTR+1;    RETURN (CHAR);  END GETCHAR;     /* INITIALIZATIONS */     EXP.FLAG=0; /* EXPONENTIAL FORMAT FLAG */  DEC.PT  =0; /* DECIMAL POINT FLAG */  N.LEFT  =0; /* DIGITS TO LEFT OF DEC. PT. */  N.RIGHT =0; /* DIGITS TO RIGHT OF DEC. PT. */  LEAD.SP =0; /* LEADING SPACES */  TRAIL.SP=0; /* TRAILING SPACES */  N.STRING(0)=0; /* INITIALIZE OUTPUT STRING */     /* SCAN INFORMATION ABOUT FORMAT */     IF FORMAT(0)=0 THEN GOTO FORM.ERR; /* NULL STRING IS F.ERROR */  IF (FORMAT(0)=1)&(BYTE(FORMAT,0)=A.STAR) THEN GOTO FREE.FORM; /* FREE FORMAT */     PTR=0; /* POINTER INTO FORMAT STRING */  CHAR=GETCHAR; /* GET 1ST CHARACTER */     /* CHECK FOR LEADING SPACES */     DO WHILE (CHAR=A.SP);  LEAD.SP=LEAD.SP+1;  CHAR=GETCHAR;  END;  IF CHAR=0 THEN GOTO FORM.ERR; /* NO FORMAT GIVEN */     IF CHAR=A.MINUS THEN DO; /* MINUS SIGN */  PM.FLAG=1; /* MINUS, NO PLUS */  CHAR=GETCHAR;  IF CHAR=0 THEN GOTO FORM.ERR;  END;  ELSE IF CHAR=A.PLUS THEN DO; /* + SIGN */  PM.FLAG=2; /* MINUS OR PLUS */  CHAR=GETCHAR;  IF CHAR=0 THEN GOTO FORM.ERR;  END;  ELSE IF CHAR=A.SHARP THEN DO; /* 1ST DIGIT */  PM.FLAG=0; /* NO PLUS OR MINUS */  N.LEFT=1; /* DIGITS TO LEFT OF DEC. PT. */  CHAR=GETCHAR;  IF CHAR=0 THEN GOTO CONSTRUCT;  END;  ELSE IF CHAR=A.PERIOD THEN DO; /* DECIMAL POINT */  DEC.PT=1; /* DECIMAL PT. FLAG */  CHAR=GETCHAR;  IF CHAR=0 THEN GOTO FORM.ERR;  GOTO RSCAN; /* SCAN DIGITS TO RIGHT OF DEC. PT. */  END;  ELSE GOTO FORM.ERR; /* ILLEGAL CHARACTER */     /* SCAN DIGITS */     DO WHILE (CHAR=A.SHARP);  N.LEFT=N.LEFT+1;  CHAR=GETCHAR;  END;  IF CHAR=0 THEN GOTO CONSTRUCT;     /* DECIMAL PT. OR SPACES */     IF CHAR=A.PERIOD THEN DO;  DEC.PT=1; /* DECIMAL PT. FLAG */  CHAR=GETCHAR;  IF CHAR=0 THEN GOTO CONSTRUCT;  END;  ELSE IF CHAR=A.SP THEN GOTO TRAIL; /* TRAILING SPACES */  ELSE IF CHAR=ASC.UPAR THEN GOTO EXPSCAN; /* EXPONENTIAL FORMAT */  ELSE GOTO FORM.ERR; /* ILLEGAL CHARACTER */     /* SCAN DIGITS TO RIGHT OF DECIMAL PT. */     RSCAN:DO WHILE (CHAR=A.SHARP);  N.RIGHT=N.RIGHT+1;  CHAR=GETCHAR;  END;  IF CHAR=0 THEN GOTO CONSTRUCT;     /* SCAN FOR EXPONENT FIELD */     EXPSCAN:IF CHAR=ASC.UPAR THEN DO; /* EXPONENT FIELD */  /* CHECK FOR 4 MORE ^'S */  DO I=1 TO 4;  CHAR=GETCHAR;  IF CHAR<>ASC.UPAR THEN GOTO FORM.ERR;  END;  EXP.FLAG=1; /* EXPONENTIAL FORMAT FLAG */  CHAR=GETCHAR;  IF CHAR=0 THEN GOTO CONSTRUCT;  END;     /* TRAILING SPACES */     TRAIL:DO WHILE (CHAR=A.SP);  TRAIL.SP=TRAIL.SP+1;  CHAR=GETCHAR;  END;  IF CHAR=0 THEN GOTO CONSTRUCT;  ELSE GOTO FORM.ERR; /* ILLEGAL CHARACTER */     /* BEGIN CONSTRUCTING STRING */     CONSTRUCT:SIG.DIG=N.LEFT+N.RIGHT; /* NO. OF SIG. DIGITS */     HI.LIM=1;  DO I=1 TO SIG.DIG;  HI.LIM=HI.LIM*10.;  END;  LO.LIM=HI.LIM/10.;     /* NORMALIZE NUMBER */     IF NUM>=0 THEN N.SIGN=1; /* SIGN OF NUMBER */  ELSE N.SIGN=-1;  NUM=ABS(NUM); /* WORK WITH MAGNITUDE ONLY */     IF EXP.FLAG=1 THEN DO; /* NORMALIZE FOR EXP. FORMAT */  NORM=0; /* NORMALIZATION COUNTER */  IF NUM=0 THEN NORM=N.RIGHT; /* KLUDGE FOR ZERO */  ELSE DO WHILE (NUM>=HI.LIM) \ (NUM<LO.LIM);  IF NUM>=HI.LIM THEN DO;  NUM=NUM/10;  NORM=NORM-1;  END;  ELSE DO;  NUM=NUM*10.;  NORM=NORM+1;  END;  END;  END;  ELSE DO; /* NORMALIZE FOR FIXED FORMAT */  DO I=1 TO N.RIGHT;  NUM=NUM*10.;  END;  IF NUM/LO.LIM>=10. THEN GOTO OVER.ERR; /* NUMBER WILL NOT FIT */  END;     IF N.SIGN=1 THEN NUM=NUM+.501; /* ROUND THE NO.'S SIG. DIGITS */  ELSE NUM=NUM+.5; /* .5 TO BE ROUNDED TO INTEGER PART FOR NEG. NO. */     IF (NUM/LO.LIM >= 10.) THEN DO; /* GUARD AGAINST QUANTIZATION SLOP */  NUM=NUM/10.;  NORM=NORM-1;  END;     /* LEADING SPACES */     PTR=0;  DO I=1 TO LEAD.SP;  CALL PBYTE(N.STRING,PTR,A.SP);  PTR=PTR+1;  END;     /* PLUS OR MINUS */     IF N.SIGN>0 THEN DO;  IF PM.FLAG=2 THEN DO;  CALL PBYTE(N.STRING,PTR,A.PLUS);  PTR=PTR+1;  END;  IF PM.FLAG=1 THEN DO;  CALL PBYTE(N.STRING,PTR,A.SP);  PTR=PTR+1;  END;  END;  ELSE DO;  IF PM.FLAG<>0 THEN DO;  CALL PBYTE(N.STRING,PTR,A.MINUS);  PTR=PTR+1;  END;  END;  N.STRING(0)=PTR; /* UPDATE STRING LENGTH */     /* PRINT OUT DIGITS */     DP=0; /* DECIMAL PT. FLAG */  ZS=0; /* ZERO SUPPRESSION FLAG */  DO N=1 TO N.LEFT+N.RIGHT;  IF N=N.LEFT THEN ZS=1; /* TURN OFF ZERO SUPPRESSION FOR DIGIT BEFORE D.P. */  IF N=N.LEFT+1 THEN DO;  CALL PBYTE(N.STRING,N.STRING(0)+N-1,A.PERIOD); /* ADD DECIMAL PT. */  DP=1;  ZS=1; /* ZERO SUPPRESSION OFF (IN CASE N.LEFT=0) */  END;  DIG=INT(NUM/LO.LIM);  IF DIG<>0 THEN ZS=1;  IF (ZS=0) THEN CALL PBYTE(N.STRING,N.STRING(0)+N+DP-1,A.SP);  ELSE CALL PBYTE(N.STRING,N.STRING(0)+N+DP-1,DIG+"060"); /* ADD DIGIT */  NUM=NUM-DIG*LO.LIM; /* GET REMAINDER */  LO.LIM=LO.LIM/10.; /* SET FOR NEXT DIGIT */  END;  N.STRING(0)=N.STRING(0)+N.LEFT+N.RIGHT+DP; /* UPDATE STRING LENGTH */     /* SEE IF DECIMAL PT. AT END */     IF (DP=0)&(DEC.PT=1) THEN DO; /* ADD DECIMAL PT. */    CALL PBYTE(N.STRING,N.STRING(0),A.PERIOD);    N.STRING(0)=N.STRING(0)+1;  END;     /* DO EXPONENT FIELD IF NECESSARY */     IF EXP.FLAG=1 THEN DO;  EXP=N.RIGHT-NORM; /* THE EXPONENT */  /* OUTPUT SP,E,+ OR - */  CALL PBYTE(N.STRING,N.STRING(0),A.SP);  CALL PBYTE(N.STRING,N.STRING(0)+1,A.E);  IF EXP>=0 THEN CALL PBYTE(N.STRING,N.STRING(0)+2,A.PLUS);  ELSE           CALL PBYTE(N.STRING,N.STRING(0)+2,A.MINUS);  N.STRING(0)=N.STRING(0)+3;     /* OUTPUT EXPONENT */     IF EXP<0 THEN EXP=-EXP; /* ABSOLUTE VALUE */  IF EXP<10 THEN DO;     CALL PBYTE(N.STRING,N.STRING(0),EXP+"060");     CALL PBYTE(N.STRING,N.STRING(0)+1,A.SP);  END;  ELSE DO;     IF EXP>19 THEN DO;        CALL PBYTE(N.STRING,N.STRING(0),2+"060"); /* HAS TO BE A 2 */        EXP=EXP-20;     END;     ELSE DO;        CALL PBYTE(N.STRING,N.STRING(0),1+"060");        EXP=EXP-10;     END;     CALL PBYTE(N.STRING,N.STRING(0)+1,EXP+"060");  END;  N.STRING(0)=N.STRING(0)+2;  END;     /* OUTPUT TRAILING SPACES */     DO I=1 TO TRAIL.SP;     CALL PBYTE(N.STRING,N.STRING(0),A.SP);     N.STRING(0)=N.STRING(0)+1;  END;     /* MOVE LEADING + OR - TO BE LEFT OF DIGIT OR D.P. */     PTR=0;  DO WHILE (PTR<N.STRING(0));     CHAR=BYTE(N.STRING,PTR);     IF (CHAR=A.PLUS) \ (CHAR=A.MINUS) THEN GOTO SWAP_LOC;     IF CHAR<>A.SP THEN GOTO DONE;     PTR=PTR+1;  END;  GOTO DONE; /* WE SHOULD NEVER GET HERE */     SWAP_LOC:  DO WHILE (BYTE(N.STRING,PTR+1)=A.SP);     CALL PBYTE(N.STRING,PTR,A.SP);     CALL PBYTE(N.STRING,PTR+1,CHAR);     PTR=PTR+1;  END;  GOTO DONE;     /* FREE-FORMAT SECTION */     FREE.FORM:  error.flag=e.format; /* not implemented */  CALL EXIT(0);     /* ALL F.ERRORS IN FORMAT STRING ARRIVE HERE */     FORM.ERR:  error.flag=e.format;  CALL EXIT(0);     /* IF NUMBER IS TOO LARGE TO FIT IN FORMAT, WE COME HERE. */     OVER.ERR:  DO I=0 TO FORMAT(0)-1; /* PRINT *****'S */    IF      BYTE(FORMAT,I)=A.SP THEN CALL PBYTE(N.STRING,I,A.SP);    ELSE IF BYTE(FORMAT,I)=A.PERIOD THEN CALL PBYTE(N.STRING,I,A.PERIOD);    ELSE                               CALL PBYTE(N.STRING,I,A.STAR);  END;  N.STRING(0)=FORMAT(0);     /* SUCCESSFUL COMPLETION ARRIVES HERE */     DONE:END NUM.TO.STR;