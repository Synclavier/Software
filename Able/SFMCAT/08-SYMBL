/* 08-SYMBL  $TITLE  Module to Process Symbol Pointers *//* Copyright 1985 by New England Digital Corporation *//* The symbol table is contained in an array pointed to by global variableSYMBOL.PTR.  The global variable SYMBOL.SECTORS is the number of sectorsof the sound file alloted to the symbol table.The zeroth word of the array is the number of entries in the table--global declaration 'number.of.symbols' is core(f.symbolptr).Each entry consists of a time value, and a symbolic name of ("sym.chrs"characters max)Given a valid index into the array, these procedures are provided:SYMBOL_TIME      returns a pointer to the time value of the entry (length=3)SYMBOL_NAME      returns a pointer to the symbolic name of the entryREMOVE_SYMBOL    deletes the entryThe following are also provided:LOCATE_INDEX(name) returns the index to the entry with symbolic name NAMEADD_SYMBOL(sector,offset,name) adds a new entry to the table*/dcl sym.chrs      lit '8'; /* max number of characters per name */dcl symbol.length lit '(1+sym.chrs/2+3)'; /* words per symbol, including character count */dcl max.symbols   lit 'sector.size*symbol.sectors/symbol.length';  dcl name.entry    lit '3'; /* name starts with third word of entry */symbol_time:proc(index) fixed; /* returns pointer to the time vector */   dcl index fixed;   if (index<=0) or (index>number.of.symbols) then do; /* invalid index */           error.flag=e.index;      return 0;   end;     return f.symbolptr+(index-1)*symbol.length;end symbol_time;symbol_name:proc(index) fixed; /* returns pointer to name */   dcl index fixed;   if (index<=0) or (index>number.of.symbols) then do; /* invalid index */      error.flag=e.index;      return 0;                        end;     return f.symbolptr+(index-1)*symbol.length+name.entry; end symbol_name;test_name:proc(name) fixed swap; /* maps to upper case, checks for invalid name */   /* test_name also truncates at spaces and if name too long */   dcl name     fixed array;   dcl (i,char) fixed;   /* valid characters:  A-Z, 0-9, _, . */      if byte(name,name(0)-1)=a.cr then name(0)=name(0)-1; /* strip cr */   if name(0)=0 then return 1; /* null name */   char=byte(name,0); /* get first char */   if char>(A.A+"40") then char=char-"40"; /* up the case */   if (char<A.A) or (char>A.Z) then return 1; /* non alpha as first char */   if name(0)>sym.chrs then name(0)=sym.chrs; /* truncate long name */   do i=0 to name(0)-1; /* loop over chars */      char=byte(name,i); /* get character */      if char=A.SP then do; /* space - exit */         name(0)=i; /* set the length */         if name(0)=0 then return 1; /* invalid */         else              return 0; /* name valid */      end;      if char=>(A.A+"40") then do; /* lower case */         char=char-"40"; /* map to upper case */         call pbyte(name,i,char); /* replace in string */      end;        if ((char>=A.0) and (char<=A.9)) /* letters */      or ((char>=A.A) and (char<=A.Z)) /* digits  */      or (char=A.PERIOD) or (char=A.SCORE) then ; /* . and _ */      else                                 return 1; /* error if other char */   end; /* of loop over chars */   return 0; /* name is okay */end test_name;locate_index:proc(name) fixed; /* returns index number of symbolic name, 0 if not found */   dcl name    fixed array;   dcl pointer fixed; /* pointer to name entry in symbol table */     dcl (i,j)   fixed;   if test_name(name) then do; /* invalid name */      error.flag=e.inval.name;      return 0;   end;   do i=1 to number.of.symbols; /* loop over defined symbols */      pointer=symbol_name(i);         if compare(location(pointer),name) then return i; /* found name */   end;   return 0; /* name not found */end locate_index;add_symbol:proc(vector,name) fixed swap;  /* >0 is error return */   dcl vector  fixed array;    dcl name    fixed array;   dcl (i,j,k) fixed;   if number.of.symbols=max.symbols then do; /* table is full */      error.flag=e.table.full;      return 1;   end;   if test_name(name) then do; /* invalid name */      error.flag=e.inval.name;      return 1;   end;   if compare_vectors(vector,location(data.end),3)>0 then do; /* out of range */      error.flag=e.location;      return 1;   end;   if locate_index(name)<>0 then do; /* name already in table */      error.flag=e.dup.name;      return 1;   end;   i=1; /* increment i until time of new symbol >= time of a symbol */   do while (i<=number.of.symbols)   and (compare_vectors(vector,location(symbol_time(i)),3)>0);      i=i+1;   end;     if (i<=number.of.symbols) /* check for duplicate time */   and (compare_vectors(vector,location(symbol_time(i)),3)=0) then do;      error.flag=e.dup.loc;      return 1;   end;   j=number.of.symbols;   do while j>=i; /* move the symbols to make room for new symbol */      do k=0 to symbol.length-1;         core(f.symbolptr+j*symbol.length+k)=core(f.symbolptr+(j-1)*symbol.length+k);          end;      j=j-1;     end;     /* add new symbol */   k=f.symbolptr+(i-1)*symbol.length; /* precompute this */   do i=0 to 3-1; /* copy time into table */      core(k+i)=vector(i);   end;   call assign(location(k+name.entry),name);   number.of.symbols=number.of.symbols+1;    return 0;end add_symbol;remove_symbol:proc(index) swap; /* remove given symbol from table */   dcl index fixed;   dcl (i,j) fixed;   if (index<1) or (index>number.of.symbols) then do; /* invalid index */       error.flag=e.index;      return 1;   end;   if (index=1) or (index=number.of.symbols) then do; /* may not delete symbol */      error.flag=e.not.delete;      return 1;   end;   number.of.symbols=number.of.symbols-1; /* decrement symbol count */   do i=index to number.of.symbols; /* loop over remaining symbols */      do j=0 to symbol.length-1; /* shift them down */         core(f.symbolptr+(i-1)*symbol.length+j)=core(f.symbolptr+i*symbol.length+j);      end;   end;   return 0;end remove_symbol;                                            symbol_catalog:proc swap; /* prints list of all symbols in table */   dcl time   data ('Time');   dcl symbol data ('Symbol');   dcl (i,j)  fixed;                             clear;   call pos(5,1); /* jump into symbol display region of screen */   ps('Symbols for file '); ps(f.name);   call pos(7,1);  ps(symbol); /* print column headings */   call pos(7,16); ps(time);   call pos(7,41); ps(symbol);   call pos(7,56); ps(time);   call set_scroll(8,24); call pos(7,56); /* allow symbol display to scroll */   do i=0 to number.of.symbols-1; /* loop over number of symbols */      j=8+shr(i,1); /* compute new screen pos */      if i then call pos(j,41);      else      call pos(j, 1);      ps(location(symbol_name(i+1)));      if i then call pos(j,56);      else      call pos(j,16);      call print_time(location(symbol_time(i+1)),3,1);       if i then nl; /* scroll screen */   end;     nl; nl; /* force scroll */   call pos(j+2, 1); ps('Play Markers:');   nl; j=j+3; /* force scroll */   call pos(j, 1); ps('Start (#1)');   call pos(j,16); call print_time(mark.start,3,1);   call pos(j,41); ps('End (#2)');   call pos(j,56); call print_time(mark.end,3,1);   call set_scroll(1,2); /* restore scrolling status to normal */   display.type=sym.display; /* mark display as symbols list */end symbol_catalog;