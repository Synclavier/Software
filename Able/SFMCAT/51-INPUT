/* 51-INPUT  $TITLE  Command Line Parser and Handler *//* Copyright 1985 by New England Digital Corporation */dcl cur.comnd fixed; /* global for current command */get_number:proc(buf,word,len); /* copies numeric string from buf to word */   dcl (buf,word) fixed array;   dcl len        fixed;   dcl (ch,ptr)   fixed;   call strip_blanks(buf);   if len>(buf(0)-byte.ptr) then len=buf(0)-byte.ptr; /* limit to length of string */   ptr=0;   ch=byte(buf,byte.ptr); /* get first char */   do while (ptr<len) and (ch<>A.SP); /* loop until end or space */      call pbyte(word,ptr,ch); /* copy a char */      ptr=ptr+1;  byte.ptr=byte.ptr+1; /* advance pointers */      ch=byte(buf,byte.ptr); /* get next char */   end;   word(0)=ptr; /* set length */end get_number;save_spectral_file:proc(name,flag) fixed; /* saves spectrum in named file */   dcl name fixed array;   dcl flag fixed; /* 0 to save, 1 to replace, 2 to save or replace */   dcl i    fixed;   /* NOTE:  This procedure saves the current spectrum in a named file.      Since there are fft.len+1 words in a spectrum (0 to nyquist freq),      the and fft.len will be an even number of sectors,      the last point will be stored as the last word of the heading      block. */   if valid_filename(name)=err then do; /* name is invalid */      error.flag=e.format;      return 1;   end;   if locate(name,1) then do; /* name is already there */      if flag=0 then do; /* if save, then name should not be found */         error.flag=e.saved; return 1;      end;      else if f#type<>t#spect then do; /* if replace, check file type */         error.flag=f#type; return 1;      end;   end; /* of name is already there */   else if flag=1 then do; /* replace, and file not found */      error.flag=e.not.saved;      return 1;   end;   i=1+(current.fft.len+255)/sector.size; /* FFT Len > 256 */   if not replace(name,t#spect,0,i,shl(i,8),1) then do;      error.flag=e.no.room; return 1;   end;   do i=0 to 255; databuf1(i)=0; end; /* clear out descriptor */   databuf1(0) =compatibility.number;   databuf1(1) =current.fft.len;   databuf1(2) =current.window.num;   databuf1(3) =current.time(0);   databuf1(4) =current.time(1);   databuf1(5) =current.time(2);   databuf1(9) =current.window.type;   databuf1(10)=current.length;   databuf1(11)=1;   call copy_vector(location(addr(databuf1(14))),location(addr(hzlimit)),2);   call assign(location(addr(databuf1(20))),sound.file.name);   call assign(location(addr(databuf1(25))),caption);   databuf1(254)=core(addr(databuf2(current.fft.len/2))); /* last point in file */   databuf1(255)=core(addr(databuf2(current.fft.len/2))+1); /* 2nd word of fp number */   if f#ls_sector+1=0 then i=1; else i=0; /* carry */   call writedata(f#ms_sector+i,f#ls_sector+1,databuf2,current.fft.len); /* write points */   call writedata(f#ms_sector,f#ls_sector,databuf1,256); /* write descriptor */   return 0;end save_spectral_file;recover_spectral_file:proc(name,buffer,flag) fixed; /* recovers a spectral file */   dcl name   fixed array;   dcl buffer fixed array;   dcl flag   fixed; /* flag=1 to replace spectrum file; =0 to input file to be ratioed with current spectrum  */   dcl i      fixed;   if not locate(name,1) then do; /* if file is not in cat */      error.flag=e.not.saved;      return 1;   end;   if f#type<>t#spect then do;      error.flag=e.not.spec.file;       return 1;   end;   call readdata(f#ms_sector,f#ls_sector,buffer,256); /* read first sector */   if (compatibility.number<>buffer(0)) or (buffer(11) IGT 1) then do; /* buffer(11) is number of spectra in file */      /* if buffer(11)>1 then we were recording individual spectra */      error.flag=e.sys.error;      return 1;   end;   if flag then do; /* bring spectral file in as current file */      current.fft.len    =buffer(1);      current.window.num =buffer(2);      current.time(0)    =buffer(3);      current.time(1)    =buffer(4);      current.time(2)    =buffer(5);      current.window.type=buffer(9);      current.length     =buffer(10);      call copy_vector(location(addr(hzlimit)),location(addr(buffer(14))),2);      call assign(sound.file.name,location(addr(buffer(20))));      call assign(caption,location(addr(buffer(25))));   end;   else if current.fft.len<>buffer(1) then do; /* insist that file has same length as current spectrum */      error.flag=e.fft.len;      return 1;   end;   buffer(current.fft.len+1)=buffer(255); /* last word */   buffer(current.fft.len)  =buffer(254);   if f#ls_sector+1=0 then i=1; else i=0; /* carry */   call readdata(f#ms_sector+i,f#ls_sector+1,buffer,current.fft.len);   return 0;end recover_spectral_file;integrate:proc (sum); /* perform integration commands */   dcl sum floating array;   dcl i   fixed;   print_integral:proc;      dcl string(10) fixed; /* for "E" format conversion */      dcl format     data('-#.####^^^^^');      if integral=0. then return;      vector_mode;      data_level(2);      vector_mode;      call #transmit_coords(260,318);        ps('Integral=');      call num.to.str(integral,string,format);      alpha_mode;      ps(string); /* E format density */      data_level(0);      transparent_mode;   end print_integral;   integrate_spectrum:proc floating; /* integrates, (also zeros spectra) */      dcl x floating;      dcl i fixed;      x=0.;      if integral.origin<spectral.cursor then do i=integral.origin to spectral.cursor;         x=x+sum(i);      end;      else do i=spectral.cursor to integral.origin;        x=x+sum(i);      end;      return x;   end integrate_spectrum;   if (aux.key=1) and (integrate.on) then do; /* "ENTER" call for compute */      call print_integral;      integral=integral+integrate_spectrum;      call print_integral;      integrate.on=0;   end;   else if (aux.key=2) and (integrate.on) then do; /* comma, zero spectral coefficients */      if integral.origin<spectral.cursor      then do i=integral.origin to spectral.cursor; sum(i)=0.; end;      else do i=spectral.cursor to integral.origin; sum(i)=0.; end;      integrate.on=0;      call anal_data(1,databuf2,1);      call save_spectral_file(SPECTRU.FILE,2);   end;   else if (aux.key=3) and (integrate.on) then do; /* "-" call for compute negative */      call print_integral;      integral=integral-integrate_spectrum;      call print_integral;      integrate.on=0;   end;   else if aux.key=4 then do; /* "." set integration origin */      integrate.on=1;      integral.origin=spectral.cursor;      if      integral.origin<0         then integral.origin=0;      else if integral.origin>bandlimit then integral.origin=bandlimit;   end;      else if aux.key=6 then do; /* "0" clear integral */      call print_integral;      integral=0.;      integrate.on=0;   end;   aux.key=0; /* clear integrate command */end integrate;smooth:proc(sum,scratch,n); /* convolve spectrum with smoothing filter */   dcl sum     floating array;   dcl scratch floating array;   dcl n       fixed; /* 2n+1 fft bins will be averaged */   dcl x       floating;   dcl (i,j,k) fixed;   if n=0 then return; /* zero smoothing width */   do i=0 to bandlimit; /* loop over bins up to nyquist */      x=0.;      do j=i-n to i+n;         if      j<0 then         k=-j;            else if j>bandlimit then k=bandlimit*2-j;         else                     k=j;         x=x+sum(k);      end;      scratch(i)=x/(2*n+1);   end;   do i=0 to bandlimit; sum(i)=scratch(i); end; /* store result */end smooth;divide_spectra:proc(buffer1,buffer2,value) fixed; /* does SUBTRACT and INVERT functions */   dcl buffer1 floating array;   dcl buffer2 floating array;   dcl value   floating;   dcl mess1   data('');   dcl mess2   data('spectral ratio');   dcl i       fixed;   if value=0. then do i=0 to current.fft.len/2; /* doing SUBTRACT function */      if   buffer2(i)=0. then buffer2(i)=0.;      else                    buffer2(i)=buffer1(i)/buffer2(i);   end;   else do i=0 to current.fft.len/2; /* doing INVERT function */      if   buffer2(i)=0. then buffer2(i)=0.;      else                    buffer2(i)=value/buffer2(i);   end;   call assign(sound.file.name,mess1);   call assign(caption,mess2);   return 0;end divide_spectra;scale_spectra:proc(buffer1,value) fixed;   dcl buffer1 floating array;   dcl value   floating;   dcl mess1   data('');   dcl mess2   data('scaled spectrum');   dcl i       fixed;   if value =0. then return 1; /* avoid divide by zero */   else do i=0 to current.fft.len/2;      buffer1(i)=buffer1(i)/value;   end;   call assign(sound.file.name,mess1);   call assign(caption,mess2);   return 0;end scale_spectra;spectrum:  proc; /* spectral analysis */   dcl arguments fixed;   dcl time2(2)  fixed;   dcl num       fixed;   dcl temp (2)  fixed;   dcl temp1(2)  fixed;   dcl temp2(2)  fixed;   current.fft.len    =fft.len;   current.length     =window.length;   current.window.type=window.type;   hzlimit=clock.rate*500./period.index; /* band limit in hz */   call assign(sound.file.name,f.name);   call assign(caption,id.field);      arguments=0; /* assume no args */   if not read_time(current.time) then do; /* a time is returned */      /* NOTE: if no time is found, READ_TIME returns cursor.time */      if compare_vectors(current.time,location(data.end),3)>0 then do; /* past end of data */         error.flag=e.past.end;      end;      else do;         call get_command(local,temp); /* try to parse another token from command line */         arguments=1;         if interpret_command(temp,'TO  ',1)=1 then do; /* second time expected */            if read_time(time2) then error.flag=e.format; /* no second time found */            else do; /* second time value parsed */               arguments=2;               if compare_vectors(current.time,time2,3)>0 then do; /* swap the two times */                  call copy_vector(temp,        current.time,3);                  call copy_vector(current.time,time2,       3);                  call copy_vector(time2,       temp,        3);               end;            end; /* of second time value parsed */         end; /* of second time expected */      end; /* of else do */   end; /* of a time is returned */   do case arguments; /* handle command according to number of args in line */      do; /* 0:  error if no args */         if error.flag<>e.past.end /* out of range time not given */         then error.flag=e.format; /* no argument was given */         return;      end;      do; /* 1:  window.number has been set, limit to end of data */         temp(0)=0; /* set temp to last sample number */         temp(1)=window.offset*(window.number-1)/sector.size;         temp(2)=current.length;         call time_to_index(current.time,current.time,period.index); /* convrt current.time to samples */         call add_len_to_len(current.time,temp,temp); /* add to end sample number */         if compare_vectors(temp,location(valid.data),3)>0 then do; /* if past the end */            call sub_len_from_len(location(valid.data),current.time,temp); /* subtract start from end */            /* recompute number of spectra */            temp1(0)=0; temp1(1)=0; temp1(2)=current.length;            if sub_len_from_len(temp,temp1,temp2) then do;               call copy_vector(temp2,zero.vector,3);               current.length=temp(1)*sector.size+temp(2); /* reduce to actual number of points */               error.flag=0;            end;            write(5)=shl(temp2(1)&"377",8)+temp2(2); /* load lsb */            write(4)=shr(temp2(1),8); /* load msb */            write(7)=window.offset; /* divide by window offset */            num=read(5)+1; /* get quotient */            if num IGT 100 then num=100; /* limit to 100 spectra */         end;         else num=window.number; /* use window number as is */         call index_to_time(current.time,current.time,period.index); /* convrt current.time back to time */      end; /* of one arg case */      do; /* 2:  compute number of windows */         if compare_vectors(time2,location(data.end),3)>0 then /* if past end of data */            call copy_vector(time2,location(data.end),3); /* set to end of data */         call time_to_index(current.time,current.time,period.index); /* convrt times to samples */         call time_to_index(time2,time2,period.index);                          call sub_len_from_len(time2,current.time,temp); /* find difference in samples */         call index_to_time(current.time,current.time,period.index); /* convrt back to time */         /* compute number of spectra */         temp1(0)=0; temp1(1)=0; temp1(2)=current.length;         if sub_len_from_len(temp,temp1,temp2) then do;            call copy_vector(temp2,zero.vector,3);            current.length=temp(1)*sector.size+temp(2); /* reduce to actual number of points */            error.flag=0;         end;         write(5)=shl(temp2(1)&"377",8)+temp2(2); /* load lsb */         write(4)=shr(temp2(1),8); /* load msb */         write(7)=window.offset; /* divide by window offset */         num=read(5)+1; /* get quotient */         if num IGT 100 then num=100; /* limit to 100 spectra */      end; /* of two arg case */   end; /* of handle command according to number of args in line */   /* now call for analysis */   call anal_data(num,databuf2,0);   call save_spectral_file(SPECTRU.FILE,2);end spectrum;return_to_sfm:proc(flag);   dcl flag fixed;   call tty_wait; disable;   core(loc.rst)=flag;   ovl.error=error.flag;   sfm.intact=1; /* means SFM high-core is still valid */   call overlay(core(loc.p1+1),core(loc.p1),core(loc.p1-1)); /* return to main module of SFM */end return_to_sfm;status:proc;  /* prints status on old command line */   call pos(1,30); /* error position */   call error(error.flag);   error.flag=0;   call cursor_restore;   call tty_wait;end status;scan_input:  proc; /* command line parser */   dcl fp         floating;   dcl command(2) fixed;   dcl name(4)    fixed;   dcl str(10)    fixed;   dcl temp(2)    fixed;   dcl valid      data('SPE SET SAV REP UNS SMO REC SUB INV SCA ');   byte.ptr=0;   call get_command(in.buf,command);   call assign(local,in.buf); /* copy line into local buffer */   nl; /* scroll command line */   ps(prompt); /* prompt */   wait.for.scan=0; /* can begin new line */   in.buf(0)=0;   cur.comnd=interpret_command(command,valid,1);   if localbytes=0 then do; /* null line */      if spectral.cursor.mode=0 then call anal_data(1,databuf2,1);   end;   else do case cur.comnd; /* process command */                         call return_to_sfm(5); /* 0:  command not recognized */      call spectrum; /* 1:  SPECTRUM */      do; /* 2:  SET - change the value of a parameter */         if byte.ptr=localbytes then do; /* typed set with no args */            call set_menu(1); /* put up set menu */            spectral.cursor.mode=0; /* disable cursor */            error.flag=0; /* clear any errors */         end;           else if change_value then do; /* changed a value */            if      display.type=set.menu then call set_menu(0); /* update set menu */            else if replot.flag=1         then call anal_data(1,databuf2,1); /* update spectral plot */            replot.flag=0; /* done with replotting */         end;        end; /* set */      do; /* 3:  SAVE spectrum */         call get_filename(local,name,0);         if name(0)=0 then error.flag=e.format;         else              call save_spectral_file(name,0);         if display.type=cat.display then call catalog;      end;      do; /* 4:  REPLACE spectrum */         call get_filename(local,name,0);         if name(0)=0 then error.flag=e.format;         else              call save_spectral_file(name,1);         if display.type=cat.display then call catalog;      end;      do; /* 5:  UNSAVE spectrum */         call get_filename(local,name,0);         if name(0)=0 then error.flag=e.format;         else              call unsave(name);         if display.type=cat.display then call catalog;      end;      do; /* 6:  SMOOTH spectrum */         call scan_number(local,temp);         call smooth(databuf2,location(addr(databuf1(0))),temp(0));         call anal_data(1,databuf2,1);         call save_spectral_file(SPECTRU.FILE,2);      end;      do; /* 7:  RECOVER spectrum */         call get_filename(local,name,0);         if name(0)=0 then call assign(name,SPECTRU.FILE);         if not recover_spectral_file(name,location(addr(databuf2(0))),1) then            call anal_data(1,databuf2,1);      end;      do; /* 8:  SUBtract (ratio) named spectrum from current spectrum */         call get_filename(local,name,0);         if      name(0)=0 then error.flag=e.format;         else if not recover_spectral_file(name,databuf1,0) then do; /* could recover */            if divide_spectra(location(addr(databuf1(0))),databuf2,0) then                error.flag=e.sys.error;            else do; /* could divide */               call anal_data(1,databuf2,1);               call save_spectral_file(SPECTRU.FILE,2);            end;         end;      end; /* subtract */      do; /* 9:  INVERT spectrum about VALUE (in Db) */         call get_number(local,str,20);         if byte(str,0)=a.star then          call copy_vector(location(addr(fp)),location(addr(databuf2(spectral.cursor))),2);         else do;            if str(0)=0 then fp=-100./10; /* assume invert around -100 db */            else             fp=str.to.flt(str)/10.;            fp=exp(2.302587*fp);         end;         if divide_spectra(databuf2,databuf2,fp) then error.flag=e.sys.error;         else do; /* could divide */            call anal_data(1,databuf2,1);            call save_spectral_file(SPECTRU.FILE,2);         end;      end; /* of INVERT spectrum */      do; /* 10:  SCALE spectrum to VALUE (in dB) */         call get_number(local,str,20);         if byte(str,0)=a.star then            call copy_vector(location(addr(fp)),location(addr(databuf2(spectral.cursor))),2);         else do;            fp=str.to.flt(str)/10.;            fp=exp(2.302587*fp);         end;         if scale_spectra(databuf2,fp) then error.flag=e.sys.error;         else do; /* could divide */            call anal_data(1,databuf2,1);            call save_spectral_file(SPECTRU.FILE,2);         end;      end; /* of SCALE spectrum */   end; /* end do case */   break.rcvd=0; /* reset break flag */   call status; /* print OK or error message, any held characters */end scan_input;