/* 44-REV  $TITLE  REVERSE - routine to reverse a sound file *//* Copyright 1985 New England Digital Corporation */reverse: proc fixed; /* perform reverse of sound file */   dcl temp(2) fixed;   dcl (t1,t2) fixed;   rev:proc; /* subproc for actual data updates */      dcl in.start  (2)       fixed; /* starting sector */      dcl out.start (2)       fixed;      dcl in.sectors  (2)     fixed;      dcl out.sectors (2)     fixed;      dcl (lim,base,i,ii,j,k) fixed;      dcl sec(2)              fixed;      dcl (flag,flag2)        fixed;      dcl sectors (2)         fixed;      /* copy file offsets into appropriate vars */      file2;      call copy_vector(out.start,location(f.data.index),3);      file1;      call copy_vector(in.start, location(f.data.index),3);      out.sectors(0)=0;out.sectors(1)=0;out.sectors(2)=0;      call copy_vector(in.sectors,location(valid.data),3);      if in.sectors(2)<>0 then do;         in.sectors(1)=in.sectors(1)+1;         if in.sectors(1)=0 then in.sectors(0)=in.sectors(0)+1;         in.sectors(2)=0;      end;      lim=buf1.len-1; /* get length to process */      if lim IGT in.sectors(1) then lim=in.sectors(1); /* limit to file size */      sec(0)=0; sec(1)=lim; sec(2)=0;      flag=1; flag2=1;      call sub_len_from_len(in.sectors,sec,sectors);      do while (not break.rcvd) and flag; /* loop over sectors */         call add_len_to_addr(sectors,in.start,temp);         call pos(7,1);  ps('Reversing sector');         call pos(7,18); call erase_line; pnum(sectors(1)); ps('...');         if flag2 then do; /* first time */           flag2=0;           if compare_vectors(sectors,zero.vector,3)=0 then flag=0;           call readdata(temp(0),temp(1),databuf1,lim*sector.size);           ii=lim*sector.size; /* point to end */           do i=0 to lim*sector.size/2-1; /* 1st loop over samples in buffer */              ii=ii-1;              k=databuf1(ii); /* get input sample */              databuf1(ii)=databuf1(i);              databuf1(i)=k; /* store result */           end; /* of loop over samples */           if (core(valid.data+2)=0)           then call writedata(out.start(0),out.start(1),databuf1,lim*sector.size);             else if flag=0            then call writedata(out.start(0),out.start(1),location(addr(databuf1(sector.size-core(valid.data+2)))),(lim)*sector.size);           else call writedata(out.start(0),out.start(1),location(addr(databuf1(sector.size-core(valid.data+2)))),(lim-1)*sector.size);             do i=0 to core(valid.data+2)-1;; /* move down tail */              databuf1(i)=databuf1(i+(lim)*sector.size-core(valid.data+2));           end;           temp(0)=0; temp(2)=0; /* number of sectors read */           if core(valid.data+2)=0 then temp(1)=lim;           else                         temp(1)=lim-1;         end;         else do; /* rest of file */           if compare_vectors(sectors,zero.vector,3)=0 then flag=0;           call readdata(temp(0),temp(1),location(addr(databuf1(core(valid.data+2)))),lim*sector.size);           ii=(lim)*sector.size+core(valid.data+2);           do i=0 to lim*sector.size/2-1; /* 1st loop over samples in buffer */              ii=ii-1;              k=databuf1(ii); /* get input sample */              databuf1(ii)=databuf1(i+core(valid.data+2));              databuf1(i+core(valid.data+2))=k; /* store result */           end; /* of loop over samples */           if core(valid.data+2)=0           then call writedata(out.start(0),out.start(1),databuf1,lim*sector.size);           else call writedata(out.start(0),out.start(1),databuf1,(lim+1)*sector.size);           do i=0 to core(valid.data+2)-1; /* move down tail */              databuf1(i)=databuf1(i+(lim)*sector.size);           end;           temp(0)=0; temp(1)=lim; temp(2)=0; /* number of sectors read */         end;         call add_len_to_addr(temp,out.start,out.start);         if lim IGT sectors(1) then lim=sectors(1); /* limit to file size */         temp(1)=lim;         if sub_len_from_len(sectors,temp,temp) then do; /* decr sectors left */            /* this should be impossible            temp(0)=0; temp(1)=0; temp(2)=0;            error.flag=0; */ /* suppress error flag */         end;         call copy_vector(sectors,temp,3);      end; /* of loop over sectors */   end rev;   /* main code of REVERSE */   file1;   call copy_vector(temp,location(valid.data),3);   t1=file.data.type; /* get parameters of input file */   t2=period.index;   file2;   if new_file(temp) then do; /* open file to hold the extracted data */      /* error -- could not create new file */      call file(1,0); /* restore to FCB #1 */      return 1;   end;   file.data.type=t1\reversed.data; /* store parameters into output file */   period.index=t2;   call copy_vector(location(valid.data),temp,3);   call sub_len_from_len(location(valid.data),zero.zero.one,location(data.end));    call index_to_time(location(data.end),location(data.end),period.index);   call add_symbol(zero.vector,'Origin'); /* create basic symbols of output file */   call add_symbol(location(data.end),'End');   call copy_vector(mark.start,zero.vector,3);   call copy_vector(mark.end,location(data.end),3);   call caption_assign('Reversed data');   clear; call pos(5,1); ps('Please wait...'); /* clear screen and print prompt */   call rev; /* perform reverse operation */   record.flag=0;   call old(recordfile.name); /* call up the file */end reverse;