/* $TITLE Driver for Signal File Manager EDIT Mode Overlay (Mixing and Splicing) *//* Copyright 1985 by New England Digital Corporation *//* MODIFIED:   97/12/09 - TY  - fixed bug in "Write.Descriptors" that occurred when upper 8 bits of starting sector was non-zero*/enter ':sfmcat:editcat';insert ':-xpl:literals'; /* system literals */insert ':-xpl:asciilit'; /* ASCII literals */insert ':-xpl:scsi';     /* SCSI device drivers */insert ':-xpl:catrtns';  /* catalog routines */insert ':-xpl:termutil'; /* package of terminal management routines */insert ':-xpl:reldat';/* Literal Declarations */dcl In.Main.Module   lit '0';  /* Edit module is not the main module of SFM */dcl Cur.Level        lit '1';  /* Current device to be accessed (CURRENT CATALOG) */dcl Max.Files        lit '12'; /* Max number of files to splice at one time */dcl File.Desc.Secs   lit '3';  /* Sectors in sound file header */dcl Success          lit '9';  /* Code for successful EDIT operation */dcl No.Action        lit '10'; /* Code for no EDIT operation performed */dcl No.Char          lit '-1'; /* Code returned by FIRST_CHAR if string is empty */dcl Chained.From.SFM lit '3';  /* Value of CORE(LOC.RST) */dcl Y.Base           lit '6';  /* Base row of display */dcl X.Base           lit '0';  /* Base column of display */dcl Status.Pos       lit '43'; /* Column to begin typing status info *//* Global Variables */dcl BufSecs               lit '100'; /* length of main buffer */dcl WorkBuf (BufSecs*256) fixed; /* main work buffer */dcl ibuf (16)             fixed; /* input buffer */dcl testbuf(50)           fixed; /* buffer for testing stereo and sample rate validity */dcl File.Info(Max.Files*f#len)  fixed; /* Will hold the FCBs for files to be spliced */dcl catalog_buffer(c#dir_max-1) fixed; /* catalog buffer */dcl Filename (5)   fixed; /* Buffer to hold filename input */dcl Buf (5)        fixed;dcl Line (64)      fixed;dcl Ans (64)       fixed; /* Temp buffer for user input */dcl Num.Files      fixed; /* Number of files inputted so far */dcl Get.Filename   fixed; /* True if more filenames to get */dcl Block.Num      fixed; /* Block # of file in catalog */dcl New.File.Secs  fixed; /* Number of sectors needed for new file */dcl New.File.Words fixed; /* Number of words MODULO-64K needed for new file */dcl Overflow       fixed; /* True if splice file gets too big */dcl Digit          fixed;dcl Sign           fixed;dcl Volume         fixed; /* Volume scale factor for a file to mix */dcl Max.Abs.Volume lit '30000'; /* allows gains or cuts of up to 60 dB */dcl Repetitions    fixed; /* Repetition factor for a splice file */dcl Get.Num        fixed; /* True if need to get a repetition number */dcl Status         fixed; /* Takes code for status of most recent edit operation */dcl Mixing         fixed; /* 0->Splice, 1->Mix */dcl Abort          fixed; /* True if edit is not to be performed */dcl (i,j,k,l)      fixed;dcl Current.Com(64)   fixed; /* Used by ERROR procedure to echo error line */dcl Error.Flag        fixed; /* True if an error has occurred *//* Values that ERROR.FLAG can take on */dcl Format.Err        lit '0'; /* A format error in command line */dcl Filename.Err      lit '1'; /* Filename is not a valid name */dcl Filetype.Err      lit '2'; /* File is not a sound file */dcl File.Conflict.Err lit '3'; /* Output file is same as one of splice files */dcl Overflow.Err      lit '4'; /* Specified splice results in too large a file */dcl Disk.Space.Err    lit '5'; /* No room on disk to put new file */dcl System.Err        lit '6'; /* System error -- should never occur */dcl Range.Err         lit '7'; /* Value out of allowed range */dcl Stereo.Err        lit '8'; /* Stereo sound files not allowed */dcl Sample.Rate.Err   lit '9'; /* Sample rate cannot be above 50kHz *//* EXTRA DEFS FOR FCB AREA (TAKEN FROM :SFMCAT:06-GLOBL) */dcl f.name        lit 'location(fcb.ptr)';  /* file name */dcl f.name.bytes  lit 'core(fcb.ptr)';      /* word 0 of file name */dcl f.index       lit '(fcb.ptr+05)';       /* pointer to 3 word drive, sector, offset index vector */dcl f.drive       lit 'core(f.index+00)';   /* upper 8 bits of 24 bit sector */  dcl f.sector      lit 'core(f.index+01)';   /* starting sector */dcl f.offset      lit 'core(f.index+02)';   /* must be zero (3rd word of index.vector) */dcl f.tlength     lit '(fcb.ptr+8)';        /* pointer to 3 word vector, upper 8 bits of first word is upper 8 bits of 24 bit sectors */   dcl f.tlen.up     lit 'core(f.tlength+00)'; /* upper 8 bits of length in sectors */dcl f.tlen.low    lit 'core(f.tlength+01)'; /* lower 16 bits of 24 bit length */dcl f.tlen.offset lit 'core(f.tlength+02)'; /* offset, words */ dcl f.type        lit 'core(fcb.ptr+11)';   /* file type */insert ':sfmcat:00-sfm'; /* SFM high core defs */insert ':sfmcat:editcat:utility';   /* Custom utility routines for handling strings */insert ':sfmcat:editcat:01-VT640';  /* Code for plotting routines on VT640 terminals */insert ':sfmcat:editcat:02-SPLIC';  /* Code for butt splice operation */insert ':sfmcat:editcat:03-MIX';    /* Routine to mix a list of sound files */insert ':sfmcat:editcat:indtotim';  /* Routine to convert SFM index format to time format */Return.To.SFM: proc (Status); /* Performs chain back to SFM program */   dcl Status fixed; /* Status to return with */   Ovl.Error     = 0; /* Set up error code for return to SFM */   Sfm.Intact    = 1; /* Denotes that high core is still valid */   CORE(Loc.Rst) = Status;   call OVERLAY(core(LOC.P1+1),core(LOC.P1),core(LOC.P1-1)); /* Chain back to SFM */end Return.To.SFM;Error: proc (Message,Err.Type); /* Prints error messages */   dcl Message  fixed array; /* Message to be printed */   dcl Err.Type fixed; /* Code for type of error */   Error.Flag = true;   do case (Err.Type);      do; /* 0; FORMAT ERROR */         PCMD('Format problem:  '); PSTRING(Message);      end;      do; /* 1; FILENAME ERROR */         PCMD('Filename problem:  File "'); PSTRING(Message); PSTRING('" not found in current catalog.');      end;      do; /* 2; FILETYPE ERROR */         PCMD('File type problem:  File "'); PSTRING(Message); PSTRING('" is not a sound file.');      end;      do; /* 3; FILE CONFLICT ERROR */         PCMD('File conflict:  '); PSTRING(Message);      end;      do; /* 4; OVERFLOW ERROR */         PCMD('Overflow:  '); PSTRING(Message);      end;      do; /* 5; DISK SPACE ERROR */         PCMD('No Room:  '); PSTRING(Message);      end;      do; /* 6; SYSTEM ERROR */         PCMD('SYSTEM ERROR:  '); PSTRING(Message);      end;      do; /* 7; VALUE OUT OF RANGE ERROR */         PCMD('Value out of range:  '); PSTRING(Message);      end;      do; /* 8; STEREO ERROR */         PCMD('File type problem:  File "'); PSTRING(Message); PSTRING('" is a stereo sound file.');      end;      do; /* 9; SAMPLING RATE ERROR */         PCMD('File type problem:  File "'); PSTRING(Message); PSTRING('" has a sampling rate over 50Khz.');      end;   end;   CRLF;   if Current.Com(0) > 0 then do; PSTRING('Line was:  "'); PSTRING(Current.Com); PSTRING('".'); end;end Error;/* $page */Write.Descriptors: proc (MS.Start.Sector, LS.Start.Sector,FCB.Array, Num.Files, Sec.Len, Word.Len); /* Writes descriptor sectors to sound files */   dcl MS.Start.Sector fixed; /* Starting sector of sound file */   dcl LS.Start.Sector fixed;   dcl FCB.Array       fixed array; /* Holds FCBs for files that were spliced */   dcl Num.Files       fixed; /* Number of files in FCB.ARRAY */   dcl Sec.Len         fixed; /* Length of new file in sectors */   dcl Word.Len        fixed; /* Length of new file in words MODULO-64K */   dcl Buf (File.Desc.Secs * 256) fixed; /* Buffer to hold Sound File descriptor area */   dcl Old.Desc.Buf (256)         fixed; /* Holds 1st sector of desc. area of 1st spliced file */   dcl Octave.Default             floating;   dcl Temp (3)                   fixed; /* Temp array for SFM file index values */   dcl i                          fixed;   /* SFM Specific Literals */   dcl Spliced.Data      lit '64'; /* Bit flags used by main SFM code */   dcl Mixed.Data        lit '128';   dcl Splice.Caption    data ('Spliced Data'); /* Caption associated with new file */   dcl Mix.Caption       data ('Mixed Data');   dcl Start.Symbol      data ('ORIGIN'); /* Label for start at start of file */   dcl End.Symbol        data ('END'); /* Label for end of file */   dcl A440              lit '3.09'; /* default octave value */   /* Index offsets into Sound File descriptor area of system variables */   dcl O.Compatibility   lit '0';   /* Offset into BUF of COMPATIBILITY */   dcl O.File.Data.Type  lit '1';   /* Offset into BUF of FILE.DATA.TYPE */   dcl O.Valid.Data      lit '2';   /* Offset into BUF of VALID.DATA */   dcl O.Total.Data      lit '6';   /* Offset into BUF of TOTAL.DATA */   dcl O.Data.End        lit '9';   /* Offset into BUF of DATA.END */   dcl O.Hertz           lit '18';  /* Offset into BUF of HERTZ */   dcl O.Octave          lit '19';  /* Offset into BUF of OCTAVE */   dcl O.Period.Index    lit '21';  /* Offset into BUF of PERIOD.INDEX */   dcl O.Mark.Start      lit '23';  /* Offset into BUF of MARK.START */   dcl O.Mark.End        lit '26';  /* Offset into BUF of MARK.END */   dcl O.Cursor.Time     lit '29';  /* Offset into BUF of CURSOR.TIME */   dcl O.Numb.Symbols    lit '33';  /* Offset into BUF of NUMBER.OF.SYMBOLS */   dcl O.ID.Field        lit '127'; /* Offset into BUF of ID.FIELD */   dcl O.Symbol.Area     lit '256'; /* Offset into BUF of start of Symbol Table */   /* $SUBTITLE Code for WRITE.DESCRIPTORS and GET.DATA.LENGTH */   do i = 0 to (File.Desc.Secs * 256) - 1; Buf(i) = 0; end; /* Zero out BUF */   if c#ls_sector+fcb.array(f#ls) ILT c#ls_sector then i=1; else i=0;   call READDATA(c#ms_sector+fcb.array(f#ms)+i,c#ls_sector+fcb.array(f#ls),Old.Desc.Buf,256); /* Read in descriptor area of first file in splice */   Buf(O.Compatibility) = Compatibility.Number;   if Mixing=1 then Buf(O.File.Data.Type) = Mixed.Data;   else             Buf(O.File.Data.Type) = Spliced.Data;   /* Compute number of data points in new sound file */   Buf(O.Valid.Data) = 0; /* No high order bits in file length allowed yet */   if (Word.Len MOD 256) <> 0 then Buf(O.Valid.Data + 1) = Sec.Len - 1 - File.Desc.Secs;   else                            Buf(O.Valid.Data + 1) = Sec.Len - File.Desc.Secs;   Buf(O.Valid.Data + 2) = Word.Len MOD 256; /* Offset into last data sector */   /* Compute number of sectors occupied by data portion of sound file on disk */   Buf(O.Total.Data) = 0; /* No high order bits in file length allowed yet */   Buf(O.Total.Data + 1) = Sec.Len - File.Desc.Secs;   Buf(O.Total.Data + 2) = 0;   /* Compute time value of last valid data point in new sound file */   Temp(0) = 0; /* No high order bits in file length allowed yet */   if Buf(O.Valid.Data + 2) = 0 then Temp(1) = Buf(O.Valid.Data + 1) - 1;   else                              Temp(1) = Buf(O.Valid.Data + 1);   if Buf(O.Valid.Data + 2) = 0 then Temp(2) = 255;   else                              Temp(2) = Buf(O.Valid.Data + 2) - 1;   call INDEX_TO_TIME(LOCATION(ADDR(Buf(O.Data.End))),Temp,Old.Desc.Buf(O.Period.Index));   Buf(O.Period.Index) = Old.Desc.Buf(O.Period.Index); /* Use period of 1st spliced file for now */   Octave.Default      =A440;   Buf(O.Octave  )     = core(addr(Octave.Default)  ); /* Set octave to 3.09 */   Buf(O.Octave+1)     = core(addr(Octave.Default)+1); /* Set octave to 3.09 */   Buf(O.Hertz)        = 4400; /* Use default of 440.0 Hz */   /* Define CURSOR POSITION, and START and END play markers */   do i = 0 to 2;      Buf(O.Cursor.Time + i) = 0; /* Put cursor at start of file */      Buf(O.Mark.Start + i)  = 0; /* Start playing from beginning of file */      Buf(O.Mark.End + i)    = Buf(O.Data.End + i); /* Play to end of file */   end;   /* Copy new caption into proper area in descriptor area */   if Mixing=1 then do; /* use MIX caption */      Buf(O.ID.Field) = Mix.Caption(0);      do i = 0 to Mix.Caption(0) - 1;         call PBYTE(LOCATION(ADDR(Buf(O.ID.Field))),I,BYTE(Mix.Caption,I));      end;   end;   else do; /* use SPLICE caption */      Buf(O.ID.Field) = Splice.Caption(0);      do i = 0 to Splice.Caption(0) - 1;         call PBYTE(LOCATION(ADDR(Buf(O.ID.Field))),i,BYTE(Splice.Caption,i));      end;   end;   /* Set up initial Sound File symbols, ORIGIN and END */   Buf(O.Numb.Symbols) = 2; /* Only two symbols to start */   do i = 0 to 2; Buf(O.Symbol.Area +  0 + i) = 0; end; /* Time vector of ORIGIN symbol */   do i = 0 to 4; Buf(O.Symbol.Area +  3 + i) = Start.Symbol(i); end; /* Copy symbol name to table */   do i = 0 to 2; Buf(O.Symbol.Area +  8 + i) = Buf(O.Data.End + i); end; /* Time vector of END symbol */   do i = 0 to 4; Buf(O.Symbol.Area + 11 + i) = End.Symbol(i); end; /* Copy symbol name to table */   if ((LS.Start.Sector<>0) or (MS.Start.Sector<>0))   /* then call WRITEDATA((shl(shr(core(LOC.UCAT+1),8),8) or MS.Start.Sector),LS.Start.Sector,Buf,shl(File.Desc.Secs,8));*//* Write out desc. area */   then call WRITEDATA(MS.Start.Sector,LS.Start.Sector,Buf,shl(File.Desc.Secs,8)); /* Write out desc. area */end Write.Descriptors;Get.Data.Length: proc (Blk); /* Determines how much real data in a sound file */   dcl Blk          fixed array; /* Holds FCB for a file */   dcl Buf (31)     fixed; /* Buffer to hold sound file descriptors */   dcl O.Valid.Data lit '2'; /* Offset into BUF of VALID.DATA array */   dcl i            fixed;   if c#ls_sector+blk(f#ls) ILT c#ls_sector then i=1; else i=0;   call READDATA(c#ms_sector+blk(f#ms)+i,c#ls_sector+blk(f#ls),Buf,32); /* Read in start of descriptor area */   /* Update actual file lengths */   Blk(f#ll)  = Buf(O.Valid.Data + 1); /* Set FCB for full sectors left to buffer */   Blk(f#wd)  = Buf(O.Valid.Data + 2); /* Set FCB for extra words left to buffer */end Get.Data.Length;/* $SUBTITLE Code to Build Splice File List */call set_catbuf (addr(catalog_buffer(0)), 0); /* set up catalog buffer */if core(LOC.RST)<>Chained.from.SFM then call exit(-1);enable;clear_vt640;i=core(c#contab+c#vstart)+core(c#contab+c#vlngth)+core(c#contab+c#stklen);if i IGE ((60*1024)-1928) then do;   /* this check will catch errors where the program is too large for 60K systems */   pstringr('SYSTEM PROGRAMMING ERROR:  This module of SFM is too large to run.');   flush_term;   call exit(-1); /* quit with stop status */end;SET_CHAR_SIZE(1); PLOT_STRING('Edit Functions ');SET_CHAR_SIZE(0); PLOT_STRING(rel.date); TRANSPARENT_MODE; Mixing=(-1);do while ((Mixing <> a.0) and (Mixing <> a.1) and (Mixing <> a.cr)); /* loop until we get a 0 or 1 */   POS(3,0); ERASE_LINE;   PSTRING('Enter 0 to perform SPLICING, or 1 to perform MIXING: ');   flush_term; disable;   linput ibuf;   Mixing = (byte(ibuf, 0));   enable;end;if Mixing=a.0 then Mixing=0; /* do a splice */else if Mixing=a.1 then Mixing=1; /* do a mix */else Mixing=2; /* CR, so do nothing - back to SFM */if Mixing=0 then begin; /* perform SPLICING function */   POS(3,0); ERASE_LINE;   PSTRINGR('Type in the names of the files to be SPLICED together (in the order that');   PSTRINGR('they should be joined), followed by an optional repetition factor.');   Status       = No.Action; /* No EDIT operation has occurred yet */   Num.Files    = 0; /* Initialize */   Get.Filename = true; /* Initialize */   Abort        = false; /* Don't want to abort initially */   /* $PAGE */   do while (Get.Filename);      Error.Flag = false;      POS(Y.Base + Num.Files,X.Base); ERASE_LINE;      PSTRING('File #'); UNUM(Num.Files + 1,0);       if Num.Files < 9 then PSTRING(':  ');      else                  PSTRING(': ');      GET.LINE(Filename,8,A.CR);      if FIRST_CHAR(Filename) <> No.Char then do; /* User has typed in another filename and optional repeater */         do i = 0 to Filename(0) - 1; call PBYTE(Current.Com,i,BYTE(Filename,i)); end; /* Copy most recent command */         Current.Com(0) = Filename(0);         if not LOCATE(Filename,Cur.Level) then call ERROR(Filename,Filename.Err);         else do; /* Have a file to look at */            Block.Num = FINDFILE(Filename); /* Get block # of file in catalog */            call GET_FCB(Block.Num,LOCATION(ADDR(File.Info(Num.Files*f#len)))); /* Put FCB into array */            if File.Info((Num.Files*f#len)+f#ty) <> T#SOUND then call ERROR(Filename,Filetype.Err);            /* read in the header to check stereo and sample rate */            if c#ls_sector+(File.Info((Num.Files*f#len)+f#ls)) ILT c#ls_sector then j=1; else j=0;            call readdata(c#ms_sector+File.Info((Num.Files*f#len)+f#ms)+j,c#ls_sector+File.Info((Num.Files*f#len)+f#ls),testbuf,50);            if (testbuf(41)<>0) then call ERROR(Filename,Stereo.Err);            else if (testbuf(42)>500) then call ERROR(Filename,Sample.Rate.Err);         end;         if not Error.Flag then do;            Get.Num = true; /* Initialize */            do while(Get.Num); /* Loop until a good response has been received */               Get.Num = false; /* Assume good response received */               POS(Y.Base + Num.Files,X.Base + 21); ERASE_LINE; PSTRING('How many copies: ');               GET.LINE(Line,8,A.CR); /* Get a number string */               do i = 0 to Line(0) - 1; call PBYTE(Current.Com,I,BYTE(Line,I)); end; /* Copy most recent command */               Current.Com(0) = Line(0);               if FIRST_CHAR(Line) <> No.Char then do; /* User has typed a repetition factor */                  Repetitions = 0; /* Initialize */                  if (FIRST_CHAR(Line) >= A.0) and (FIRST_CHAR(Line) <= A.9) then do;                     do while ((FIRST_CHAR(Line) >= A.0) and (FIRST_CHAR(Line) <= A.9)                                and (not Error.Flag) and (Line(0) > 0));                        Digit = FIRST_CHAR(Line) - A.0; /* Get next digit on line */                        if Repetitions IGT (Repetitions * 10 + Digit) then do;                           call ERROR('Repetition factor too large for this program.',Overflow.Err);                           Get.Num = true;                           Line(0) = 0; /* Clear line buffer */                        end;                        else do;                           Repetitions = Repetitions * 10 + Digit;                           STRIP_FIRST_CHAR(Line); /* Get rid of digit */                        end;                     end;                  end;                  else do;                     call ERROR('Repetition factor begins with non-numeric characters.',Format.Err);                     Get.Num = true;                     Line(0) = 0; /* Clear line buffer */                  end;               end; /* of IF FIRST_CHAR(LINE) <> NO.CHAR THEN DO */               else do; Repetitions = 1; UNUM(1,0); end;/* Default case */               Error.Flag = false; /* Reset */               if (Line(0) <> 0) then call ERROR('Extra characters found at end of line.',Format.Err);            end; /* of DO WHILE (GET.NUM) */         end; /* of IF NOT ERROR.FLAG THEN DO */         if not Error.Flag then do;            File.Info(Num.Files*f#len+f#ty) = Repetitions; /* Put number of repetitions into FCB structure as file type */            Num.Files = Num.Files + 1; /* Increment file count */            ERASE_COMMAND; CRLF; ERASE_LINE; /* Erase any error message recieved on this command */                     if Num.Files = Max.Files then do;               POS(Y.Base+Num.Files,X.Base); PSTRING('No more files can be spliced in this SPLICE operation.');               Get.Filename = false;            end;         end;      end; /* of IF FIRST_CHAR(FILENAME) <> NO.CHAR THEN DO */      else do;         Get.Filename = false; /* User hit just CR */         WCHAR(A.CR); ERASE_LINE;         ERASE_COMMAND; CRLF; ERASE_LINE;      end;         end; /* of DO WHILE (GET.FILENAME) */   /* $SUBTITLE Code to Compute New File Size and Initiate Splice */   if (Num.Files > 0) then do;      New.File.Secs = 0; /* Initialize */      New.File.Words = 0; /* Initialize */      /* Compute size of file to be created */      Overflow = false;      i = 0; /* initialize file number */      do while ((i ILE (Num.Files - 1)) and not Overflow);         call GET.DATA.LENGTH(LOCATION(ADDR(File.Info(i*f#len)))); /* Adjust FCB file length values */         j = 1; /* Initialize */         do while (j ILE (File.Info((i*f#len)+f#ty) and not Overflow)); /* Repeat file correct number of times */            if (New.File.Secs + File.Info((i*f#len)+f#ll)) ILT New.File.Secs then Overflow = true;            New.File.Secs = New.File.Secs + File.Info((i*f#len)+f#ll); /* Add sector length of file */            New.File.Words = New.File.Words + File.Info((i*f#len)+f#wd);            if (New.File.Secs + shr(New.File.Words,8)) ILT New.File.Secs then Overflow = true;            New.File.Secs = New.File.Secs + shr(New.File.Words,8); /* If NEW.FILE.WORDS >= whole sector */            New.File.Words = New.File.Words MOD 256;            j = j + 1;         end;         i = i + 1;      end;      if New.File.Secs + File.Desc.Secs ILT New.File.Secs then Overflow = true;      New.File.Secs  = New.File.Secs + File.Desc.Secs; /* Add in length of sound file descriptor area */      New.File.Words = New.File.Words + ((New.File.Secs MOD 256) * 256); /* Convert to MODULO-64K */      if (New.File.Words MOD 256) <> 0 then New.File.Secs = New.File.Secs + 1;      if (New.File.Secs = 0) or (New.File.Secs IGT 60000) then Overflow = true; /* limit file length to 60000 */      Current.Com(0) = 0; /* Get rid of last line typed */      if Overflow then call ERROR('Specified splice results in file larger than 60000 sectors.',Overflow.Err);      else if (findstorage(0,New.File.Secs) <> -1) then do; /* Enough room on disk for file */         Get.Filename = true;         do while (Get.Filename); /* Loop until you get a good name */            Get.Filename = false;            Error.Flag = false;            POS(20,0); ERASE_LINE; PSTRING('Enter name of new file (Press <RETURN> to abort edit)?  ');            GET.LINE(Filename,8,A.CR); WCHAR(A.CR); ERASE_LINE;            if Filename(0) = 0 then Abort = true; /* User wants to quit edit */            else do;               do i = 0 to Filename(0) - 1; call PBYTE(Current.Com,i,BYTE(Filename,i)); end; /* Copy filename */               Current.Com(0) = Filename(0);               if VALID_FILENAME(Filename)=0 then do; /* illegal filename supplied */                  call ERROR('Name is not a valid filename',0);               end;               else do i = 0 to Num.Files - 1; /* Check to see file name is not same as one of splice files */                  Buf(0) = 8;                  do j = 0 to shr(f#name_len,1)-1; Buf(j+1) = File.Info((i*f#len)+(j)); end; /* Convert filename to string format */                  do j = 0 to f#name_len-1;                     if BYTE(Buf,j) = 0 then Buf(0) = Buf(0) - 1;                  end;                  if COMPARE(Filename,Buf,0)                   then call ERROR('Your output file may not be the same as any of the splice files.',File.Conflict.Err);               end;               if not Error.Flag then do;                  if LOCATE(Filename,Cur.Level) then do; /* Verify overwrite */                     ERASE_COMMAND; CRLF; ERASE_LINE; /* Erase any error messages remaining */                     POS(20,0); PSTRING('"'); PSTRING(Filename); PSTRING('"');                     PSTRINGR(' already exists on the disk.  Press <RETURN> to enter');                     PSTRING('a new name or type GO to overwrite the existing version -->');                     GET.LINE(Ans,2,A.CR); CRLF;                     do I = 20 to 21; POS(i,0); ERASE_LINE; end;                     if not COMPARE(Ans,'GO',0) then Get.Filename = true;                  end;               end; /* of IF NOT ERROR.FLAG THEN DO */               else Get.Filename = true;            end; /* of ELSE DO */         end; /* of DO WHILE (GET.FILENAME) */         /* $PAGE */         Current.Com(0) = 0; /* Erase last filename typed */         if not Abort then do;            if REPLACE(Filename,t#sound,0,New.File.Secs,New.File.Words,Cur.Level) /* Allocate space */            then do; /* go ahead and perform splice */               call BUTT.SPLICE(f#ms_sector,f#ls_sector,File.Info,Num.Files,WorkBuf,BufSecs); /* Perform splice */               /* Now write the Sound File descriptor information to the disk */               call WRITE.DESCRIPTORS(f#ms_sector,f#ls_sector,File.Info,Num.Files,New.File.Secs,New.File.Words);               Status = Success;               PCMD('Splice completed. New file is '); UNUM(New.File.Secs,0); PSTRINGR(' sectors long.');               j = 0;               do i = 0 to Num.Files - 1;                  j = j + File.Info((i*f#len) + f#ty); /* Count total number of splices */               end;               PSTRING('Total number of splice operations performed was '); UNUM(J,0); WCHAR(A.PERIOD);            end;         end; /* of IF NOT ABORT THEN DO */         else do; PCMD('Edit operation aborted.'); CRLF; ERASE_LINE; end;      end; /* of IF FINDSTORAGE THEN DO */      else call ERROR('There is not enough space in current catalog for new file.',Disk.Space.Err);   end; /* of IF (NUM.FILES > 0) THEN DO */   else PCMD('No SPLICE operation requested.');end; /* of begin block for splicing operation *//* $SUBTITLE Mixing Routine */else if Mixing=1 then begin; /* perform mixing operation */   POS(3,0); ERASE_LINE;   PSTRINGR('Type in the names of the files to be MIXED together, followed by an');   PSTRING('optional volume scaling factor in the range of ');   PNUM(-Max.Abs.Volume,0); PSTRING(' to +'); PNUM(Max.Abs.Volume,0); PSTRINGR('.');   Status       = No.Action; /* No EDIT operation has occurred yet */   Num.Files    = 0; /* Initialize */   Get.Filename = true; /* Initialize */   Abort        = false; /* Don't want to abort initially */   do while (Get.Filename);      Error.Flag = false;      POS(Y.Base + Num.Files,X.Base); ERASE_LINE;      PSTRING('File #'); UNUM(Num.Files + 1,0);       if Num.Files < 9 then PSTRING(':  ');      else                  PSTRING(': ');      GET.LINE(Filename,8,A.CR);      if FIRST_CHAR(Filename) <> No.Char then do; /* User has typed another filename and optional repeater in */         do i = 0 to Filename(0) - 1; call PBYTE(Current.Com,i,BYTE(Filename,I)); end; /* Copy most recent command */         Current.Com(0) = Filename(0);         if not LOCATE(Filename,Cur.Level) then call ERROR(Filename,Filename.Err);         else do; /* Have a file to look at */            Block.Num = FINDFILE(Filename); /* Get block # of file in catalog */            call get_fcb(Block.Num,LOCATION(ADDR(File.Info(Num.Files*f#len)))); /* Put FCB into array */            if File.Info((Num.Files*f#len)+f#ty) <> t#sound then call ERROR(Filename,Filetype.Err);            /* read in the header to check stereo and sample rate */            if c#ls_sector+(File.Info((Num.Files*f#len)+f#ls)) ILT c#ls_sector then j=1; else j=0;            call readdata(c#ms_sector+File.Info((Num.Files*f#len)+f#ms)+j,c#ls_sector+File.Info((Num.Files*f#len)+f#ls),testbuf,50);            if (testbuf(41)<>0) then call ERROR(Filename,Stereo.Err);            else if (testbuf(42)>500) then call ERROR(Filename,Sample.Rate.Err);         end;         if not Error.Flag then do;            Get.Num = true; /* Initialize */            do while(Get.Num); /* Loop until a good response has been received */               Get.Num = false; /* Assume good response received */               POS(Y.Base + Num.Files,X.Base + 21); ERASE_LINE; PSTRING('Volume Level: ');               GET.LINE(Line,8,A.CR); /* Get a number string */               do i = 0 to Line(0) - 1; call PBYTE(Current.Com,i,BYTE(Line,I)); end; /* Copy most recent command */               Current.Com(0) = Line(0);               if FIRST_CHAR(Line) <> No.Char then do; /* User has typed a vol level factor */                  Sign=(+1); /* Assume a positive volume */                  if (FIRST_CHAR(Line)=A.MINUS) then do;                      Sign=(-1); STRIP_FIRST_CHAR(Line);                  end;                  else if FIRST_CHAR(Line)= A.PLUS then STRIP_FIRST_CHAR(Line);                  Volume = 0; /* Initialize */                  if (FIRST_CHAR(Line) >= A.0) and (FIRST_CHAR(Line) <= A.9) then do;                     do while ((FIRST_CHAR(Line) >= A.0) and (FIRST_CHAR(Line) <= A.9)                                and (not Error.Flag) and (Line(0) > 0));                        Digit = FIRST_CHAR(Line) - A.0; /* Get next digit on line */                        if abs(Volume*10+Digit) IGT Max.Abs.Volume then do;                           call Error('Volume level must be between -30000 and 30000.',Range.Err);                           Get.Num = true;                           Line(0) = 0; /* Clear line buffer */                        end;                        else do;                           Volume = Volume * 10 + Digit;                           STRIP_FIRST_CHAR(Line); /* Get rid of digit */                        end;                     end;                     Volume=Volume*Sign;                  end;                  else do;                     call ERROR('Volume level begins with non-numeric characters.',Format.Err);                     Get.Num = true;                     Line(0) = 0; /* Clear line buffer */                  end;               end; /* of IF FIRST_CHAR(LINE) <> NO.CHAR THEN DO */               else do; Volume = 1000; UNUM(1000,0); end;/* Default case */               Error.Flag = false; /* Reset */               if (Line(0) <> 0) then call ERROR('Extra characters found at end of line.',Format.Err);            end; /* of DO WHILE (GET.NUM) */         end; /* of IF NOT ERROR.FLAG THEN DO */         if not Error.Flag then do;            File.Info((Num.Files*f#len)+f#ty) = Volume; /* Put volume level into FCB structure in type position*/            Num.Files = Num.Files + 1; /* Increment file count */            ERASE_COMMAND; CRLF; ERASE_LINE; /* Erase any error message recieved on this command */                     if Num.Files = Max.Files then do;               POS(Y.Base+Num.Files,X.Base); PSTRING('No more files can be mixed in this MIXING operation.');               Get.Filename = false;            end;         end;      end; /* of IF FIRST_CHAR(FILENAME) <> NO.CHAR THEN DO */      else do;         Get.Filename = false; /* User hit just CR */         WCHAR(A.CR); ERASE_LINE;         ERASE_COMMAND; CRLF; ERASE_LINE;      end;         end; /* of DO WHILE (GET.FILENAME) */   /* $SUBTITLE Code to Compute New File Size and Initiate Splice */   if (Num.Files > 0) then do;      /* Size of file to be created equals largest specified sound file */      New.File.Secs=0; New.File.Words=0; /* Initialize */      do i=0 to num.files-1;         call Get.Data.Length(location(addr(file.info(i*f#len))));         if  (File.Info(i*f#len+f#ll) IGT New.File.Secs)         or ((File.Info(i*f#len+f#ll)  =  New.File.Secs)         and (File.Info(i*f#len+f#wd) IGT New.File.Words)) then do;            New.File.Secs =File.Info(i*f#len+f#ll);            New.File.Words=File.Info(i*f#len+f#wd);         end;      end;      New.File.Secs =New.File.Secs +File.Desc.Secs;      New.File.Words=New.File.Words+shl(New.File.Secs,8);      if (New.File.Words&255)<>0 then New.File.Secs=New.File.Secs+1;      Current.Com(0) = 0; /* Get rid of last line typed */      if (findstorage(0,New.File.Secs) <> -1) then do; /* Enough room on disk for file */         Get.Filename = true;         do while (Get.Filename); /* Loop until you get a good name */            Get.Filename = false;            Error.Flag = false;            POS(20,0); ERASE_LINE; PSTRING('Enter name of new file (Press <RETURN> to abort edit)?  ');            GET.LINE(Filename,8,A.CR); WCHAR(A.CR); ERASE_LINE;            if Filename(0) = 0 then Abort = true; /* User wants to quit edit */            else do;               do i = 0 to Filename(0) - 1; call PBYTE(Current.Com,i,BYTE(Filename,I)); end; /* Copy filename */               Current.Com(0) = Filename(0);               if VALID_FILENAME(Filename)=0 then do; /* illegal filename supplied */                  call ERROR('Name is not a valid filename',0);               end;               else do i = 0 to Num.Files - 1; /* Check to see file name is not same as one of splice files */                  Buf(0) = 8;                  do j = 0 to (shr(f#name_len,1)-1); Buf(j+1) = File.Info((i*f#len)+j); end; /* Convert filename to string format */                  do j = 0 to f#name_len-1;                     if BYTE(Buf,j) = 0 then Buf(0) = Buf(0) - 1;                  end;                  if COMPARE(Filename,Buf,0)                   then call ERROR('Your output file may not be the same as any of the mix files.',File.Conflict.Err);               end;               if not Error.Flag then do;                  if LOCATE(Filename,Cur.Level) then do; /* Verify overwrite */                     ERASE_COMMAND; CRLF; ERASE_LINE; /* Erase any error messages remaining */                     POS(20,0); PSTRING('"'); PSTRING(Filename); PSTRING('"');                     PSTRINGR(' already exists on the disk.  Press <RETURN> to enter');                     PSTRING('a new name or type GO to overwrite the existing version -->');                     GET.LINE(Ans,2,A.CR); CRLF;                     do i = 20 to 21; POS(i,0); ERASE_LINE; end;                     if not COMPARE(Ans,'GO',0) then Get.Filename = true;                  end;               end; /* of IF NOT ERROR.FLAG THEN DO */               else Get.Filename = true;            end; /* of ELSE DO */         end; /* of DO WHILE (GET.FILENAME) */         /* $PAGE */         Current.Com(0) = 0; /* Erase last filename typed */         if not Abort then do;            if REPLACE(Filename,t#sound,0,New.File.Secs,New.File.Words,Cur.Level) /* Allocate space */            then do; /* go ahead and perform splice */               call MIX.SOUNDS(f#ms_sector,f#ls_sector,New.File.Secs,File.Info,Num.Files,                               WorkBuf,location(addr(WorkBuf(shl(BufSecs,7)))),shr(BufSecs,1)); /* Perform mix */               /* Now write the Sound File descriptor information to the disk */               call WRITE.DESCRIPTORS(f#ms_sector,f#ls_sector,File.Info,Num.Files,New.File.Secs,New.File.Words);               Status = Success;               PCMD('Mix completed. New file is '); UNUM(New.File.Secs,0); PSTRINGR(' sectors long.');               PSTRING('Total number of mix operations performed was '); UNUM(Num.Files,0); WCHAR(A.PERIOD);            end;         end; /* of IF NOT ABORT THEN DO */         else do; PCMD('Mix operation aborted.'); CRLF; ERASE_LINE; end;      end; /* of IF FINDSTORAGE THEN DO */      else call ERROR('There is not enough space in current catalog for new file.',Disk.Space.Err);   end; /* of IF (NUM.FILES > 0) THEN DO */   else PCMD('No MIX operation requested.');end; /* of begin block for MIXING function */else if Mixing=2 then PCMD('No operation requested.'); /* CR, go back to SFM */if Status = Success then do;              /* set up filename for new file */   fcb.ptr=file.block.loc+file.block.len; /* point at FCB #2 */   f.name.bytes=0;                        /* init file name to zero length */   j=(-1);   do while ((j<>0)                        /* loop while haven't hit a null */   and       (f.name.bytes<Filename(0))    /* and we should copy more chars */   and       (f.name.bytes<(f#name_len*2))); /* but not too many chars        */      j=BYTE(Filename,f.name.bytes);      if j<>0 then do;                    /* put a new char into the filename */         call PBYTE(f.name,f.name.bytes,j);         f.name.bytes=f.name.bytes+1;      end;   end;   /* look up data from catalog entry and store in global FCB vars */   call locate(f.name,1);   f.type       = f#type;   f.drive      = f#ms_sector;   f.sector     = f#ls_sector;   f.offset     = 0;   f.tlen.up    = f#ms_length;   f.tlen.low   = f#ls_length;    f.tlen.offset= 0;end;flush_term;call RETURN.TO.SFM(Status);