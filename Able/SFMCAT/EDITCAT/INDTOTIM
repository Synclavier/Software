/* INDTOTIM  $TITLE  Routine to Convert from Sectors to Seconds *//* convert sectors to time:.  works for sector numbers up to 24 bits,  sampling periods up to 29,999,.  and times up to 32 bits of milliseconds.*/index_to_time:proc(time.vector,index.vector,periods);    dcl time.vector fixed array;    dcl index.vector fixed array;    dcl periods fixed;     dcl msb lit 'index.vector(0)';    dcl lsb lit 'index.vector(1)';    dcl offset lit 'index.vector(2)';    dcl seconds lit 'time.vector(0)';    dcl milliseconds lit 'time.vector(1)';    dcl microseconds lit 'time.vector(2)';    dcl (a,b,c,d,e,f,i,x,y) fixed;  /* compute xy. sample # */  x=shl(msb,8)\shr(lsb,8); /* upper 16 bits of sample # */  y=shl(lsb,8)\offset; /* lower 32 bits of sample # */  /* compute .abc milliseconds/sample */  write(5)=0;write(4)=periods;write(7)=clock.rate; /* compute microseconds/sample */  a=read(5);  i=read(4);write(5)=0;write(4)=i;write(7)=clock.rate;  b=read(5);  i=read(4);write(5)=0;write(4)=i;write(7)=clock.rate; /* to 48 bit accuracy */  c=read(5);  /* multiply xy. (sample #) times .abc (ms./sample) to get de.f milliseconds */  d=0;e=0;f=0;  write(5)=c;write(6)=x;  f=read(4);  write(5)=b;write(6)=y;  f=f+read(4);if f ilt read(4) then e=e+1;  write(5)=b;write(6)=x;  f=f+read(5);if f ilt read(5) then e=e+1;  e=e+read(4);if e ilt read(4) then d=d+1;  write(5)=a;write(6)=y;  f=f+read(5);if f ilt read(5) then do;e=e+1;if e=0 then d=d+1;end;  e=e+read(4);if e ilt read(4) then d=d+1;  write(5)=a;write(6)=x;  e=e+read(5);if e ilt read(5) then d=d+1;  d=d+read(4);  /* round up to nearest microsecond */  f=f+32; /* add 1/2000 of a millisecond */  if f ilt 32 then do;e=e+1;if e=0 then d=d+1;end;  /* compute answer: */  write(5)=e;write(4)=d; /* milliseconds */  write(7)=1000; /* to get seconds */  seconds=read(5);milliseconds=read(4);  write(5)=f;write(6)=1000; /* and microseconds */  microseconds=read(4); /* fractional multiply result */end index_to_time;