/* $TITLE Routine to Perform Butt Splicing of Sound Files *//* Copyright 1985 New England Digital Corporation */Butt.Splice: proc (MS.Start.Sector,LS.Start.Sector,FCB.Array,Num.Files,Buf,Buf.Secs); /* Performs a butt splice on a bunch of files */   dcl MS.Start.Sector fixed; /* Starting sector and device of spliced file */   dcl LS.Start.Sector fixed;   dcl FCB.Array       fixed array; /* The FCBs for the files to be spliced */   dcl Num.Files       fixed; /* Number of FCBs in FCB.ARRAY */   dcl Buf.Secs     fixed; /* Size of buffer in sectors */   dcl Buf          fixed array; /* Sound file data buffer */   dcl Dump.Full.Secs lit 'true';  /* Used in calls to UNLOAD.BUFFER */   dcl Dump.All       lit 'false'; /* Used in calls to UNLOAD.BUFFER */   dcl Bufptr         fixed; /* (GLOBAL) Index pointer to next free word in BUF */   dcl MS.Write.Start fixed; /* (GLOBAL) Sector to write next block of data to in splice */   dcl LS.Write.Start fixed;   dcl File.Num       fixed; /* Index of file currently being spliced */   dcl Blk (f#len-1)  fixed; /* Temp array to hold an FCB during processing */   dcl Secs.Left      fixed; /* Full sectors left to be buffered */   dcl Words.Left     fixed; /* Words left in sound file to be buffered */   dcl MS.Read.Start  fixed;   dcl LS.Read.Start  fixed; /* Sector on winchester to begin reading from */   dcl Read.Len       fixed; /* Number of words to read from disk into BUF */   dcl (i,j,k)        fixed;      Compute.Max.Read.Len: proc (Secs.Left,Words.Left,Buf.Words.Left) fixed;      dcl Secs.Left      fixed; /* Full sectors left to be buffered */      dcl Words.Left     fixed; /* Words left to buffer in addition to SECS.LEFT */      dcl Buf.Words.Left fixed; /* Available words left in BUF */      dcl Max.Len        fixed; /* Computed maximum words to read into BUF */      if Secs.Left IGT (Buf.Words.Left - Words.Left)/256 then Max.Len = Buf.Words.Left;      else                                                    Max.Len = Secs.Left * 256 + Words.Left;      return (Max.Len);   end Compute.Max.Read.Len;   Unload.Buffer: proc (Buf,Length,Dump.Type); /* Dumps contents of BUF to disk */      dcl Buf             fixed array; /* Data buffer */      dcl Length          fixed; /* Number of words to write to disk */      dcl Dump.Type       boolean; /* Either write integral # of sectors or whole buffer */      dcl Remainder.Len   fixed; /* Number of words in last unfilled sector */      dcl Remainder.Start fixed; /* Index of first word in remainder */      dcl I               fixed;      if Dump.Type = Dump.Full.Secs then Remainder.Len = Length MOD 256; /* Words that exceed integral # of sectors */      else                               Remainder.Len = 0; /* This only happens on final disk write */      Remainder.Start = Length - Remainder.Len; /* Index of first word of remaining data */      if ((LS.Write.Start <> 0) or (MS.Write.Start <> 0))      then call WRITEDATA(MS.Write.Start,LS.Write.Start,Buf,Length - Remainder.Len); /* Write out data */      LS.Write.Start = LS.Write.Start + Length/256; /* Update GLOBAL starting sector variable */      if LS.Write.Start ILT Length/256 then MS.Write.Start=MS.Write.Start+1;      /* Copy all data not written to disk into start of BUF */      do I = 0 to (Remainder.Len - 1);         Buf(I) = Buf(Remainder.Start + I);      end;      Bufptr = Remainder.Len; /* Reset GLOBAL index pointer */      end Unload.Buffer;   /* $page */   Subtract: proc (Num1,Num2) fixed; /* Subtracts two unsigned integers */      dcl (Num1,Num2) fixed;      dcl Flag        fixed; /* True if NUM2 >= 32K */      dcl Diff        fixed; /* Difference of two numbers */      Flag = 0; /* Initialize */      if Num2 IGE "100000" then do; Num2 = Num2 & "077777"; Flag = 1; end;      Diff = Num2 - Num1;      if Flag then Diff = Diff + "100000";      return (Diff);   end Subtract;   /* MAIN CODE for BUTT.SPLICE */   File.Num = 0; /* Start with first file */   Bufptr   = 0; /* Initialize */   MS.Write.Start = MS.Start.Sector;   LS.Write.Start = LS.Start.Sector + File.Desc.Secs; /* skip over file desc. area for now */   if LS.Write.Start ILT File.Desc.Secs then MS.Write.Start = MS.Write.Start + 1;   do while (File.Num < Num.Files);      do i = 0 to f#len-1; Blk(i) = FCB.Array((File.Num * f#len) + i);  end; /* Copy FCB into temp array */      do i = 0 to Blk(f#ty) - 1; /* Loop for correct number of repetitions */         POS(Y.Base + File.Num,Status.Pos); ERASE_LINE;         PSTRING('Performing splice #');UNUM(I+1,0); WCHAR(A.PERIOD);         Secs.Left = Blk(f#ll); /* 32K length limit */         Words.Left = Blk(f#wd);         MS.Read.Start = Blk(f#ms); /* Start reading data after descriptor area */         LS.Read.Start = Blk(f#ls) + File.Desc.Secs;         if LS.Read.Start ILT blk(f#ls) then MS.Read.Start = MS.Read.Start+1;         do while ((Secs.Left IGT 0) or (Words.Left IGT 0));            Read.Len = COMPUTE.MAX.READ.LEN(Secs.Left,Words.Left,(Buf.Secs*256)-Bufptr);            /* If whole file cannot be buffered, then only read in an integral number of sectors */            if (SUBTRACT(Read.Len/256,Secs.Left) <> 0) or (SUBTRACT(Read.Len MOD 256,Words.Left) <> 0)            then Read.Len = (Read.Len/256) * 256;            if c#ls_sector+LS.Read.Start ILT LS.Read.Start then k=1; else k=0;            call READDATA(c#ms_sector+(MS.Read.Start&"377")+k,c#ls_sector+LS.Read.Start,LOCATION(ADDR(Buf(Bufptr))),Read.Len); /* Buffer a block of data */            Bufptr     = Bufptr + Read.Len; /* Update index pointer */            Secs.Left  = SUBTRACT(Read.Len/256,Secs.Left);            Words.Left = SUBTRACT(Read.Len MOD 256,Words.Left);            LS.Read.Start = LS.Read.Start + Read.Len/256;            if LS.Read.Start ILT Read.Len/256 then MS.Read.Start=MS.Read.Start+1;            if (Bufptr + 256) IGE (Buf.Secs*256) then call UNLOAD.BUFFER(Buf,Bufptr,Dump.Full.Secs);         end; /* of DO WHILE ((SECS.LEFT IGT 0) OR (WORDS.LEFT IGT 0)) */      end; /* of DO I = 0 to Blk(f#ty) - 1 */      POS(Y.Base + File.Num,Status.Pos); ERASE_LINE;      PSTRING('Performed '); UNUM(Blk(f#ty),0); PSTRING(' splice(s) on file.');      File.Num = File.Num + 1; /* Go on to next file */   end; /* of DO WHILE (FILE.NUM < NUM.FILES) */   call UNLOAD.BUFFER(Buf,Bufptr,Dump.All); /* Dump buffer to disk for last time */end Butt.Splice;