/* 80-OVRLY  $TITLE  Sample Driver Program for Use with OVERLAY Command *//* Copyright 1985 by New England Digital Corporation */dcl vel.kbd        lit '1';   /* set to 1 for velocity keyboard compilation */dcl in.main.module lit '0';   /* not the main SFM module */dcl sector.size    lit '256'; /* number of 16-bit words in one sector *//* GLOBAL work buffers -- allocate sizes as desired */dcl buf1.len lit '25'; /* sectors to allocate for DATABUF1 */dcl buf2.len lit '0';  /* sectors to allocate for DATABUF2 */dcl databuf1(buf1.len*sector.size) fixed;    /* fixed    pt. work buffer */dcl databuf2(buf2.len*sector.size) floating; /* floating pt. work buffer */insert ':-xpl:literals';insert ':-xpl:asciilit';insert ':-xpl:scsi';insert ':-xpl:catrtns'; /* catalog routines */insert ':-xpl:strings';/* SFM System File Inserts:   You should include any other insert files from the SFM system   that you need here. The following insert files are the basic   files that you will usually need to include. Insert any other   files after these. */insert '00-sfm';   /* SFM upper memory definitions and overlay routine */insert '00-vkbd';  /* velocity keyboard scanning primitives */insert '01-io';    /* ascii definitions, interrupt I/O */insert '02-plot';  /* plotting procedures */insert '04-angle'; /* fast sine & cosine routine */insert '06-globl'; /* global variables */insert '07-util';  /* utility procedures */insert '08-symbl'; /* symbol procedures for labeling time domain display */insert '09-files'; /* utility procedures which access catalog */  insert '10-set';   /* input time values and process set menu *//* RETURN_TO_SFM is a special routine which will perform   the overlay back to the main module of the SFM system.   It takes one parameter.  This parameter is the value   that you want the global error status variable, ERROR.FLAG,   to be set to, upon return. */dcl catalog_buffer (c#dir_max - 1) fixed; /* catalog buffer */return_to_sfm:proc(e.flag); /* special return routine */  dcl e.flag fixed; /* error flag to return */  ovl.error=e.flag; core(loc.rst)=10; /* error return state */  call overlay(core(loc.p1+1),core(loc.p1),core(loc.p1-1)); /* return to main module of SFM */end return_to_sfm;call set_catbuf (addr(catalog_buffer(0)), 0); /* set up catalog buffer */mem.siz=memory.size; /* look up configured memory size */enable;if (core(loc.rst)<>3) then do; /* invalid invocation of module */   psr('This module may only be invoked through SFM');   call tty_wait; /* allow chars to be printed before quitting */   call exit(-1); /* quit to MONITOR */end;dcl new.sectors (2) fixed;dcl i               fixed;i=core(core(1)+14);            /* get misc info word from configuration area */clock.inc=10;                  /* assume 10 msec clock */if (i& 2)<>0 then clock.inc=5; /* 5 msec */dq640=(terminal.model=t#dq640); /* VT100 (type 3) with graphics 2 is a DQ640 */mg600=((terminal.model=t#mg600)  /* VT100 (type 3) with graphics 3 is an MG600 */    or (terminal.model=t#macintosh)); /* Mac II is used as MG600 for now */if dq640 then punits(799,479);else          punits(639,479); /* initialize display units */call read_system_file (SINTAB.FILE,sintable,sintable.len+intpol.len+1); /* read sine table *//* $SUBTITLE  Start of Your Specialized Code -- Insert Below */file1; /* access the last current file from SFM *//* If you don't need to access the last current file, then the   following line can be deleted.  If included, it will cause this   program to return to the main SFM module if there is no current   display file. */if f.name.bytes=0 then call return_to_sfm(E.NO.FILE); /* no previous current file */call copy_vector(new.sectors,location(valid.data),3); /* get length of original sound file */file2; /* point to output File Control Block (FCB #2) */if new_file(new.sectors)=0 then begin; /* was able to create a new sound file */   dcl tbuf (255)    fixed; /* temporary work buffer */   dcl temp (2)      fixed; /* temporary buffer */   dcl blen          data (0,buf1.len,0); /* length of DATABUF1 in index format */   dcl in.start  (2) fixed; /* 3 word ptr to start of input  samples */   dcl in.end    (2) fixed; /* 3 word ptr to end   of input  samples */   dcl out.start (2) fixed; /* 3 word ptr to start of output samples */   dcl out.end   (2) fixed; /* 3 word ptr to end   of output samples */   file1; /* point back at FCB #1 (the original sound file) */   tbuf(0)=file.data.type; /* pick up data from file 1 */   tbuf(1)=period.index;   tbuf(2)=nyquist.freq;   tbuf(3)=core(octave);   tbuf(4)=core(octave+1);   call copy_vector(in.start,location(f.data.index),3); /* look up start address of input samples */   call add_len_to_addr(location(valid.data),in.start,temp); /* compute end address of input samples */   call sub_len_from_addr(temp,zero.zero.one,in.end);   file2; /* Point at newly allocated sound file; copy info to new file */   file.data.type=tbuf(0)\filtered.data; /* store data on file 2 */   period.index  =tbuf(1);   nyquist.freq  =tbuf(2);   core(octave)  =tbuf(3);   core(octave+1)=tbuf(4);   call copy_vector(location(valid.data),new.sectors,3); /* copy length for new sound */   /* Convert index of last sample to time at last sample */   call copy_vector(location(data.end),location(valid.data),3);   call sub_len_from_len(location(data.end),zero.zero.one,temp); /* subtract one from DATA.END */   call index_to_time(location(data.end),temp,period.index); /* convert samples to time */   call caption_assign('Modified Sound Data'); /* Assign caption to new sound file */   /* Set up the basic sound file symbols */   call add_symbol(zero.vector,       'Origin');      /* ORIGIN Symbol */   call add_symbol(location(data.end),'End'   );      /* END    Symbol */   call copy_vector(mark.start,zero.vector,       3); /* Mark START (#1) */   call copy_vector(mark.end,  location(data.end),3); /* Mark END   (#2) */   call copy_vector(out.start,location(f.data.index),3); /* look up start address of output samples */   call add_len_to_addr(location(valid.data),out.start,temp); /* compute end address of output samples */   call sub_len_from_addr(temp,zero.zero.one,out.end);   /* $PAGE */   /*********************************************************************   ******* INSERT XPL CODE HERE WHICH PERFORMS DESIRED OPERATIONS ******/                                                              /*  When you want to access the input file FCB, use the FILE1 statement.   To access the output file FCB, use the FILE2 statement.  You will need   to keep track of which sector you are currently processing in both the   input and the output files.  This example program sets up 4 useful   variables for you.  These 4 variables are as follows:          IN.START     Absolute disk address of first input  sample          IN.END       Absolute disk address of last  input  sample          OUT.START    Absolute disk address of first output sample          OUT.END      Absolute disk address of last  output sample   Using the READDATA and WRITEDATA routines described in the XPL manuals,   you can access and modify the samples stored with each file.  Or you   can use the above routines, READ_WORDS and WRITE_WORDS, which do much   of the work for you.  The following example loop simply copies the   samples from the original sound file into the new sound file. */   do while (compare_vectors(in.start,in.end,3)<=0) /* loop until IN.START = IN.END */      and   (error.flag=0); /* and no errors encountered */      call sub_len_from_len(in.end,in.start,temp); /* compute samples left to copy */      call add_len_to_len(zero.zero.one,temp,temp);      if compare_vectors(temp,blen,3)>0   /* if samples left greater than buffer size */      then call copy_vector(temp,blen,3); /* limit amount to copy this time through loop */      if read_words(in.start,temp,databuf1)<>0 then do; /* read in a buffer full */         if write_words(out.start,temp,databuf1,tbuf)=0 /* write buffer to new sound file */         then error.flag=e.sys.error; /* this should never occur if program is debugged */      end;      else error.flag=e.sys.error; /* this should never occur if program is debugged */      call add_len_to_addr(temp,in.start,in.start); /* update current ptr into original sound file */      call add_len_to_addr(temp,out.start,out.start); /* update current ptr into new sound file */   end; /* end of loop over sectors in original sound file */   /****** BOTTOM OF XPL CODE WHICH PERFORMS DESIRED OPERATIONS *********   *********************************************************************/   file2; /* force changes related to new sound file to get saved on disk */   /* NOTE:  You will note that this block ends up with FCB #2 as the      current FCB.  Therefore, when you return to the main SFM module      the file in FCB #2 will be automatically called up.  However,      at that time, the file information will be put into FCB #1. */end; /* of able to create new file */else; /* This is where we would branch to if there were no more space          on disk for the new file. */if error.flag<>0 then call file(1,0); /* had error, so restore current file to original sound file */call return_to_sfm(ERROR.FLAG); /* Returns current ERROR.FLAG status */