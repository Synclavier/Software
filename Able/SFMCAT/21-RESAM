/* 21-RESAM  $TITLE  Routines to Perform Digital Resampling of Sound Files *//* Copyright 1985 by New England Digital Corporation *//* initialization program for 3 stage interpolator *//* adapted from program 8.3 - decimation and 1 and 2 stage procedures removed */dcl common  (39) fixed; /* array to pass common parameters for interpolation */dcl common2 (39) fixed; /* for decimation *//* note that interpolation stages are numbered backwards from 3 to 1 */dcl coef1   (17) fixed; /* last interpolation stage (stage 1) */dcl coef2   (17) fixed; /* second interpolation stage */dcl coef3   (49) fixed; /* first interpolation stage */dcl coef4  (513) fixed; /* resampling stage */dcl coef5   (49) fixed; /* last decimation stage */dcl coef6   (21) fixed; /* second decimation stage */dcl coef7   (13) fixed; /* first decimation stage for R=8 */dcl coef8   (25) fixed; /* first decimation stage for R=16 */   initialize_interpolate3:  proc(ratio1,ratio2,ratio3,len1,len2,len3,coef1,coef2,coef3,buff.len,sbuff,sbuff.len) fixed swap;   dcl ratio1    fixed;       /* 1st stage interpolation ratio */   dcl ratio2    fixed;       /* 2nd stage interpolation ratio */   dcl ratio3    fixed;       /* 3rd stage interpolation ratio */   dcl len1      fixed;       /* length of filter 1 */   dcl len2      fixed;       /* length of filter 2 */   dcl len3      fixed;       /* length of filter 3 */   dcl coef1     fixed array; /* filter 1 coefficients - upper half - size=(len1+1)/2 */   dcl coef2     fixed array; /* filter 2 coefficients - upper half - size=(len2+1)/2 */   dcl coef3     fixed array; /* filter 3 coefficients - upper half - size=(len3+1)/2 */   dcl buff.len  fixed;       /* length of buff */   dcl sbuff     fixed array; /* scratch buffer for internal variables */   dcl sbuff.len fixed;       /* length of sbuff n1p+n2p+n3p+ratio1+ratio2 */   /* nxp=(int(lenx/ratiox)+1)*ratiox */      dcl id1  lit 'common(0)';   dcl id2  lit 'common(1)';   dcl id3  lit 'common(2)';   dcl n1   lit 'common(3)';   dcl n2   lit 'common(4)';   dcl n3   lit 'common(5)';   dcl id   lit 'common(6)';   dcl isb  lit 'common(7)';   dcl n1p  lit 'common(8)';   dcl n2p  lit 'common(9)';   dcl n3p  lit 'common(10)';   dcl idd  lit 'common(11)';   dcl j1   lit 'common(12)';   dcl j2   lit 'common(13)';   dcl j3   lit 'common(14)';   dcl j4   lit 'common(15)';   dcl j5   lit 'common(16)';   dcl j6   lit 'common(17)';   dcl j7   lit 'common(18)';   dcl j8   lit 'common(19)';   dcl j9   lit 'common(20)';   dcl j10  lit 'common(21)';   dcl j11  lit 'common(22)';   dcl j12  lit 'common(23)';   dcl j1s  lit 'common(24)';   dcl j2s  lit 'common(25)';   dcl j3s  lit 'common(26)';   dcl ncf1 lit 'common(27)';   dcl ncf2 lit 'common(28)';   dcl ncf3 lit 'common(29)';   dcl nf1  lit 'common(30)';   dcl nf2  lit 'common(31)';   dcl nf3  lit 'common(32)';   dcl iq1  lit 'common(33)';   dcl iq2  lit 'common(34)';   dcl iq3  lit 'common(35)';   dcl k1s  lit 'common(36)';   dcl k2s  lit 'common(37)';   dcl k3s  lit 'common(38)';   dcl (m,idx,md,mq,sum,mm) fixed;   id1=ratio1; id2=ratio2; id3=ratio3;   n1 =len1;   n2 =len2;   n3 =len3;   id =buff.len; isb=sbuff.len;      m=id3;   iq3=n3/id3; if n3<>(iq3*id3) then iq3=iq3+1;   m=m*id2; iq2=n2/id2; if n2<>(iq2*id2) then iq2=iq2+1;   m=m*id1; iq1=n1/id1; if n1<>(iq1*id1) then iq1=iq1+1;   idd=id/m; if id<>(m*idd) then return 2; /* error */   n1p=iq1*id1; n2p=iq2*id2; n3p=iq3*id3;   /* set up address location in SBUFF or internal storage */   j1 =0;          j2 =j1*2*n1p;   j3 =j2+2*n2p;   j4 =0;   j5 =j4+iq1*id1; j6 =j5+iq2*id2; j7 =j6+iq3*id3; j8 =j7+2*iq1;   j9 =j8+2*iq2;   j10=j9+2*iq3;   j11=j10+id2;    j12=j11+id3;   if isb ILT j12 then return 3; /* error */   do m=0 to j12-1; sbuff(m)=0; end;   /* setup scrambled coefficient sets for interpolation, initialize      moving address pointers, and half first coefficient in sets      coef1 to coef3 */   /***** stage 1 *****/   idx=j4; ncf1=(n1+1)/2; sum=id1;   do md=0 to id1-1;      do mq=0 to iq1-1;         m=md+mq*id1;         if m ILT ncf1 then mm=ncf1-m;         else               mm=m-(n1-ncf1-1);         if mm ILE ncf1 then sbuff(idx)=coef1(mm-1);         else                sbuff(idx)=0;         idx=idx+1;      end;   end;   k1s=j7+iq1-1;   /***** stage 2 *****/   idx=j5; ncf2=(n2+1)/2; sum=id2;   do md=0 to id2-1;      do mq=0 to iq2-1;         m=md+mq*id2;         if m ILT ncf2 then mm=ncf2-m;         else               mm=m-(n2-ncf2-1);         if mm ILE ncf2 then sbuff(idx)=coef2(mm-1);         else                sbuff(idx)=0;         idx=idx+1;      end;   end;   k2s=j8+iq2-1;   /***** stage 3 *****/   idx=j6; ncf3=(n3+1)/2; sum=id3;   do md=0 to id3-1;      do mq=0 to iq3-1;         m=md+mq*id3;         if m ILT ncf3 then mm=ncf3-m;         else               mm=m-(n3-ncf3-1);         if mm ILE ncf3 then sbuff(idx)=coef3(mm-1);         else                sbuff(idx)=0;         idx=idx+1;      end;   end;   k3s=j9+iq3-1;     return 0;end initialize_interpolate3;interpolate3:proc(buff,sbuff) swap; /* three stage interpolation; may be called repeatedly */  dcl buff fixed array; /* input and output buffer */  dcl sbuff fixed array; /* internal variables */  /* fill BUFF with buff.len/(ratio1*ratio2*ratio2) samples .    (buff.len=integer*ratio1*ratio2*ratio3);.    receive buff.len samples in BUFF */     dcl id1   lit   '4';   dcl id2   lit   '2';   dcl id3   lit   '2';   dcl n1    lit   '17';   dcl n2    lit   '17';   dcl n3    lit   '49';   dcl id    lit   '4096';   dcl isb   lit   'common(7)';   dcl n1p   lit   '20';   dcl n2p   lit   '18';   dcl n3p   lit   '50';   dcl idd   lit   '256';   dcl j1    lit   'common(12)';   dcl j2    lit   'common(13)';   dcl j3    lit   'common(14)';   dcl j4    lit   '0';   dcl j5    lit   '20';   dcl j6    lit   '38';   dcl j7    lit   '88';   dcl j8    lit   '98';   dcl j9    lit   '116';   dcl j10   lit   '166';   dcl j11   lit   '168';   dcl j12   lit   '170';   dcl j1s   lit   'common(24)';   dcl j2s   lit   'common(25)';   dcl j3s   lit   'common(26)';   dcl ncf1  lit   'common(27)';   dcl ncf2  lit   'common(28)';   dcl ncf3  lit   'common(29)';   dcl nf1   lit   'common(30)';   dcl nf2   lit   'common(31)';   dcl nf3   lit   'common(32)';   dcl iq1   lit   '5';   dcl iq2   lit   '9';   dcl iq3   lit   '25';   dcl k1s   lit   'common(36)';   dcl k2s   lit   'common(37)';   dcl k3s   lit   'common(38)';   dcl mul1 lit 'write(5)=imsb1;write(6)=imsb2;omsb=omsb+read(4);olsb=olsb+read(5);';   dcl mul2 lit 'if olsb ilt read(5) then omsb=omsb+1;if imsb1<0 then omsb=omsb-imsb2;';   dcl mul3 lit 'if imsb2<0 then omsb=omsb-imsb1;';   dcl multiply lit 'mul1;mul2;mul3;';                  dcl (mm,nn,m,omsb,olsb,md,mq,m1,m2,m3,idx) fixed;  dcl sum lit 'omsb';  nn=0;  mm=id-idd;  do m=0 to idd-1;    buff(mm)=buff(m);    mm=mm+1;  end;    do mm=id-idd to id-1; /* store samples in S3I */    sum=buff(mm);    sbuff(k3s)=sum;    md=k3s+iq3;    sbuff(md)=sum;        /* compute output for stage 3I */    /* ASSUME RATIO=2 */    mq=j6+iq3;    sbuff(j11)=sbuff(k3s+iq3/2);    do;          /* m=j11+1 to j12-1;*/  /* fill buffer T3I with D3 samples */      omsb=0;olsb="040000"; /* round */      do m3=k3s to md-1;   /* convolve filter with data */        begin;          dcl imsb1 lit 'sbuff(mq)';          dcl imsb2 lit 'sbuff(m3)';          multiply;        end;        mq=mq+1;      end;      omsb=shl(omsb,1);      if (olsb&"100000")^=0 then omsb=omsb\1;            sbuff(j11+1)=omsb; /* store output in S2I (multiply by 2 due to effect of fractional multiply) */    end;      k3s=k3s-1;    if k3s ilt j9 then k3s=j9+iq3-1;    do m=j11 to j12-1; /* Stage 2 */      sbuff(k2s)=sbuff(m); /* store data in S2I */      md=k2s+iq2;      sbuff(md)=sbuff(m);      mq=j5+iq2;      sbuff(j10)=sbuff(k2s+iq2/2);      do;/* idx=j10 to j11-1; */ /* compute output for stage 2I */         omsb=0;olsb="040000"; /* round */         do m2=k2s to md-1; /* convolve filter with data */           begin;              dcl imsb1 lit 'sbuff(mq)';              dcl imsb2 lit 'sbuff(m2)';              multiply;           end;           mq=mq+1;         end;         omsb=shl(omsb,1);         if (olsb&"100000")^=0 then omsb=omsb\1;         sbuff(j10+1)=omsb; /* store output in T2I */      end;      k2s=k2s-1;      if k2s ilt j8 then k2s=j8+iq2-1;            do idx=j10 to j11-1;        sbuff(k1s)=sbuff(idx); /* store data in S1I */        md=k1s+iq1;        sbuff(md)=sbuff(idx);        buff(nn)=sbuff(k1s+iq1/2);  /* 1 */        nn=nn+1;        omsb=0;olsb="040000"; /* 2 */             begin;                dcl imsb1 lit 'sbuff(j4+iq1)';                dcl imsb2 lit 'sbuff(k1s)';                multiply;             end;             begin;                dcl imsb1 lit 'sbuff(j4+iq1+1)';                dcl imsb2 lit 'sbuff(k1s+1)';                multiply;             end;             begin;                dcl imsb1 lit 'sbuff(j4+iq1+2)';                dcl imsb2 lit 'sbuff(k1s+2)';                multiply;             end;             begin;                dcl imsb1 lit 'sbuff(j4+iq1+3)';                dcl imsb2 lit 'sbuff(k1s+3)';                multiply;             end;             begin;                dcl imsb1 lit 'sbuff(j4+iq1+4)';                dcl imsb2 lit 'sbuff(k1s+4)';                multiply;             end;          omsb=shl(omsb,1);          if (olsb&"100000")^=0 then omsb=omsb\1;          buff(nn)=omsb; /* store output in buff */          nn=nn+1;          omsb=0;olsb="040000";             begin;                dcl imsb1 lit 'sbuff(j4+iq1+5)';                dcl imsb2 lit 'sbuff(k1s)';                multiply;             end;             begin;                dcl imsb1 lit 'sbuff(j4+iq1+6)';                dcl imsb2 lit 'sbuff(k1s+1)';                multiply;             end;             begin;                dcl imsb1 lit 'sbuff(j4+iq1+7)';                dcl imsb2 lit 'sbuff(k1s+2)';                multiply;             end;             begin;                dcl imsb1 lit 'sbuff(j4+iq1+8)';                dcl imsb2 lit 'sbuff(k1s+3)';                multiply;             end;             begin;                dcl imsb1 lit 'sbuff(j4+iq1+9)';                dcl imsb2 lit 'sbuff(k1s+4)';                multiply;             end;          omsb=shl(omsb,1);          if (olsb&"100000")^=0 then omsb=omsb\1;          buff(nn)=omsb; /* store output in buff */          nn=nn+1;          omsb=0;olsb="040000";             begin;                dcl imsb1 lit 'sbuff(j4+iq1+10)';                dcl imsb2 lit 'sbuff(k1s)';                multiply;             end;             begin;                dcl imsb1 lit 'sbuff(j4+iq1+11)';                dcl imsb2 lit 'sbuff(k1s+1)';                multiply;             end;             begin;                dcl imsb1 lit 'sbuff(j4+iq1+12)';                dcl imsb2 lit 'sbuff(k1s+2)';                multiply;             end;             begin;                dcl imsb1 lit 'sbuff(j4+iq1+13)';                dcl imsb2 lit 'sbuff(k1s+3)';                multiply;             end;             begin;                dcl imsb1 lit 'sbuff(j4+iq1+14)';                dcl imsb2 lit 'sbuff(k1s+4)';                multiply;             end;          omsb=shl(omsb,1);          if (olsb&"100000")^=0 then omsb=omsb\1;          buff(nn)=omsb; /* store output in buff */          nn=nn+1;        k1s=k1s-1;        if k1s ilt j7 then k1s=j7+iq1-1;      end;    end;  end;    return;end interpolate3;initialize_decimate:proc(stages,ratio1,ratio2,ratio3,len1,len2,len3,buff.len,sbuff,sbuff.len,common) fixed swap;   dcl stages fixed; /* number of stages */   dcl ratio1 fixed; /* 1st stage decimation ratio */   dcl ratio2 fixed; /* 2nd stage decimation ratio */   dcl ratio3 fixed; /* 3rd stage decimation ratio */   dcl len1 fixed; /* length of filter 1 */   dcl len2 fixed; /* length of filter 2 */   dcl len3 fixed; /* length of filter 3 */   dcl buff.len fixed; /* length of buff */   dcl sbuff fixed array; /* scratch buffer for internal variables */   dcl sbuff.len fixed; /* length of sbuff n1p+n2p+n3p+ratio1+ratio2 */   dcl common fixed array;   /* nxp=(int(lenx/ratiox)+1)*ratiox */      dcl id1   lit   'common(0)';   dcl id2   lit   'common(1)';   dcl id3   lit   'common(2)';   dcl n1    lit   'common(3)';   dcl n2    lit   'common(4)';   dcl n3    lit   'common(5)';   dcl id    lit   'common(6)';   dcl isb   lit   'common(7)';   dcl n1p   lit   'common(8)';   dcl n2p   lit   'common(9)';   dcl n3p   lit   'common(10)';   dcl idd   lit   'common(11)';   dcl j1    lit   'common(12)';   dcl j2    lit   'common(13)';   dcl j3    lit   'common(14)';   dcl j4    lit   'common(15)';   dcl j5    lit   'common(16)';   dcl j6    lit   'common(17)';   dcl j7    lit   'common(18)';   dcl j8    lit   'common(19)';   dcl j9    lit   'common(20)';   dcl j10   lit   'common(21)';   dcl j11   lit   'common(22)';   dcl j12   lit   'common(23)';   dcl j1s   lit   'common(24)';   dcl j2s   lit   'common(25)';   dcl j3s   lit   'common(26)';   dcl ncf1  lit   'common(27)';   dcl ncf2  lit   'common(28)';   dcl ncf3  lit   'common(29)';   dcl nf1   lit   'common(30)';   dcl nf2   lit   'common(31)';   dcl nf3   lit   'common(32)';   dcl iq1   lit   'common(33)';   dcl iq2   lit   'common(34)';   dcl iq3   lit   'common(35)';   dcl k1s   lit   'common(36)';   dcl k2s   lit   'common(37)';   dcl k3s   lit   'common(38)';   dcl kd    lit   'common(39)';      dcl (m,idx,md,mq,sum,mm) fixed;   kd=stages;   id1=ratio1;   id2=ratio2;   id3=ratio3;   n1=len1;   n2=len2;   n3=len3;   id=buff.len;   isb=sbuff.len;   if (stages<0)\(stages>3) then return 1;   m=1;   if stages<3 then do;     n3=0;     id3=0;     iq3=0;   end;   else do;      m=m*id3;      iq3=n3/id3;      if n3^=(iq3*id3) then iq3=iq3+1;   end;   if stages<2 then do;     n2=0;     id2=0;     iq2=0;   end;   else do;     m=m*id2;     iq2=n2/id2;     if n2^=(iq2*id2) then iq2=iq2+1;   end;   m=m*id1;   iq1=n1/id1;   if n1^=(iq1*id1) then iq1=iq1+1;                       idd =id/m;   if id^=m*idd then return 2;      n1p=iq1*id1;   n2p=iq2*id2;   n3p=iq3*id3;  /* set up address location in sbuff or internal storage */  j1=0;  j2=j1+2*n1p;  j3=j2+2*n2p;  j4=j3+2*n3p;  j5=j4+iq1*id1;  j6=j5+iq2*id2;  j7=j6+iq3*id3;  j8=j7+2*iq1;  j9=j8+2*iq2;  j10=j9+2*iq3;  j11=j10+id2;  j12=j11+id3;  if isb ilt j4 then return 3; /* error */  do m=0 to j4-1;     sbuff(m)=0;  end;     ncf1=(n1+1)/2;  nf1=(n1+2)/2;  j1s=j1+n1p-1;  if stages>1 then do;     ncf2=(n2+1)/2;     nf2=(n2+2)/2;     j2s=j2+n2p-1;  end;    if stages=3 then do;     ncf3=(n3+1)/2;     nf3=(n3+2)/2;     j3s=j3+n3p-1;  end;  return 0;end initialize_decimate;decimate:proc(coef1,coef2,coef3,buff,sbuff,common) swap;   dcl coef1 fixed array;   dcl coef2 fixed array;   dcl coef3 fixed array;   dcl buff fixed array;   dcl sbuff fixed array;   dcl common fixed array;      dcl id1   lit   'common(0)';   dcl id2   lit   'common(1)';   dcl id3   lit   'common(2)';   dcl n1    lit   'common(3)';   dcl n2    lit   'common(4)';   dcl n3    lit   'common(5)';   dcl id    lit   'common(6)';   dcl isb   lit   'common(7)';   dcl n1p   lit   'common(8)';   dcl n2p   lit   'common(9)';   dcl n3p   lit   'common(10)';   dcl idd   lit   'common(11)';   dcl j1    lit   'common(12)';   dcl j2    lit   'common(13)';   dcl j3    lit   'common(14)';   dcl j4    lit   'common(15)';   dcl j5    lit   'common(16)';   dcl j6    lit   'common(17)';   dcl j7    lit   'common(18)';   dcl j8    lit   'common(19)';   dcl j9    lit   'common(20)';   dcl j10   lit   'common(21)';   dcl j11   lit   'common(22)';   dcl j12   lit   'common(23)';   dcl j1s   lit   'common(24)';   dcl j2s   lit   'common(25)';   dcl j3s   lit   'common(26)';   dcl ncf1  lit   'common(27)';   dcl ncf2  lit   'common(28)';   dcl ncf3  lit   'common(29)';   dcl nf1   lit   'common(30)';   dcl nf2   lit   'common(31)';   dcl nf3   lit   'common(32)';   dcl iq1   lit   'common(33)';   dcl iq2   lit   'common(34)';   dcl iq3   lit   'common(35)';   dcl k1s   lit   'common(36)';   dcl k2s   lit   'common(37)';   dcl k3s   lit   'common(38)';   dcl kd lit  'common(39)';   dcl mul1 lit 'write(5)=imsb1;write(6)=imsb2;omsb=omsb+read(4);olsb=olsb+read(5);';   dcl mul2 lit 'if olsb ilt read(5) then omsb=omsb+1;if imsb1<0 then omsb=omsb-imsb2;';   dcl mul3 lit 'if imsb2<0 then omsb=omsb-imsb1;';   dcl multiply lit 'mul1;mul2;mul3;';  dcl (jd,ju,mm,nn,m,omsb,olsb,md,mq,m1,m2,m3,idx) fixed;  dcl coef fixed;  dcl sum lit 'omsb';  nn=0;  mm=0;  do case kd-1;     do while mm ilt id; /* one stage decimation */               /* read id1 samples from buff into s1d buffer */       m1=j1s-id1;       md=j1s+n1p;       do while m1 < j1s;         sbuff(j1s)=buff(mm);         sbuff(md)=buff(mm);         mm=mm+1;         j1s=j1s-1;         md=md-1;       end; /* do while m1 */              /* compute one filter output for stage 1D */       jd=j1s+ncf1-1;       ju=j1s+nf1;       omsb=0;olsb="100000"; /* round */       begin;         dcl imsb1 lit 'sbuff(ju)';         dcl imsb2 lit 'coef1(0)';         mul1;mul2;       end;       ju=ju+1;       do m1=1 to ncf1-1; /* assume odd filter length */         if coef1(m1)^=0 then do; /* half of terms may be zero */           begin;             dcl imsb1 lit 'coef1(m1)';             dcl imsb2 lit 'sbuff(ju)';             multiply;           end;           begin;              dcl imsb1 lit 'coef1(m1)';              dcl imsb2 lit 'sbuff(jd)';              multiply;           end;         end;         jd=jd-1;         ju=ju+1;       end; /* do m1= */              if j1s < j1 then j1s=j1+n1p-1;              buff(nn)=omsb;       nn=nn+1;     end; /* one stage(do while) */      do while mm ilt id; /* two stages */       m2=j2s-id2;       mq=j2s+n2p;              do while m2<j2s; /* read id1 sample from buff into s1d buffer */         m1=j1s-id1;         md=j1s+n1p;         do while m1<j1s;           sbuff(j1s)=buff(mm);           sbuff(md)=buff(mm);           mm=mm+1;           j1s=j1s-1;           md=md-1;         end; /* do while m1<j1s */                  /* compute one filter output for stage 1d */        jd=j1s+ncf1-1;        ju=j1s+nf1;        omsb=0;olsb="100000";        begin;          dcl imsb1 lit 'sbuff(ju)';          dcl imsb2 lit 'coef1(0)';          mul1;mul2;        end;        ju=ju+1;        do m1=1 to ncf1-1; /* assume odd filter length */          if coef1(m1)^=0 then do; /* half of terms may be zero */            begin;              dcl imsb1 lit 'coef1(m1)';              dcl imsb2 lit 'sbuff(ju)';              multiply;            end;            begin;               dcl imsb1 lit 'coef1(m1)';               dcl imsb2 lit 'sbuff(jd)';               multiply;            end;          end;          jd=jd-1;          ju=ju+1;        end; /* do m1= */                 if j1s < j1 then j1s=j1+n1p-1;        /* store data into s2d */        sbuff(j2s)=omsb;        sbuff(mq)=omsb;        j2s=j2s-1;        mq=mq-1;       end; /* do while m2<j2s */       jd=j2s+ncf2-1;       ju=j2s+nf2;       omsb=0;olsb="100000";       begin;         dcl imsb1 lit 'sbuff(ju)';         dcl imsb2 lit 'coef2(0)';         mul1;mul2;       end;       ju=ju+1;       do m2=1 to ncf2-1; /* assume odd filter length */         if coef2(m2)^=0 then do; /* half of terms may be zero */           begin;             dcl imsb1 lit 'coef2(m2)';             dcl imsb2 lit 'sbuff(ju)';             multiply;           end;           begin;              dcl imsb1 lit 'coef2(m2)';              dcl imsb2 lit 'sbuff(jd)';              multiply;           end;         end;         jd=jd-1;         ju=ju+1;       end; /* do m2= */              if j2s < j2 then j2s=j2+n2p-1;       buff(nn)=omsb;       nn=nn+1;     end; /* end do while mm ilt id ( 2 stages) */     do while mm ilt id; /* three stages */       m3=j3s-id3;       m=j3s+n3p;       do while m3<j3s;          m2=j2s-id2;         mq=j2s+n2p;                do while m2<j2s; /* read id1 sample from buff into s1d buffer */           m1=j1s-id1;           md=j1s+n1p;           do while m1<j1s;             sbuff(j1s)=buff(mm);             sbuff(md)=buff(mm);             mm=mm+1;             j1s=j1s-1;             md=md-1;           end; /* do while m1<j1s */                    /* compute one filter output for stage 1d */          jd=j1s+ncf1-1;          ju=j1s+nf1;          omsb=0;olsb="100000";          begin;            dcl imsb1 lit 'sbuff(ju)';            dcl imsb2 lit 'coef1(0)';            mul1;mul2;          end;          ju=ju+1;          do m1=1 to ncf1-1; /* assume odd filter length */            if coef1(m1)^=0 then do; /* half of terms may be zero */              begin;                dcl imsb1 lit 'coef1(m1)';                dcl imsb2 lit 'sbuff(ju)';                multiply;              end;              begin;                 dcl imsb1 lit 'coef1(m1)';                 dcl imsb2 lit 'sbuff(jd)';                 multiply;              end;            end;            jd=jd-1;            ju=ju+1;          end; /* do m1= */                   if j1s < j1 then j1s=j1+n1p-1;          /* store data into s2d */          sbuff(j2s)=omsb;          sbuff(mq)=omsb;          j2s=j2s-1;          mq=mq-1;         end; /* do while m2<j2s */         jd=j2s+ncf2-1;         ju=j2s+nf2;         omsb=0;olsb="100000";         begin;           dcl imsb1 lit 'sbuff(ju)';           dcl imsb2 lit 'coef2(0)';           mul1;mul2;         end;         ju=ju+1;         do m2=1 to ncf2-1; /* assume odd filter length */           if coef2(m2)^=0 then do; /* half of terms may be zero */             begin;               dcl imsb1 lit 'coef2(m2)';               dcl imsb2 lit 'sbuff(ju)';               multiply;             end;             begin;                dcl imsb1 lit 'coef2(m2)';                dcl imsb2 lit 'sbuff(jd)';                multiply;             end;           end;           jd=jd-1;           ju=ju+1;         end; /* do m1= */                if j2s < j2 then j2s=j2+n2p-1;                  /* store data in s3d */         sbuff(j3s)=omsb;         sbuff(m)=omsb;         j3s=j3s-1;         m=m-1;       end; /*  do while m3<j3s */       /* compute one filter output for stage 3d */       jd=j3s+ncf3-1;       ju=j3s+nf3;            omsb=0;olsb="100000"; /* round */       begin;          dcl imsb1 lit 'sbuff(ju)';          dcl imsb2 lit 'coef3(0)';          mul1;mul2; /* coef3(0) cannot be negative */       end;       ju=ju+1;       do m3=1 to ncf3-1; /* assume odd filter length */         if coef3(m3)^=0 then do; /* half of terms may be zero */           begin;             dcl imsb1 lit 'coef3(m3)';             dcl imsb2 lit 'sbuff(ju)';             multiply;           end;           begin;              dcl imsb1 lit 'coef3(m3)';              dcl imsb2 lit 'sbuff(jd)';              multiply;           end;         end;         jd=jd-1;         ju=ju+1;       end; /* do m3= */                if j3s < j3 then j3s=j3+n3p-1;              buff(nn)=omsb;       nn=nn+1;            end; /* do while mm ilt id (three stages) */  end; /* do case STAGES */end decimate;dcl buff.len          lit '4096';dcl sbuff.len         lit '170';dcl dbuff.len         lit '200';dcl dbuff (dbuff.len) fixed;dcl sbuff (sbuff.len) fixed;dcl (inc.msb,inc.lsb,decimate.ratio) fixed;delta:  proc(in.period,out.period,in.hertz,out.hertz) swap;  dcl (in.period,out.period) fixed;  dcl (in.hertz ,out.hertz)  floating;  dcl x                      floating;  decimate.ratio=1;  x=(out.period*out.hertz/in.period/in.hertz);  do while x>1; /* don't decimate */    decimate.ratio=shl(decimate.ratio,1);    x=x/2;  end;  x=16*x;  inc.msb=int(x);  x=x-inc.msb;  inc.lsb=int(65536.*x);  if (x>0.5) and (inc.lsb=0) then inc.msb=inc.msb+1; /* check for overflow */end delta;resample:proc(in.start.sector,out.start.sector,num.sectors,out.end.sector,in.buff,out.buff) fixed swap;   dcl in.start.sector  fixed array; /* disk addr of start of input  file */   dcl out.start.sector fixed array; /* disk addr of start of output file */   dcl num.sectors      fixed array; /* length of input data in sectors */   dcl out.end.sector   fixed array; /* disk addr of end of output file */   dcl in.buff          fixed array; /* input  file work buffer */   dcl out.buff         fixed array; /* output file work buffer */   dcl (msb,lsb)       fixed;   dcl (x,i,j,k)       fixed;    dcl group.delay     lit '244';   dcl dec.group.delay fixed;   dcl jlimit          fixed;   /* coef4 is non-negative 16bit multiplier */   dcl mul1 lit 'write(5)=imsb1;write(6)=imsb2;omsb=omsb+read(4);olsb=olsb+read(5);';   dcl mul2 lit 'if olsb ilt read(5) then omsb=omsb+1;if imsb1<0 then omsb=omsb-imsb2;';   /* imsb2 cannot be negative */   dcl multiply lit 'mul1;mul2;';                   cycle:  proc(limit) fixed;      dcl limit fixed;      call interpolate3(location(addr(in.buff(1))),sbuff);      do while msb ilt limit;         begin; /* interpolate with 2 point filter (about 3db better than linear) */            dcl index       fixed;            dcl (omsb,olsb) fixed;            index=shr(lsb,7);            if index=0 then out.buff(j)=in.buff(msb);            else do;               omsb=0; olsb="100000";               begin;                  dcl imsb1 lit 'in.buff(msb)';                  dcl imsb2 lit 'coef4(index)';                  multiply;               end;                  begin;                  dcl imsb1 lit 'in.buff(msb+1)';                  dcl imsb2 lit 'coef4(512-index)';                  multiply;               end;                 out.buff(j)=omsb;            end;         end;         j=j+1;         if j=jlimit then do;            j=0;            if      decimate.ratio=16 then call decimate(coef8,coef6,coef5,out.buff,dbuff,common2);            else if decimate.ratio= 8 then call decimate(coef7,coef6,coef5,out.buff,dbuff,common2);            else if decimate.ratio= 4 then call decimate(coef6,coef5,coef5,out.buff,dbuff,common2);            else if decimate.ratio= 2 then call decimate(coef5,coef5,coef5,out.buff,dbuff,common2);            if dec.group.delay=0 then begin;               call writedata(out.start.sector(0),out.start.sector(1),out.buff,sector.size);               call add_len_to_addr(zero.one.zero,out.start.sector,out.start.sector);               if compare_addrs(out.start.sector,out.end.sector)>=0 then return 1; /* end of output file */            end;               else dec.group.delay=0; /* throw out samples before filter delay, set flag */         end;         msb=msb+inc.msb; lsb=lsb+inc.lsb; /* perform 32-bit add */         if lsb ilt inc.lsb then msb=msb+1;      end;      in.buff(0)=in.buff(buff.len); /* cycle back last sample */      msb=msb-buff.len;      return 0;   end cycle;     j=0; in.buff(0)=0;   msb=group.delay;lsb=0; /* delay by filter group delay  */   dec.group.delay=0;   jlimit=decimate.ratio*sector.size;   if decimate.ratio<>1 then begin; /* see formula on page 8.3-3 of IEEE book */      dcl d1 lit 'common2(0)';      dcl d2 lit 'common2(1)';      dcl d3 lit 'common2(2)';      dcl t1 lit 'common2(27)'; /* (N+1)/2 */      dcl t2 lit 'common2(28)';      dcl t3 lit 'common2(29)';      dec.group.delay=(t1+d1*t2+d1*d2*t3-decimate.ratio+1);   end;   if dec.group.delay<>0 then j=jlimit-dec.group.delay;   do i=0 to j; out.buff(i)=0; end; /* zero output work buffer */   call pos(5,1); pnum(num.sectors(1)); psr(' sectors to convert');   nl; psr('Converting sector:');   i=0;   do while i ILT num.sectors(1);      call pc("15"); pnum(i+1);      call readdata(in.start.sector(0),in.start.sector(1),location(addr(in.buff(1))),sector.size);      call add_len_to_addr(zero.one.zero,in.start.sector,in.start.sector);      if cycle(buff.len) then return 1;      i=i+1;   end;   do while 1; /* finish data */      do i=1 to 256; in.buff(i)=0; end; /* rezero buffer */      if cycle(buff.len) then return 0;   end;end resample;initialize_fir_buffers:  proc swap; /* initialize buffers */   dcl (i,j,k) fixed;   call openfile(INT.FILE,loc.p2,1); /* look for and open resampling data file */   call readdata(f#ms_sector,f#ls_sector,databuf1,1000);   k=0;         /* init number of elements */   do i=0 to 7; /* loop over the eight sets of coeffs */      do case i;         do j=0 to databuf1(k)-1; coef3(j)=databuf1(k+j+1); end;         do j=0 to databuf1(k)-1; coef2(j)=databuf1(k+j+1); end;         do j=0 to databuf1(k)-1; coef1(j)=databuf1(k+j+1); end;         do j=0 to databuf1(k)-1; coef4(j)=databuf1(k+j+1); end;         do j=0 to databuf1(k)-1; coef5(j)=databuf1(k+j+1); end;         do j=0 to databuf1(k)-1; coef6(j)=databuf1(k+j+1); end;         do j=0 to databuf1(k)-1; coef7(j)=databuf1(k+j+1); end;         do j=0 to databuf1(k)-1; coef8(j)=databuf1(k+j+1); end;      end;      k=k+databuf1(k)+1;   end;end initialize_fir_buffers;  /* end initialize */change_rate:  proc(buff1,buff2) fixed swap;   dcl buff1    fixed array;   dcl buff2    fixed array;   dcl temp  (2) fixed;   dcl temp2 (2) fixed;   dcl temp3 (2) fixed;   dcl t1        fixed;   dcl (in.pitch,out.pitch) floating;   file1;   clear;   call copy_vector(temp,location(valid.data),3);   call copy_vector(location(addr(out.pitch)),location(frequency),2);   call copy_vector(location(addr(in.pitch)), location(octave),   2);   in.pitch=pitch_to_freq(in.pitch);   begin;      dcl (fp,x) floating;     call initialize_interpolate3(4,2,2,17,17,49,coef1,coef2,coef3,buff.len,sbuff,sbuff.len);     call delta(period.index,current.per.index,in.pitch,out.pitch);     if decimate.ratio IGT 16 then do;       error.flag=e.range; return 1;     end;      if      decimate.ratio= 2 then call initialize_decimate(1,2,0,0,49,0,0,2*sector.size,dbuff,dbuff.len,common2);     else if decimate.ratio= 4 then call initialize_decimate(2,2,2,0,21,49,0,4*sector.size,dbuff,dbuff.len,common2);     else if decimate.ratio= 8 then call initialize_decimate(3,2,2,2,13,21,49,8*sector.size,dbuff,dbuff.len,common2);     else if decimate.ratio=16 then call initialize_decimate(3,4,2,2,25,21,49,16*sector.size,dbuff,dbuff.len,common2);     fp=inc.msb+inc.lsb/65536.; if inc.lsb<0 then fp=fp+1.;     fp=decimate.ratio*fp/16.;     x=temp(0)/fp;     temp(0)=int(x);     x=65536.*(x-temp(0))+temp(1)/fp;      temp(1)=int(x);     x=256*(x-temp(1))+temp(2)/fp;     temp(2)=int(x);   end;   call add_len_to_len(zero.vector,temp,temp); /* to normalize */      call copy_vector(temp2,temp,3);   t1=file.data.type;   file2;   if new_file(temp2) then return 1; /* open file to hold the extracted data */   file.data.type=t1\converted.data;   period.index=current.per.index;   out.pitch=freq_to_pitch(out.pitch);   call copy_vector(location(octave),location(addr(out.pitch)),2);   call copy_vector(location(valid.data),temp,3);   call sub_len_from_len(location(valid.data),zero.zero.one,location(data.end));    call index_to_time(location(data.end),location(data.end),period.index);   call add_symbol(zero.vector,'Origin');   call add_symbol(location(data.end),'End');   call copy_vector(mark.start,zero.vector,3);   call copy_vector(mark.end,location(data.end),3);   call caption_assign('Resampled data');   call copy_vector(temp2,location(f.data.index),3);   file1;      call add_len_to_addr(temp,temp2,temp3); /* TEMP3 is the end addr of output file */   call resample(location(f.data.index),temp2,location(valid.data),temp3,buff1,buff2);end change_rate;