/* 02-PLOT  $TITLE  Graphics and Plotting Package *//* Copyright 1985 by New England Digital Corporation *//* description:  xpl insert-file of procedures for plotting .                on a retrographics VT640 plotter.  *//* global variable declarations */dcl #phys.limits      data (0,1023,0,779);dcl (#lastx,#lasty)   fixed; /* coordinates of last point */dcl #data.level       fixed; /* 0 for white, 1 for black, 2 for complemented  */dcl #line.type        fixed; /* save line type */dcl #char.size        fixed; /* save character size */dcl #window.limits(3) fixed; /* user units */ dcl #view.limits(3)   fixed; /* plotter units of viewport */dcl (pxnum,#ynum)     fixed; /* numerator to scale point */dcl (#xden,#yden)     fixed; /* denominator to scale point */dcl (#px,#py)         fixed; /* user's plot units */dcl #initialize       fixed; /* flag to mark first point in point or vector sequence */dcl restore.flag      fixed; /* true to do restore */dcl dq640             fixed; /* true if using DQ640 terminal instead of VT640 */dcl mg600             fixed; /* true if using Mg600 terminal */dcl #xwbase lit '#window.limits(0)';  /* x axis base in user coordinates */dcl #ywbase lit '#window.limits(2)';  /* y axis base in user coordinates */dcl #xvbase lit '#view.limits(0)';    /* x axis base of viewport */dcl #yvbase lit '#view.limits(2)';    /* y axis base of viewport *//* device dependent code section: for VT640 and DQ640 terminals */dcl (#highy,#lowy,#highx) fixed; /* last coordinates transmitted */         dcl point_mode          lit 'do;call pc("34");#mode=#point;#initialize=1;end;';dcl vector_mode         lit 'do;call pc("35");#mode=#vector;#initialize=1;end;'; dcl transparent_mode    lit 'if #mode<>#transparent then do;call pc("30");#mode=#transparent;end;';dcl alpha_mode          lit 'do;call pc("37");#mode=#alpha;end;';#clear:proc; /* clear screen, leave in transparent mode */  /* normal tek10 = esc,ff,cr */  vector_mode;  call pc(A.ESC); call pc("14"); /* ff */  transparent_mode;  if interruptio then call restore;end #clear;dcl clear lit 'call #clear';#char_size:proc(i); /* char size 0 - 80 per line;  1-40 per line */  dcl i fixed;    if (i<0) or (i>3) then return;  call pc(A.ESC);  call pc(a.0+i);  #char.size=i;end #char_size;dcl char_size lit 'call #char_size';#data_level:proc(i); /* sets line to on, off, or complement */  dcl i fixed;  if (i<0) or (i>2) then return; /* error return */  call pc(A.ESC); call pc(a.slash);  do case i;    call pc(a.0  ); /* dots on */    call pc(a.0+1); /* dots off */    call pc(a.0+2); /* dots complemented */  end;    call pc("144");  #data.level=i; /* save value */end #data_level;dcl data_level lit 'call #data_level';#line_type:proc(i); /* sets line type */  dcl i fixed;             if (i<0) or (i>4) then return; /* user defined types not implemented */  call pc(A.ESC);  do case i;    call pc("140"); /* normal line, note 140 not 134 */    call pc("141"); /* dotted line */    call pc("142"); /* dot-dashed line */    call pc("143"); /* short-dashed line */    call pc("144"); /* long-dashed line */  end;    #line.type=i; /* save value */end #line_type;dcl line_type lit 'call #line_type';#greater:proc(a,b) fixed; /* returns 1 if a>b, in range -32768,+32767 */   dcl (a,b)   fixed;   dcl (g1,g2) fixed;   g1=((a&"100000")=0); /* test to see if positive number */   g2=((b&"100000")=0);   if (g1 xor g2) then return g1;   if a>b then return 1;   return 0;end #greater;#converty:proc(y) fixed;   dcl (y,sign) fixed;   sign=0;   if #greater(y,#ywbase) then write(5)=y-#ywbase;   else do;      sign=1;      write(5)=#ywbase-y;   end;   write(6)=#ynum; y=read(5); write(7)=#yden; /* compute (y-base)*num/den */   if sign then return #yvbase-read(5);   else         return #yvbase+read(5);end #converty;#convertx:proc(x) fixed;   dcl (x,sign) fixed;   sign=0;   if #greater(x,#xwbase) then write(5)=x-#xwbase;   else do;      sign=1;      write(5)=#xwbase-x;   end;   write(6)=pxnum; x=read(5); write(7)=#xden; /* compute (x-base)*num/den */   if sign then return #xvbase-read(5);   else         return #xvbase+read(5);end #convertx;dcl #convert_x lit 'x=#convertx(x)';dcl #convert_y lit 'y=#converty(y)';dcl #convert_coordinates lit '#convert_x;#convert_y';#transmit_coords:proc(x,y);    dcl (x,y)                   fixed;                               dcl (highy,lowy,highx,lowx) fixed;   /* scale from user's punits to physical plotter units */   write(5)=x;   write(6)=#phys.limits(1);   x=read(5);   write(7)=#px;   x=read(5);   if (dq640 and (read(4)>=shr(#px+1,1))) then x=x+1; /* round up */   write(5)=y;   write(6)=#phys.limits(3);   y=read(5);   write(7)=#py;   y=read(5);   if (dq640 and (read(4)>=shr(#py+1,1))) then y=y+1; /* round up */     highy=(shr(y,5)+32); /* high y */   lowy=((y&"37")+96);  /* low  y */   highx=(shr(x,5)+32); /* high x */   lowx=((x&"37")+64);  /* low  x */   if #initialize then do; /* must write all bytes */      #initialize=0;      call pc(highy); call pc(lowy); call pc(highx);   end;   else do; /* conditionally write bytes */      if #highy<>highy then call pc(highy);      if #highx<>highx then do;         call pc(lowy); call pc(highx);      end;      else if #lowy<>lowy then call pc(lowy);   end;      call pc(lowx);   #highy=highy;  #lowy=lowy;  #highx=highx; /* keep track of last values */end #transmit_coords;/* end device dependent code */#code:proc(x,y) fixed; /* endpoint codes for 9 regions of screen */  dcl (x,y)  fixed;  dcl c      fixed;  dcl clipxl lit '#view.limits(0)';  dcl clipxr lit '#view.limits(1)';  dcl clipyb lit '#view.limits(2)';  dcl clipyt lit '#view.limits(3)';  c=0; /* initialize */  if      #greater(clipxl,x) then c=1;  else if #greater(x,clipxr) then c=2;  if      #greater(clipyb,y) then c=c+4;  else if #greater(y,clipyt) then c=c+8;  return c;end #code;#move:proc (h,v) fixed; /* begin new vector drawing sequence at (h,v), return 1 if out of bounds */   dcl (h,v) fixed;   #lastx=h;   #lasty=v;   if #code(h,v)<>0 then return 1;   if #mode<>#point then vector_mode;   call #transmit_coords(h,v);   return 0;end #move;#draw:proc(x,y); /* called to draw vector to or put point at (x,y) */                dcl (x,y) fixed;   dcl clipxl lit '#view.limits(0)';   dcl clipxr lit '#view.limits(1)';   dcl clipyb lit '#view.limits(2)';   dcl clipyt lit '#view.limits(3)';     dcl flag fixed; /* to indicate that (x,y) has been clipped */   /* CLIP is derived from the procedure on page 66 of Newman and Sproull */   clip:proc(x1,y1,x2,y2); /* clips vector from (x1,y1) to (x2,y2) at viewport */      dcl (x1,y1,x2,y2) fixed;       dcl (c,c1,c2)     fixed;      dcl (x,y)         fixed;         c1=#code(x1,y1);  c2=#code(x2,y2);  flag=0;      do while (c1+c2)<>0;         if (c1&c2)<>0 then return; /* line is off screen */         c=c1; if c=0 then c=c2;         if (c&1)>0 then do; /* crosses left edge */            y=(y2-y1)*(#view.limits(0)-x1)/(x2-x1);            y=y+y1;            x=#view.limits(0);         end;           else if (c&2)>0 then do; /* crosses right edge */            y=(y2-y1)*(#view.limits(1)-x1)/(x2-x1);            y=y+y1;            x=#view.limits(1);         end;         else if (c&4)>0 then do; /* crosses bottom edge */            x=(x2-x1)*(#view.limits(2)-y1)/(y2-y1);            x=x+x1;            y=#view.limits(2);         end;           else if (c&8)>0 then do; /* crosses top edge */            x=(x2-x1)*(#view.limits(3)-y1)/(y2-y1);            x=x+x1;            y=#view.limits(3);         end;         if c=c1 then do;            x1=x;            y1=y;            c1=#code(x,y);         end;           else do;            x2=x;            y2=y;            c2=#code(x,y);            flag=1; /* end of vector is out */         end;        end; /* of do while */            if (x1<>#lastx) or (y1<>#lasty) then call #move(x1,y1); /* begin new vector if start of vector has been clipped */      call #transmit_coords(x2,y2);   end clip;  if #mode=#point then do;    if #code(x,y)=0 then call #transmit_coords(x,y);    #lastx=x;    #lasty=y;    return;  end;  else if #mode<>#vector then call #move(x,y);  else do;      call clip(#lastx,#lasty,x,y);    #lastx=x;    #lasty=y;  end;end #draw; #pstring:proc(str); /* plots string in TEK4010 alpha characters */   dcl str fixed array; /* string to be printed */   dcl i   fixed;   if (#mode<>#alpha) and (#mode<>#transparent) then alpha_mode;   do i=0 to str(0)-1; /* loop over chars */      call pc(byte(str,i));   end;end #pstring;  dcl ps lit 'call #pstring';#plot:proc(x,y); /* continues vector sequence to (x,y) in user units */   dcl (x,y) fixed;     #convert_coordinates;   if (#mode=#vector) or (#mode=#point) then call #draw(x,y);   else                                      call #move(x,y);end #plot;dcl plot lit 'call #plot';#move_to:proc(x,y) fixed; /* begin vector sequence at user's (x,y), return 1 if out  */   dcl (x,y) fixed;      #convert_coordinates;   return #move(x,y);end #move_to;dcl move_to lit 'call #move_to';#connect:proc(a,b,c,d); /* connects users (a,b) to (c,d) */   /* moves to (a,b) with pen in present state and     then connects (a,b) with (c,d) and leaves pen up at the end */   dcl (a,b,c,d) fixed;   call #move_to(a,b);   call #plot (c,d);end #connect;dcl connect lit 'call #connect';#axes:proc(x,y); /* axes through (x,y) */    dcl (x,y) fixed;   connect(x,#window.limits(3),  x,#window.limits(2));   connect(#window.limits(0),y,  #window.limits(1),y); end #axes;dcl axes lit 'call #axes';#border:proc; /* draw border around viewport */   call #move(#view.limits(0),#view.limits(2));   call #draw(#view.limits(1),#view.limits(2));   call #draw(#view.limits(1),#view.limits(3));   call #draw(#view.limits(0),#view.limits(3));   call #draw(#view.limits(0),#view.limits(2));end #border;dcl border lit 'call #border';#map:proc; /* computes numerator and denominator for scaling */   pxnum=#view.limits(1)  -#view.limits(0);     #ynum=#view.limits(3)  -#view.limits(2);   #xden=#window.limits(1)-#window.limits(0);   #yden=#window.limits(3)-#window.limits(2);end #map;#punits:proc(x,y); /* user units for viewports */   /* for VT-640, call with (639,479) */   dcl (x,y) fixed;   #px=x;   #py=y;end #punits;dcl punits lit 'call #punits';#frame:proc(vector,x1,x2,y1,y2); /* to store viewport or window coordinates */   dcl vector        fixed array;        dcl (x1,x2,y1,y2) fixed;   vector(0)=x1;   vector(1)=x2;   vector(2)=y1;   vector(3)=y2;end #frame;#window:proc(x1,x2,y1,y2); /* set plot limits in user units */  dcl (x1,x2,y1,y2) fixed;    call #frame(#window.limits,x1,x2,y1,y2); /* sets window limits */  call #map; /* update scaling */end #window;dcl window lit 'call #window';#viewport:proc(x1,x2,y1,y2); /* set plot limits in plotter units */   dcl (x1,x2,y1,y2) fixed;      call #frame(#view.limits,x1,x2,y1,y2); /* set view limits */   call #map; /* update scaling */end #viewport;dcl viewport lit 'call #viewport';begin; /* initial setup */   dcl i fixed;     do i=0 to 3;      #window.limits(i)=#phys.limits(i);      #view.limits(i)  =#phys.limits(i);   end;     punits(#phys.limits(1),#phys.limits(3));   call #map;   #mode=#transparent;   #data.level=0; /* white */end; /* of initialize */NUM_TO_STR:PROC(STRING,VAL); /* this version of pnum prints left justified */   DCL STRING     FIXED ARRAY;                                   DCL VAL        FIXED;   DCL DIVISORS   DATA (-10000,-1000,-100,-10,-1);   DCL (GO,I,CHR) FIXED;   PC:PROC(CHR);     DCL CHR FIXED;       CALL PBYTE(STRING,STRING(0),CHR);     STRING(0)=STRING(0)+1;   END PC;   STRING(0)=0;   IF VAL<0 THEN CALL PC("055"); /* NEGATIVE - MINUS SIGN */   ELSE VAL=-VAL; /* WE USE NEGATIVE NUMBER SO THAT -32768 WON'T BLOW UP */   GO=0;/* SUPPRESS LEADING ZEROS */   DO I=0 TO 4;      CHR=VAL/DIVISORS(I);      IF CHR<>0 THEN GO=1; /* NOT LEADING ZERO */      IF (GO) OR (I=4) THEN CALL PC(A.0+CHR);      VAL=VAL-(DIVISORS(I)*CHR); /* REDUCE */   END;END NUM_TO_STR;INT_TO_STR:PROC(STRING,VAL); /* this version of pint prints left justified */   DCL STRING     FIXED ARRAY;                                   DCL VAL        FIXED;   DCL DIVISORS   DATA (10000,1000,100,10,1);   DCL (GO,I,CHR) FIXED;   PC:PROC(CHR);     DCL CHR FIXED;       CALL PBYTE(STRING,STRING(0),CHR);     STRING(0)=STRING(0)+1;   END PC;   STRING(0)=0;   GO=0;/* SUPPRESS LEADING ZEROS */   DO I=0 TO 4;      WRITE(5)=VAL;  WRITE(7)=DIVISORS(I);      CHR=READ(5);       IF CHR<>0 THEN GO=1; /* NOT LEADING ZERO */      IF (GO) OR (I=4) THEN CALL PC(A.0+CHR);      VAL=VAL-(DIVISORS(I)*CHR); /* REDUCE */   END;END INT_TO_STR;#pnum:proc(val);   dcl val       fixed;   dcl string(4) fixed;   call num_to_str(string,val);   ps(string);end #pnum;dcl pnum lit 'call #pnum';#pint:proc(val);   dcl val       fixed;   dcl string(4) fixed;   call int_to_str(string,val);   ps(string);end #pint;dcl pint lit 'call #pint';#nl:proc;   call pc("015");     call pc("012");end #nl;dcl nl lit 'call #nl';pos:proc(line,col); /* position cursor at line and col (adapted from screen editor code  */    dcl (line,col) fixed;      call pc(a.esc); call pc(a.lbracket);    pnum(line);   call pc(a.semicolon);   pnum(col);   call pc("110");end pos;   dcl ALTERNATE_CHARS data (3,"H281B","H0030"); /* Invoke special graphics character set */dcl NORMAL_CHARS    data (3,"H281B","H0042"); /* Invoke standard ascii character set */box:  proc(up.left.x,up.left.y,low.right.x,low.right.y); /* prints a box using alternate char set for VT100 */   dcl (  up.left.x,  up.left.y) fixed; /* upper left screen pos for box */   dcl (low.right.x,low.right.y) fixed; /* lower right screen pos for box */   dcl i                         fixed;   /* X coordinates should be in range 0 to 79 */   /* Y coordinates should be in range 0 to 23 */   ps(ALTERNATE_CHARS);             /* switch to special char set */   call pos(up.left.y,up.left.x);   /* move to start location */   call pc("154");                  /* upper left corner */   do i=up.left.x to low.right.x-2; /* top side */      call pc("161");   end;   call pc("153");                  /* upper right corner */   do i=up.left.y to low.right.y-2; /* right side */      call pc(a.lf); if low.right.x<79 then call pc(a.bs);      call pc("170");    end;   call pos(up.left.y+1,up.left.x);   do i=up.left.y to low.right.y-2; /* left side */      call pc("170"); call pc(a.bs); call pc(a.lf);    end;   call pc("155");                  /* lower left corner */   do i=up.left.x to low.right.x-2; /* bottom side */      call pc("161");   end;   call pc("152");                  /* lower right corner */   ps(NORMAL_CHARS);                /* return to normal char set */end box;