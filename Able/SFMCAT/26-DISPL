/* 26-DISPL  $TITLE  Signal Display Plotting Module *//* Copyright 1985 by New England Digital Corporation *//* declarations for time display */dcl last.point            fixed; /* last valid point in display   */dcl display.origin(2)     fixed; /* time vector of display origin */dcl display.end(2)        fixed; /* time vector of display end    */dcl compress              fixed; /* time axis compression amount  */dcl cursor.loc            fixed; /* current cursor position within display */dcl plot.len              fixed;dcl plot.max              lit '(560+120)'; /* one pixel per point-big enough for dq640 */dcl plot.buffer(plot.max) fixed;multiply_by_compress:proc(x,index); /* convert x at 'compress' samples per point plot units to sector,offset */    dcl x     fixed;    dcl index fixed array;    load x; mul compress;    index(2)=res&255;    index(1)=shr(res,8)+shl(read(4),8);    index(0)=0;end multiply_by_compress;divide_by_compress:proc(index) fixed; /* return plot coordinate of index for 'compress' samples per plot point */   dcl index   fixed array;   dcl x       fixed;   dcl temp(2) fixed;   call time_to_index(display.origin,temp,period.index);   call sub_len_from_len(index,temp,temp);   load temp(1); mul 256; x=res; div compress; x=res;   load read(4)+temp(2);         div compress; /* remainder */   return x+res;end divide_by_compress;increment_cursor:proc(increment); /* increments cursor.loc and computes cursor.time */   dcl increment fixed;     dcl temp(2) fixed;   cursor.loc=cursor.loc+increment;   if      cursor.loc>last.point then cursor.loc=last.point;         else if cursor.loc<0          then cursor.loc=0;   call multiply_by_compress(cursor.loc,temp);   call time_to_index(display.origin,cursor.time,period.index);   call add_len_to_len(temp,cursor.time,cursor.time);   call index_to_time(cursor.time,cursor.time,period.index);end increment_cursor;/* $SUBTITLE  Symbol Plotting Routines */plot_symbol:proc(x,y,name) swap; /* plots symbol name at coordinate (x,y) */   dcl (x,y)     fixed; /* cursor.loc */        dcl name      fixed array;   dcl savelevel fixed;   savelevel=#data.level; /* save current data level */   vector_mode;   data_level(2);   #convert_coordinates;   if compress=1 then do;      if ^#move(x+3,y+3) then call #transmit_coords(x-3,y-3);      if ^#move(x+3,y-3) then call #transmit_coords(x-3,y+3);   end;   vector_mode;   call #transmit_coords(x,#view.limits(3));   call #transmit_coords(x,#view.limits(3)+6);   if x+8*name(0) > #px then do; /* prevent printing beyond right margin */      vector_mode;      call #transmit_coords(#px-8*name(0),#view.limits(3)+6);   end;   alpha_mode;   ps(name);   vector_mode;   data_level(savelevel); /* restore */   transparent_mode;end plot_symbol;plot_marker:proc(time) swap; /* routine to plot a play marker */   dcl time    fixed array;    dcl temp(2) fixed;   dcl x       fixed;   if display.type<>time.display then return;   if compare_vectors(time,display.end,   3)>0 then return;   if compare_vectors(time,display.origin,3)<0 then return;   call time_to_index(time,temp,period.index);   x=divide_by_compress(temp);   vector_mode;   data_level(2);          line_type(1);   #convert_x;   call #move(x,#view.limits(2));   call #draw(x,#view.limits(3));   data_level(0);   line_type(0);   transparent_mode;  end plot_marker;    plot_current_symbols:proc swap; /* plot all symbols in display range */   dcl temp(2) fixed;   dcl (i,x)   fixed;   call plot_marker(mark.start); /* plot start */   call plot_marker(mark.end);   /* plot end   */   i=1;   do while (i<number.of.symbols) /* skip up to first symbol in range */   and (compare_vectors(display.origin,location(symbol_time(i)),3)>0);      i=i+1;   end;   do while (i<=number.of.symbols) /* loop over remaining symbols in range */   and (compare_vectors(display.end,location(symbol_time(i)),3)>=0);      call time_to_index(location(symbol_time(i)),temp,period.index);      x=divide_by_compress(temp);      call plot_symbol(x,plot.buffer(x),location(symbol_name(i)));      i=i+1; /* advance to next symbol */   end; /* of loop over symbols */end plot_current_symbols;/* $SUBTITLE */time_axis:proc fixed swap; /* time values on x axis */   dcl inc(2)   fixed;   dcl time(2)  fixed;   dcl index(2) fixed;   dcl delta    fixed;   dcl (i,j)    fixed;   call copy_vector(time,display.origin,3);   call time_to_index(time,index,period.index);   call time_to_index(location(hor.time),inc,period.index);   call add_len_to_len(index,inc,inc);   i=divide_by_compress(inc)/10;   call multiply_by_compress(i,inc);   call index_to_time(inc,inc,period.index);   inc(2)=0;   if inc(0)<>0 then do;      inc(1)=0;      if      inc(0)>=100 then inc(0)=100*(inc(0)/100+1);      else if inc(0)>=10  then inc(0)=10*(inc(0)/10+1);   end;   else if inc(1)>=100 then inc(1)=100*(inc(1)/100+1);   else if inc(1)>=10  then inc(1)=10*(inc(1)/10+1);   else inc(1)=inc(1)+1;   call time_to_index(inc,inc,period.index);   do while compare_vectors(time,display.end,3)<=0;      if break.rcvd or (pfkey>2) or (ud.arrow<>0) then do; /* abort */         break.rcvd=0;         transparent_mode;         return 1;      end;      i=divide_by_compress(index);      move_to(i,bottom.limit);      call #transmit_coords(#lastx,#lasty-3);      vector_mode;      call #transmit_coords(#lastx-28,#lasty-12);      alpha_mode;      call print_time(time,3,0);      call add_len_to_len(inc,index,index);      call index_to_time(time,index,period.index);   end;   vector_mode;   call #transmit_coords((300+dq640*75),#view.limits(2)-28);   ps('Seconds');   transparent_mode;   return 0;end time_axis;/* $SUBTITLE  Routine to Draw the Waveform in Signal Display */load_display:proc(start) swap; /* plot the signal from databuf1 starting at 'START' */   dcl start       fixed array; /* starting time in file */   dcl origin(2)   fixed;    dcl temp(2)     fixed;   dcl test(2)     fixed;   dcl valid       fixed;   dcl (max,min)   fixed;   dcl (x,g1,g2)   fixed;   dcl more        fixed;   dcl (i,j,k)     fixed;   if (display.type<>time.display) or (f.name.bytes=0) then do;      error.flag=e.sys.error; return 1;   end;   call copy_vector(origin,start,2);   origin(2)=0; /* truncate to even milliseconds */   call time_to_index(origin,origin,period.index);      call multiply_by_compress(plot.len,temp);   call add_len_to_len(origin,temp,test); /* the observation at the end of the display */   if compare_vectors(test,location(valid.data),3)>0 then do; /* outside of data */      if compare_vectors(location(valid.data),temp,3)>0 then do; /* data larger than display */         call sub_len_from_len(location(valid.data),temp,origin);         call index_to_time(origin,origin,period.index);         if origin(2)>0 then do; /* truncate to even number of milliseconds */            origin(2)=0;            origin(1)=origin(1)+1;            if origin(1)=0 then origin(0)=origin(0)+1;         end;         call time_to_index(origin,origin,period.index);      end;          else call copy_vector(origin,zero.vector,3); /* if display longer than data */      call index_to_time(display.end,location(valid.data),period.index);   end;   else call index_to_time(display.end,test,period.index);    call index_to_time(display.origin,origin,period.index);   do i=0 to plot.len-1; plot.buffer(i)=0; end;     vector_mode;   if compress=1 then do; /* case for non-compressed plot */      if not line.mode then point_mode;      call sub_len_from_len(location(valid.data),origin,temp);      if temp(1) IGE buf1.len then valid=plot.len+1;      else                         valid=temp(1)*sector.size+temp(2);      if valid IGT plot.len then valid=plot.len+1;      call add_len_to_addr(origin,location(f.data.index),temp);      call readdata(temp(0),temp(1),databuf1,valid+origin(2));      last.point=valid-1;      do i=0 to last.point; /* loop over points */         plot.buffer(i)=databuf1(i+origin(2));         plot(i,plot.buffer(i));         if (break.rcvd) or (pfkey>2) or (ud.arrow<>0) then do; /* abort */            break.rcvd=0;            transparent_mode;            return 0;         end; /* of abort */      end; /* of loop over points */   end; /* of not compressed plot */   /* $PAGE */   else do; /* compressed plot */      i=origin(2); more=1; last.point=0;      do while (more) and (last.point<=plot.len); /* loop over points */         call sub_len_from_len(location(valid.data),origin,temp);         if temp(1) IGE buf1.len then valid=buf1.len*sector.size;         else do;            more=0; valid=temp(1)*sector.size+temp(2)+origin(2)+1;         end;         call add_len_to_addr(origin,location(f.data.index),temp);         call readdata(temp(0),temp(1),databuf1,valid);         x=databuf1(i); /* speed up? */         j=0; /* init compressed point count */         do while (last.point<=plot.len) and (i<valid); /* loop over points */            if j=0 then do; /* first point - use value as max and min */               max=databuf1(i); min=max;            end;            else do; /* not first point - update max and min */               x=databuf1(i);               g1=((x  &"100000")=0);               g2=((max&"100000")=0);               if g1 xor g2 then do; if g1 then max=x; end;               else              if x>max then max=x;               g2=((min&"100000")=0);               if g1 xor g2 then do; if g2 then min=x; end;               else              if x<min then min=x;            end; /* update max and min */            i=i+1; /* bump data point index */            j=j+1; /* bump compressed point count */            if j=compress then do; /* end of compresion segment - emit */               if not line.mode then vector_mode;               plot(last.point,max);               plot(last.point,min);               plot.buffer(last.point)=max;               j=0; /* clear compressed point counter */               last.point=last.point+1;               if (break.rcvd) or (pfkey>2) or (ud.arrow<>0) then do; /* abort */                  break.rcvd=0;                  transparent_mode;                  return 0;               end;            end; /* of emit compression segment */         end; /* of loop over points */         temp(0)=0; temp(1)=0; temp(2)=valid;         i=0;         call add_len_to_len(temp,origin,origin);         end; /* of loop over points */      last.point=last.point-1;   end; /* of compressed plot */   if time_axis then return 0;   call plot_current_symbols;   return 0;end load_display;/* $SUBTITLE *//* the following three variables are computed in new_frame */dcl save.x.coord  fixed; /* plotter x coordinate of cursor and level values */dcl save.level.y  fixed; /* plotter y coordinate of cursor level */dcl save.cursor.y fixed; /* plotter y coordinate of cursor time value */cursor:proc(x,y,time,scale); /* positions cursor at (x,y) */  dcl (x,y)     fixed;    dcl time      fixed array; /* sec, ms, usec at cursor */  dcl scale     fixed; /* y coordinate */  dcl value     fixed;   dcl savelevel fixed; /* temporary to save data.level */  value=y;  savelevel=#data.level;  #convert_coordinates; /* convert to plotter units */  vector_mode;  if #data.level<>2 then data_level(2); /* complement dots */  if cursor.on then do;     if compress=1 then do;        call #move(x-6,y);        call #draw(x+6,y);     end;     call #move(x,#view.limits(2));     call #draw(x,#view.limits(3));  end;  vector_mode;  call #transmit_coords(save.x.coord,save.cursor.y);  alpha_mode;  call print_time(time,3,1);  vector_mode;  if compress=1 then do;     call #transmit_coords(save.x.coord,save.level.y);     alpha_mode;     call print_value(value,scale,3,4);  end;  if #data.level<>savelevel then data_level(savelevel); /* restore */  transparent_mode;end cursor;new_frame:proc swap; /* draw the plot frame and labels for a signal display */  dcl time(2)      fixed;  dcl temp(2)      fixed;  dcl tab0         lit '3';  dcl tab1         lit '(80+dq640*20)';  dcl tab2         lit '(175+dq640*44)';  dcl right.edge   lit '(612+dq640*133)';  dcl left.edge    lit '(52+dq640*13)';  dcl top1         lit '250';  /* top of data viewport - symbols extend up 20 punits */  dcl border.port  lit '(left.edge,right.edge,top1-190,top1)';  dcl data.port    lit '(left.edge+6,right.edge-6,top1-190,top1)';  /* viewport for waveform */  dcl label.port   lit '(8,(240+dq640*58),top1+18+35,top1+18+105)'; /* viewport for id and file name */  dcl label.window lit '(0,232+dq640*58,0,70)';  dcl i            fixed;  /* $PAGE */  if f.name.bytes=0 then do;     error.flag=e.no.file;     return 1;  end;  display.type=time.display;  plot.len=plot.max;  call time_to_index(location(hor.time),temp,period.index);  if 1 then compress=temp(1)/2+1;  /* THIS IS BUGGY, I THINK -- TSS */  else do;                         /* SHOULD BE THE FOLLOWING */     load shl(temp(1),8)+temp(2); write(4)=shr(temp(1),8); div plot.len;     compress=res;     if read(4) IGE shr(plot.len,1) then compress=compress+1;     if compress=0 then compress=1;  end;  if compress=1 then plot.len=temp(1)*sector.size+temp(2);  clear;  vector_mode;  call #transmit_coords(0,407);  char_size(1);  ps('Signal Display: ');   if compress<>1 then do;     vector_mode;     call #transmit_coords(300+dq640*75,top1+68);     ps('(Compressed)');  end;  char_size(0);  vector_mode;  if dq640 then call #transmit_coords(560-5*id.field.bytes,407);  else call #transmit_coords(448-4*id.field.bytes,407);  ps(id.field);  viewport label.port;  window label.window;  border;  move_to(tab0,52);  ps('File ');  ps(f.name);  move_to(112,52);  ps(' (');  call fprint(clock.rate*1./period.index,2,3);    ps(' kHz)');  move_to(tab0,38);  ps('Length:');  move_to(tab1,38);  alpha_mode;  call print_time(location(data.end),3,1);  move_to(tab2,38);  ps('Sec.');  move_to(tab0,24);  ps('Cursor:');  move_to(tab1,24);  save.x.coord=#lastx;  save.cursor.y=#lasty;  move_to(tab2,24);  ps('Sec.');  move_to(tab0,10);  ps('Level:');  save.level.y=#lasty;  move_to(tab2,10);  ps('Volts');  viewport border.port;  window(0,1000,bottom.limit,top.limit);    border;  if (top.limit>0) and (bottom.limit<0) then do; /* draw zero axis if on plot */    line_type(1); /* dotted */    connect(0,0,1000,0);    line_type(0);  end;    #lastx=0; #lasty=(#view.limits(2)+#view.limits(3))/2+25; /* center of viewport + 25 punits */  call print_vertical('Volts');  /* $PAGE */  begin; /* now put scale on left axis; find integer tic intervals */     dcl (top,bottom) fixed; /* range to plot */     dcl inc          fixed; /* step increment */     dcl constant     lit '(2000*scale.factor)';     dcl trail        fixed; /* digits after point */     dcl (i,x)        fixed;          top   =top.limit    % constant;     bottom=bottom.limit % constant;     inc=(top-bottom); /* compute range to be displayed */     if      inc>=constant/10  then inc=constant/10; /* calculate intervals for tick marks */     else if inc>=constant/100 then inc=constant/100;     else                           inc=constant/1000;     if (((top-bottom)/inc)<3) and (inc>=50) then inc=inc/5; /* ensure at least 3 tick marks */     trail=1; /* assume one digit to right of decimal point */     if inc<constant/100 then trail=2; /* space for 2 */     bottom=inc*(bottom/inc-1); /* increase the bottom */     top   =inc*(top/inc+1); /* decrease the top */     if bottom<(-constant)/2 then bottom=(-constant)/2; /* apply limits */     if top   >  constant/2  then top   =  constant/2;          do i=bottom to top by inc; /* loop over display range */        if i=scale.factor*1000 then x=32767; /* compute x value */        else                        x=i fdiv 10000;        if not #move_to(0,x) then do; /* if within view limits */           call #transmit_coords(#lastx+4,#lasty);           vector_mode;           call #transmit_coords(#view.limits(1)-4,#lasty);           call #transmit_coords(#view.limits(1),#lasty);           vector_mode;           call #transmit_coords(8,#lasty-3);           alpha_mode;           call print_value(x,scale.factor,4-trail,trail); /* print voltage label */        end; /* of if within view limits */     end; /* of loop over display range */  end; /* of put left axis label on plot */  viewport data.port;  window(0,plot.len,bottom.limit,top.limit);  transparent_mode;  return 0;end new_frame; /* $SUBTITLE */insert_symbol:proc(name) fixed swap; /* adds symbol to table and plots it */   dcl name    fixed array;     dcl temp(2) fixed;   if add_symbol(cursor.time,name) then return 1; /* symbol definition failed */   if display.type = time.display /* plot symbol if time disp on screen */   then call plot_symbol(cursor.loc,plot.buffer(cursor.loc),name);   return 0;end insert_symbol;delete_symbol:proc(name) fixed swap; /* deletes symbol from table, and removes from plot */   dcl name      fixed array;     dcl temp(2)   fixed;   dcl (index,x) fixed;    index=locate_index(name); /* look up given name */   if index=0 then do; /* if not defined */      error.flag=e.no.name;      return 1;   end;        if  (compare_vectors(location(symbol_time(index)),display.origin,3)>=0)   and (compare_vectors(location(symbol_time(index)),display.end,3)<=0)   and (display.type = time.display) then do; /* remove label from signal display plot */      call time_to_index(location(symbol_time(index)),temp,period.index);      x=divide_by_compress(temp);      call plot_symbol(x,plot.buffer(x),location(symbol_name(index))); /* erase it */   end; /* of remove from display */   return remove_symbol(index); /* delete from table, return status */end delete_symbol;/* $SUBTITLE */scroll_to_time:proc(time,center,force) fixed swap; /* moves cursor to indicated time, scrolls data if necessary */   dcl time     fixed array;   dcl center   fixed; /* if true, try to center time */   dcl force    fixed; /* if not center, then set true to force new plot */   dcl temp(2)  fixed;   dcl temp2(2) fixed;   if (record.flag=1) or (f.name.bytes=0) then do; /* no file to display */      error.flag=e.no.file;      return 1;   end;   if compare_vectors(time,location(data.end),3)>0 then do; /* past end of data */      error.flag=e.past.end;      return 1;   end;   if center then do; /* scroll data to put time near center of display */      call time_to_index(time,temp2,period.index);      call multiply_by_compress(plot.len/2,temp);      if sub_len_from_len(temp2,temp,temp) then do; /* use file origin */         temp(0)=0; temp(1)=0; temp(2)=0;         error.flag=0;      end;      else call index_to_time(temp,temp,period.index); /* compute left hand side time */      if (compare_vectors(temp,display.origin,3)<>0) or force then do; /* display must be shifted */         if new_frame then return 1; /* new display */         if load_display(temp) then return 1;           end;        else call cursor(cursor.loc,plot.buffer(cursor.loc),cursor.time,scale.factor);   end;   else if (not force)   and (compare_vectors(time,display.origin,3)>=0)   and (compare_vectors(time,display.end,   3)<=0) then /* just move cursor */      call cursor(cursor.loc,plot.buffer(cursor.loc),cursor.time,scale.factor);          else do; /* must scroll display */      if new_frame then return 1;      if load_display(time) then return 1;   end;   call copy_vector(cursor.time,time,3); /* copy input time to cursor time */   call time_to_index(time,temp,period.index); /* conv to index */   cursor.loc=divide_by_compress(temp);   call cursor(cursor.loc,plot.buffer(cursor.loc),time,scale.factor); /* draw cursor */   return 0;   end scroll_to_time;initialize_display:proc(name,flag) swap; /* call to display a file */   dcl name    fixed array;   dcl flag    fixed;   dcl i       fixed;   record.flag=0;   if name(0)=0 then call assign(name,recordfile.name); /* store name */   call file(1,flag);             /* update last current file */   if  (compare(name,f.name)<>0)  /* names are same */   and (shr(f.drive,8)=shr(core(loc.ucat+1),8)) /* and on the same drive */   then i=1;                      /* assume already the current file */   else i=(old(name)=0);          /* desired filename different from last current file */   if i<>0 then do;               /* could recall */      display.type=non.graphical;      clear;      call pos(5,1);      ps('File: '); ps(name); ps('  '); psr(id.field);              nl;      ps('Length: '); call print_time(location(data.end),3,1); ps(' Seconds');      call cursor_restore;      call set_scale;   end;   else if flag=0 then do; /* return from overlay-put up catalog */      f.name.bytes=0;      call catalog;   end;end initialize_display;/* $PAGE */move_cursor:proc; /* move cursor according to arrow count */   dcl psave fixed;    psave=0;   disable;   psave=psave+rl.arrow*arrow.count;      enable;   call cursor(cursor.loc,plot.buffer(cursor.loc),cursor.time,scale.factor);   call increment_cursor(psave);   call cursor(cursor.loc,plot.buffer(cursor.loc),cursor.time,scale.factor); /* write new cursor */   call tty_wait;   rl.arrow=0; /* throw away any that occurred during cursor draw */end move_cursor;scroll_down:proc swap; /* move one screen to left */   dcl temp(2) fixed;   ud.arrow=0;   if compare_vectors(zero.vector,display.origin,3)<>0 then do; /* not at start */      call multiply_by_compress(plot.len,temp);         call time_to_index(display.origin,display.origin,period.index);      if sub_len_from_len(display.origin,temp,temp) then do; /* limit to zero */         temp(0)=0; temp(1)=0; temp(2)=0;      end;      call index_to_time(temp,temp,period.index);      if new_frame then return 1;      call load_display(temp);      call copy_vector(cursor.time,display.end,3);      cursor.loc=last.point;              call cursor(cursor.loc,plot.buffer(cursor.loc),cursor.time,scale.factor);   end; /* of not at start */   error.flag=0; /* supress any spurious error conditions */   call tty_wait;end scroll_down;scroll_up:proc swap; /* move one screen to right */   ud.arrow=0;   if compare_vectors(location(data.end),display.end,3)<>0 then do; /* not at end */      if new_frame then return 1;      call load_display(display.end);      call copy_vector(cursor.time,display.origin,3);      cursor.loc=0;      call cursor(cursor.loc,plot.buffer(cursor.loc),cursor.time,scale.factor);   end;   error.flag=0; /* supress any spurious error conditions */   call tty_wait;end scroll_up;/* $SUBTITLE */search:proc(value) swap; /* search forward till value exceeds threshold */   dcl value     fixed array;    dcl cur   (2) fixed;   dcl stop  (2) fixed;   dcl temp  (2) fixed;   dcl lim       fixed;   dcl flag      fixed;   dcl (i,j,y)   fixed;   if value(0)<0 then do; /* take abs value of target voltage */      value(0)=-value(0);      value(1)=-value(1);   end;   y=convert_to_abs(value); /* convert target volts to internal units */   call time_to_index(cursor.time,cur,period.index); /* find starting time */   call add_len_to_addr(cur,location(f.data.index),temp); /* add in file base */   call copy_vector(cur,temp,3);   call add_len_to_addr(location(valid.data),location(f.data.index),stop); /* find end */   flag=0; /* assume no success */   do while (not break.rcvd) and (compare_addrs(stop,cur)>0); /* loop over sectors till end */      call sub_len_from_len(stop,cur,temp); /* compute number of sectors to read */      lim=temp(1); /* get number of sectors */      if temp(2)<>0 then lim=lim+1; /* account for fractional sector */      if lim>buf1.len then lim=buf1.len; /* limit to buffer size */      call readdata(cur(0),cur(1),databuf1,lim*sector.size); /* do the read */      do i=cur(2) to lim*sector.size-1; /* loop over data in buffer */         j = databuf1(i); /* get value */         if j=(-32768) then flag=1; /* always succeeds */         else do; /* can do abs and compare */            if j<0 then j=-j; /* take abs */            if j>y then flag=1; /* successful search */         end;         if flag then do; /* success */            temp(0)=0; temp(1)=0; temp(2)=i-cur(2); /* count samples skipped */            call add_len_to_addr(temp,cur,cur); /* add in samples skipped */            call sub_len_from_addr(cur,location(f.data.index),stop); /* subtract off file base */            call index_to_time(stop,stop,period.index);            call scroll_to_time(stop,1,0);            return;         end; /* success */      end; /* of loop over data */      cur(1)=cur(1)+lim; /* update current position */      if cur(2)<>0 then cur(1)=cur(1)-1; /* compensate for fractional sector */      cur(2)=0; /* start next from sector boundary */   end; /* of loop over sectors */end search;change_scale:proc swap; /* to increase or decrease hor.time if pfkey pressed */   dcl temp0 lit 'core(hor.time+0)';   dcl temp1 lit 'core(hor.time+1)';   dcl temp2 lit 'core(hor.time+2)';   call time_to_index(location(hor.time),location(hor.time),period.index);   if pfkey=3 then do; /* PF3:  compress horizontal scale */      temp2=temp2/2;      if temp1 then temp2=temp2+128;      temp1=temp1/2;      if temp0 then temp1=temp1+32768;      temp0=temp0/2;      if (temp0=0) and (temp1=0) and (temp2<50) then temp2=50;   end;   else do; /* PF4:  expand horizontal scale */      temp0=temp0*2;      if temp1<0 then temp0=temp0+1;      temp1=shl(temp1,1);      temp2=temp2*2;   end;   call index_to_time(location(hor.time),location(hor.time),period.index);   pfkey=0; /* clear pfkey operation */   call scroll_to_time(cursor.time,0,1);end change_scale;/* $SUBTITLE */peak:proc(sign) swap; /* to position cursor on local peak */   dcl sign   fixed; /* 0 for positive peak, 1 for negative */   dcl temp   fixed; /* temporary cursor */   parabola:proc(time); /* tries to interpolate peak position */      dcl time fixed array; /* = cursor.time */      /* a parabola is fit to the three peak samples, and the derivative set to zero */      dcl (del1,del2,a,b) fixed;      if (cursor.loc=0) or (cursor.loc=plot.max) then return;      del1=plot.buffer(cursor.loc-1)-plot.buffer(cursor.loc); /* y1-y2 */      del2=plot.buffer(cursor.loc+1)-plot.buffer(cursor.loc); /* y3-y2 */      a=del1+del2; /* actually 2a */      b=(del2-del1)/2;      a=-1000*b/a;      a=a*period.index/clock.rate;      time(2)=time(2)+a;   end parabola;   if display.type<>time.display then return; /* must have signal display on screen */   if compress<>1 then return; /* can not find peaks on compressed plot */   temp=cursor.loc; /* start at current cursor loc */   if sign then do; /* look for negative peak */      do while (temp>0)&(plot.buffer(temp-1)<plot.buffer(temp));         temp=temp-1;      end;      do while (temp<plot.max)&(plot.buffer(temp+1)<plot.buffer(temp));         temp=temp+1;      end;   end;   else do; /* look for positive peak */      do while (temp>0)&(plot.buffer(temp-1)>plot.buffer(temp));         temp=temp-1;      end;      do while (temp<plot.max)&(plot.buffer(temp+1)>plot.buffer(temp));         temp=temp+1;      end;   end;   call cursor(cursor.loc,plot.buffer(cursor.loc),cursor.time,scale.factor);   call increment_cursor(temp-cursor.loc);   call parabola(cursor.time);   call cursor(cursor.loc,plot.buffer(cursor.loc),cursor.time,scale.factor);  /* write new  cursor */end peak;