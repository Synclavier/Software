/* 00-OKBD  $TITLE  LOW LEVEL SCANNING ROUTINES FOR ORIGINAL SYNCLAVIER II PANEL *//* FIRST, THE KEYBOARD: *//* A new scanning routine has been implemented for the scanning.  of the clavier.   The routine 'scan.new.notes' is called every loop time..  It detects changes in the keyboard and records entries on a push.  down stack when a key is pressed or released.   See stack definitions.  below. *//* Use of key numbers:..  The higher level software can accept key numbers that span the.  range from C0 (use 0) to C7 (use 84).   Keyboards must be mapped.  to produce a key number form 0 to 84.   Middle C is C3 (key number.  of 36...  The original synclavier II keyboard spans C1 to C6 */DCL BIT.TABLE DATA (1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768);DCL PULSE_EXWR1      LIT ''; /* NEEDED BY COMPILER */DCL LIST.SIZE        LIT '12';DCL NEW.NOTE.LIST    (LIST.SIZE) FIXED;   /* STACK FOR NEW KEYBOARD NOTES */DCL NEW.NOTE.KEY#    (LIST.SIZE) FIXED;DCL NEW.NOTE.VEL     (LIST.SIZE) FIXED;DCL NEW.BUTTON.LIST  (LIST.SIZE) FIXED;DCL NUM.OCTAVES      LIT '06'; /* NUMBER OF OCTAVES TO SCAN FROM KEYBOARD */DCL NUM.SW.PANS      LIT '08'; /* NUMBER OF SWITCH PANELS TO SCAN */DCL ANALOG.IN (7)  FIXED;   /* 8 ANALOG INPUTS */DCL KNOB.POS       LIT 'ANALOG.IN(0)';DCL RIBBON.POS     LIT 'ANALOG.IN(1)';DCL PWHEEL.POS     LIT 'ANALOG.IN(2)';DCL PEDAL1.POS     LIT 'ANALOG.IN(3)'; /* VOL */DCL PEDAL2.POS     LIT 'ANALOG.IN(4)'; /* RTE */DCL MWHEEL.POS     LIT '0';DCL BREATH.POS     LIT '0';DCL UNUSED.POS     LIT '0';DCL KNOB.BASE      FIXED;DCL VOLPEDALPOS    FIXED; /* GLOBAL FOR LOGICAL VOLUME PEDAL POS (FILTERED) */DCL RTEPEDALPOS    FIXED; /* PEDAL2=RTE PEDAL */DCL D130 LIT '"130"';DCL D131 LIT '"131"';SCAN.NEW.NOTES:  PROC; /* CREATE LIST OF NEW NOTES ON KEYBOARD */  DCL MAX.KEY      DATA (11,11,11,11,11,1); /* NUMBER OF KEYS IN EACH OCTAVE */  DCL OLD.BITS (5) FIXED;  DCL (I,J,K,L)    FIXED;  WRITE(D131)="20"; /* FIRST STOP THE WRITE IN PROGRESS */  DO I=0 TO NUM.OCTAVES-1; /* SCAN THE KEYBOARD */    WRITE(D131)=I\"100"; /* SET UP ADDRESS WITH READ BIT*/    J=READ(D130);        /* GET NEW BITS */    IF OLD.BITS(I)<>J THEN DO; /* CHANGE IN REGISTER DATA */       DO K=0 TO MAX.KEY(I); /* MUST TEST EACH BIT TO SEE WHICH BITS DIFFER */          IF ((J XOR OLD.BITS(I)) & BIT.TABLE(K)) <> 0 THEN DO; /* THIS BIT IS DIFFERENT */             L=I*12+K+12; /* COMPUTE KEY NUMBER 0-60,  OFFSET BY 1 OCTAVE */             IF NEW.NOTE.LIST(0)<LIST.SIZE THEN DO;    /* ADD TO LIST */                NEW.NOTE.LIST(0)=NEW.NOTE.LIST(0)+1;                NEW.NOTE.KEY#(NEW.NOTE.LIST(0))=L;     /* STORE KEY NUMBER */                IF (J&BIT.TABLE(K))=0 THEN DO;              /* NEW KEY - SET TO MAX VELOCITY FOR OLD KEYBOARD - NOTE NEGATIVE LOGIC OF OLD HARDWARE */                   NEW.NOTE.LIST(NEW.NOTE.LIST(0))=1;  /* CODE FOR NEW NOTE */                   NEW.NOTE.VEL(NEW.NOTE.LIST(0))=0;   /* INDICATE 0 TRANSIT TIME (MAX VOLUME) */                END;                ELSE DO;                               /* HANDLE KEY RELEASE */                  NEW.NOTE.LIST(NEW.NOTE.LIST(0))=2;   /* CODE FOR NOTE RELEASE */                END;                OLD.BITS(I)=OLD.BITS(I) XOR BIT.TABLE(K); /* TOGGLE BIT IN OLD REGISTER - DO IT THIS WAY TO SAVE BUTTON FOR NEXT TIME IN CASE OF STACK OVERFLOW */             END;          END;       END;    END;  END;  WRITE(D131)=I; /* AND OFF WITH READ */  WRITE(D131)="20"; /* SET UP EXTERNAL WRITE AGAIN */  WRITE(D131)="260"; /* START CONVERSION, SET UP EXTERNAL WRITE */END SCAN.NEW.NOTES;CLEAR.LIGHT:  PROC(LIGHT.NUM);      /* CLEARS A BUTTON - PASS PHYSICAL BUTTON NUMBER */   DCL LIGHT.NUM FIXED;END CLEAR.LIGHT;CLEAR.DISPLAY: PROC; END; /* NEEDED FOR COMPILATION */SCAN.ANALOG.INPUTS:  PROC; /* READ ANALOG INPUTS AND DIGITAL SWITCHES */   DCL I  FIXED;   DCL AD LIT '"163"'; /* AD CONVERTER    - OLD PANEL */   WRITE(AD)=2;    ANALOG.IN(0)=READ(AD); /* SELECT CONVERSION & READ VALUE */   WRITE(AD)=2+4;  ANALOG.IN(1)=READ(AD);   WRITE(AD)=2+8;  ANALOG.IN(2)=READ(AD);   WRITE(AD)=2+12; ANALOG.IN(3)=READ(AD);   WRITE(AD)=2+16; ANALOG.IN(4)=READ(AD);   WRITE(AD)=3; /* INITIATE NEXT ADC CONVERSION CYCLE */END SCAN.ANALOG.INPUTS;SCAN.PRESSURE:PROC(A);   DCL (A) FIXED;   STOP(3);END SCAN.PRESSURE;