/* 21-EXTCT  $TITLE  Process Extract Command (also handles Quantization) *//* Copyright 1985 by New England Digital Corporation */extract_times:proc(head,tail,start,stop) fixed; /* extract waveform between START and STOP */   dcl head  fixed array; /* attack ramp length (time) */   dcl tail  fixed array; /* decay  ramp length (time) */   dcl start fixed array; /* time to finish attack     */   dcl stop  fixed array; /* time to start  decay      */      /* temporary vectors to hold sector,offset values of times */   dcl a(2)       fixed; /* first point of trapezoid (start of attack ramp) */   dcl b(2)       fixed; /* end   of attack ramp */   dcl c(2)       fixed; /* start of decay  ramp */   dcl d(2)       fixed; /* last  point of trapezoid (end   of decay  ramp) */    dcl (temp,temp1,temp2) (2) fixed;   extract:proc(a,b,c,d) fixed; /* extract waveform, with trapezoidal window multiplier */      /* a=start attack ramp, b=top of ramp, c=begin decay ramp, d=end decay */      /*      TRAPEZOIDAL WINDOW                   .........................                       .                            .              .                                 .            .                                      .      ____.___________________________________________.____          A       B                       C           D        */      dcl (a,b,c,d)  fixed array; /* sectormsb, sectorlsb, offset */      dcl valid      fixed; /* end of usable data in input buffer */      dcl origin(2)  fixed; /* sector count in originating file */      dcl dest  (2)  fixed; /* sector count in destination file */      dcl length(2)  fixed;      dcl limit      fixed;      dcl (mask,roundbit)                     fixed; /* quantization vars */      dcl (attack.ramp,decay.ramp) (2)        fixed; /* lengths of ramps */      dcl (attack.ptr, decay.ptr )            fixed; /* location on ramp */      dcl (attack.ramp.msb,attack.ramp.lsb)   fixed;      dcl attack.ramp.rem                     fixed;      dcl (attack.samps.msb,attack.samps.lsb) fixed;      dcl (attack.accum.msb,attack.accum.lsb) fixed;      dcl (decay.ramp.msb,decay.ramp.lsb)     fixed;      dcl decay.ramp.rem                      fixed;      dcl (decay.samps.msb,decay.samps.lsb)   fixed;      dcl (decay.accum.msb,decay.accum.lsb)   fixed;      dcl time.for.decr                       fixed;      dcl (msb,lsb)                           fixed;      dcl (i,j,k)                             fixed;      file2;          call copy_vector(dest,location(f.data.index),3); /* point to file base */      file1;      /* compute attack ramp variable values here */      call sub_len_from_len(b,a,attack.ramp); /* find length of attack ramp */      attack.ptr=0; /* will go from 0 to 65535 */      i=shr(attack.ramp(1),8); /* upper 16 bits */      j=shl(attack.ramp(1)&"377",8)+attack.ramp(2); /* lower 16 bits */      write(5)=j; write(4)=i; write(7)=65535;      attack.ramp.msb=read(5); attack.ramp.rem=read(4);      write(5)=0; write(4)=attack.ramp.rem; write(7)=65535;      attack.ramp.lsb=read(5);      if read(4) IGE shr(65535,1) then attack.ramp.lsb=attack.ramp.lsb+1;      attack.accum.msb=0; attack.accum.lsb=0;      /* compute decay ramp variable values here */      call sub_len_from_len(d,c,decay.ramp); /* find length of decay ramp */      decay.ptr=65535; /* will go from 65535 to 0 */      i=shr(decay.ramp(1),8); /* upper 16 bits */      j=shl(decay.ramp(1)&"377",8)+decay.ramp(2); /* lower 16 bits */      write(5)=j; write(4)=i; write(7)=65535;      decay.ramp.msb=read(5); decay.ramp.rem=read(4);      write(5)=0; write(4)=decay.ramp.rem; write(7)=65535;      decay.ramp.lsb=read(5);      if read(4) IGE shr(65535,1) then decay.ramp.lsb=decay.ramp.lsb+1;      decay.accum.msb=0; decay.accum.lsb=0;      call copy_vector(origin,a,3); /* copy a to origin */      do while compare_vectors(d,origin,3)>=0; /* loop while data to extract */         call sub_len_from_len(d,origin,length); /* compute length left */         call add_len_to_len(zero.zero.one,length,length);         /* limit length of read to buffer size, leaving two sectors for fractional amounts */         if length(1)>buf1.len-2 then length(1)=buf1.len-2; /* limit length */         if length(1)>0 then do; /* not at end */            length(2)=0; /* limit to even sectors */            valid=length(1)*sector.size; /* compute actual number of points */         end;         else valid=length(2); /* special case for end */         call add_len_to_addr(origin,location(f.data.index),temp); /* add file base */         call readdata(temp(0),temp(1),databuf1,valid+origin(2)); /* do the read */         /* compute range of buffer which is in attack region */         if sub_len_from_len(a,origin,temp1) then do; /* start of attack */            temp1(0)=0; temp1(1)=0; temp1(2)=0;            error.flag=0; /* clear overflow */         end;         if sub_len_from_len(b,origin,temp2) then do; /* end of attack */            temp2(0)=0; temp2(1)=0; temp2(2)=0;            error.flag=0; /* clear overflow */         end;         if compare_vectors(temp2,length,3)>0 then call copy_vector(temp2,length,3);         temp(0)=0; temp(1)=0; temp(2)=origin(2); /* put offset into vector format */         if compare_vectors(temp1,length,3)<=0 then do; /* perform attack */            call add_len_to_len(temp,temp1,temp1); /* add in fractional offset */            call add_len_to_len(temp,temp2,temp2); /* add in fractional offset */            do i=temp1(1)*sector.size+temp1(2) to temp2(1)*sector.size+temp2(2)-1; /* loop over points in attack region */               j=databuf1(i); /* get value */               if j>=0 then write(5)=(+j); /* write abs value */               else         write(5)=(-j);               write(6)=attack.ptr; /* perform scaling */               k=read(5);               write(7)=65535;               if j>=0 then k= read(5); /* read result and restore sign */               else         k=-read(5);               if read(4) IGT shr(65535,1) then k=k+1; /* round */               databuf1(i)=k; /* store value back in buffer */               if attack.ptr ILT 65535 then do; /* now update ramp variables */                  attack.accum.msb=attack.accum.msb+1;                  time.for.decr=0;                  if        attack.accum.msb IGT attack.ramp.msb  then time.for.decr=1;                  else if  (attack.accum.msb  =  attack.ramp.msb)                        and (attack.accum.lsb IGE attack.ramp.lsb) then time.for.decr=1;                  do while time.for.decr and (attack.ptr ILT 65535);                     if        attack.accum.msb ILT attack.ramp.msb  then time.for.decr=0;                     else if  (attack.accum.msb  =  attack.ramp.msb)                           and (attack.accum.lsb ILT attack.ramp.lsb) then time.for.decr=0;                     if time.for.decr then do; /* incr attack ptr */                        begin;                           dcl omsb  lit 'msb';              dcl olsb  lit 'lsb';                           dcl imsb1 lit 'attack.accum.msb'; dcl ilsb1 lit 'attack.accum.lsb';                           dcl imsb2 lit 'attack.ramp.msb';  dcl ilsb2 lit 'attack.ramp.lsb';                           subtract;                           attack.accum.msb=msb; attack.accum.lsb=lsb;                        end;                        attack.ptr=attack.ptr+1;                     end;                  end;               end; /* of update ramp variables */            end; /* of loop over points in attack region */         end; /* perform attack */         /* compute range of points in decay region */         if sub_len_from_len(c,origin,temp1) then do; /* start of decay */            temp1(0)=0; temp1(1)=0; temp1(2)=0;            error.flag=0; /* clear overflow */         end;         else call add_len_to_len(zero.zero.one,temp1,temp1);         if sub_len_from_len(d,origin,temp2) then do; /* end of decay */            temp2(0)=0; temp2(1)=0; temp2(2)=0;            error.flag=0; /* clear overflow */         end;         else call add_len_to_len(zero.zero.one,temp2,temp2);         if compare_vectors(temp2,length,3)>0 then call copy_vector(temp2,length,3);         if compare_vectors(temp1,length,3)<=0 then do; /* perform decay */            call add_len_to_len(temp,temp1,temp1); /* add in fractional offset */            call add_len_to_len(temp,temp2,temp2); /* add in fractional offset */            do i=temp1(1)*sector.size+temp1(2) to temp2(1)*sector.size+temp2(2)-1; /* loop over points in decay region */               j=databuf1(i); /* get value */               if j>=0 then write(5)=(+j); /* write abs value */               else         write(5)=(-j);               write(6)=decay.ptr; /* perform scaling */               k=read(5);               write(7)=65535;               if j>=0 then k= read(5); /* read result and restore sign */               else         k=-read(5);               if read(4) IGT shr(65535,1) then k=k+1; /* round */               databuf1(i)=k; /* store value back in buffer */               if decay.ptr IGT 0 then do; /* now update ramp variables */                  decay.accum.msb=decay.accum.msb+1;                  time.for.decr=0;                  if        decay.accum.msb IGT decay.ramp.msb  then time.for.decr=1;                  else if  (decay.accum.msb  =  decay.ramp.msb)                        and (decay.accum.lsb IGE decay.ramp.lsb) then time.for.decr=1;                  do while time.for.decr and (decay.ptr IGT 0);                     if        decay.accum.msb ILT decay.ramp.msb  then time.for.decr=0;                     else if  (decay.accum.msb  =  decay.ramp.msb)                           and (decay.accum.lsb ILT decay.ramp.lsb) then time.for.decr=0;                     if time.for.decr then do; /* incr decay ptr */                        begin;                           dcl omsb  lit 'msb';             dcl olsb  lit 'lsb';                           dcl imsb1 lit 'decay.accum.msb'; dcl ilsb1 lit 'decay.accum.lsb';                           dcl imsb2 lit 'decay.ramp.msb';  dcl ilsb2 lit 'decay.ramp.lsb';                           subtract;                           decay.accum.msb=msb; decay.accum.lsb=lsb;                        end;                        decay.ptr=decay.ptr-1;                     end;                  end;               end; /* of update ramp variables */            end; /* of loop over points in decay region */         end; /* of perform decay */         if (bits>0) and (bits<16) then do; /* must apply quantization */            roundbit = shl( 1,15-bits);            mask     = shl(-1,16-bits);            do i = origin(2) to origin(2)+valid-1;               databuf1(i) = (databuf1(i) /* + roundbit */) & mask;            end;         end; /* of apply quantization */         call writedata(dest(0),dest(1),location(addr(databuf1(origin(2)))),valid); /* write it out */         call add_len_to_len(length,origin,origin); /* update origin */         call add_len_to_addr(length,dest,dest);    /* update dest   */      end; /* of loop while there is data */   end extract;   /* $SUBTITLE  Main Code for Extract */   if (start(0)<0) or (stop(0)<0) then do; /* check for times out of range */      error.flag=e.times;      return 1;   end;   /* compute the 4 points of the trapezoid, truncate at origin and end of original waveform */    call time_to_index(head, a,period.index); /* convert to sector indices */   call time_to_index(tail, d,period.index);   call time_to_index(start,b,period.index);   call time_to_index(stop, c,period.index);      if (compare_vectors(c,b,3)<0) /* if c<b */   or (compare_vectors(c,location(valid.data),3)>0) then do; /* if c>file.end */      error.flag=e.times; /* invalid times */      return 1;   end;   if compare_vectors(a,b,3)>0 then call copy_vector(a,b,3); /* limit attack time */   call sub_len_from_len(b,a,a); /* compute attack start */   call add_Len_to_len(c,d,d);   /* compute decay end */   if compare_vectors(d,location(valid.data),3)>0 /* limit decay end */   then call copy_vector(d,location(valid.data),3);   file2; /* select .DATA */   call sub_len_from_len(d,a,temp); /* compute total length of result */   call add_len_to_len(zero.zero.one,temp,temp); /* add one more sample to len */   if new_file(temp) then do; /* create file to hold result */      /* error -- could not create new file */      call file(1,0); /* restore to FCB #1 */      return 1;   end;   call copy_vector(location(valid.data),temp,3); /* store total number of samples */   clear; /* tell user to wait */   call pos(5,1); psr('Please wait');   call extract(a,b,c,d); /* perform it */   file1;   temp1(0)=file.data.type; /* pick up data from file 1 */   temp1(1)=period.index;   temp1(2)=nyquist.freq;   temp2(0)=core(octave);   temp2(1)=core(octave+1);   file2;   file.data.type=temp1(0)\extracted.data; /* store data on file 2 */   period.index  =temp1(1);   nyquist.freq  =temp1(2);   core(octave)  =temp2(0); core(octave+1)=temp2(1);   /* convert index of last sample to time at last sample */   call copy_vector(location(data.end),location(valid.data),3);    call sub_len_from_len(location(data.end),zero.zero.one,temp); /* subtract one from data.end */   call index_to_time(location(data.end),temp,period.index);   call caption_assign('Extracted data');   call add_symbol(zero.vector,       'Origin'); /* set up basic symbols */   call add_symbol(location(data.end),'End'   );   call copy_vector(mark.start,zero.vector,       3);   call copy_vector(mark.end,  location(data.end),3);   call sub_len_from_len(b,a,temp); /* add symbols at envelope points */   call index_to_time(temp,temp,period.index);   call add_symbol(temp,'P1');   call sub_len_from_len(c,a,temp);   call index_to_time(temp,temp,period.index);   call add_symbol(temp,'P2');      if (error.flag=e.dup.loc) or (error.flag=e.location) then error.flag=0; /* suppress error message */   return 0; /* OK */end extract_times;