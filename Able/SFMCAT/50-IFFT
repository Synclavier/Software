/* 50-IFFT  $TITLE  Main Module for Plotting of Spectra *//* Copyright 1985 by New England Digital Corporation */dcl current.fft.len      fixed; /* value of fft.len    when last spectrum calculated */dcl current.window.num   fixed; /* value of window.num when last spectrum calculated */dcl current.length       fixed; /* length of window to use */dcl current.time(2)      fixed; /* base time of window */dcl spectral.cursor.mode fixed; /* 0=disable; 1=linear mode; 2=log mode */dcl spectral.cursor      fixed; /* fft bin number */dcl spectral.factor      floating; /* spectral scaling factor */dcl freq.infox           fixed; /* screen coordinates for frequency */dcl freq.infoy           fixed; /* screen coordinates for frequency */dcl cursor.flag          fixed; /* controls writing of info in box */dcl scale1               floating; dcl bandlimit            fixed; /* fft bin corresponding to nyquist freq */dcl lowlimit             fixed; /* fft bin at left  of plot */dcl highlimit            fixed; /* fft bin at right of plot */dcl hzlimit              floating; /* Hz corresponding to nyquist freq */dcl caption(128)         fixed; /* current caption */dcl sound.file.name(4)   fixed; /* name of sound file */dcl current.window.type  fixed;dcl harmonic.cursor      fixed; /* if true, mark harmonics of cursor position */dcl integral             floating; dcl integrate.on         fixed;dcl integral.origin      fixed;compute_limits:proc(spec.scalex); /* computes limits for scaling spectrum */    dcl spec.scalex floating array; /* spectrum passed in */    dcl origin      fixed;    dcl range       fixed;    dcl (band,fp)   floating;         band=current.fft.len*0.5;  /* fft index corresponding to nyquist freq  */    fp=spectral.origin*1000.; /* in Hz */    if fp>hzlimit then fp=hzlimit;    lowlimit=int(fp*band/hzlimit+0.5);    fp=fp+spectral.range*1000.;    if fp<0       then fp=0;    if fp>hzlimit then fp=hzlimit;    highlimit=int(fp*band/hzlimit+0.5);    bandlimit=int(band+0.5);    scale1=10000./spec.scalex(0); /* scale by first point in spectrum */end compute_limits;clip_spectrum:proc(y,mode) floating; /* returns scaled and clipped coordinate */   dcl y    floating;    dcl mode fixed;   if mode=1 then do; /* log density */      if y<=0.0 then y=(-15.0*1000);      else           y=1000.*log10(y*scale1);      if y<(-15.0*1000.) then y=(-15.0*1000);   end;      else if mode=0 then do; /* linear */      y=y*scale1;      if y>10000. then y=10000.;   end;       else do; /* magnitude */      y=y*scale1*10000.;      if y>(10000.*10000.) then y=(10000.*10000.);      y=sqr(y);   end;   return y;end clip_spectrum;/* $SUBTITLE */harmonic_cursor:proc; /* writes the harmonic markers on spectrum */   /* routine assumes data_level=2 */   dcl (i,k) fixed;   if spectral.cursor>2 then do;      line_type(1); /* dotted */      i=2; /* count harmonics */      k=i*spectral.cursor; /* compute harmonic freq */      do while k<=highlimit;         if k>=lowlimit then connect(k,#window.limits(2),k,#window.limits(3));         i=i+1; /* next harmonic */         k=i*spectral.cursor;      end;      line_type(0); /* restore regular line */   end;end harmonic_cursor;write_cursor:proc(x,y,flag); /* writes the spectral cursor on spectrum */    dcl x          fixed;    dcl y          floating;    dcl flag       fixed; /* bit 0 true to print box, bit 1 true to write cursor */    dcl fl         floating;    dcl fx         fixed;    dcl format     data ('-#.####^^^^^');    dcl scale      floating;    dcl string(10) fixed; /* for "E" format conversion */    if (x<0) or (x>bandlimit) then return; /* out of spectrum range */    vector_mode;    data_level(2);        if (flag&2)<>0 then do; /* must write cursor */       if (x<=highlimit) and (x>=lowlimit) then do; /* put cursor on plot */          connect(x,#window.limits(2),x,#window.limits(3));          fx=#converty(int(clip_spectrum(y,spectral.cursor.mode-1)));          call #move(#lastx-6, fx);           call #draw(#lastx+12,fx);       end;         if harmonic.cursor then call harmonic_cursor;    end; /* of must write cursor */    if flag then do; /* draw box and fill with values */       /* print cursor frequency */       vector_mode; call #transmit_coords(freq.infox+100+dq640*25,freq.infoy+48);       alpha_mode;       fl=x*clock.rate*1000./current.fft.len/period.index; /* compute cursor freq */       call fprint(fl,5,4);        /* print cursor pitch class number */       vector_mode; call #transmit_coords(freq.infox+200+dq640*50,freq.infoy+48);        ps('('); call fprint(freq_to_pitch(fl),2,4); ps(')');        /* print default spectral scale */       vector_mode; call #transmit_coords(freq.infox+2,freq.infoy+18);       ps(' 1.0');       /* print absolute log density in F format */       vector_mode; call #transmit_coords(freq.infox+90+dq640*23,freq.infoy+18);       alpha_mode;       call fprint(10.*log10(y),3,2);       /* print absolute linear density in E format */       vector_mode; call #transmit_coords(freq.infox+160+dq640*40,freq.infoy+18);       alpha_mode;       call num.to.str(y,string,format);       ps(string);       /* print absolute magnitude in E format */       vector_mode; call #transmit_coords(freq.infox+275+dq640*69,freq.infoy+18);       alpha_mode;       call num.to.str(sqr(y),string,format);       ps(string);       /* $PAGE */       /* print spectral scale in E format */       vector_mode; call #transmit_coords(freq.infox+2,freq.infoy+6);       alpha_mode;       scale=scale1/10000.;       call num.to.str(1./scale,string,format);       ps(string);       /* print log density (db) relative to spectral scale in F format */       vector_mode; call #transmit_coords(freq.infox+90+dq640*23,freq.infoy+6);       alpha_mode;       call fprint(clip_spectrum(y,1)/100.-40.,3,2);       /* print linear density relative to spectral scale in E format */       vector_mode; call #transmit_coords(freq.infox+160+dq640*40,freq.infoy+6);       y=y*scale;       call num.to.str(y,string,format);       alpha_mode;       ps(string);       /* print magnitude relative to spectral scale in E format */       vector_mode; call #transmit_coords(freq.infox+275+dq640*69,freq.infoy+6);       call num.to.str(sqr(y),string,format);       alpha_mode;       ps(string);    end; /* of draw and fill box */        data_level(0);    transparent_mode;end write_cursor;toggle_harmonic:proc(sum); /* turns on or off the harmonic markers */   dcl sum floating array; /* holds average spectrum values */   call write_cursor(spectral.cursor,sum(spectral.cursor),2); /* erase current cursor */   harmonic.cursor=not harmonic.cursor; /* toggle switch */   call write_cursor(spectral.cursor,sum(spectral.cursor),2); /* redraw with harmonic line type */   pfkey=0;end toggle_harmonic;move_freq:proc(sum); /* move cursor in frequency */   dcl sum floating array; /* holds average spectrum values */   if display.type<>spectral.display /* no spectrum on screen */   or spectral.cursor.mode=0 then return; /* no cursor defined */   call write_cursor(spectral.cursor,sum(spectral.cursor),cursor.flag\2); /* erase current one */   cursor.flag=0;   if spectral.cursor<lowlimit  then spectral.cursor=lowlimit -1;   if spectral.cursor>highlimit then spectral.cursor=highlimit+1;   disable;   spectral.cursor=spectral.cursor+rl.arrow*arrow.count; /* update cursor */   enable;   if spectral.cursor<lowlimit  then spectral.cursor=lowlimit -1;   if spectral.cursor>highlimit then spectral.cursor=highlimit+1;   call write_cursor(spectral.cursor,sum(spectral.cursor),2); /* write new one */   rl.arrow=0;  end move_freq;max: proc(x,y); /* return greater of two */   dcl (x,y) fixed;   if x>y then return (x);   else        return (y);end max;min: proc(x,y); /* return smaller of two */   dcl (x,y) fixed;   if x<y then return(x);   else        return(y);end min;/* $SUBTITLE */compute_u:proc floating; /* window energy normalization factor */   dcl u            floating;   dcl (i,u1,u2,u3) fixed;   if current.window.type=0 then return current.length;   u1=0; u2=0; u3=0;   do i=0 to current.length-1; /* loop over points */      write(5)=0; write(4)=i;      write(7)=current.length;      call angle(read(5));            if current.window.type=1 then do; /* hanning */         cosine=32767-cosine; /* a positive number <65536 */      end;      else do; /* hamming */         write(5)=cosine;         write(6)=60293;         if cosine<0 then cosine=read(4)-60293;         else             cosine=read(4);         cosine=35389-cosine;      end;      write(5)=cosine; write(6)=cosine;      u2=u2+read(4);      if u2 ILT read(4) then u1=u1+1;      u3=u3+read(5);      if u3 ILT read(5) then do;         u2=u2+1;         if u2=0 then u1=u1+1;      end;   end; /* end of loop over points */   u=u2+u3/65536.;   if u3<0 then u=u+1.;   u=u1+u/65536.;   if u2<0 then u=u+1.;   return u;   end compute_u;/* $SUBTITLE */square:proc(b,blsb); /* squares complex elements */  dcl b           fixed array;  dcl blsb        fixed array;  dcl (i,msb,lsb) fixed;  dcl (real,imag) fixed;  dcl (tmsb,tlsb) fixed;  do i=0 to fft.len/2; /* loop over points up to nyquist */    real=shl(i,1); imag=real+1;    if b(real)<0 then do;       b(real)=-b(real);       if blsb(real)<>0 then b(real)=b(real)-1;       blsb(real)=-blsb(real);    end;    write(5)=b(real);    write(6)=b(real);    msb=read(4);    lsb=read(5);    write(5)=b(real);    write(6)=blsb(real);    lsb=lsb+read(4);    if lsb ilt read(4) then msb=msb+1;    lsb=lsb+read(4);    if lsb ilt read(4) then msb=msb+1;    if b(imag)<0 then do;       b(imag)=-b(imag);       if blsb(imag)<>0 then b(imag)=b(imag)-1;       blsb(imag)=-blsb(imag);    end;    write(5)=b(imag);    write(6)=b(imag);    msb=msb+read(4);    lsb=lsb+read(5);    if lsb ilt read(5) then msb=msb+1;    write(5)=b(imag);    write(6)=blsb(imag);    lsb=lsb+read(4);    if lsb ilt read(4) then msb=msb+1;    lsb=lsb+read(4);    if lsb ilt read(4) then msb=msb+1;    b(i)=msb; blsb(i)=lsb;  end; /* of loop over points */end square;  finish:proc(plot.av,sum); /* clean up after computing spectra */   dcl plot.av fixed;   dcl sum     floating array;   dcl fp      floating;   dcl i       fixed;   if current.window.num=1 then spectral.cursor.mode=1+log.mode;   else do;      spectral.cursor.mode=0;      if  (current.window.num>0)      and (error.flag=0) then error.flag=s.average.ready;   end;   integral=0.;   integrate.on=0;   cursor.flag=0;   if plot.av then call write_cursor(spectral.cursor,sum(spectral.cursor),2);   else do; /* adjust the spectral sum */      fp=1./current.window.num;       if current.window.num>1 then do i=0 to bandlimit; /* normalize spectrum average */         sum(i)=fp*sum(i);       end;      spectral.cursor=-1;   end;   transparent_mode;end finish;/* $SUBTITLE  Main Spectrum Computation and Display Routine */anal_data:proc(window.num,sum,plot.av);   dcl window.num  fixed; /* number of spectra */   dcl sum         floating array;   dcl plot.av     fixed; /* true to plot only precomputed average spectrum */   dcl (index,ihz) fixed;   dcl increment   fixed; /* freq scale tick mark increment */   dcl temp(2)     fixed; /* temporaries for computing times */   dcl spec.scale  floating;   dcl fp          floating; /* temporary loc */   dcl (i,j,k)     fixed;   dcl left             fixed;   dcl right            fixed;   dcl (xdisp, ydisp)   fixed; /* punit shift values used to get "perspective" effect */   dcl composite.w(800) fixed; /* array to hold "horizon" image - composite waveform */   dcl plot.range       fixed; /* plottable punit X range  (+1 for line draw convention) */   dcl start            fixed; /* where in virtual screen units, does this wave start? */   dcl height    lit '100'; /* punit vertical height for spectrum */   dcl top       lit '308';   dcl bottom    lit '62';   dcl dbottom   lit '50';   dcl max.X.res lit '(640+160*dq640-1)'; /* (640-1)  for 0 to 639 format */   dcl zx.offset lit '140'; /* each wave shifts in X and Y to simulate Z */   dcl zy.offset lit '(top-bottom)';   compute.spec:proc(specnum,start.ind); /* computes one spectrum */      dcl specnum   fixed; /* how many window offsets from cursor to compute spec */      dcl start.ind fixed array; /* returned index vector of start sample of spectrum */      dcl temp2(2)  fixed;       /* compute the starting sector for this window */      write(5)=specnum;       write(6)=window.offset;      start.ind(0)=shr(read(4),8); /* load product into 48-bit index vector */      start.ind(1)=shr(read(5),8)+shl(read(4),8);      start.ind(2)=read(5)&255;      call time_to_index(current.time,temp2,period.index); /* index vector of starting sample */      call add_len_to_len(temp2,start.ind,start.ind); /* index vector for start of this window */      temp2(0)=0; temp2(1)=0; temp2(2)=current.length;       call add_len_to_len(start.ind,temp2,temp2);     /* index vector for end   of this window */       if compare_vectors(temp2,location(valid.data),3)>0 then do; /* beyond end of file */         error.flag=e.window;         current.window.num=j; /* number of successful spectrum computations */         call finish(plot.av,sum);         return 1;      end;            call add_len_to_addr(start.ind,location(f.data.index),temp2); /* starting sector */      if temp2(2)>0 then do;        call readdata(temp2(0),temp2(1),databuf1,current.length+sector.size);           do i=0 to current.length-1; databuf1(i)=databuf1(i+temp2(2)); end; /* move down array */      end;        else call readdata(temp2(0),temp2(1),databuf1,current.length);       call data_window(databuf1,lsb1,fft.len,current.window.type,current.length); /* apply window */      rescale=0;      call normalize1(databuf1,lsb1,fft.len,15); /* normalize windowed data */      DISABLE;      call ifast(databuf1,lsb1,fft.len);      ENABLE;      call normalize1(databuf1,lsb1,fft.len+1,15); /* normalize fft results */      rescale=2*rescale;      call square(databuf1,lsb1); /* square elements, gives mag and phase */   end compute.spec;   /* $PAGE */   left = 100+dq640*100;  right = left+410;   if window.num>0 then do; left = left+10; right = right+10; end;       ydisp = zy.offset/window.num;   xdisp = zx.offset/window.num;   plot.range = (right-left+1);   if plot.av and (current.window.num=0) then return; /* no ave spectrum to plot */   call copy_vector(location(addr(spec.scale)),spectral.scale,2);   display.type=spectral.display;   clear;   vector_mode;   call #transmit_coords(0,407);   char_size(1);   if plot.av and (current.window.num>1) then do;      ps('Average of '); pnum(current.window.num); ps(' Spectra');   end;     else ps('Spectral Display');      char_size(0);   vector_mode;   if dq640 then call #transmit_coords(580-5*caption(0),407); /* center */   else call #transmit_coords(464-4*caption(0),407); /* center */   ps(caption);   if not plot.av then do; /* not plotting average spectrum */      do i = 0 to max.X.res;          composite.w(i) = dbottom; /* init horizon line to lowest viewport */      end;      do i=0 to fft.len/2-1; sum(i)=0; end; /* zero out fft average */   end;   call compute_limits(spectral.scale);   ihz=int(hzlimit+.5);   if      spectral.range>10 then increment=2000;   else if spectral.range>5  then increment=1000;   else if spectral.range>1  then increment=500;   else                           increment=100;   /* $PAGE */   if window.num=1 then do; /* single spectrum case */      viewport(8+dq640*2,8+218+dq640*56, top+31,top+31+60); /* draw box to hold spectrum parameters */      window(0,218,0,60); /* I didn't adjust x for dq640 here and left move_to's as is */      border;      /* fill box with parameters */      alpha_mode;      move_to(5,42);   ps('File:');       move_to(67,42);  ps(sound.file.name);      move_to(5,30);   ps('Time:');      move_to(67,30);  call print_time(current.time,3,1);      move_to(184,30); ps('Sec.');      move_to(5,18);   ps('Window:');      temp(0)=0; temp(1)=0; temp(2)=current.length;      call index_to_time(temp,temp,period.index);      move_to(67,18);  call print_time(temp,3,1);      move_to(184,18); ps('Sec.');      move_to(67,6);      do case current.window.type;         ps('Boxcar');         ps('Hanning');         ps('Hamming');      end;      viewport(260+dq640*65,#px,top+31,top+31+60); /* draw box for cursor info */      window(0,379,0,60);      border;      /* initialize cursor box info */      move_to(0,0); freq.infox=#lastx; freq.infoy=#lasty;      move_to(2,48);   ps('Frequency');      move_to(2,30);   ps('Norm.');      move_to(90,30);  ps('  db');      move_to(160,30); ps('Density');      move_to(275,30); ps('Magnitude');      /* label Y-axis */      vector_mode;      window  (0,#px,0,#py);      viewport(0,#px,0,#py);      move_to(25+dq640*100,top-31);      if log.mode=1 then do;         move_to(25*dq640*100,top);         call print_vertical('Log Spectral Density');      end;      else if log.mode=0 then call print_vertical('Spectral Density');      else                    call print_vertical('Magnitude');      /* label X-axis */      move_to(250+dq640*63,bottom-31);      ps('Frequency in ');      if increment>=1000 then ps('kHz');      else                    ps('Hz');      transparent_mode; /* in case we exit next */   end; /* of single spectra case */   /* $PAGE */   else do; /* multiple spectra case */      viewport(8+dq640*2,170+dq640*43, top-20,top+85); /* draw box for spectrum parameters */      window(0,162, 0,105);      border;      /* fill in spectrum parameters */      move_to(2,90);  ps('File:');       move_to(67,90); ps(sound.file.name);      move_to(2,75);  ps('Time:');      move_to(67,75); call print_time(current.time,3,1);      move_to(2,60);  ps('Window:');      temp(0)=0; temp(1)=0; temp(2)=current.length;      call index_to_time(temp,temp,period.index);      move_to(67,60); call print_time(temp,3,1);      move_to(67+16,45);      do case current.window.type;         ps('Boxcar');         ps('Hanning');         ps('Hamming');      end;      move_to(2,30);  ps('Offset:');      temp(0)=0; temp(1)=0; temp(2)=window.offset;      call index_to_time(temp,temp,period.index);      move_to(67,30); call print_time(temp,3,1);      move_to(2,15);  ps('Scale:');      move_to(67,15); ps(' '); call fprint(spec.scale,1,6);      /* label Y-axis */      vector_mode;      window  (0,#px,0,#py);      viewport(0,640 /* #px */,0,#py);      move_to( 25, top-50);      if      log.mode=1 then call print_vertical('Log Spectral Density');      else if log.mode=0 then call print_vertical('Spectral Density');      else                    call print_vertical('Magnitude');      /* label X-axis */      move_to((left-(zx.offset/2)+200), bottom-45); ps('Frequency in ');      if increment>=1000 then ps('kHz');      else                    ps('Hz');      transparent_mode; /* in case we exit next */   end; /* of multiple spectra case */   /* $PAGE */   if window.num=1 then viewport(left,right,bottom,top);   else do; /* multiple spectra */      start=left-window.num*xdisp/2-dq640*100; /* (undo the addition if dq640) */      viewport(start, start+plot.range-1,dbottom,height+dbottom);   end;     /* draw x axis and label kHz */   i=(spectral.origin+spectral.range)*1000;   if i igt ihz then i=ihz;   window (spectral.origin*1000,i,0,100);   connect(spectral.origin*1000,0,i,0  );   do i=0 to ihz by increment; /* loop over Hz and draw tick marks and freq values */      k=i;      if not #move_to(k,0) then do;         call #transmit_coords(#lastx,#lasty-8);         vector_mode;         call #transmit_coords(#lastx-3,#lasty-18);         alpha_mode;         if increment>=1000 then pnum(i/1000);         else                    pnum(i);      end;   end; /* of loop over Hz and draw tick marks and freq values */      /* draw Y-axis and label units */   window (0,20,0,100);   connect(0, 0,0,100);   call #transmit_coords(#lastx,  #lasty+10); /* NOTE:  #lastx,y not reset with calls to #xmit_coords */   call #transmit_coords(#lastx-4,#lasty+4);   vector_mode;   call #transmit_coords(#lastx+4,#lasty+4);   call #transmit_coords(#lastx,  #lasty+10);      increment=10;   fp=10.*log10(spec.scale);   do i=0 to 100 by increment; /* loop over scale units and draw tick marks and units */      move_to(0,i);      call #transmit_coords(#lastx-3,#lasty);      vector_mode;        if window.num=1 then do; /* must add label */         call #transmit_coords(#lastx-76,#lasty-5);         alpha_mode;          if log.mode=1 then do; /* log plot */           if (i mod 20)=0 then call fprint(fp-100.+i,3,2);         end; /* of log plot */         else do; /* linear plot */            if      i=0 then call fprint(0.,3,3);            else if i=100 then do;               if log.mode=0 then call fprint(spec.scale,1,6);               else               call fprint(sqr(spec.scale),1,6);            end;            else if (i mod 20)=0 then do;               if log.mode=0 then call fprint(i*spec.scale/100.,1,5);                else               call fprint(i*sqr(spec.scale)/100.,1,5);            end;          end; /* of linear plot */      end; /* of must add label */   end; /* of loop over scale units and draw tick marks and units */   /* $SUBTITLE  Main Loop Over Spectra */   do j=0 to window.num-1; /* loop over FFT's */      transparent_mode;      if not plot.av then do; /* compute one new spectrum */         if break.rcvd or (pfkey=2) then do; /* break received.  exit */            break.rcvd=0; /* reset it */            pfkey=0;            current.window.num=j;            call finish(plot.av,sum);            return 1; /* aborted */         end;         start = left+j*xdisp-window.num*xdisp/2-dq640*100; /* compute plot start point */         call compute.spec(j,temp); /* compute the jth spectrum */      end;   /* of compute one new spectrum */      if window.num>1 then viewport(start, start+plot.range-1, ydisp*j+dbottom, ydisp*j+height+dbottom);      if log.mode then window(lowlimit,highlimit,-6000,4000);       else             window(lowlimit,highlimit,0,10000);      if not plot.av then begin; /* not plotting average spectra */         dcl (x,lastx,newx) fixed;         dcl (y,lasty,newy) fixed;         dcl (below,count)  fixed;         dcl (fy,yy)        floating;                 spectral.factor=exp(log(2)*(rescale-12))/compute_u/current.length; /* full scale sine wave =1/spec.scale */         yy=0.; count=0;         move_to(lowlimit,int(clip_spectrum(0.,log.mode)));  /* initialize */         #lastx=#lastx-1;         below=1;         do i=0 to bandlimit; /* loop over FFT bins */            fy=spectral.factor*(databuf1(i)+lsb1(i)/65536.);            if lsb1(i)<0 then fy=fy+spectral.factor;            sum(i)=sum(i)+fy; /* accumulate average */            yy=yy+fy; count=count+1;            if (i>=lowlimit) and (i<=highlimit) then do; /* if bin is within plot limits */               if      window.num=1 then plot(i,int(clip_spectrum(sum(i),log.mode)));               else if count>0      then do; /* 3-D plot case */                  newx=#convertx(i);                  if (newx>#lastx) then do; /* average data within pixel */                     yy=yy/count;                      newy=#converty(int(clip_spectrum(yy,log.mode)));                     if newy<#view.limits(2) then newy=#view.limits(2); /* TEMPORARY - for 3d plot */                     yy=0; count=0;                     lasty=#lasty; lastx=#lastx;                     do x=lastx+1 to newx;                        y=lasty+(x-lastx)*(newy-lasty)/(newx-lastx);                        if y<composite.w(x) then do; /* point below horizon */                                   if not below then do;                              call #draw(x,composite.w(x)); /* 1 pixel gap */                              below=1;                           end;                          end; /* of point below horizon */                        else do; /* point above horizon */                           if below then do; /* previous point was below */                              call #move(x,composite.w(x)); /* start at horizon */                              below=0;                           end;                           composite.w(x)=y;                          call #draw(x,y);                      end; /* of point above horizon */                   end; /* do x= */                end;   /* if x>#lastx */             end; /* do 3d plot  */          end; /* of bin within plot limits */       end; /* of loop over FFT bins */     end; /* of not plot average */     /* $PAGE */     else do; /* plot previous average */        vector_mode;        do i=lowlimit to highlimit; /* loop through freq range */           plot(i,int(clip_spectrum(sum(i),log.mode)));           if break.rcvd or (pfkey>0) or (ud.arrow<>0) then do; /* stop */              break.rcvd=0;              call finish(plot.av,sum);              return 1; /* abort */           end;        end; /* of frequency loop */     end; /* of plot average */     if window.num>1 then begin; /* put in the time */        DCL ptime  fixed; /* switch to decide if it's time to print out the time */        if window.num>15 then ptime = j mod (window.num/8);        else                  ptime = j mod 2;        vector_mode;        if j<(window.num-1) then call #transmit_coords(#view.limits(1)+6+xdisp, #view.limits(2)+ydisp);        call #transmit_coords(#view.limits(1)+6, #view.limits(2));        if ptime=1 then call #transmit_coords(#view.limits(1)+12, #view.limits(2));        else            call #transmit_coords(#view.limits(1)+9, #view.limits(2));        vector_mode;        call #transmit_coords(#view.limits(1)+6, #view.limits(2)-5);        if ptime=1 then do; /* print the time value */           alpha_mode;           call index_to_time(temp,temp,period.index);           call print_time(temp,2,0);        end;     end; /* of put in the time */     transparent_mode;   end; /* of loop over FFT's */   if window.num>1 then do; /* label time axis */      dcl timet data ('Time in sec.');      dcl xfac  fixed; /* spacing control value */      if dq640 then right=right-100;      viewport(right-zx.offset/2, right+(zx.offset/2)+50, bottom, bottom+zy.offset);      window(0,100, 0,100);      xfac =(zx.offset*12)/(zy.offset); /* based on 8 by 10 chars;  spaced xfac by 12 */      if dq640 then xfac=xfac*5/4;      move_to(50+dq640*13, 1);      do i = 0 to timet(0)-1; /* loop over chars in label */         vector_mode;         call #transmit_coords(#lastx+(i*xfac),#lasty+(i*12));         alpha_mode;         call pc(byte(timet,i));      end;   end; /* of label time axis */      current.window.num=window.num;   call finish(plot.av,sum);end anal_data;/* $SUBTITLE */change_scale:proc; /* update spectral scale for pf key operations */   dcl hz fixed;   hz=int(hzlimit/1000.);   if pfkey=1 then return; /* ignore pf1 */   if pfkey=2 then do; /* renorm to current point */     if  (spectral.cursor.mode<>0)      and (spectral.cursor>=lowlimit) and (spectral.cursor<=highlimit) then do;        call copy_vector(spectral.scale,location(addr(databuf2(spectral.cursor))),2);     end;   end;   else if pfkey=3 then do; /* div range by 2 */      spectral.range=spectral.range/2;      if spectral.range<1 then spectral.range=1;   end;   else do; /* mul range by 2 */      spectral.range=spectral.range*2;      if                 spectral.range>hz then spectral.range =hz;      if spectral.origin+spectral.range>hz then spectral.origin=hz-spectral.range;   end;   pfkey=0;     call anal_data(1,databuf2,1);end change_scale;scroll_spectrum:proc; /* update spectrum display for arrow keys */  dcl hz fixed;    hz=int(hzlimit/1000.);    if      ud.arrow=1 then do;     spectral.origin=spectral.origin+spectral.range;     if (spectral.origin+spectral.range)>hz then spectral.origin=hz-spectral.range;  end;  else if ud.arrow=-1 then do;     spectral.origin=spectral.origin-spectral.range;     if spectral.origin<0 then spectral.origin=0;  end;  ud.arrow=0;  call anal_data(1,databuf2,1);end scroll_spectrum;