/* 10-SET  $TITLE  Parameter and Set Menu Update and Display Module *//* Copyright 1985 by New England Digital Corporation */dcl replot.flag fixed; /* indicates to replot time display if scale changes */dcl local       lit 'location(old.buf)';dcl localbytes  lit 'core(old.buf)';read_time:proc(time) fixed swap; /* parses and computes a time expression */   dcl name(4)  fixed;   dcl time     fixed array;   dcl temp1(2) fixed;   dcl (chr,i)  fixed;    get_time:proc(time) fixed; /* get one term of input */      dcl time fixed array;         if (chr>"140") and (chr<"173") then chr=chr-"40"; /* up the case */      if      chr=A.STAR   then do; /* term is * - use current time */         call copy_vector(time,cursor.time,3);         byte.ptr=byte.ptr+1;      end;      else if chr=A.SHARP then do; /* term is # - use play marker */         byte.ptr=byte.ptr+1;                          chr=byte(local,byte.ptr);         if      chr=a.0+1 then call copy_vector(time,mark.start,3);         else if chr=a.0+2 then call copy_vector(time,mark.end,3);         else do; error.flag=e.format; return 1; end; /* not #1 or #2 */         byte.ptr=byte.ptr+1;      end;         else if (chr>"100")&(chr<"133") then do; /* term is alphanumeric symbol */         call get_word(local,name,8);         chr=locate_index(name);                   if chr=0 then do; error.flag=e.no.name; return 1; end; /* not found */         chr=symbol_time(chr); /* find address of time */         if chr=0 then return 1; /* invalid */         call copy_vector(time,location(chr),3); /* use time */      end;          else if scan_number(local,time)<>0 then do; /* term is not numeric */         error.flag=e.format; return 1;      end;      return 0; /* got a term - returned in 'time' */   end get_time;      call strip_blanks(local); /* skip leading blanks */   if byte.ptr=localbytes then do; /* blank line */      call copy_vector(time,cursor.time,3); /* use cursor.time */      return 0;              end;   chr=byte(local,byte.ptr); /* get first char of first term */   if (chr=A.PLUS)    or (chr=A.MINUS) then call copy_vector(time,cursor.time,3); /* relative time */   else                  if get_time(time) then return 1; /* get first term */   call strip_blanks(local);   if byte.ptr=localbytes then return 0; /* expression ends */   chr=byte(local,byte.ptr); /* store next operator */   if (chr<>A.PLUS) and (chr<>A.MINUS) then return 0; /* expression ends here */   byte.ptr=byte.ptr+1;   if get_time(temp1) then return 1; /* get second term */   i=compute.best.period.index; /* use appropriate clock rate */   call time_to_index(time, time, i); /* convert each to samples */   call time_to_index(temp1,temp1,i);   if chr=A.PLUS  then if add_len_to_len  (time,temp1,temp1) then return 1; /* perform operation */   if chr=A.MINUS then if sub_len_from_len(time,temp1,temp1) then return 1;   call index_to_time(time,temp1,i); /* convert back to time */   return 0;end read_time;     get_command:proc(buf,command) swap; /* get command token, fill with blanks */   dcl buf     fixed array;   dcl command fixed array;   call get_word(buf,command,3);   do while command(0) < 4; /* fill with spaces out to 4 chars long */      call pbyte(command,command(0),A.SP);      command(0) = command(0) + 1;   end;end get_command;interpret_command:proc(command,codes,base) fixed swap; /* returns index number of 4 char string in code string */   dcl command  fixed array;   dcl codes    fixed array;   dcl base     fixed; /* command number for first list entry */   dcl i        fixed;   do i=1 to codes(0)/4;      if (command(1)=codes(2*i-1)) and (command(2)=codes(2*i)) then      return (base + i - 1); /* found */   end;   return 0; /* not in list */end interpret_command;v.scale:proc(min,max,arguments); /* set vertical scale for plotting */   dcl max          fixed array; /* max(0)=-scale.factor to scale factor, max(1)=0 to +-999 */                          dcl min          fixed array;   dcl arguments    fixed; /* number of time values scanned */   dcl (top,bottom) fixed;   if arguments=0 then do; top=32767; bottom=-32768; end; /* default */   else if arguments=1 then do; /* plus and minus one argurment */      top=convert_to_abs(min);      if top<0 then top=-top;      bottom=(-top);   end;       else do; /* two arguments */      top   =convert_to_abs(max);      bottom=convert_to_abs(min);      if #greater(bottom,top) then do; /* reverse if necessary */        bottom=top;        top   =convert_to_abs(min);      end;      end;      if #greater(bottom+64,top) then return; /* range must be at least 65 */   bottom.limit=bottom; /* update global vars */   top.limit   =top;              end v.scale;change_value:proc swap; /* process changes in parameters */  /* return true if a change is made.      set replot.flag if param of current display is changed. */  /* Type Codes:  1  integer                  2  another 3 letter code                    3  time value (sec, msec, usec)                  4  floating point number                  5  two time values - separated by word TO                  6  a time value to be converted into a number of samples   Names:  ATTack -  attack time for trapezoidal window in EXTRACT command        DECay  -  decay time  for trapezoidal window in EXTRACT command  NUMber of spectra in 3D spectral plot  LENgth of spectral window (time)  OFFset between spectral windows  MODe of spectral scale (lin or log)   SCAle of spectral factor  HORizontal scale of time display (msec)  VERtical scale of time display (volts)  RATe - sampling rate in KHz  GAIn - filter gain factor in db (in 3db steps)   FREquency of wave to create  AMPlitude of wave to create  PITch of sampled waveform   KEYboard decay    */  dcl codes1 data('ATT DEC NUM TYP LEN OFF MOD SCA HOR VER ');  dcl codes2 data('RAT GAI FRE AMP OCT KEY FFT PIT ORI RAN ');  dcl codes3 data('SEM VIB DEP VAT BIT ');  dcl types  data( 3,  3,  1,  2,  6,  6,  2,  4,  3,  5,                     4,  1,  4,  3,  4,  1,  1,  4,  1,  1,                   3,  3,  3,  3,  1);  dcl command(2)        fixed; /* holds command chars */  dcl (arguments,param) fixed;  dcl (num1,num2) (2)   fixed; /* holds arg values */  dcl fp                floating;  dcl i                 fixed;  call get_command(local,command); /* get and parse command */  param                =interpret_command(command,codes1,1);  if param=0 then param=interpret_command(command,codes2,11);  if param=0 then param=interpret_command(command,codes3,21);  arguments=0; /* assume no arguments */  if param<>0 then do case types(param-1); /* case to determine arg types */    ;  /* 0:  error */    if scan_number(local,num1)=0 then arguments=1; /* 1:  num1(0) will be the integer */    do; call get_command(local,command); arguments=1; end; /* 2:  get code */    if ^read_time(num1) then arguments=1;  /* 3:  get time value */    if scan_number(local,num1)=0 then do; /* 4:  floating point*/      arguments=1;      fp=num1(0)+num1(1)/1000.+num1(2)/1000000.;        end;      do; /* 5:  two numbers separated by "TO" */      if scan_number(local,num1)=0 then do;         arguments=1;         call get_command(local,command);         if interpret_command(command,'TO  ',1)=1 then             if scan_number(local,num2)=0 then arguments=2;      end;       end;    if ^read_time(num1) then do; /* 6:  get time value, convert to # of points */       arguments=1;       i=compute.best.period.index; /* use appropriate clock rate */       call time_to_index(num1,num1,i);       if num1(0)<>0 then error.flag=e.range;       write(5)=sector.size;       write(6)=num1(1);       if read(4)<>0 then error.flag=e.range;       num1(0)=read(5)+num1(2);       if error.flag=e.range then return 0; /* args are out of range - no change */    end;  end; /* of do case on types */  if arguments=0 then do; /* invalid param or args were typed */     error.flag=e.format; return 0; /* no change */  end;  do case param; /* case on parameter type */    ; /* invalid - handled above */    call copy_vector(attack,num1,3); /* set attack time */    call copy_vector(decay,num1,3); /* set decay time */    do; /* set number of spectral plots in 3D display */       if      num1(0) IGT 100 then window.number=100;       else if num1(0) <>  0   then window.number=num1(0);    end;    do; /* set spectral window type */       num1(0)=interpret_command(command,'BOX HAN HAM ',1);       if num1(0)>0 then window.type=num1(0)-1;       else              do; error.flag=e.format; return 0; end; /* no change */    end;       do; /* set spectral window length */                                                            if num1(0) IGT fft.len then window.length=fft.len;       else                        window.length = num1(0);    end;      window.offset=num1(0); /* set spectral window offset */    do; /* log or linear spectral scale */       num1(0)=interpret_command(command,'LIN LOG MAG ',1);       if num1(0)=0 then do; error.flag=e.format; return 0; end; /* no change */       else do;          log.mode=num1(0)-1;          if display.type=spectral.display then replot.flag=1; /* must redraw */       end;       end;    do; /* spectral scale */       call copy_vector(spectral.scale,location(addr(fp)),2);       if display.type=spectral.display then replot.flag=1; /* must redraw */    end;    do; /* horizontal time scale */       call copy_vector(location(hor.time),num1,3);       if display.type=time.display then replot.flag=1; /* must redraw */    end;    do;      call v.scale(num1,num2,arguments);      if display.type=time.display then replot.flag=1; /* must redraw */    end;      do; /* sampling rate */      current.per.index=int(clock.rate/fp+.5);      if current.per.index IGT max.period then current.per.index=max.period;      if (clock.rate/current.per.index) > max.sampling.rate then current.per.index=clock.rate/max.sampling.rate;    end;    gain.factor=num1(0)/6; /* filter gain */    call copy_vector(location(frequency),location(addr(fp)),2); /* frequency */    amplitude=convert_to_abs(num1); /* amplitude */    do; /* keyboard octave */      call copy_vector(location(octave),location(addr(fp)),2);      hertz=int(10.*pitch_to_freq(fp));    end;    keyboard.decay.number=num1(0); /* KEYboard decay (ms) */    do; /* fft length */      if num1(0) < 0 then do; error.flag=e.range; return 0; end; /* no change */      else do; /* adjust to power of two */        num1(1)=32;        do while (num1(1)<num1(0))&(num1(1)<fft.max);num1(1)=num1(1)*2;end;        fft.len=num1(1);        if window.length > fft.len then window.length = fft.len;      end;       end;    do; /* pitch */      fp=pitch_to_freq(fp);      call copy_vector(location(frequency),location(addr(fp)),2);    end;    do; /* spectrum origin */       spectral.origin=num1(0);       if spectral.origin>25 then spectral.origin=25; /* (khz) */       if spectral.origin<0  then spectral.origin=0;       if display.type=spectral.display then replot.flag=1; /* must redraw */    end;    do; /* spectrum range */      spectral.range=num1(0);      if spectral.range<1  then spectral.range=1;      if spectral.range>25 then spectral.range=25;      if display.type=spectral.display then replot.flag=1; /* must redraw */    end;    semitones     =num1(0)*100+num1(1)/10; /* pitch bend semitones */    vibrato.rate  =num1(0)*100+num1(1)/10; /* vibrato rate * 100 */    vibrato.depth =num1(0)*100+num1(1)/10; /* depth * 100 */    vibrato.attack=num1(0); /* milliseconds */    if (num1(0) > 0) and (num1(0) < 17) then bits=num1(0); /* processing bits */    else do; error.flag = e.range; return 0; end; /* illegal value for quantization bits */  end; /* end do case on parameter */   return 1; /* change was made */end change_value;set_menu:proc(flag) swap; /* print current settings */   dcl flag     fixed; /* =1 to print alphanumerics, 0 to skip */   dcl temp(20) fixed;   dcl fp       floating;   dcl i        fixed;   pnt:proc(ypos,xpos,string,type,parameter); /* screen print routine */      dcl (xpos,ypos) fixed; /* screen position */      dcl string      fixed array;      dcl type        fixed; /* code for type of argument */      dcl parameter   fixed array; /* value to print */      dcl i           fixed;      /* Types:  0=string, 1=integer, 2=time value, 3=floating point, 4=integer scaled */      if flag then do; call pos(ypos,xpos); ps(string); end; /* print label */      call pos(ypos,xpos+22);      do case type; /* field width is eleven chars, right justified */         do; /* 0:  string */            ps(parameter);            do i=parameter(0) to 10; call pc(A.SP); end;            end;            do; /* 1:  integer */            do i=num_count(parameter(0)) to 10; call pc(A.SP); end;            pnum(parameter(0));         end;         call print_time(parameter,3,1); /* 2:  time */         do; /* 3:  floating */            call copy_vector(location(addr(fp)),parameter,2);            call fprint(fp,4,5);         end;          do; /* 4:  scaled integer */            fp=parameter(0)/(32767.)*scale.factor;            call fprint(fp,4,3); ps('00');         end;      end; /* of do case */   end pnt;   display.type=set.menu; /* mark the display type */   if flag then clear; /* rewrite the whole screen */   if flag then do; call pos(4,1);ps('Signal display settings:');end;      call pnt(5,1,'HORizontal scale',2,location(hor.time));      call pos(6,1); ps('VERtical scale');   call pos(6,19); call print_value(bottom.limit,scale.factor,3,2);   ps(' to');      call print_value(top.limit,   scale.factor,3,2);   if flag then do; call pos(8,1); ps('Spectral display settings:'); end;   temp(0)=window.number; call pnt(9,1,'NUMber of spectra',1,temp);   temp(0)=fft.len;       call pnt(10,1,'FFT length',1,temp);   do case window.type;      call assign(temp,'     BOXCAR');      call assign(temp,'    HANNING');      call assign(temp,'    HAMMING');   end;   call pnt(11,1,'window TYPe',0,temp);   call copy_vector(temp,zero.vector,2); temp(2)=window.length;   i=compute.best.period.index; /* get appropriate clock period */   call index_to_time(temp,temp,i);   call pnt(12,1,'window LENgth',2,temp);   call copy_vector(temp,zero.vector,2); temp(2)=window.offset;   call index_to_time(temp,temp,i);   call pnt(13,1,'window OFFset',2,temp);   do case log.mode;      call assign(temp,'     LINEAR');      call assign(temp,'LOGARITHMIC');      call assign(temp,'  MAGNITUDE');   end;   call pnt(14,1,'spectral scale MODe',0,temp);   call pnt(15,1,'spectral SCAle',3,spectral.scale);   temp(0)=spectral.origin;call pnt(16,1,'plot ORIgin (kHz)',1,temp);   temp(0)=spectral.range; call pnt(17,1,'plot RANge (kHz)',1,temp);   if flag then do; call pos(19,1); ps('Extract command:'); end;   call pnt(20,1,'ATTack ramp',2,attack);   call pnt(21,1,'DECay  ramp',2,decay);   temp(0)=bits;call pnt(22,1,'quant. BITs',1,temp);   if flag then do; call pos(4,40); ps('Signal function generation:'); end;   call pnt(5,40,'FREquency',3,location(frequency));   call copy_vector(location(addr(fp)),location(frequency),2);   fp=freq_to_pitch(fp); call pnt(6,40,'PITch',3,location(addr(fp)));   temp(0)=amplitude; call pnt(7,40,'AMPlitude',4,temp);   if flag then do; call pos(9,40); ps('Miscellaneous:'); end;   fp=clock.rate*1./current.per.index;   call pnt(10,40,'sample RATe',3,location(addr(fp)));   temp(0)=gain.factor*6; call pnt(11,40,'filter GAIn (db)',1,temp);   if any.kbd<>0 then do; /* print keyboard params if keyboard present */      if flag then do; call pos(13,40); ps('Keyboard performance:'); end;      call pnt(14,40,'OCTave base',3,location(octave));      temp(0)=keyboard.decay.number;      call pnt(15,40,'KEYboard decay (msec)',1,temp);      fp=semitones/100;       call pnt(16,40,'pitch bend SEMitones',3,location(addr(fp)));      fp=vibrato.rate/100;    call pnt(17,40,'VIBrato rate (Hz)',3,location(addr(fp)));      fp=vibrato.depth/100;   call pnt(18,40,'vib DEPth (semitones)',3,location(addr(fp)));      temp(0)=vibrato.attack; call pnt(19,40,'Vib ATtack (msec)',1,temp);   end;end set_menu;