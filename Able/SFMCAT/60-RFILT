/* 60-RFILT  $TITLE  Filtering Module *//* Copyright 1985 by New England Digital Corporation *//* RFILT:  Filter one frame of dataSee page 3.1-8 of "IEEE Programs for D. S. P." for assumptions */rfilt:proc(rmsb,rlsb,fmsb,flsb,smsb,slsb,np) fixed SWAP;   dcl rmsb fixed array;  dcl rlsb fixed array;  dcl fmsb fixed array;  dcl flsb fixed array;  dcl smsb fixed array;  dcl slsb fixed array;  dcl np   fixed;  dcl (k,nppk,npt2)                 fixed;  dcl (frmsb,fimsb,frlsb,filsb)     fixed; /* temporary storage */  dcl (fisign,frsign,rrsign,risign) fixed; /* signs */  dcl (tmsb,tlsb)                   fixed; /* temporary */  dcl (xmsb,xlsb,ymsb,ylsb)         fixed;  dcl (overflow,check)              fixed; /* flag */    npt2=2*np;  dcl negate    lit 'do;omsb=-omsb;if olsb<>0 then omsb=omsb-1;olsb=-olsb;end;';  dcl mult1     lit 'write(5)=imsb1;write(6)=imsb2;omsb=read(4);olsb=read(5);';  dcl mult2     lit 'write(5)=imsb1;write(6)=ilsb2;olsb=olsb+read(4);if olsb ilt read(4) then omsb=omsb+1;';  dcl mult3     lit 'write(5)=imsb2;write(6)=ilsb1;olsb=olsb+read(4);if olsb ilt read(4) then omsb=omsb+1;';  dcl multiply2 lit 'do; mult1; mult2; mult3; end;';                               /* store previous tail in scratch array S; zero 2nd half of R;      first half of R is new data to be filtered */  k=0;  nppk=np;  smsb(k)=rmsb(nppk);  slsb(k)=rlsb(nppk);     do k=0 to np-1;        nppk=np+k;     smsb(k)=rmsb(nppk);     slsb(k)=rlsb(nppk);     rmsb(nppk)=0;     rlsb(nppk)=0;  end;  rescale=0;  call ifast(rmsb,rlsb,npt2);  call normalize1(rmsb,rlsb,npt2+1,15);       do k=0 to npt2 by 2; /* multiply complex elements */     frsign=0; rrsign=0; fisign=0; risign=0;     frmsb=fmsb(k);     frlsb=flsb(k);     fimsb=fmsb(k+1);     filsb=flsb(k+1);     if frmsb<0 then begin;        dcl omsb lit 'frmsb';        dcl olsb lit 'filsb';        negate;        frsign=1;     end;       if fimsb<0 then begin;        dcl omsb lit 'fimsb';        dcl olsb lit 'filsb';        negate;        fisign=1;     end;            if rmsb(k)<0 then begin;        dcl omsb lit 'rmsb(k)';        dcl olsb lit 'rlsb(k)';        negate;        rrsign=1;     end;     if rmsb(k+1)<0 then begin;        dcl omsb lit 'rmsb(k+1)';        dcl olsb lit 'rlsb(k+1)';        negate;        risign=1;     end;     begin;        dcl omsb  lit 'tmsb';        dcl olsb  lit 'tlsb';        dcl imsb1 lit 'frmsb';        dcl ilsb1 lit 'frlsb';        dcl imsb2 lit 'rmsb(k)';        dcl ilsb2 lit 'rlsb(k)';        multiply2;         if (rrsign+frsign) then negate;     end;     begin;        dcl omsb  lit 'xmsb';        dcl olsb  lit 'xlsb';        dcl imsb1 lit 'fimsb';        dcl ilsb1 lit 'filsb';        dcl imsb2 lit 'rmsb(k+1)';        dcl ilsb2 lit 'rlsb(k+1)';        multiply2;         if (fisign+risign) then negate;     end;     begin; /* subtract to get x */        dcl omsb  lit 'xmsb';        dcl olsb  lit 'xlsb';        dcl imsb1 lit 'tmsb';        dcl ilsb1 lit 'tlsb';        dcl imsb2 lit 'xmsb';        dcl ilsb2 lit 'xlsb';        subtract;     end;     begin;        dcl omsb  lit 'tmsb';        dcl olsb  lit 'tlsb';        dcl imsb1 lit 'frmsb';        dcl ilsb1 lit 'frlsb';        dcl imsb2 lit 'rmsb(k+1)';        dcl ilsb2 lit 'rlsb(k+1)';        multiply2;         if (frsign+risign) then negate;     end;     begin;        dcl omsb  lit 'ymsb';        dcl olsb  lit 'ylsb';        dcl imsb1 lit 'fimsb';        dcl ilsb1 lit 'filsb';        dcl imsb2 lit 'rmsb(k)';        dcl ilsb2 lit 'rlsb(k)';        multiply2;        if (fisign+rrsign) then negate;     end;     begin;        dcl omsb lit 'ymsb';        dcl olsb lit 'ylsb';        dcl imsb1 lit 'tmsb';        dcl ilsb1 lit 'tlsb';        dcl imsb2 lit 'ymsb';        dcl ilsb2 lit 'ylsb';        add;     end;     rmsb(k)=xmsb;     rlsb(k)=xlsb;     rmsb(k+1)=ymsb;     rlsb(k+1)=ylsb;  end; /* of multiply complex elements */  rescale=rescale+1; /* multiplies have divided input by 2 */  rescale=rescale+fscale+gain.factor; /* add in scale for filter */  call ifsst(rmsb,rlsb,npt2);      overflow=0;  if shift(rmsb,rlsb,npt2,rescale) then overflow=1;      do k=0 to np-1; /* add in tail */     begin;        dcl omsb  lit 'rmsb(k)';        dcl olsb  lit 'rlsb(k)';        dcl imsb1 lit 'smsb(k)';        dcl ilsb1 lit 'slsb(k)';        dcl imsb2 lit 'rmsb(k)';        dcl ilsb2 lit 'rlsb(k)';        check=( (imsb2&"100000") = (imsb1&"100000") ); /* true if same sign */        add;        if (check) and ((omsb&"100000")<>(imsb1&"100000")) then overflow=1;     end;  end; /* of add in tail */  return overflow;  end rfilt;