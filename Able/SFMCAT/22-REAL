/* 22-REAL  $TITLE  Envelope Display Module *//* Copyright 1985 by New England Digital Corporation *//* envelope plot:  586 pixels of 1024 samples each=600064 samples per line.                   at 50 kHz this is 12 sec of data.   */dcl port.number     fixed; /* block of 586 pixels */dcl x.pixel         fixed;dcl pixel.max       lit '586'; dcl left.env.margin lit '25';env_cursor:proc(pixel,port); /* draws cursor on envelope plot */   dcl pixel fixed;   dcl port  fixed;   dcl left  lit 'left.env.margin';   dcl right lit '(left+pixel.max)';   dcl delta lit '65';   viewport(left,right,(5-port)*delta+19,(6-port)*delta);   if cursor.on then do;      vector_mode;      data_level(2); /* complement */      call #move(pixel,#view.limits(2));      call #draw(pixel,#view.limits(3));      data_level(0);      transparent_mode;     end;end env_cursor;pixel_and_port:proc(time); /* compute x.pixel and port.number from cursor.time */   dcl time    fixed array;   dcl temp(2) fixed;       dcl left    lit 'left.env.margin';   call time_to_index(time,temp,period.index);   write(5)=temp(1);   write(4)=shr(temp(0),8);   write(7)=(4*pixel.max); /* 4 * 586 */   port.number=read(5);   write(5)=read(4); /* remainder must be divided by 4 */     write(7)=4;   x.pixel=left+read(5);    if port.number>5 then do; /* past last port */      port.number=5; x.pixel=left+pixel.max; /* limit to end */   end;end pixel_and_port;env_arrow:proc; /* process cursor movements */   dcl temp(2) fixed;    dcl left    lit 'left.env.margin';   dcl right   lit '(left+pixel.max)';   if (ud.arrow=0) and (rl.arrow=0) then return; /* no action */   call env_cursor(x.pixel,port.number); /* erase */   disable;   x.pixel=x.pixel+rl.arrow*arrow.count;   port.number=port.number-ud.arrow; /* reversed time direction on screen */   ud.arrow=0;   rl.arrow=0;   enable;   if x.pixel<left  then x.pixel=left;   if x.pixel>right then x.pixel=right;   if port.number<0 then port.number=0;   if port.number>5 then port.number=5;   temp(2)=0;   temp(1)=4*(port.number*pixel.max+x.pixel-left);   temp(0)=0;   call index_to_time(temp,temp,period.index);   if compare_vectors(location(data.end),temp,3)=<0 then do;      call copy_vector(temp,location(data.end),3);      call pixel_and_port(temp);   end;   call copy_vector(cursor.time,temp,3);   call env_cursor(x.pixel,port.number);end env_arrow;plot_env:proc(min,max); /* plots one horiz. pixel of envelope per call; 1326 usec/call */   dcl (min,max) fixed; /* min and max value in 4 sector block */   dcl left      lit 'left.env.margin';   dcl right     lit '(left+pixel.max)';   dcl delta     lit '65';   if port.number<6 then do; /* if line on screen */      vector_mode;      call #transmit_coords(x.pixel,#converty(min)); /* draw line */      call #transmit_coords(x.pixel,#converty(max));   end;   x.pixel=x.pixel+1; /* move right by a pixel */   if x.pixel=right then do; /* wrap to next line */      port.number=port.number+1;      x.pixel=left;      viewport(left,right,(5-port.number)*delta+19,(6-port.number)*delta);   end;end plot_env;initialize_env:proc(max.time,ticks); /* draws and labels env for recording */   dcl max.time  fixed array;     dcl ticks     fixed; /* true if tick marks are desired on envelope */   dcl limit     fixed;    dcl right.end fixed; /* right end of previously printed number */   dcl number    fixed;   dcl left      lit 'left.env.margin';   dcl right     lit '(left+pixel.max)';   dcl delta     lit '65'; /* 19 for label, 46 for signal */   dcl (i,j,k)   fixed;   display.type=real.time; /* establish the display type */   clear; /* clear and put up header info */   vector_mode;   call #transmit_coords(0,407);   alpha_mode;   char_size(1);   ps('Envelope display:');   char_size(0);   call pixel_and_port(max.time); /* sets x.pixel and port.number to max.time */   do j=0 to port.number; /* loop up to maximum port number */      k=5-j; /* reverse loop */      viewport(left-8,right,k*delta+19,(k+1)*delta); /* select this port */      window(left-8,right,0,2);      if j=port.number then connect(left-8,0,x.pixel,0); /* if last port */      else                  connect(left-8,0,right,0); /* full line if not last */      connect(left-8,0,left-8,2);      do i=0 to 2; /* label y axis */         move_to(left-8,i);         call #transmit_coords(#lastx-5,#lasty);      end;      limit=6000*period.index/clock.rate; /* gives left margin in seconds*10: 6000=586*1024/100 */      viewport(left,right,k*delta+19,(k+1)*delta);      window(0,limit,0,100);      right.end=left;      do i=0 to limit by 5; /* loop from left to right end */         move_to(i,0);         if (j<>port.number) or (#lastx<x.pixel) then do;            if (i mod 10)=0 then do; /* time to plot a time label */               call #transmit_coords(#lastx,#lasty-5); /* draw tick mark */               vector_mode;               call #transmit_coords(#lastx,#lasty-19); /* move to number loc */               number=(i+limit*j)/10; /* time in seconds */               if #lastx>=right.end then do;                  pnum(number);                  right.end=#lastx+8*num_count(number)+4;               end;            end;            else if (clock.rate/period.index>25) and ticks then /* time to plot a tick mark */                 call #transmit_coords(#lastx,#lasty-3);         end; /* of not done initializing display */      end; /* of loop over pixels on current port */   end; /* of loop over ports */   port.number=0; /* re-initialize */   x.pixel=left;  /* re-initialize */   window(0,pixel.max,-32768,32767);     viewport(left,right,5*delta+19,6*delta); /* top viewport */end initialize_env;construct_env:proc; /* draw and label env plot for a previously recorded file */   dcl cur(2)     fixed; /* current sector to process */                    dcl num.sec(2) fixed; /* number of sectors left to process */   dcl stop(2)    fixed; /* last sector to process */   dcl (max,min)  fixed; /* max and min for plotting interval */   dcl (lim,base) fixed; /* buffer size and pointer */   dcl count      fixed; /* count of total sectors read (plot each 4 sectors) */   dcl (i,j,k)    fixed;   if display.type=0 then do; /* no file to display */      error.flag=e.no.file; return;   end;    call initialize_env(location(data.end),1); /* draw the labels */   call add_len_to_addr(location(valid.data),location(f.data.index),stop); /* compute last sector */   call copy_vector(cur,location(f.data.index),3); /* set up first sector */   max=(-32768); min=32767; /* preset limits */   count=0; /* init count of sectors scanned */   do while (not break.rcvd) and (compare_addrs(stop,cur)>0); /* loop over sectors */      call sub_len_from_len(stop,cur,num.sec); /* number of sectors left */      lim=num.sec(1); /* compute number of sectors to read */      if num.sec(2)<>0    then lim=lim+1; /* adjust for fractional sectors */      if lim IGT buf1.len then lim=buf1.len; /* limit by buffer size */      call readdata(cur(0),cur(1),databuf1,shl(lim,8)); /* do the read */      do i=0 to lim-1; /* loop over sectors of data in buffer */         base=(i*sector.size); /* compute base for this sector */         do j=0 to 255 by 4; /* loop over a sector of data - check min & max every 4 samples */            k=databuf1(base+j); /* get sample value */            if #greater(k,max) then max=k; /* update the max */            if #greater(min,k) then min=k; /* update the min */         end;         count=count+1; /* incr sector counter */         j=cur(0)&"177400"; /* save device byte */         call add_len_to_addr(zero.one.zero,cur,cur); /* advance cur */         cur(0)=cur(0)\j; /* restore device byte */         if (count&"3")=0 then do; /* time for plot */            call plot_env(min,max); /* plot the envelope segment */            max=(-32768); min=32767; /* reset limits */         end;      end; /* of loop over data in buffer */   end; /* of loop over sectors in file */   call pixel_and_port(cursor.time); /* find cursor position */   call env_cursor(x.pixel,port.number); /* put cursor on plot */   break.rcvd=0;   transparent_mode;end construct_env;