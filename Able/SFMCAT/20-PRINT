/* 20-PRINT  $TITLE   Hardcopy Routines for VT640 and DQ640 Terminals *//* Copyright 1985 by New England Digital Corporation */hardcopy: proc swap; /* dumps from the screen to the I.D.S. */   dcl gon      lit 'character(03)';   dcl goff     lit 'gon,character(02)';   dcl linefeed lit 'gon,character(14)';   dcl formfeed lit 'gon,character(ff)';   dcl storage ((((1024 + 3)/4)*4 + 1)/2) fixed; /* this is just (GROUPS*4 + 1)/2 for largest screen (and N) supported */   dcl bit      fixed;   dcl last_byt fixed;   read_screen: proc(y, groups, screen_width, n);      pstring: proc(str); /* print string routine */         dcl str fixed array; /* string to be printed */         dcl i   fixed;         do i=0 to str(0)-1; /* loop over chars */            call pc(byte(str,i));         end;      end pstring;        print_num:proc(val);         dcl val       fixed;         dcl string(4) fixed;         call num_to_str(string,val);         call pstring(string);      end print_num;      map_bits: proc(c, byt, n); /* map screen bits to printer bits */         dcl c   fixed; /* character to map */         dcl byt fixed; /* byte position in mapped printer array */         dcl n   fixed; /* number of bits in C that are valid */         dcl j   fixed;         if mg600 then c = rot(c, 16 - n); /* bits are in reverse order on MG600 */         if c <> 0 /* don't waste time if C = 0 */         then do j = 0 to n; /* map all bits that are valid */            byt = byt - 1;            if c then do; /* if the bit is set, map it onto the printer */               call pbyte(storage, byt, (byte(storage, byt) or bit));               if last_byt < byt then last_byt = byt; /* look for the end */            end;            if mg600 /* if MG600 */            then c = rot(c, 1); /* take next bit from top */            else c = shr(c, 1); /* look at the next bit (from bottom) */         end; /* of mapping bits */      end map_bits;      dcl y                 fixed; /* Y position of line to read */      dcl groups            fixed; /* number of 5-pixel or 6-pixel groups in line */      dcl screen_width      fixed; /* width (in pixels) of screen */      dcl n                 fixed; /* number of bits in a group */      dcl buf (((1024 + 3)/4 + 1)/2) fixed; /* input buffer (size is # groups for largest screen (and N) supported) */      dcl byt               fixed; /* byte position in printer array */      dcl c                 fixed; /* next character from screen */      dcl count             fixed; /* number of consecutive bytes */      dcl last_bit          fixed; /* last bit on line */      dcl (i, j)            fixed;      enable;      if mg600 then do; /* if an MG600 */         i = shr(y, 5) + 32; j = (y and "37") + 96; /* high y, low y */         call pc(a.esc); call pstring('}9'); call pc(i); call pc(j); call pc(i); call pc(j); /* ask for line Y */      end; /* of MG600 */      else do; /* VT640 or DQ640 */         call pc(a.esc); call pstring('"0;'); call print_num(y); call pc(a.semicolon); /* ask for line Y */         if dq640 then do; /* for DQ640 */            call print_num(screen_width); call pc(a.c);         end;         else do; /* for VT640 */            call print_num(groups); call pc(l.c);         end;      end; /* of VT640 or DQ640 */      call tty_wait; disable;      i = 0; /* start reading bytes at byte zero */      buf (0) = groups; /* there are GROUPS bytes in the buffer */      do while (i <= groups - 1); /* read all bytes */         c = read("50"); /* get next character */         if c = a.dollar then do; /* repeating bytes of all zeroes */            c = 0; /* pattern is all zeros */            count = (read("50") & "077"); /* get count */         end; /* of repeating zeroes */         else if c = a.percent then do; /* repeating bytes of all ones */            c = "077"; /* pattern is all ones */            count = (read("50") & "077"); /* get count */         end; /* of repeating ones */         else if c = a.and then do; /* repeating bytes of an arbitrary pattern */            c = read("50"); /* get the pattern */            count = (read("50") & "077"); /* and the count */         end; /* of repeating pattern */         else count = 1; /* just a single byte */         do j = 1 to count; /* save the bytes */            call pbyte(buf, i, c); /* save this character */            i = i + 1; /* advance screen counter */         end; /* of saving bytes */      end; /* of reading all bytes */      c = read("50"); /* read trailer */      last_bit = ((screen_width - 1) mod n); /* last bit on line */      byt = 0; /* start at beginning of printer array */      do i = 0 to groups - 1; /* map the screen bytes onto the printer */         if i = groups - 1 then do; /* make sure we don't map too many bits on last byte */            byt = byt + last_bit + 1; /* advance printer counter */            call map_bits (byte(buf, i), byt, last_bit); /* map bits */         end; /* of mapping bits on last pass */         else do; /* no need to be careful the rest of the time */            byt = byt + n; /* advance printer counter */            call map_bits (byte(buf, i), byt, n - 1); /* map bits */         end; /* of rest of the time */      end; /* of mapping screen bytes onto printer */   end read_screen;   dcl screen_width  fixed; /* width of screen in pixels */   dcl screen_height fixed; /* height of screen in pixels */   dcl groups        fixed; /* width of screen in 6-pixel units */   dcl swaths        fixed; /* height of screen in swaths (7-pixel units) */   dcl (i,j,k,n,y)   fixed;   vector_mode; call tty_wait;   disable; /* no interrupts */   send gon,; /* turn printer graphics on */   if mg600 then do; /* mg600 */      screen_width = 1024; /* for MG600 */      screen_height = 780;      n = 4; /* readback is in 4-pixel groups */   end;   else if dq640 then do; /* dq640 */      screen_width = 800; /* for DQ640 */      screen_height = 480;      n = 6; /* readback is in 6-pixel groups */   end;   else do; /* vt640 */      screen_width = 640; /* for VT640 */      screen_height = 480;      n = 5; /* readback is in 5-pixel groups */   end;   groups = (screen_width + (n - 1))/n; /* round up to nearest N-pixel boundary */   swaths = (screen_height + 6)/7; /* round up to nearest 7-pixel boundary */      do i = 0 to swaths - 1;      do j = 0 to (groups*n + 1)/2; storage (j) = 0; end;      last_byt = -1; bit = 1;      if i = swaths - 1 then k = ((screen_height - 1) mod 7); /* restrict last swath to screen size */      else k = 6; /* not last swath - create all 7 swath lines */      do j = 0 to k;         y = (screen_height - 1) - i*7 - j; /* calculate next line address */         call read_screen (y, groups, screen_width, n);         bit = shl(bit, 1);      end;      do j = 0 to last_byt;         k = byte(storage, j);         if k = 3 then send gon,;         send character(k),;      end;      send linefeed,;   end;   send goff,; /* turn printer graphics off */   enable; /* turn interrupts back on here */   transparent_mode;end hardcopy;SIDEWAYS:proc swap;     /* for dq640, turns picture 90 degrees to right for IDS printer */   dcl (msb,lsb) fixed;   dcl (i,j) fixed;   dcl GON      lit 'character(03)';   dcl GOFF     lit 'GON,character(02)';   dcl LINEFEED lit 'GON,character(14)';   dcl FORMFEED lit 'GON,character(a.FF)';   dcl SCREEN_WIDTH lit '800'; /* for DQ640 */   dcl SCREEN_HEIGHT lit '480';   dcl save fixed;   dcl pixels lit '((buf1.len*sector.size/screen_height)*16)';  /* truncate words */   read_screen: proc(x,bitx);      dcl c                 fixed; /* next character from screen */      dcl bitx fixed;      /* pixels to read per line */      dcl (x) fixed;                 /* x pos of screen */      dcl count             fixed;      dcl (i,j,k,l,y)            fixed;      dcl buf lit 'databuf1';      dcl inbuf(pixels/6) fixed;      dcl groups   lit '(bitx/6)'; /* read groups of 6 pixels (is divisable by 6)  */      do y=0 to screen_height-1;      enable;      call pc (a.esc);    ps ('"');pnum(x);call pc(a.semicolon);pnum (y);      call pc (a.semicolon); pnum (bitx); call pc (a.c);      call tty_wait; disable;  /* read COUNT bits from a horiz. line */      i = 0; /* start reading bytes at byte zero */      do while (i <= groups - 1); /* read all bytes */                       c = read("50"); /* get next character */         if c = a.dollar then do; /* repeating bytes of all zeroes */            c = 0; /* pattern is all zeros */            count = (read("50") & "077"); /* get count */         end; /* of repeating zeroes */         else if c = "45" then do; /* repeating bytes of all ones */            c = "077"; /* pattern is all ones */            count = (read("50") & "077"); /* get count */         end; /* of repeating ones */         else if c = "46" then do; /* repeating bytes of an arbitrary pattern */            c = read("50"); /* get the pattern */            count = (read("50") & "077"); /* and the count */         end; /* of repeating pattern */         else count = 1; /* just a single byte */         c=c&"77"; /* mask off garbage */         do j = 1 to count; /* save the bytes */            inbuf(i)=c;            i = i + 1; /* advance screen counter */         end; /* of saving bytes */      end; /* of reading all bytes */      c = read("50"); /* read trailer */      k=y*((bitx+15)/16);      do i=0 to groups-1 by 8;  /* number of words */         databuf1(k)=shl(inbuf(i),16-6)\shl(inbuf(i+1),16-12)\shr(inbuf(i+2),2);         k=k+1;         databuf1(k)=shl(inbuf(i+2),16-6+4)\shl(inbuf(i+3),20-12)\shl(inbuf(i+4),20-18)\shr(inbuf(i+5),4);         k=k+1;         databuf1(k)=shl(inbuf(i+5),16+2-6)\shl(inbuf(i+6),18-12)\inbuf(i+7);         k=k+1;      end;      end; /* y */   end read_screen;   reverse:proc(x); /* reverse 7 bits */      dcl x fixed;      dcl a fixed;      dcl i fixed;      a=0;      do i=0 to 6;         if (x&(shl(1,i)))^=0 then a=a\shl(1,6-i);      end;      return a;   end reverse;   printit:proc(bitx);      dcl bitx fixed;      dcl groups fixed;      dcl (i,j,k,l,c) fixed;      dcl cycle fixed;      do i=0 to bitx-7 by 7;        l=i/16;        cycle=i mod 16;        do j=0 to screen_height-1;          k=j*((bitx+15)/16)+l;          if cycle<=16-7 then c=shr(databuf1(k),16-cycle-7);          else c=shl(databuf1(k),7-16+cycle)\shr(databuf1(k+1),32-7-cycle);          c=reverse(c);          if c = 3 then send GON,;          send character(c),;        end;       send LINEFEED,;     end;   end printit;   dcl GROUPS lit '((SCREEN_WIDTH + 6)/7)'; /* round up to nearest 7-pixel boundary */   dcl count fixed;   vector_mode; alpha_mode; call tty_wait;   save = read("314"); /* save interrupt status (should be "enable") */   disable;   send GON,;                  count=((pixels)/42)*42; /* divisible by 6 and 7  */   do i=0 to screen_width by count;      if (i+count)>screen_width then count=screen_width-i;      do j=0 to buf1.len*sector.size-1;databuf1(j)=0;end;      call read_screen(i,count);      call printit(count);   end;   send FORMFEED,GOFF,; /* end graphics mode on printer */   do while (read("51")&2)<>0; j=read("50"); end; /* read any trailer codes */   write("314") = save; write("1") = save; /* restore interrupt status */   transparent_mode;end SIDEWAYS;