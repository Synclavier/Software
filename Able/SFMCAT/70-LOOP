/* LOOP  $TITLE  Overlay Which Creates Perfect Loop Points in Sound Files *//* Copyright 1985 by New England Digital Corporation */dcl debug.parsing  lit '0';   /* set to 1 for parsing debug info */dcl debug.loop     lit '0';   /* set to 1 for debug info */dcl in.main.module lit '0';   /* not the main SFM module */dcl sector.size    lit '256'; /* number of 16-bit words in one sector *//* GLOBAL work buffers */dcl buflen                    lit '64'; /* sectors to allocate for BUF1 and BUF2 */dcl buf1 (buflen*sector.size) fixed;    /* fixed pt. work buffer */dcl buf2 (buflen*sector.size) fixed;    /* fixed pt. work buffer */dcl buf1.len                  lit '0';  /* not used - needed by compiler */dcl databuf1 (0)              fixed;    /* not used - needed by compiler */insert ':-xpl:literals'; 	/* system literals  */insert ':-xpl:asciilit'; 	/* ASCII literals  */insert ':-xpl:scsi';     	/* SCSI device drivers */insert ':-xpl:catrtns';  	/* catalog routines */insert ':-xpl:strings';  	/* string handling */insert ':-xpl:intrprtr';	/* interpreter interface *//* SFM System File Inserts */insert ':sfmcat:00-sfm';   /* SFM upper memory definitions and overlay routine */insert ':sfmcat:01-io';    /* ascii definitions, interrupt I/O */insert ':sfmcat:02-plot';  /* plotting procedures */insert ':sfmcat:06-globl'; /* global variables */insert ':sfmcat:07-util';  /* utility procedures */insert ':sfmcat:08-symbl'; /* symbol procedures for labeling time domain display */insert ':sfmcat:09-files'; /* utility procedures which access catalog */  insert ':sfmcat:10-set';   /* input time values and process set menu *//* RETURN_TO_SFM is a special routine which will perform   the overlay back to the main module of the SFM system.   It takes one parameter.  This parameter is the value   that you want the global error status variable, ERROR.FLAG,   to be set to, upon return. */return_to_sfm:proc(e.flag); /* special return routine */  dcl e.flag fixed; /* error flag to return */  call tty_wait;  ovl.error=e.flag; core(loc.rst)=10; /* error return state */  call overlay(core(loc.p1+1),core(loc.p1),core(loc.p1-1)); /* return to main module of SFM */end return_to_sfm;dcl catalog_buffer (c#dir_max - 1) fixed; /* catalog buffer */call set_catbuf (addr(catalog_buffer(0)), 0); /* set up catalog buffer */mem.siz=memory.size; /* look up configured memory size */enable;if (core(loc.rst)<>3) then do; /* invalid invocation of module */   psr('This module may only be invoked through SFM');   call tty_wait; /* allow chars to be printed before quitting */   call exit(-1); /* quit to MONITOR */end;if (core(c#contab+c#vstart)+core(c#contab+c#vlngth)+core(c#contab+c#stklen))   IGE ((60*1024)-1928) then do;   /* this check will catch errors where the program is too large for 56K systems */   ps('SYSTEM PROGRAMMING ERROR:  This module of SFM is too large to run.');   call tty_wait; call exit(-1); /* quit with stop status */end;clock.inc=10/d03_speed;          /* compute real time clock period */dq640    =((terminal.type=t#dq640) and (terminal.graphics=g#dq640));if dq640 then punits(799,479);else          punits(639,479);   /* initialize display units */ovl.error=0; error.flag=0;       /* initialize error status *//* $SUBTITLE  Custom Routines to Parse Command Line */dcl asc.chr       fixed; /* GLOBAL character used in all the routines */dcl asc.ptr       fixed; /* GLOBAL byte ptr  used in all the routines */dcl asc.cmnd (40) fixed; /* GLOBAL command string used in all the routines */get_chr:  proc; /* scan off next char of ASC.CMND, return 0 if no more chars */   if asc.ptr>=asc.cmnd(0) then asc.chr=0; /* at end of string */   asc.chr=byte(asc.cmnd,asc.ptr);         /* get next char */   if (asc.chr>"140") and (asc.chr<"173")  /* lowercase letter */   then asc.chr=asc.chr-"40";              /* make uppercase */   asc.ptr=asc.ptr+1;end get_chr;skip_spaces: proc;   do while asc.chr=A.SP; call get_chr; end;end skip_spaces;parse_word:  proc(word,len); /* get word, pad with spaces */   dcl word fixed array;   dcl len  fixed; /* number of characters in word */   dcl ptr  fixed;     alpha:proc(chr) fixed; /* true if chr is alphanumeric, else false */      dcl chr fixed;      if (chr>=A.0) and (chr<=A.9) then return 1; /* digits */      if (chr>=(A.A+"40")) and (chr<=(A.Z+"40")) then return 1; /* upper case letters */      if (chr>= A.A      ) and (chr<= A.Z      ) then return 1; /* lower case letters */      if (chr=A.PERIOD) or (chr=A.SCORE) then return 1; /* period or underline */      return 0; /* all else is non-alphanumeric */   end alpha;   ptr=0;   do while (asc.chr<>0) and alpha(asc.chr) and (ptr<len);      call pbyte(word,ptr,asc.chr); /* put char into output string */      ptr=ptr+1;                    /* advance ptr */      call get_chr;                 /* get next char */   end;   do while ptr<len;                /* now pad string with spaces */      call pbyte(word,ptr,A.SP);      ptr=ptr+1;   end;   word(0)=ptr;                     /* store resulting string length */   do while (asc.chr<>0) and alpha(asc.chr); call get_chr; end; /* skip chars until non-alpha found */end parse_word;parse_digits:  proc(len,out); /* returns numeric value (string of digits) */  dcl len fixed;       /* max number of digits to scan */       dcl out fixed array; /* OUT(0) holds value, OUT(1) holds count of digits read */  out(0)=0; out(1)=len;                /* initialize output values */  do while (out(1)<>0)      and (asc.chr<>0)  and      (asc.chr>=A.0) and (asc.chr<=A.9);     out(0)=out(0)*10+(asc.chr-A.0); /* add in digit */     call get_chr;                     /* get next char */     out(1)=out(1)-1;                  /* decrement chars left to read */  end;end parse_digits;/* $PAGE *//* PARSE_DECIMAL scans ASC.CMND and extracts a three field vector in the    format t(1) = integer portion, t(2) = first 3 digits to right of decimal   pt., if any, t(3) = last 3 digits to right of decimal pt., if any.   error codes: 0  ->  no error                1  ->  no digits found in string                2  ->  missing decimal point in number string */parse_decimal:  proc(num) fixed; /* gets a number in SFM Time format */   dcl num   fixed array;         /* 3 word output array */   dcl x (2) fixed;   call skip_spaces;   num(0)=0; num(1)=0; num(2)=0;           /* init all fields to zero */   if  (asc.chr=0)   or  ((asc.chr<>A.PERIOD) and ((asc.chr<A.0) or (asc.chr>A.9)))   then return 1;                          /* end of string; no digits found */   if asc.chr<>A.PERIOD then do;                /* char is a digit */      call parse_digits(5,x);      num(0)=x(0);      if asc.chr=0 then return 0;          /* exit if at string end */      if (asc.chr>=A.0) and (asc.chr<=A.9)/* a sixth digit */      then return 2;                       /* too many digits */   end;   if asc.chr<>A.PERIOD   then return 0;                          /* done */   else call get_chr;                      /* scan off decimal point */   call parse_digits(3,x);                 /* scan for milliseconds */   num(1)=x(0);                            /* get value returned */   if      x(1)=1 then num(1)=num(1)*10;   /* adjust milliseconds - got two digits */   else if x(1)=2 then num(1)=num(1)*100;  /* got one digit */   if (asc.chr=A.SP) then call get_chr;  /* skip over space if there */   if (asc.chr=0)                          /* exit if at string end */   or (asc.chr<A.0) or (asc.chr>A.9)   /* or number end */   then return 0;                          /* done */   call parse_digits(3,x);                 /* scan for microseconds */   num(2)=x(0);                            /* get value parsed */   if      x(1)=1 then num(2)=num(2)*10;   /* adjust microseconds field */   else if x(1)=2 then num(2)=num(2)*100;   if (asc.chr>=A.0) and (asc.chr<=A.9) then do; /* still more digits */      asc.chr=asc.chr-A.0;               /* look at digit and round */      if asc.chr>=5 then do;               /* round up */         num(2)=num(2)+1;         if num(2)=0 then do;            num(1)=num(1)+1;            if num(1)=0 then num(0)=num(0)+1;         end;      end;   end;      do while (asc.chr<>0)                   /* scan off the rest of the number */   and      (asc.chr>=A.0) and (asc.chr<=A.9);      call get_chr;   end;   return 0;                               /* successful */end parse_decimal;/* $PAGE */parse_time:  proc (time) fixed; /* parses TIME value from ASC.CMND string */   dcl time     fixed array; /* 3 word time output array in SFM format */   dcl out  (1) fixed;       /* 2 word array used to talk to PARSE_DIGITS */   dcl name (4) fixed;   dcl i        fixed;   time(0)=0; time(1)=0; time(2)=0;  /* initialize */   call skip_spaces;                 /* skip over spaces */   if asc.chr=0 then return 1;       /* ERROR: no chars in string */   else if asc.chr=A.STAR then do;  /* return CURSOR.TIME */      call copy_vector(time,cursor.time,3);      call get_chr;   end;   else if asc.chr=A.SHARP then do;/* look for #1 or #2 (MARK.START or MARK.END) */      call get_chr;                  /* skip to next char */      if      asc.chr=(A.0+1) then call copy_vector(time,mark.start,3);      else if asc.chr=(A.0+2) then call copy_vector(time,mark.end  ,3);      else do; error.flag=e.format; return 1; end; /* not #1 or #2 */      call get_chr;   end;   else if (asc.chr>=A.A) and (asc.chr<=A.Z) then do; /* look for symbol name */      call parse_word(name,8);              /* parse a possible symbol name */      i=locate_index(name);                 /* get index # of symbol */      if i=0 then do; error.flag=e.no.name; return 1; end; /* not a valid symbol */      i=symbol_time(i);                     /* get addr of time */      call copy_vector(time,location(i),3); /* copy symbol time */   end;   else if (asc.chr=A.PERIOD) or ((asc.chr>=A.0) and (asc.chr<=A.9)) then do; /* look for number */      return parse_decimal(time)<>0;       /* try to parse a time value */   end;   else return 1;                           /* unrecognized chars */   return 0;                                /* successful */end parse_time;parse_time_expression:  proc(time) fixed; /* parses a whole expression, puts result into TIME */   dcl time      fixed array;             /* output buffer */   dcl temp1 (2) fixed;   dcl operator  fixed;   dcl i         fixed;    call skip_spaces;   if asc.chr=0 then do;                     /* blank line */      call copy_vector(time,zero.vector,3);  /* use zero */      return 0;              end;   if parse_time(time) then return 1;        /* get first term, return if error */   call skip_spaces;   if asc.chr=0 then return 0;               /* expression ends -- successful */   operator=asc.chr;   do while (operator=A.PLUS) or (operator=A.MINUS); /* continue w/expression */      call get_chr;                          /* skip over operator */      if parse_time(temp1) then return 1;    /* get next operand, return if error */      i=compute.best.period.index;           /* use appropriate clock rate */      call time_to_index(time, time, i);     /* convert each to samples */      call time_to_index(temp1,temp1,i);      if operator=A.PLUS  then if add_len_to_len  (time,temp1,temp1) then return 1; /* perform operation */      if operator=A.MINUS then if sub_len_from_len(time,temp1,temp1) then return 1;      call index_to_time(time,temp1,i);      /* convert back to time */      call skip_spaces;      operator=asc.chr;                      /* save next char */   end;   return 0;                                 /* done -- successful */end parse_time_expression;/* $SUBTITLE  Start of Loop Construction Code */dcl l.start         (2) fixed; /* start time of loop */dcl l.stop          (2) fixed; /* end   time of loop */dcl fade            (2) fixed; /* crossfade time at loop end */dcl fade.max            fixed;dcl fade.val            fixed;dcl fade.accum          fixed;dcl fade.count          fixed;dcl (m.start,m.end) (2) fixed; /* index format for MARK.START, MARK.END */dcl new.len         (2) fixed; /* length of new file to create */dcl tbuf          (255) fixed; /* temporary disk buffer */dcl in.start        (2) fixed; /* 3 word ptr to start of input  samples */dcl in.end          (2) fixed; /* 3 word ptr to end   of input  samples */dcl out.start       (2) fixed; /* 3 word ptr to start of output samples */dcl out.end         (2) fixed; /* 3 word ptr to end   of output samples */dcl blen            (2) fixed;dcl (sign1,sign2)       fixed;dcl (t1,t2)         (2) fixed; /* a couple of temporaries */dcl (t3,t4)         (2) fixed; /* a couple of temporaries */dcl str            (10) fixed;dcl a                   fixed;dcl (i,j,k)             fixed;dcl default.fade data (0,500,0); /* default crossfade of 500 msec */file1;                  /* access the last current file from SFM */byte.ptr=0;                         /* init byte ptr */call get_command(local,str);        /* scan off LOOP command */if byte.ptr>=localbytes then do;    /* default - beginning to end */   /* put in help screen here */   call return_to_sfm(e.format);end;asc.ptr    =0;                /* init command string ptr */asc.cmnd(0)=0;                /* init command string */do while byte.ptr<localbytes; /* copy rest of chars to global ASC.CMND */   call pbyte(asc.cmnd,asc.cmnd(0),byte(local,byte.ptr));   asc.cmnd(0)=asc.cmnd(0)+1; /* increment length word of ASC.CMND */   byte.ptr   =byte.ptr   +1; /* and corresponding SFM global byte counter */end;if f.name.bytes=0then call return_to_sfm(E.NO.FILE); /* no previous current file */if debug.parsing then do;   clear; call set_scroll(4,24);   call pos(7,0); ps('Parsing Input String: "'); ps(asc.cmnd); ps('"'); nl;   ps('Current ASC.PTR:  '); pnum(asc.ptr); nl;end;/* $PAGE */if error.flag=0 then do;   call time_to_index(mark.start,m.start,period.index); /* convert to samples */   call time_to_index(mark.end  ,m.end  ,period.index);   call get_chr; /* get first char of string */   if debug.parsing then do;      k=asc.ptr; a=asc.chr;      j=parse_time_expression(t1);      asc.ptr=k; asc.chr=a;      ps('PARSE_TIME_EXPRESSION Return Code:  '); pnum(j); ps('   ERROR.FLAG:  '); pnum(error.flag); nl;      call print_vector(t1,'***** Time Value #1 Returned:  '); nl;   end;   if parse_time_expression(t1) then error.flag=e.format;   else do;      call time_to_index(t1,l.start,period.index);      if debug.parsing then do;         k=asc.ptr; a=asc.chr;         call parse_word(str,3);         asc.ptr=k; asc.chr=a;         ps('PARSE_WORD String:  "'); ps(str); ps('"   ERROR.FLAG:  '); pnum(error.flag); nl;      end;      call parse_word(str,3);      if interpret_command(str,'TO  ',1)=1 then do;         if debug.parsing then do;            k=asc.ptr; a=asc.chr;            j=parse_time_expression(t1);            asc.ptr=k; asc.chr=a;            ps('PARSE_TIME_EXPRESSION Return Code:  '); pnum(j); ps('   ERROR.FLAG:  '); pnum(error.flag); nl;            call print_vector(t1,'***** Time Value #2 Returned:  '); nl;         end;         if parse_time_expression(t1) then error.flag=e.format;         else call time_to_index(t1,l.stop,period.index);      end;        else call copy_vector(l.stop,m.end,3); /* use mark.end */   end;end;if error.flag=0 then do;   if asc.chr=A.COMMA then do;      call get_chr; /* skip over comma */      if debug.parsing then do;         k=asc.ptr; a=asc.chr;         j=parse_time_expression(t1);         asc.ptr=k; asc.chr=a;         ps('PARSE_TIME_EXPRESSION Return Code:  '); pnum(j); ps('   ERROR.FLAG:  '); pnum(error.flag); nl;         call print_vector(t1,'***** Fade Time Value Returned:  '); nl;      end;      if parse_time_expression(t1) then error.flag=e.format;      else call time_to_index(t1,fade,period.index);   end;   else call time_to_index(default.fade,fade,period.index);end;if debug.parsing then do;   nl; ps('At end of parsing ERROR.FLAG:  '); pnum(error.flag); nl;   nl; ps('Press <RETURN> to continue');   call tty_wait; input i;end;/* $PAGE *//* NOTE: M.START, M.END, L.START, L.STOP and FADE are all in index format now. *//* do some simple bounds checking now to check for fatal errors */if error.flag=0 then do;   if (compare_vectors(l.start,l.stop              ,3)>0) /* start > stop */   or (compare_vectors(l.stop ,location(valid.data),3)>0) /* beyond end of file */   or (compare_vectors(l.stop ,m.end               ,3)>0) /* loop stop > mark.end */   or (compare_vectors(m.start,l.start             ,3)>0) /* mark.start > loop start */   then error.flag=e.times;end;if error.flag<>0 then call return_to_sfm(error.flag); /* return if any fatal errors */call sub_len_from_len(l.start,m.start,t1);if        compare_vectors(fade,t1,3)>0then call copy_vector    (fade,t1,3);      /* limit crossfade time */call sub_len_from_len(location(valid.data),zero.one.zero,t1);if        compare_vectors(l.stop,t1,3)>0then call copy_vector    (l.stop,t1,3); /* allow one extra sector at end */call sub_len_from_len(l.stop,l.start,t1);if        compare_vectors(fade,t1,3)>0then call copy_vector    (fade,t1,3);      /* limit crossfade time */call add_len_to_len(zero.one.zero,l.stop,t1); /* add extra sector to new length */call sub_len_from_len(t1,m.start,new.len);file2;                                   /* point at output FCB #2 *//* allocate space for new file */if new_file(new.len)<>0 then do;         /* no room for new file */   if error.flag<>0 then call file(1,0); /* had error, so restore current file to original sound file */   call return_to_sfm(ERROR.FLAG);       /* Returns current ERROR.FLAG status */end;/* $SUBTITLE  File Created -- Now Perform Extract and Splice */clear; call pos(7,0); ps('Please wait....');if debug.loop then do;   call set_scroll(4,24);   call pos(8,0); call print_vector(new.len,'Just allocated new file of length:'); nl;   file1; ps('PERIOD.INDEX: '); pnum(period.index);  nl; file2;   call print_vector(m.start,'MARK.START: '); nl;   call print_vector(m.end  ,'MARK.END:   '); nl;   call print_vector(l.start,'L.START:    '); nl;   call print_vector(l.stop ,'L.STOP:     '); nl;   call print_vector(fade   ,'FADE:       '); nl;end;file1; /* point back at FCB #1 (the original sound file) */tbuf(0)=file.data.type; /* pick up data from file 1 */tbuf(1)=period.index;tbuf(2)=nyquist.freq;tbuf(3)=core(octave);tbuf(4)=core(octave+1);call add_len_to_addr(m.start,location(f.data.index),in.start); /* start addr of input samps */call add_len_to_addr(new.len,location(f.data.index),t2);       /* restore device byte */call add_len_to_addr(m.start,t2,t2);            /* add in mark.start offset */call sub_len_from_addr(t2,zero.zero.one,in.end); /* end addr of input samps */file2; /* Point at newly allocated sound file; copy info to new file */file.data.type=tbuf(0)\looped.data; /* store data on file 2 */period.index  =tbuf(1);nyquist.freq  =tbuf(2);core(octave)  =tbuf(3);core(octave+1)=tbuf(4);call copy_vector(location(valid.data),new.len,3); /* copy length for new sound *//* Convert index of last sample to time at last sample */call copy_vector     (location(data.end),location(valid.data),3);call sub_len_from_len(location(data.end),zero.zero.one,t1); /* subtract one from DATA.END */call index_to_time   (location(data.end),t1,period.index);  /* convert samples to time *//* convert L.START, L.STOP to index relative to M.START */call sub_len_from_len(l.stop,m.start,t1);call copy_vector     (l.stop,t1     ,3);call sub_len_from_len(l.start,m.start,t1);call copy_vector     (l.start,t1     ,3);call copy_vector     (total.length,l.stop,3);      /* save total.length for Synclavier */call sub_len_from_len(l.stop,l.start,loop.length); /* save loop.length  for Synclavier */if debug.loop then do;   nl; ps('Loop Start & End Relative to M.START');       nl;   call print_vector(l.start     ,'   L.START:       '); nl;   call print_vector(l.stop      ,'   L.STOP:        '); nl;   call print_vector(total.length,'   TOTAL.LENGTH:  '); nl;   call print_vector(loop.length ,'   LOOP.LENGTH:   '); nl;end;call caption_assign('Looping Sound File'); /* Assign caption to new sound file *//* Set up the basic sound file symbols */call add_symbol(zero.vector,       'Origin');      /* ORIGIN Symbol */call add_symbol(location(data.end),'End'   );      /* END    Symbol */call copy_vector(mark.start,zero.vector,       3); /* Mark START (#1) */call copy_vector(mark.end,  location(data.end),3); /* Mark END   (#2) */call copy_vector(out.start,location(f.data.index),3); /* look up start address of output samples */call add_len_to_addr  (location(valid.data),out.start,t1); /* compute end address of output samples */call sub_len_from_addr(t1,zero.zero.one,out.end);/* $SUBTITLE  Stage 1:  Perform Extract Operation */blen(0)=0; blen(1)=buflen; blen(2)=0; /* set up buffer len in index format *//* 1. first do the extract of the whole new file */if debug.loop then do;   nl; ps('Beginning Extract Procedure'); nl;   file1;   call sub_len_from_addr(in.start ,location(f.data.index),t4);   call print_vector(t4,'   IN.START:  '); nl;   call sub_len_from_addr(in.end   ,location(f.data.index),t4);   call print_vector(t4,'   IN.END:    '); nl;   file2;   call sub_len_from_addr(out.start,location(f.data.index),t4);   call print_vector(t4,'   OUT.START: '); nl;   call sub_len_from_addr(out.end  ,location(f.data.index),t4);   call print_vector(t4,'   OUT.END:   '); nl;end;do while (compare_addrs(in.start,in.end)<=0)   /* loop until IN.START=IN.END */   and   (error.flag=0)                          /* and no errors encountered */   and   (break.rcvd=0);                         /* and break key not hit */   call sub_len_from_len(in.end,in.start,t1); /* compute samples left to process */   call add_len_to_len  (zero.zero.one,t1,t1);   if        compare_vectors(t1,blen,3)>0 /* if samples left greater than buffer size */   then call copy_vector    (t1,blen,3);  /* limit amount to copy this time through loop */   if read_words(in.start,t1,buf1)<>0 then do; /* read in a buffer full */      if write_words(out.start,t1,buf1,tbuf)=0 /* write buffer to new sound file */      then error.flag=e.sys.error; /* this should never occur if program is debugged */   end;   else error.flag=e.sys.error; /* this should never occur if program is debugged */   call add_len_to_addr(t1, in.start, in.start);         /* update current ptr into original sound file */   call add_len_to_addr(t1,out.start,out.start);         /* update current ptr into new sound file */end; /* end of loop over sectors in original sound file *//* $SUBTITLE  Stage 2:  Perform Crossfade Operation *//* 2.  Now construct the crossfade region for perfect looping */call sub_len_from_len(l.stop,fade,t1);call add_len_to_addr (t1,    location(f.data.index),in.start);call add_len_to_addr (l.stop,location(f.data.index),in.end);call sub_len_from_len(l.start,fade,t1);call add_len_to_addr (t1,    location(f.data.index),t2);if debug.loop then do; nl; ps('Beginning Crossfade Procedure'); nl; end;call copy_vector(t4,fade,3);fade.accum=1;                            /* start with 1 */do while t4(1) IGE 256;   t4(2)=shr(t4(2),1)\(shl(t4(1)&1,7));  /* move into bit 7 */   t4(1)=shr(t4(1),1);   fade.accum=shl(fade.accum,1);         /* go up by powers of two */end;call copy_vector(fade,t4,3); fade.max=shl(t4(1),8)+t4(2); fade.val=0; fade.count=0; /* init for crossfade */do while (compare_addrs(in.start,in.end)<=0) /* loop until IN.START=IN.END */   and   (error.flag=0)                      /* and no errors encountered */   and   (break.rcvd=0);                     /* and break key not hit */   call sub_len_from_len(in.end,in.start,t1); /* compute samples left to process */   call add_len_to_len(zero.zero.one,t1,t1);   if        compare_vectors(t1,blen,3)>0 /* if samples left greater than buffer size */   then call copy_vector    (t1,blen,3);  /* limit amount to copy this time through loop */   if debug.loop then do;      nl;      call sub_len_from_addr(in.start,location(f.data.index),t4);      call print_vector(t4,'   IN.START:     '); nl;      call sub_len_from_addr(in.end,location(f.data.index),t4);      call print_vector(t4,'   IN.END:       '); nl;      call sub_len_from_addr(t2,location(f.data.index),t4);      call print_vector(t4,'   T2:           '); nl;      call print_vector(t1,'   T1(buf len):  '); nl;      ps('   FADE.VAL:      '); pnum(fade.val);  nl;      ps('   FADE.MAX:      '); pnum(fade.max);  nl;   end;   if read_words(in.start,t1,buf1)=0 then error.flag=e.sys.error; /* read in a buffer full */   if read_words(t2      ,t1,buf2)=0 then error.flag=e.sys.error; /* read in a buffer full */   do i=0 to shl(t1(1),8)+t1(2)-1; /* loop over samples in buffer */      j=buf1(i); k=buf2(i);        /* get absolute values of sample points */      if j<0 then do; sign1=1; j=-j; end; else sign1=0;      if k<0 then do; sign2=1; k=-k; end; else sign2=0;      /* compute crossfade value */      write(5)=j; write(6)=fade.max-fade.val; j=read(5);      write(7)=fade.max; j=read(5);      if read(4) IGE shr(fade.max,1) then j=j+1;      write(5)=k; write(6)=fade.val; k=read(5);      write(7)=fade.max; k=read(5);      if read(4) IGE shr(fade.max,1) then k=k+1;      if sign1<>0 then j=-j;    /* restore proper sign */      if sign2<>0 then k=-k;    /* restore proper sign */      buf1(i)=j+k;              /* mix values          */      fade.count=fade.count+1;  /* check fade count    */      if fade.count=fade.accum then do;         fade.count=0; fade.val=fade.val+1;      end;   end;   if write_words(in.start,t1,buf1,tbuf)=0 /* write buffer to new sound file */   then error.flag=e.sys.error;   call add_len_to_addr(t1,in.start ,in.start);        /* update current ptr into original sound file */   call add_len_to_addr(t1,t2       ,t2);              /* update current ptr into original sound file */end; /* end of loop over sectors in original sound file *//* $SUBTITLE  Clean Up By Splicing Extra Sector of Sound at End */if debug.loop then do;   nl; call sub_len_from_addr(in.start,location(f.data.index),t4);   call print_vector(t4,'   IN.START:     '); nl;   call sub_len_from_addr(in.end,location(f.data.index),t4);   call print_vector(t4,'   IN.END:       '); nl;   call sub_len_from_addr(t2,location(f.data.index),t4);   call print_vector(t4,'   T2:           '); nl;   ps('   FADE.VAL:      '); pnum(fade.val);  nl;   ps('   FADE.MAX:      '); pnum(fade.max);  nl;end;/* write out final extra sector */t1(0)=0; t1(1)=1; t1(2)=0;if read_words(t2,t1,buf1)=0 then error.flag=e.sys.error; /* read in a buffer full */k=0;do i=0 to 245; /* do a little decay -- leaves 10 samples the same as at L.START */   j=buf1(i+10);   if j<0 then do; sign1=1; j=-j; end; else sign1=0;   write(5)=j; write(6)=246-i; j=read(5);   write(7)=246; j=read(5);   if read(4) IGE shr(246,1) then j=j+1;   if sign1<>0 then j=-j;   buf1(i+10)=j;end;if write_words(in.start,t1,buf1,tbuf)=0 then error.flag=e.sys.error; /* write buffer to new sound file */if error.flag<>0then call file(1,0); /* had error, so restore current file to original sound file */else file2;          /* force changes related to new sound file to get saved on disk */if debug.loop then do;   nl; ps('ERROR.FLAG:  '); pnum(error.flag); nl;   nl; ps('Press <RETURN> to continue');   call tty_wait; input i;end;call return_to_sfm(ERROR.FLAG); /* Returns current ERROR.FLAG status */