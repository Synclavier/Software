/* 20-MISC  $TITLE  Some Miscellaneous Routines *//* Copyright (c) 1985 by New England Digital Corporation *//* This program represents proprietary information and may not be released   publically without written permission from New England Digital Corp. */sfm_overlay:proc(return.code);   dcl return.code fixed;   call openfile(SFM.FILE,loc.p1,1);   call tty_wait; disable;   ovl.error=return.code; /* pass error code back to SFM module */   if overlayed.from.sfm then core(loc.rst)=10; /* do    warm boot of SFM */   else                       core(loc.rst)=2;  /* force cold boot of SFM */   sfm.intact=1; /* means SFM high-core is still valid */   call overlay(f#ms_sector,f#ls_sector,f#words);end sfm_overlay;pause:  proc; /* disables interrupts & pauses until return key is pressed */   dcl (save,i,j) fixed;   nl; nl; ps('Press <RETURN> to continue ');   call tty_wait; save=read("314"); disable;   i=read("50");   if i=0 then do j=1 to 60; write(3)=0; end;   do while (i&"177")<>A.CR;      i=read("50");      if i=0 then do j=1 to 60; write(3)=0; end;   end;   write("314")=save; write("1")=save;end;   file_missing:  proc(name); /* prints prompt & returns to SFM */   dcl name fixed array;   if overlayed.from.sfm then clear;   nl; ps('System file "'); ps(name);   psr('" was not found on your disk.');   if overlayed.from.sfm then do;      call pause;      call sfm_overlay(e.sys.error); /* return to SFM */   end;   else do;      call tty_wait; disable; call exit(0); /* quit to monitor */   end;end file_missing;filename.valid:proc(name) fixed; /* returns 1 if filename is valid, else 0 */   dcl name fixed array;   dcl i    fixed;     do i=0 to name(0)-1; if valid_filechar(byte(name,i))=0 then return 0; end;   return 1;end filename.valid;strexct: proc(s,t,l,u); /* extract Lower to Upper chars from T, put in S */   dcl (s,t) fixed array; /* strings to extract to and from */   dcl (l,u) fixed; /* lower and upper chars to extract */   dcl (i,j) fixed;   j=0;   do i=l to u;      call pbyte(s,j,byte(t,i)); /* extract one char */      j=j+1;   end;   s(0)=j; /* set length */end strexct;/* $SUBTITLE  A Max Value Routine */float:  proc(num) floating;   dcl num floating array;   return num(0);end float;max:  proc(buf,len,type) fixed; /* returns max of an array of numbers */   dcl buf    fixed array;   dcl len    fixed; /* length of array */   dcl type   fixed; /* -1 for neg. max, 0 for absolute max, 1 for pos. max */   dcl maxval fixed;   dcl i      fixed;   #greater:proc(a,b) fixed; /* returns 1 if a>b, in range -32768,+32767 */      dcl (a,b)   fixed;      dcl (g1,g2) fixed;      g1=((a&"100000")=0); /* test to see if positive number */      g2=((b&"100000")=0);      if (g1 xor g2) then return g1;      if a>b then return 1;      return 0;   end #greater;   do case type+1;      do; /* negative max */         maxval=buf(0);         do i=1 to len-1;            if #greater(maxval,buf(i)) then maxval=buf(i);         end;      end;      do; end; /* absolute max */      do; /* positive max */              maxval=buf(0);         do i=1 to len-1;            if #greater(buf(i),maxval) then maxval=buf(i);         end;      end;   end; /* of do case */   return maxval;end max;/* $SUBTITLE  Some Special Terminal Routines */dcl DOUBLE_WIDE     data (3,"H231B","H0036"); /* Make current line double width */dcl SPACE_5         data ('    '); /* 5 spaces */dcl CMDLINE         lit '22';      /* line number of command line */#reverse:  proc(state); /* turn reverse video on or off */   dcl state     fixed;   dcl cur.state fixed;   if state=cur.state then return;   cur.state=state;   call pc(A.ESC); call pc(A.LBRACKET);   if state then call pc(A.0+7);   else          call pc(A.0+0);   call pc("155");end #reverse;dcl REVERSE lit 'call #reverse';#r_video: proc(str); /* prints a string in reverse video */   dcl str fixed array;   reverse(1); ps(str); reverse(0);end #r_video;dcl R_VIDEO lit 'call #r_video';#pcmd:  proc(str); /* prints a message on the command line */   dcl str fixed array;   call pos(cmdline,0); call erase_line; nl; call erase_line;   call pos(cmdline,0); reverse(1); ps(str); reverse(0);end #pcmd;dcl PCMD lit 'call #pcmd';peek:  proc fixed; /* returns next char in input buf or (-1) if none */   dcl c fixed;   c=(-1);   if in.buf(0)<>0 then c=byte(in.buf,in.buf(0))&"177";   return c;end peek;/* $SUBTITLE  Routines to Run Timer */dcl (elapsed.ms,elapsed.sec)  fixed; /* clock timer variables */dcl (elapsed.min,elapsed.hrs) fixed; /* clock timer variables */dcl sampled.ms                fixed; /* temp used by timer */dcl refresh.period            lit '1000'; /* milliseconds between display refreshes */dcl et                        data ('Elapsed time is ');dcl show.time lit 'do; reverse(0); call pos(cmdline+2,1); ps(ET); call redraw.clock.time; end';init.clock.time:  proc; /* reset clock timber to zero */   elapsed.ms=0; elapsed.sec=0; elapsed.min=0; elapsed.hrs=0;   sampled.ms=milliseconds;end init.clock.time;update.clock.time:  proc; /* updates values of elapsed msec, sec, and min */   /* for this clock to work, this routine must be called at least      once every 10 or 15 seconds, or so.  And interrupts must always      be enabled inorder to maintain accuracy */   elapsed.ms=elapsed.ms+(milliseconds-sampled.ms);   sampled.ms=milliseconds;   do while elapsed.ms>=1000; /* let clock catch up with real world */      elapsed.sec=elapsed.sec+1;      if elapsed.sec>=60 then do;         elapsed.min=elapsed.min+1;         if elapsed.min>=60 then do;            elapsed.hrs=elapsed.hrs+1;            elapsed.min=elapsed.min-60;         end;         elapsed.sec=elapsed.sec-60;      end;      elapsed.ms=elapsed.ms-1000;   end;end update.clock.time;redraw.clock.time:  proc; /* draws current elapsed time at cursor pos */   call update.clock.time;   pnum(elapsed.hrs/10); pnum(elapsed.hrs mod 10); call pc(a.colon);   pnum(elapsed.min/10); pnum(elapsed.min mod 10); call pc(a.colon);   pnum(elapsed.sec/10); pnum(elapsed.sec mod 10);end redraw.clock.time;