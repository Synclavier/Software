/* 23-SYN  $TITLE  Routines to Set Up Synclavier RTP Timbres *//* Copyright (c) 1984 by New England Digital Corporation *//* This program represents proprietary information and may not be released   publically without written permission from New England Digital Corp. */syn_overlay:  proc(device,start,len); /* overlays to Synclavier RTP */   dcl (device,start,len) fixed;   enable; call tty_wait; disable;   /* Set up special info for new Synclavier operating system */   if examount<>0   then core(loc.synmed)=1;           /* timbre is in ext mem */   else core(loc.synmed)=0;           /* timbre is in internal memory */   core(loc.synmisc)=0;               /* null ptr to misc area */   if examount<>0   then core(loc.syntimb)=0;          /* timbre starts at sector zero of ext mem */   else core(loc.syntimb)=timbre.ptr; /* ptr to start of timbre in core */   core(loc.synseq )=0;               /* null ptr to sequence */   core(loc.synstat)=0;               /* zero status word */   core(loc.synret) =loc.mon;         /* not used, but quit to MONITOR if bomb */   call overlay(device,start,len);end syn_overlay;DEPOSIT:PROC(NUM,VAL);   DCL (X,NUM,VAL) FIXED;   DO X=1 TO NUM; CORE(TIMBRE.PTR)=VAL; TIMBRE.PTR=TIMBRE.PTR+1; END;END DEPOSIT;DEPOSIT_ARRAY: PROC(BUF,LEN);   DCL BUF     FIXED ARRAY;   DCL (X,LEN) FIXED;   DO X=0 TO LEN-1; CORE(TIMBRE.PTR)=BUF(X); TIMBRE.PTR=TIMBRE.PTR+1; END;END DEPOSIT_ARRAY;ZERO_TIMBRE: PROC; /* SET UP A NULL TIMBRE (JUST A SINE WAVE) */   TIMBRE.PTR=FREE.BASE;  /* INIT TIMBRE PTR */   CALL DEPOSIT( 1,   0); /* PROVIDE 0 DELAY */   CALL DEPOSIT( 1,  45); /* => 25 MILLISECOND ATTACK */   CALL DEPOSIT( 1,   0); /* INITIAL DECAY */   CALL DEPOSIT( 1,  25); /* FINAL DECAY */   CALL DEPOSIT( 1,1000); /* PEAK LEVEL */   CALL DEPOSIT( 1,1000); /* SUSTAIN LEVEL */   CALL DEPOSIT( 6,   0); /* ZERO FM ENVELOPE FOR NOW */   CALL DEPOSIT( 1,1000); /* SINE WAVE */   CALL DEPOSIT(23,   0); /* OTHER 23 HARMONIC COEFS */   CALL DEPOSIT( 1,4400); /* 440.0 PARTIAL TUNING */   CALL DEPOSIT( 6,   0); /* NO VIBRATO OR PORTAMENTO */   CALL DEPOSIT( 1,1000); /* PROVIDE A RATIO OF 1 */   CALL DEPOSIT( 1,   0); /* DECAY/HARMONIC ADJUST OF ZERO */   CALL DEPOSIT( 1,1000); /* AND A NEW CHORUS VALUE OF 1.000 */   CALL DEPOSIT(46,    0); /* PROVIDE ZEROES FOR OTHER 3 PARTIAL TIMBRES */   CALL DEPOSIT(46,    0);   CALL DEPOSIT(46,    0);   CALL DEPOSIT( 6,    0); /* PROVIDE ZEROES FOR MISC BITS & FILTER SETTINGS */   CALL DEPOSIT( 1, 1000); /* PROVIDE 1.000 CHORUS FUNCTION */   CALL DEPOSIT( 1,"172"); /* PROVIDE DEFAULT RTE BITS OF PEDAL, P1, P2, P3, P4 */   TIMBRE.LEN=4*46+8;      /* 192 WORDS FOR DEFAULT TIMBRE */END ZERO_TIMBRE;FIND.PEAK.PTR:  PROC(FRAME) FIXED; /* RETURNS ADDR OF PEAK FOR DESIRED FRAME */   DCL FRAME FIXED; /* FRAME TO LOOK AT */   IF FRAME=0   THEN RETURN FREE.BASE+4;                              /* PTR TO PARTIAL TIMBRE DEF */   ELSE RETURN (FREE.BASE+46+12+(FRAME-1)*FRAME.LENGTH); /* PTR TO FRAME DEF */END FIND.PEAK.PTR;/* $SUBTITLE  Routines to Create Partials and Timbre Frames and Write Timbre to Ext Mem */CREATE.PARTIAL:  PROC(ATTCK,COEFS,NCOEFS,PAR.TUNING); /* SETS UP A PARTIAL IN CORE */   DCL ATTCK      FIXED;       /* ATTACK TIME FOR PARTIAL  */   DCL COEFS      FIXED ARRAY; /* HARMONIC COEFS & PHASES  */   DCL NCOEFS     FIXED;       /* NUMBER OF HARMONIC COEFS */   DCL PAR.TUNING FIXED;       /* PARTIAL TUNING           */   LOAD 0; WRITE(4)=ATTCK; DIV 36864; ATTCK=RES; /* ADJUST FOR ANCIENT BUG */   IF READ(4)<>0 THEN ATTCK=ATTCK+1;   CALL DEPOSIT( 1,         0); /* PROVIDE 0 DELAY */   CALL DEPOSIT( 1,     ATTCK); /* MILLISECOND ATTACK */   CALL DEPOSIT( 1,         0); /* INITIAL DECAY */   CALL DEPOSIT( 1,        50); /* FINAL DECAY */   CALL DEPOSIT( 1,         0); /* NO PEAK LEVEL YET */   CALL DEPOSIT( 1,         0); /* SUSTAIN LEVEL - WILL SET LATER */   CALL DEPOSIT( 6,         0); /* ZERO FM ENVELOPE FOR NOW */   COEFS(0)=COEFS(0)&1023; /* MASK OFF PHASE FOR COEF 0 OF FIRST WAVE */   IF NCOEFS<24 THEN DO;      CALL DEPOSIT_ARRAY(COEFS,NCOEFS); /* HARMONIC COEFS */      CALL DEPOSIT(24-NCOEFS,0);        /* ZERO UNUSED HARMONIC COEFS */   END;   ELSE CALL DEPOSIT_ARRAY(COEFS,24); /* 24 HARMONIC COEFS */   CALL DEPOSIT( 1,PAR.TUNING); /* SET PARTIAL TUNING */   CALL DEPOSIT( 6,         0); /* NO VIBRATO OR PORTAMENTO */   CALL DEPOSIT( 1,      1000); /* PROVIDE A RATIO OF 1 */   CALL DEPOSIT( 1,         0); /* DECAY/HARMONIC ADJUST OF ZERO */   CALL DEPOSIT( 1,      1000); /* AND A NEW CHORUS VALUE OF 1.000 */END CREATE.PARTIAL;CREATE.FRAME:  PROC(ATTCK,COEFS,NCOEFS,CENTS);   DCL ATTCK  FIXED;       /* ATTACK TIME FOR FRAME    */   DCL COEFS  FIXED ARRAY; /* HARMONIC COEFS & PHASES  */   DCL NCOEFS FIXED;       /* NUMBER OF HARMONIC COEFS */   DCL CENTS  FIXED;       /* CENTS TO GLIDE           */   /* NOTE:  A TIMBRE FRAME STARTS WITH A -1, CONTAINS A TYPE WORD (0),   A LENGTH WORD (172), 5 ZEROES,  12 PARAMETERS, 24 COEFFICIENTS,   AND 128 DATA WORDS - THE FIRST BYTE OF THE WAVE TABLE IS STORED IN   THE LOWER HALF OF THE FIRST DATA WORD, THEN THE UPPER HALF */   CALL DEPOSIT(1,          -1); /* DENOTE FRAME STRUCTURE TO FOLLOW */   CALL DEPOSIT(1,           0); /* FRAME TYPE */   CALL DEPOSIT(1,FRAME.LENGTH); /* FRAME LENGTH */   CALL DEPOSIT(5,           0); /* MISC PARAMETERS */   CALL DEPOSIT(1,           0); /* FRAME DELAY */   CALL DEPOSIT(1,       ATTCK); /* FRAME ATTACK */   CALL DEPOSIT(1,           0); /* SELECT S-CURVE CROSSFADE */   CALL DEPOSIT(1,           0); /* NO PITCH RANDOMNESS */   CALL DEPOSIT(1,           0); /* NO PEAK LEVEL YET */   CALL DEPOSIT(5,           0); /* NULL PARAMETERS */   CALL DEPOSIT(1,       CENTS); /* PITCH GLIDE */   CALL DEPOSIT(1,           0); /* NO TIMBRE FRAME LOOPING */   IF NCOEFS<24 THEN DO;      CALL DEPOSIT_ARRAY(COEFS,NCOEFS); /* HARMONIC COEFS */      CALL DEPOSIT(24-NCOEFS,0);        /* ZERO UNUSED HARMONIC COEFS */   END;   ELSE CALL DEPOSIT_ARRAY(COEFS,NCOEFS); /* UP TO 128 HARMONIC COEFS */   /* WILL CALCULATE TABULAR WAVESHAPE LATER - FILL AREA WITH ZEROES FOR NOW */   IF NCOEFS>24 THEN CALL DEPOSIT(128+24-NCOEFS,0);   ELSE              CALL DEPOSIT(128,          0);END CREATE.FRAME;put.timbre.in.xmem: proc; /* copies timbre to external memory */   if examount=0 then return;   write(mam)=0; write(mal)=0;           /* set addr to sector 0, word 0 */   call copy.out(timbre.ptr,timbre.len); /* dump out whole timbre */end put.timbre.in.xmem;/* $SUBTITLE  Timbre Binding Routine */bind_timbre:  proc; /* finishes setting up Synclavier timbre */   dcl phase.mask    fixed;   dcl (max,raw.max) floating;   dcl frm           fixed;   dcl sustain.ptr   fixed;   dcl (i,j,k)       fixed;   /* This routine is a destructive routine.  It should only be called      when you are creating the final timbre definition before overlaying      to the Synclavier RTP. */   /* NOTE:  3 NULL PARTIAL TIMBRES MUST BE PROVIDED.  DUE TO A PROBLEM IN   SYNCLAVIER OPERATING SYSTEM, ALL 4 PARTIALS MUST APPEAR AND CAN   NOT BE SUPPRESSED WITH A (-2).  USE A BLOCK OF 46 ZEROES. */   TIMBRE.PTR=FREE.BASE+TIMBRE.LEN; /* INIT PTR TO NEXT FREE WORD */   CALL DEPOSIT(46,    0); /* PROVIDE ZEROES FOR 3 ADDITIONAL PARTIAL TIMBRES */   CALL DEPOSIT(46,    0);   CALL DEPOSIT(46,    0);   CALL DEPOSIT( 6,    0); /* PROVIDE ZEROES FOR MISC BITS & FILTER SETTINGS */   CALL DEPOSIT( 1, 1000); /* PROVIDE 1.000 CHORUS FUNCTION */   CALL DEPOSIT( 1,"172"); /* PROVIDE DEFAULT RTE BITS OF PEDAL, P1, P2, P3, P4 */   TIMBRE.LEN=TIMBRE.LEN+3*46+8; /* FINAL TIMBRE LENGTH */   /* AT THIS POINT THE RAW TIMBRE IS ALL SET UP */   /* now compute final timbre according to menu settings */   timbre.ptr =free.base;    /* reset ptr to start of timbre */   sustain.ptr=timbre.ptr+5; /* save ptr to partial sustain level */   frm        =0;            /* current frame is now 0 */   if ncoefs.use>ncoefs.stored then ncoefs.use=ncoefs.stored; /* limit */   if use.phase then phase.mask="177777"; /* use to pass upper 6 bits of phase info */   else              phase.mask="001777"; /* use to mask off upper 6 bits of phase info */   if not track.pitch then core(timbre.ptr+36)=default.tuning; /* set up for default keyboard tuning */   do i=12 to 12+23; /* apply noise floor and phase */      j=timbre.ptr+i;                  /* precompute ptr to coef */      if (core(j)&1023) ILE noise.floor      then core(j)=0;                  /* coef falls below threshold */      else core(j)=core(j)&phase.mask; /* apply phase info */   end;   call calcwave(location(timbre.ptr+12),24); /* need to get p-to-p of wave */   float.peak(0)=core(find.peak.ptr(frm))*last.max/255;   max=float.peak(0);  /* init max to peak on zeroth frame */   /* $PAGE */   timbre.ptr=timbre.ptr+46;       /* jump to frame 1 */   do while core(timbre.ptr)=(-1); /* step over frames to bind */      frm=frm+1;      if not track.pitch then core(timbre.ptr+18)=0; /* zero out pitch glide info */      do i=20 to 20+ncoefs.use-1;                /* apply noise floor and phase */         j=timbre.ptr+i;                         /* precompute coef ptr */         if (core(j)&1023) ILE noise.floor then core(j)=0; /* coef falls below threshold */         else core(j)=core(j)&phase.mask;        /* apply phase info */      end;      if ncoefs.use<24 then do i=20+ncoefs.use to 20+23;         core(timbre.ptr+i)=0; /* zero out unused coefficients */      end;      call calcwave(location(timbre.ptr+20),ncoefs.use); /* need to get p-to-p of wave */      float.peak(frm)=core(find.peak.ptr(frm))*last.max/255;      if float.peak(frm)>max then max=float.peak(frm);   /* new peak max */      /* load tabular wave into timbre area */      do i=0 to 127; core(timbre.ptr+44+i)=wave.msb(i); end;      timbre.ptr=timbre.ptr+frame.length; /* step to next frame or partial */   end; /* of stepping over frames to bind */   /* perform final rescaling of peak values before creation of timbre */   do i=0 to frames-1;      core(find.peak.ptr(i))=int(float.peak(i)*1000/max+.5); /* rescaled to range 0 - 1000 */   end;   core(sustain.ptr)=core(find.peak.ptr(frames-1)); /* set partial sustain to this value */end bind_timbre;/* $SUBTITLE  Some Debugging Timbre Display Routines */display.partial: proc(ptr,num); /* display partial timbre pointed to by PTR */   dcl ptr fixed; /* ptr to partial timbre */   dcl num fixed; /* number of partial */   dcl i   fixed;   print 'Partial Timbre at ',ptr,'  Frame Number: ',num;   print '  Delay   ',core(ptr+00),'  Attack ',core(ptr+01),'  Init Dec ',core(ptr+02);   print '  Fin Dec ',core(ptr+03),'  Peak V ',core(ptr+04),'  Sust V   ',core(ptr+05);   print '  Harmonic Phases and Coefs',;   do i=0 to 23;      if (i mod 4)=0 then do; print; print '    ',i,':',; end;      print shr(core(ptr+i+12),10),core(ptr+i+12)&1023,' ',;   end;   print;   print '  Par Tun ',core(ptr+36),'  FM Rat ',core(ptr+43),'  Chorus   ',core(ptr+45);   print;   print 'Press return to continue  ',; input i; print; print;   return i;end display.partial;display.frame:  proc(ptr,num);  /* display timbre frame pointed to by PTR */   dcl ptr fixed; /* ptr to timbre frame */   dcl num fixed; /* number of current frame */   dcl i   fixed;   print 'Timbre Frame #',num,' at ',ptr,'  Type: ',core(ptr+1),'  Length: ',core(ptr+2);   print '  Delay   ',core(ptr+08),'  CrossF ',core(ptr+09),'  Splc Cur ',core(ptr+10);   print '  Pit Rnd ',core(ptr+11),'  Peak V ',core(ptr+12),'  Partl V  ',core(ptr+13);   print '  Glide   ',core(ptr+18),'  Loop F ',core(ptr+19);   print '  Harmonic Phases and Coefs',;   do i=0 to 23;      if (i mod 5)=0 then do; print; print '    ',i,':',; end;      print shr(core(ptr+i+20),10),core(ptr+i+20)&1023,' ',;   end;   print;   print '  Tabular Wave',;   do i=0 to 127;      if (i mod 12)=0 then do; print; print '    ',; end;      print core(ptr+i+44),;   end;   print;   print 'Press return to continue  ',; input i; print; print;   return i;end display.frame;display.timbre:  proc(ptr); /* display timbre pointed to by PTR */   dcl ptr   fixed; /* ptr to timbre */   dcl (i,j) fixed;   clear; call tty_wait; disable;   i=display.partial(ptr,0);   ptr=ptr+46;   j=1;   do while core(ptr)=(-1);      if i<=j then i=display.frame(ptr,j);      ptr=ptr+frame.length;      j=j+1;   end;   enable;end display.timbre;