/* 21-CALCW  $TITLE  High-Speed Double Precision CALCWAVE Routine *//* Copyright (c) 1984 by New England Digital Corporation *//* This program represents proprietary information and may not be released   publically without written permission from New England Digital Corp. *//* literal to do 32-bit add; output must not be input1 */dcl add1  lit 'olsb=ilsb1+ilsb2;';dcl add2  lit 'omsb=imsb1+imsb2;';dcl add3  lit 'if olsb ilt ilsb1 then omsb=omsb+1;';dcl add   lit 'add1;add2;add3;';/* literal to subtract */dcl sub1  lit 'omsb=imsb1-imsb2;';dcl sub2  lit 'if ilsb2 igt ilsb1 then omsb=omsb-1;';dcl sub3  lit 'olsb=ilsb1-ilsb2;';dcl subtract lit 'sub1;sub2;sub3;';DCL STAB     (255) FIXED; /* SINE TABLE BUFFER */DCL WAVE.MSB (255) FIXED; /* 32-BIT FIXED POINT TABULAR WAVE */DCL WAVE.LSB (255) FIXED;DCL OFFSET.MSB     FIXED; /* ACCUMULATED DC OFFSET VALUE FOR A WAVE */DCL OFFSET.LSB     FIXED;DCL LAST.MAX       FLOATING; /* MAX SAMPLE IN LAST WAVE TABLE BEFORE RESCALING *//* THE FOLLOWING SUBROUTINE IS CALLED FROM 'CALCWAVE' TO ADD HARMONICS .  TO THE GLOBAL ARRAYS 'WAVE.MSB' AND 'WAVE.LSB'.  'ADDCOEF' TAKES TWO .  ARGUMENTS:  THE COEFFICIENT NUMBER (1=FUNDAMENTAL, 2=SECOND .  HARMONIC, ETC), AND A RELATIVE AMPLITUDE (RANGE 0-1000, WHICH .  IS 0 TO 100.0 ON THE REAL-TIME SYSTEM. */ADDCOEF:PROC(NUM,COEF); /* PASS HARMONIC NUMBER AND VALUE (0-1000) */   DCL (I,J,K,NUM,COEF) FIXED;   DCL (FCOEF)          FIXED;   IF (COEF&1023)=0 THEN RETURN; /* NOTHING TO ADD IN */   J=SHR(COEF,8)&"374"; /* COMPUTE STARTING PHASE */   FCOEF =(COEF&1023); /* TRASH PHASE INFO */   /* KEEP TRACK OF CUMULATIVE WAVE RANGE */   LOAD FCOEF; MUL 32767;   OFFSET.MSB=OFFSET.MSB+READ(4); OFFSET.LSB=OFFSET.LSB+RES;   IF OFFSET.LSB ILT RES THEN OFFSET.MSB=OFFSET.MSB+1;   DO I=0 TO 255; /* CYCLE THROUGH */      /* ADD IN HARMONIC */      LOAD FCOEF; MUL STAB(J);      WAVE.MSB(I)=WAVE.MSB(I)+READ(4); WAVE.LSB(I)=WAVE.LSB(I)+RES;      IF WAVE.LSB(I) ILT RES THEN WAVE.MSB(I)=WAVE.MSB(I)+1;      J=(J+NUM)&255; /* INCREMENT PHASE COUNTER */   END;END ADDCOEF;PACKWAVE:  PROC; /* PACKS 256 PT WAVE INTO FIRST 128 WORDS */   DCL I FIXED;   DO I=0 TO 255 BY 2;      WAVE.MSB(SHR(I,1))=WAVE.MSB(I)\SHL(WAVE.MSB(I+1),8);   END;END PACKWAVE;/* $SUBTITLE  CALCWAVE Routine *//* THE ROUTINE 'CALCWAVE' IS USED TO CALCULATE AN ENTIRE WAVE SHAPE..  IT IS PASSED A FIXED POINT ARRAY CONTAINING A LIST OF HARMONIC.  COEFFICIENTS AND A FIXED POINT VALUE WHICH IS THE NUMBER OF.  COEFFICIENTS IN THE ARRAY..  THE TIME-DOMAIN TABULAR FUNCTION IS COMPUTED AND STORED IN THE.  FIXED POINT GLOBAL ARRAY 'WAVE.MSB'. */CALCWAVE:PROCEDURE(COEFLIST,NHARM); /* PASS ARRAY CONTAINING COEFFICIENTS */   DCL COEFLIST    ARRAY; /* PASS DATA */   DCL NHARM       FIXED; /* NUMBER OF HARMONICS IN COEFLIST */   DCL (MIN.MSB,MIN.LSB) FIXED;   DCL (MAX.MSB,MAX.LSB) FIXED;   DCL (POSMSB,POSLSB)   FIXED;   DCL (NEGMSB,NEGLSB)   FIXED;   DCL (DEVMSB,DEVLSB)   FIXED;   DCL (SHIFT,I,J,K)     FIXED;   DO I=0 TO 255; WAVE.MSB(I)=0; WAVE.LSB(I)=0; END; /* ZERO OUT WAVEBUF */   OFFSET.MSB=0; OFFSET.LSB=0; /* INITIALIZE DC OFFSET TO ZERO */   DO I=0 TO NHARM-1; /* LOOP OVER COEF LIST */      if (milliseconds-sampled.ms) IGT refresh.period then show.time; /* update clock display */      CALL ADDCOEF(I+1,COEFLIST(I)); /* ADD IN HARMONIC */   END;   /* SCALE THE WAVESHAPE - BRING IT WITHIN BOUNDS 0 TO 255 */   MIN.MSB=WAVE.MSB(0); MIN.LSB=WAVE.LSB(0);   MAX.MSB=WAVE.MSB(0); MAX.LSB=WAVE.LSB(0);   DO I=1 TO 255; /* FIND MAX AND MIN OF WAVE */      IF  (WAVE.MSB(I) IGT MAX.MSB)      OR ((WAVE.MSB(I)  =  MAX.MSB) AND (WAVE.LSB(I) IGT MAX.LSB))      THEN DO; MAX.MSB=WAVE.MSB(I); MAX.LSB=WAVE.LSB(I); END;      IF  (WAVE.MSB(I) ILT MIN.MSB)      OR ((WAVE.MSB(I)  =  MIN.MSB) AND (WAVE.LSB(I) ILT MIN.LSB))      THEN DO; MIN.MSB=WAVE.MSB(I); MIN.LSB=WAVE.LSB(I); END;   END;   BEGIN; /* COMPUTE POSITIVE GOING ABS. DEVIATION FROM WAVE CENTER */      DCL OMSB  LIT 'POSMSB';     DCL OLSB  LIT 'POSLSB';      DCL IMSB1 LIT 'MAX.MSB';    DCL ILSB1 LIT 'MAX.LSB';      DCL IMSB2 LIT 'OFFSET.MSB'; DCL ILSB2 LIT 'OFFSET.LSB';      SUBTRACT;   END;   BEGIN; /* COMPUTE NEGATIVE GOING ABS. DEVIATION FROM WAVE CENTER */      DCL OMSB  LIT 'NEGMSB';     DCL OLSB  LIT 'NEGLSB';      DCL IMSB1 LIT 'OFFSET.MSB'; DCL ILSB1 LIT 'OFFSET.LSB';      DCL IMSB2 LIT 'MIN.MSB';    DCL ILSB2 LIT 'MIN.LSB';      SUBTRACT;   END;   /* COMPUTE MAX ABSOLUTE DEVIATION FROM DC OFFSET */   DEVMSB=POSMSB; DEVLSB=POSLSB;   IF  (NEGMSB IGT DEVMSB)   OR ((NEGMSB  =  DEVMSB) AND (NEGLSB IGT DEVLSB))   THEN DO; DEVMSB=NEGMSB; DEVLSB=NEGLSB; END;   /* ADJUST MAX AND MIN VALUES TO BE CENTERED AROUND DC OFFSET */   BEGIN;      DCL OMSB  LIT 'MAX.MSB';    DCL OLSB  LIT 'MAX.LSB';      DCL IMSB1 LIT 'DEVMSB';     DCL ILSB1 LIT 'DEVLSB';      DCL IMSB2 LIT 'OFFSET.MSB'; DCL ILSB2 LIT 'OFFSET.LSB';      ADD;   END;   BEGIN;      DCL OMSB  LIT 'MIN.MSB';    DCL OLSB  LIT 'MIN.LSB';      DCL IMSB1 LIT 'OFFSET.MSB'; DCL ILSB1 LIT 'OFFSET.LSB';      DCL IMSB2 LIT 'DEVMSB';     DCL ILSB2 LIT 'DEVLSB';      SUBTRACT;   END;   /* $PAGE */   IF (MIN.MSB<>0) OR (MIN.LSB<>0) THEN DO I=0 TO 255; /* SUBTRACT MIN FROM WAVE */      BEGIN;         DCL OMSB  LIT 'DEVMSB';      DCL OLSB  LIT 'DEVLSB';         DCL IMSB1 LIT 'WAVE.MSB(I)'; DCL ILSB1 LIT 'WAVE.LSB(I)';         DCL IMSB2 LIT 'MIN.MSB';     DCL ILSB2 LIT 'MIN.LSB';         SUBTRACT;         IMSB1=OMSB; ILSB1=OLSB;      END;   END;   BEGIN; /* COMPUTE NEW MAX */      DCL OMSB  LIT 'DEVMSB';  DCL OLSB  LIT 'DEVLSB';      DCL IMSB1 LIT 'MAX.MSB'; DCL ILSB1 LIT 'MAX.LSB';      DCL IMSB2 LIT 'MIN.MSB'; DCL ILSB2 LIT 'MIN.LSB';      SUBTRACT;      IMSB1=OMSB; ILSB1=OLSB;   END;   K=0;    IF (MAX.MSB=0) AND (MAX.LSB=0) THEN DO;/* AVOID DIVISION ERROR */      MAX.LSB=1; K=128;   END;   /* RESCALE MAX AND WAVE TO BE 16-BIT QUANTITIES */   SHIFT=0;   DO WHILE MAX.MSB IGT 0;      MAX.LSB=SHR(MAX.LSB,1);      IF MAX.MSB THEN MAX.LSB=MAX.LSB\"100000";      MAX.MSB=SHR(MAX.MSB,1);      SHIFT=SHIFT+1;   END;   DO I=0 TO 255; /* LOOP THROUGH PTS IN WAVE */      DO J=1 TO SHIFT;         WAVE.LSB(I)=SHR(WAVE.LSB(I),1);         IF WAVE.MSB(I) THEN WAVE.LSB(I)=WAVE.LSB(I)\"100000";         WAVE.MSB(I)=SHR(WAVE.MSB(I),1);      END;   END;   DO I=0 TO 255;      LOAD 255; MUL WAVE.LSB(I); J=READ(5); DIV MAX.LSB;      WAVE.MSB(I)=RES+K;      IF READ(4) IGE SHR(MAX.LSB,1) THEN WAVE.MSB(I)=WAVE.MSB(I)+1;   END;   CALL PACKWAVE; /* COMPRESS WAVE INTO FISRT 128 WORDS OF WAVE.MSB() */   if (milliseconds-sampled.ms) IGT refresh.period then show.time; /* update clock display */   /* UPDATE LAST MAX WAVE VALUE BEFORE RESCALING */   IF MAX.LSB<0 THEN LAST.MAX=65535.-NOT(MAX.LSB); /* CONVERT TO FLOATING PT */   ELSE              LAST.MAX=MAX.LSB;   LAST.MAX=LAST.MAX*EXP(0.69314718*SHIFT); /* USE SHIFT INFORMATION */END CALCWAVE;