/* 22-DISK  $TITLE  Routines to Read Samples from Disk into Memory *//* Copyright (c) 1984 by New England Digital Corporation *//* This program represents proprietary information and may not be released   publically without written permission from New England Digital Corp. */read_samples:  proc(index,buf,len.to.read); /* reads in desired words from current file */   dcl index         fixed array; /* absolute disk addr of start point */   dcl buf           fixed array; /* output buf */   dcl len.to.read   fixed; /* words to read from disk */   dcl sec (2)       fixed; /* temp to hold copy of INDEX */   dcl tempbuf (255) fixed; /* temp buf to hold one sector */   dcl (len.read,i)  fixed; /* words read and index counter */    sec(0)=index(0); sec(1)=index(1); sec(2)=index(2); /* make copy of disk addr */   i=256; len.read=0;   do while (len.read ILT len.to.read);      if i>255 then do; /* need to get a new sector */         call readdata(sec(0),sec(1),tempbuf,256);         i=sec(2);         sec(1)=sec(1)+1;         if sec(1)=0 then sec(0)=sec(0)+1;         if sec(2)<>0 then sec(2)=0;      end;      buf(len.read)=tempbuf(i);      len.read=len.read+1; i=i+1;   end;end read_samples;load_wave: proc(s.time,e.time,buf) fixed; /* reads in a set of samples */   dcl s.time                  fixed array; /* label name of start of wave */   dcl e.time                  fixed array; /* label name of end   of wave */   dcl buf                     fixed array; /* buffer for samples to read in */   dcl (s.vector,e.vector) (2) fixed;   dcl len.vector (2)          fixed;   dcl len                     fixed; /* number of samples between start & end times */   call time_to_index(s.time,s.vector,period.index); /* convert times to sectors */   call time_to_index(e.time,e.vector,period.index);   call sub_len_from_len(e.vector,s.vector,len.vector); /* compute len of wave */   call add_len_to_len(zero.zero.one,len.vector,len.vector); /* one more point */   call add_len_to_addr(s.vector,location(f.data.index),e.vector); /* get abs addr of wave on disk */   call copy_vector(s.vector,e.vector,3);   len=len.vector(1)*256+len.vector(2);   call read_samples(s.vector,buf,len); /* read data from disk */   return len;end load_wave;/* $SUBTITLE  Routine to Write Analyzed Timbre Data to Disk */save_timbre:  proc(filename) boolean; /* writes timbre data to disk */   dcl filename   fixed array;   dcl i          fixed;   if valid_filename(filename)=0 then return 2; /* illegal filename */   if replace(filename,t#data,0,shr(timbre.len+255,8)+1,timbre.len+256,1) then do; /* write to disk */      databuf1(0)=compatibility.value; /* store compatibility number with timbre */      databuf1(1)=timbre.len;          /* length of timbre in words  */      databuf1(2)=frames;              /* number of frames in timbre */      databuf1(3)=ncoefs.stored;       /* harmonic coefs per frame   */      do i=0 to frames-1; databuf1(i+4)=analysis.status(i); end;      call strcpy(location(addr(databuf1(4+frames))),timbre.name); /* get name of original sound file */      call writedata(f#ms_sector,f#ls_sector,databuf1,4+frames+5);      call writedata(f#ms_sector,f#ls_sector+1,location(free.base),timbre.len);      return 0;   end;   else return 1;end save_timbre;/* $SUBTITLE  Routines to Read in a Timbre from the Disk */dcl find.peak.ptr  procedure (fixed) returns (fixed);dcl create.partial procedure (fixed,fixed array,fixed,fixed);dcl create.frame   procedure (fixed,fixed array,fixed,fixed);convert_format:  proc(ms.sector,ls.sector) fixed; /* recalls timbre data from disk */   dcl ms.sector fixed; /* sector at which timbre info starts */   dcl ls.sector fixed;    dcl (d.ptr,i) fixed; /* ptr to start of data read from disk */   /* IMPORTANT:  this routine leaves TIMBRE.PTR pointing at next free word */   frames=databuf1(1); ncoefs.stored=databuf1(2);   do i=0 to frames-1; analysis.status(i)=databuf1(i+3); end; /* load errors */   call strcpy(timbre.name,location(addr(databuf1(3+databuf1(1))))); /* get name of original sound file */   ncoefs.use=ncoefs.stored;      /* assume user wants to use all of them */   ls.sector=ls.sector+1;         /* update start sector for next disk read */   if ls.sector=0 then ms.sector=ms.sector+1;   i=frames*ncoefs.stored;        /* words of harmonic coefs in timbre */   d.ptr=free.base+65*ncoefs.max; /* assumes longest old format timbre will be 64 frames or so */   call readdata(ms.sector,ls.sector,location(d.ptr),i); /* load harmonic coefs */   ls.sector=ls.sector+shr(i+255,8); /* update start sector for next disk read */   if ls.sector ILT shr(i+255,8) then ms.sector=ms.sector+1;   timbre.ptr=free.base;       /* reset ptr to start of timbre area */   timbre.len=46+(frames-1)*frame.length; /* set up length word */   call create.partial(0,location(d.ptr),ncoefs.stored,0); /* set up first partial */   do i=1 to frames-1; /* set up frames */      call create.frame(0,location(d.ptr+i*ncoefs.stored),ncoefs.stored,0); /* set up subsequent frames */   end;   /* assumes no more than 256 words of attack, peak, or glide info */   call readdata(f#ms_sector,f#ls_sector,location(d.ptr),3*256);   do i=0 to frames-1;      if i=0 then core(free.base+1)=core(d.ptr); /* get attack info */      else core(free.base+46+9+(i-1)*frame.length)=core(d.ptr+i);      core(find.peak.ptr(i))=core(d.ptr+256+i); /* get peak info */      if i=0 then core(free.base+36)=core(d.ptr+512); /* get partial tuning and glide info */      else core(free.base+46+18+(i-1)*frame.length)=core(d.ptr+512+i);   end;   partial.tuning=core(d.ptr+512);end convert_format;recall_timbre:  proc(filename) boolean; /* recalls timbre data from disk */   dcl filename   fixed array;   dcl i          fixed;   if locate(filename,1) then do; /* file exists */      if f#type<>t#data then return 2; /* file is not a data file */      call readdata(f#ms_sector,f#ls_sector,databuf1,256); /* read descriptor sector */      i=databuf1(0);  /* get compatibility number */      if i=1 then do; /* convert old format timbre to current format */         call convert_format(f#ms_sector,f#ls_sector); return 0;      end;      if i<>compatibility.value then return 3; /* wrong compatibility number */      timbre.len   =databuf1(1); /* get length of timbre in words */      frames       =databuf1(2); /* and number of frames */      ncoefs.stored=databuf1(3); /* and coefs per frame  */      do i=0 to frames-1; analysis.status(i)=databuf1(i+4); end;   /* load errors */      call strcpy(timbre.name,location(addr(databuf1(4+frames)))); /* get name of original sound file */      if timbre.len IGT free.len then return 4; /* timbre is too long */      ncoefs.use=ncoefs.stored; /* assume user wants to use all of them */      /* read in raw timbre definition */      if f#ls_sector+1 IEQ 0 then i=1; else i=0;      call readdata(f#ms_sector+i,f#ls_sector+1,location(free.base),timbre.len);      timbre.ptr=free.base;               /* init ptr to start of timbre */      partial.tuning=core(timbre.ptr+36); /* set up partial tuning */      return 0;   end;   else return 1; /* file not found */end recall_timbre;