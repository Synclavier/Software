/* $SUBTITLE Symbolic Definitions for Upper Memory Used by SFM *//* Copyright 1985 by New England Digital Corporation *//* Literals for D4567 Multiply/Divide Card */dcl load lit 'write(5)='; dcl mul lit 'write(6)=';dcl div  lit 'write(7)='; dcl res lit 'read(5)';dcl no.err       lit '1'; /* no error detected in called routine */dcl err          lit '0'; /* error detected */dcl pdl.size             lit '256';   /* length of XPL push down stack to use */dcl clock.rate           lit '30000'; /* d66 oscillator frequency in kHz */dcl max.sampling.rate    lit '51';    /* in kHz as limited by Winchester bandwidth */dcl max.period           lit '4095';  /* d66 clock max */dcl compatibility.number lit '4';     /* Signal file format check 8-20-84 *//* SFM System Object File Names */dcl SFM.FILE        data ('.SFM-7');   /* Main driver module for SFM system */dcl SFMNOVEL.FILE   data ('.SFMNV-7'); /* Non-velocity version of main module */dcl SFMVEL.FILE     data ('.SFMV-7');  /* Velocity version of main module */dcl SPE.FILE        data ('.SPE-7');   /* Spectrum processing module */dcl FUN.FILE        data ('.FUN-7');   /* Function generating module */dcl FIL.FILE        data ('.FIL-7');   /* Convolution module */dcl EDIT.FILE       data ('.EDIT-7');  /* Splicing and Mixing module */dcl LOOP.FILE       data ('.LOOP-7');  /* Loop Point Creation Module */dcl SPAT.FILE       data ('.SRTP-7');  /* Patch Program module */dcl SONO.FILE       data ('.SONO-7');  /* Sonograph module */dcl SYN.FILE        data ('.SYN-7');   /* Analysis program for Resynthesis System */dcl SINTAB.FILE     data ('.STBL-7');  /* Sine table data file */dcl INT.FILE        data ('.INT-7');   /* Interpolation data file for Resampling routine */dcl SONODAT.FILE    data ('.SONODAT'); /* Sonograph module data file */dcl SPECTRU.FILE    data ('.SPECTRU'); /* Holds last spectral file */dcl RECORDFILE.NAME data ('.DATA');    /* Temp work file *//* extend XPL/4 upper memory definitions to preserve changes in default    values between overlays of SFM modules */dcl attack            lit 'location(mem.siz-1027)'; /* 3 word time vector */dcl decay             lit 'location(mem.siz-1030)'; /* 3 word time vector */dcl window.number     lit 'core(mem.siz-1031)'; /* number of spectra */dcl window.type       lit 'core(mem.siz-1032)'; /* spectral window type */dcl window.length     lit 'core(mem.siz-1033)'; /* spectral window length */dcl window.offset     lit 'core(mem.siz-1034)'; /* offset between successive windows */dcl log.mode          lit 'core(mem.siz-1035)'; /* true for log spectral scale */dcl spectral.scale    lit 'location(mem.siz-1037)'; /* 2 word floating point */dcl current.per.index lit 'core(mem.siz-1038)'; /* current sampling period in 30 nsec units */dcl top.limit         lit 'core(mem.siz-1039)'; /* signal display limit */dcl bottom.limit      lit 'core(mem.siz-1040)'; dcl line.mode         lit 'core(mem.siz-1041)'; /* msec length of signal display */dcl cursor.on         lit 'core(mem.siz-1042)'; /* flag for cursor */dcl gain.factor       lit 'core(mem.siz-1043)';  /* filter gain factor */dcl frequency         lit '(mem.siz-1045)'; /* floating point wave frequency */dcl amplitude         lit 'core(mem.siz-1046)'; /* wave amplitude */dcl old.buf           lit '(mem.siz-1111)'; /* previous tty buffer (65 words) */dcl hor.time          lit '(mem.siz-1114)';dcl bits              lit 'core(mem.siz-1115)'; /* bits to quantize to when EXTRACTing  */dcl f.data.index      lit '(mem.siz-1118)'; /* sector,offset of start of data in sound file */dcl fcb.ptr           lit 'core(mem.siz-1119)'; /* point to current fcb */dcl fft.len           lit 'core(mem.siz-1120)'; /* current fft len (<=fft.max) */dcl spectral.origin   lit 'core(mem.siz-1121)'; /* kHz origin of spectrum  */dcl spectral.range    lit 'core(mem.siz-1122)'; /* kHz range of spectrum plot  */dcl dac.volume        lit 'core(mem.siz-1123)'; /* current DAC volume */dcl ovl.error         lit 'core(mem.siz-1124)'; /* global for error codes generated in overlays */dcl beep.status       lit 'core(mem.siz-1125)'; /* status of beep mode from PATCH */dcl sintable.dev      lit '(mem.siz-1126)'; /* device/MSB start of sintable */dcl sintable.loc      lit '(mem.siz-1127)'; /* starting sector of sintable */dcl sintable.wrd      lit '(mem.siz-1128)'; /* words - not used */dcl sfm.intact        lit 'core(mem.siz-1129)'; /* set flag to true if SFM high core is intact *//* locations (mem.siz-1130) to (mem.siz-1134) unused */dcl max.file.blocks   lit '3'; /* max number of files open at one time */dcl file.block.len    lit '12'; /* length of file control block */dcl file.block.loc    lit '(mem.siz-1134-max.file.blocks*file.block.len)'; /* file control blocks */dcl f.headptr         lit '(file.block.loc-sector.size*3)'; /* file heading and symbols buffer */    /* STATIC HIGH CORE AREA ENDS AT (MEM.SIZ - 1938) *//* $SUBTITLE  Routines to Overlay and See That Overlay Will Be Possible */pdl pdl.size; /* set the push down stack length */overlay:proc(ms.start,ls.start,len);   /* special routine to overlay and object file */  dcl (ms.start,ls.start) fixed; /* device and starting sector of file */  dcl (len, i)            fixed;  if in.main.module <> 0 then do;     ovl.error =0; /* reset before overlaying to other modules */     sfm.intact=0; /* sfm modules should set this to 1 before returning */  end;  i = loc.load + 1;        /* get start location of loader code */  write("300") = ms.start; /* R0: device/MS sector */  write("301") = ls.start; /* R1: LS starting sector of program to overlay */  write("302") = 0;        /* R2: memory dest for disk-to-core copy */  write("303") = len;      /* R3: length, in words, to copy */  write("320") = i;        /* transfer control to high-core copy routine */end overlay;can.overlay:  proc (dev,sec,int.reserved,ext.reserved,secbuf) fixed;   dcl dev          fixed; /* DEVICE and MSB of starting SECTOR of program to overlay */   dcl sec          fixed; /* lower 16 bits of starting sector */   dcl int.reserved fixed; /* WORDS of internal memory to reserve */   dcl ext.reserved fixed; /* SECTORS of external memory to reserve */   dcl secbuf       fixed array; /* a 1 SECTOR work buffer */   dcl (i,j)        fixed;   /* NOTE:  this routine computes whether or not the program pointed to      by SEC can be overlayed to give certain memory constraints.  If      okay to overlay, routine returns 0; otherwise it returns a negative      value as follows:            0:  okay to overlay           -1:  desired pgm is a -6 or earlier compilation           -2:  not enough int. memory to hold core procedures,vars, etc.           -3:  not enough int. memory for reserved words           -4:  not enough ext. memory to hold swap procedures           -5:  not enough ext. memory for reserved sectors           -6:  zero sector (means an empty file)           -7:  not an XPL program at all */    if ((dev=0) and (sec=0)) then return (-6); /* file not found (should return -8) */    if (((dev and "377")=0) and (sec=0)) then return (-6); /* empty file */    call readdata(dev,sec,secbuf,256); /* read first sector of target pgm */    j=secbuf(1);    i=secbuf(j+c#vstart)+secbuf(j+c#vlngth)+secbuf(j+c#stklen); /* words need for core procs, vars, pdl */    j=secbuf(j+c#swplen); /* sectors needed for swap procedures */    if (secbuf(0) <>  "100377")    or (secbuf(1) IGT (256-c#conlen))        then return (-7); /* not an XPL program */    if secbuf(secbuf(1)+c#version) <> c#current_version then return (-1); /* program compiled before -7 */    if                i IGT LOC.LOAD         then return (-2); /* not enough int mem for core procs */    if (int.reserved+i) IGT LOC.LOAD         then return (-3); /* not enough int mem for resrvd words */    if                j IGT core(LOC.EMSIZE) then return (-4); /* not enough ext mem for swap procs */    if (j+ext.reserved) IGT core(LOC.EMSIZE) then return (-5); /* not enough ext mem for resrvd secs */    return 0; /* okay to overlay */end can.overlay;