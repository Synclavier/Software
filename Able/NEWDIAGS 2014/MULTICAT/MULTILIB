/*New England Digital CorporationPoly routines for Multi-channel testing programWritten May 1986, WSLModification history:  01/09/89     WSL : Removed from main program into this insert file  *//* Required for stand-alone compilation:  insert ':-xpl:termutil';  insert ':-xpl:asciidef';  insert ':NEWDIAGS:sysinit';*//***************************************************************************//************************  Global literals  ********************************/dcl con           lit     '"32"';          /* d32x control address         */dcl mtdat         lit     '"33"';          /* d32x data    address         */dcl vcon          lit '"040000"';          /* voice on  bit                */dcl vcoff         lit '"000000"';          /* voice off bit                *//***************************************************************************//***************    Multi-channel global variables   **********************/dcl mt2_type        fixed;   dcl inverting     lit  '0';  dcl non_inverting lit  '1';dcl num_output       fixed;         /* number of mt outputs          */dcl stat(32)         fixed;         /* multichns output status   */dcl no_poly_lefts    boolean;dcl all_poly_rights  boolean;dcl mono_poly_voices boolean;dcl mt_short(256)    boolean;               /* mt_short(i) true if shorted *//***************************************************************************//**********************   Multi-channel routines    ************************/dcl wait_for_voice lit 'call vwait';vwait: proc;   dcl i fixed;   dcl j fixed;   do i = 1 to 15; j=read(1); end;end vwait;/***************************************************************************/dcl display_map_heading lit 'call map_heading';map_heading: proc;  pos(3,22);  pstring('MT1 Inputs');  pos(3,54); pstring('MT1 Inputs');  pos(4,14);  pstring('Chan   Left   Right');   pos(4,46);  pstring('Chan   Left   Right');  pos(5,14);  pstring('-------------------');  pos(5,46);  pstring('-------------------');  crlf;end map_heading;/***************************************************************************/search_for_input:  proc(map,index) returns (boolean);   dcl map     fixed array;                /* voice-mt input mapping array */   dcl index   fixed;                      /* array index                  */   dcl num_out fixed;   dcl (i,j)   fixed;                        /* counter                      */   map(index) = (-1);                      /* assume no connection         */   write(con) = "21";                      /* select mt operations         */   do i = 0 to 255;                        /* loop over mt input channels  */      write(mtdat) = vcon \ shl(7,8) \ i;    /* route voice i to output 7    */      wait_for_voice;                      /* delay for voice to start up  */       if read(mtdat) then                   /* found a routing              */        if map(index) = -1 then do;        /* if 1st route found then      */          map(index) = i;                  /* store mt input # in map      */          num_out = 0;                     /* assume no outputs            */          do j = 0 to 63;                  /* count multi-channel outputs  */            write(mtdat) = vcon\shl(j,8)\i;             wait_for_voice;                /* delay for voice to start up  */            if read(mtdat) then num_out = num_out + 1;          end;          wchar(asc.0+i/100); wchar(asc.0+((i/10) mod 10)); wchar(asc.0+(i mod 10));        end;        else do;                           /* routed to > 1 mt input       */          if map(index) >= 0 then do;      /* if mt input in voice map then*/            mt_short(map(index)) = true;   /* mark that input in short map */            map(index) = -2;               /* mark input index in short map*/          end;          mt_short(i) = true;              /* mark input i in short map    */          wchar(bs); wchar(bs); wchar(bs); /* XXX out input on terminal    */          pstring('XXX');        end;      write(mtdat) = vcoff \ shl(7,8) \ i;   /* turn off routing for input   */   end;   if map(index) = -1 then pstring('   '); /* if no input found then       */   if num_out > num_output                 /* global num_output = the max  */     then num_output = num_out;            /*   # of outputs routed to     */   if map(index) < 0 then return false;    /* error occurred               */   else return true;                       /* voices mt input found        */end search_for_input;/***************************************************************************/find_dc: proc returns (boolean);  dcl i fixed;  write(con) = "21";                      /* select mt operations         */  do i = 0 to 255;                         /* loop over mt input channels  */    write(mtdat) = vcon \ shl(7,8) \ i;    /* route voice i to output 7    */    wait_for_voice;                        /* delay for voice to start up  */    if read(mtdat) then do;      write(mtdat) = vcoff \ shl(7,8) \ i; /* turn off routing for input   */      return true;                         /* found a routing              */    end;    write(mtdat) = vcoff \ shl(7,8) \ i;   /* turn off routing for input   */  end;  return false;end find_dc;/************************************************************************/mt1_short: proc;                         /* display mt1 shorts          */   dcl (i,j,card_num,input_cnt) fixed;   dcl left_col boolean;    pstringr('The following MT1 inputs were involved:');    pstring('      ');                   /* margin                      */    card_num = -1;                       /* init an invalid mt1 card #  */    left_col = false;                    /* not in left col of display  */    input_cnt = 0;                       /* bad input per card count = 0*/                                             do i = 0 to 255;                     /* do for each mt1 input       */      if mt_short(i) = true then do;     /* if mt input was shorted     */        if card_num <> int(i/8) then do; /* if input not on current card*/          wchar(bs); wchar(sp);          /* erase last comma displayed  */          if left_col then do;           /* if in left display column   */            left_col = false;            /* not there any more          */            do j = 1 to (8 - input_cnt); /* do for each good card input */              pstring('  ');             /* print spaces instead of n,  */            end;            pstring('     ');            /* margin between columns      */          end;                                     else do;                       /* if in right display column  */            left_col = true;             /* not there any more          */            crlf; pstring('      ');     /* carriage return, margin     */          end;          card_num = int(i/8);           /* update current mt1 card #   */          pstring('MT1 card #'); pnum(card_num,2); pstring(': ');          input_cnt = 0;        end;        pnum((i mod 8),1); pstring(','); /* display card input number   */        input_cnt = input_cnt + 1;      end;    end;   /* do i = 0 to 255 */    wchar(bs); wchar(sp);                /* erase last comma displayed  */end mt1_short;/************************************************************************/