/*Title           : STMADJ STM offset adjust programProject Engineer: William LeathersProject Start   : Feb 1989New England Digital CorporationWritten by A. Dombeck for STM/NED PSAD's, called PSADADJModification History:        02/30/89  WSL - Combined PSADADJ and ANLOGIC to form this test.                      (Also tested with PRM & 2 PSADs)    ??/??/??  JBP - Split into a separate program ANLOGIC for new PSAD's*/configuration modelc, MULDIV;insert ':-xpl:asciidef';insert ':-xpl:termutil';insert ':-xpl:intrprtr';insert ':newdiags:sysinit';insert ':newdiags:datelit';dcl status_line1         lit '18,10';  dcl status_line2 lit '19,10'; dcl status_line3         lit '20,10';  dcl status_line4 lit '21,10'; dcl spread_lim        lit '12';dcl ned_daughter      lit  '0';dcl analogic_daughter lit  '1';dcl (i,j,k)  fixed;dcl chr fixed;dcl sum fixed;dcl bin# fixed;dcl (ave0,sum0)  fixed;dcl (ave1,sum1)  fixed;dcl out_of_range fixed;dcl gain         fixed;dcl ch0_gain     fixed;dcl ch1_gain     fixed;dcl spread       fixed;dcl num_boxes    fixed;dcl num_safes    fixed;dcl config       fixed;dcl ch0_dat      floating;dcl ch1_dat      floating;/***************************************************************************/dcl erase_status_lines lit 'call clr_status';clr_status: proc;pos(status_line4); erase_line;pos(status_line3); erase_line;pos(status_line2); erase_line;pos(status_line1); erase_line;end clr_status;/***************************************************************************/delay: proc; dcl i fixed;  interp_delay_on_d3_write(true);  do i = 0 to 4; write(3) = 0; end;  interp_delay_on_d3_write(false);end delay;/***************************************************************************/find_peak:proc;   dcl (pmsb0,plsb0,pmsb1,plsb1) fixed;   dcl bin# fixed;   dcl i fixed;   dcl value fixed;    bin# = 0;   call pbmread(bin#,0,0);    i = read(psd); i = read(psd);   /* Flush first sample */   plsb0 = 0; pmsb0 = 0;   plsb1 = 0; pmsb1 = 0;   do i = 0 to 1999;               /* channel 0 */      value = abs(read(psd));      plsb0 = plsb0 + value;      if plsb0 ILT value then pmsb0 = pmsb0 + 1;                                    /* channel 1 */      value = abs(read(psd));      plsb1 = plsb1 + value;      if plsb1 ILT value then pmsb1 = pmsb1 + 1;   end;   /* divide */   write(5) = plsb0; write(4) = pmsb0; write(7) = 2000;   ave0 = read(5);   if read(4) IGT SHR(2000,1) then      ave0 = ave0 + 1;   write(5) = plsb1; write(4) = pmsb1; write(7) = 2000;   ave1 = read(5);   if read(4) IGT SHR(2000,1) then      ave1 = ave1 + 1;end find_peak;/***************************************************************************/get_data:proc;   write(psc) = 0;   write(psf) = PSBA;               /* Base address is used for      */   write(psd) = 0; write(psd) = 0;  /*  sample loading. Set to 0.   */   write(psf) = PSADMC;             /* Set number of sampling chans  */   write(psd) = 2;                        /* The order of turning channels on and off is important! */   write(psc) = 1;                  /* busy out channel 1 to inhibit */   write(psf) = PSON;               /*  computer cycles              */   write(psd) = 3;   write(psc) = 0;                  /* start sampling                */   write(psf) = PSON;   write(psd) = 3;   interp_delay_on_d3_write(true);   write(3) = 0; write(3) = 0;      /* delay while sampling */   write(3) = 0; write(3) = 0;      /* delay while sampling */   write(3) = 0; write(3) = 0;      /* delay while sampling */   write(3) = 0; write(3) = 0;      /* delay while sampling */   write(3) = 0; write(3) = 0;      /* delay while sampling */   write(3) = 0; write(3) = 0;      /* delay while sampling */   interp_delay_on_d3_write(false);                                    /* reset sampling channels       */   write(psc) = 0; write(psf) = PSON; write(psd) = 0;   write(psc) = 1; write(psf) = PSON; write(psd) = 0;   write(psf) = PSADMC;  write(psd) = 0;end get_data; /***************************************************************************/calc_ave:proc;  dcl bin# fixed;  dcl i fixed;  bin# = 0;  call pbmread(bin#,0,0);  i = read(psd); i = read(psd);  sum0 = 0; sum1 = 0;  do i = 0 to 15;     sum0 = sum0 + read(psd);     sum1 = sum1 + read(psd);  end;  ave0 = sum0/16;  ave1 = sum1/16;end calc_ave;      /***************************************************************************/dcl update_screen lit 'call #update_screen';#update_screen:proc;   pos(12,24);  erase_line;           fprint(ch0_dat,3,2);   pos(12,32);  fprint(ch1_dat,3,2);  pstring(' ');end #update_screen;/***************************************************************************/dcl setup_channels lit 'call #setup_channels';#setup_channels: proc;  /*************************************************/  /* Set up oscillators: channels 0,1 for sampling */                           /* Set up channel 0 for 50 khz rate */  write(psc) = 0;  write(psf)=PSWL;  write(psd)=  -4096; write(psd)=-1;  /* wave table length of 4096 sectors */  write(psd)=   0;    write(psd)=0;   /* base address of 0        */  write(psd)=  -4096; write(psd)=-1;  /* loop length of 4096 sectors (max sc)       */  write(psd)=   0;    write(psd)=2;   /* phase incr of 2          */  write(psd)=   0;                    /* incr of 1                */  write(psd)= 254;                    /* modulus of 2             */  write(psd)=   0;                    /* off and no looping       */                           /* Busy out channel 1 at 100 khz */  write(psc) = 1;                           write(psf)=PSWL;  write(psd)=  -1;    write(psd)=-1;  /* wave table length of 0 sectors */  write(psd)=   0;    write(psd)=0;   /* base address of 0        */  write(psd)=  -1;    write(psd)=-1;  /* loop length of 0 sectors */  write(psd)=   0;    write(psd)=0;   /* phase incr of 0          */  write(psd)=   0;                    /* incr of 1                */  write(psd)= 255;                    /* modulus of 1             */  write(psd)=   0;                    /* off and no looping       */  write(psc) = 0;  write(psf) = PSADMODE;              /* sampling mode, <50 kHz   */  write(psd) = 2;                     /* A->0, A->1, B->2, B->3   */end #setup_channels;/***************************************************************************/dcl adjust_ned_stm lit 'call #adjust_ned_stm';#adjust_ned_stm: proc;  dcl (i,j) fixed;  dcl chr fixed;  dcl (low_msg_flag,ok_msg_flag,hi_msg_flag) fixed;  setup_channels;  do i = 1 to #_daughters(bin#);                  write(psf) = PSADACT;     write(psd) = shl(3,2*(i-1)); /* Activate the appropriate channels */     pos( 6,18); pstring('Input ');     if i = 1 then pstring('1A');     else pstring('1B');     pstring(' should be terminated with 600 ohms.');     pos( 8,20); pstring('Amp Input Offset Adjust  - PSAD #'); pnum(i,0);     pos( 9,21); pstring('- Adjust pots for a reading of 0');     pos(11,30); pstring('R32        R33');     pos(status_line1); pstring('Hit a key to go on to the next adjustment or <BREAK> to exit.');     clear_typeahead;     do while peek = -1;                      /* loop until a chr is typed */        write(psf) = PSADVOL;                 /* input gain offset adjust  */        write(psc) = 2*(i-1);    write(psd) = 0;        write(psc) = 2*(i-1)+1;  write(psd) = 0;        call delay;        call get_data;           call calc_ave;        ch0_dat = ave0;          ch1_dat = ave1;        write(psf) = PSADVOL;        write(psc) = 2*(i-1);    write(psd) = 224;        write(psc) = 2*(i-1)+1;  write(psd) = 224;        call delay;              call delay;   /* extra delay to slow display */        call get_data;           call calc_ave;        ch0_dat = ch0_dat - ave0;        ch1_dat = ch1_dat - ave1;        pos(12,27);  erase_line;                   fprint(ch0_dat,3,2);     pstring('    ');          fprint(ch1_dat,3,2);     pstring(' ');     end;     chr = rchar; if chr = 0 then call exit(0);     pos( 8,20); pstring('Amp Output Offset Adjust  - PSAD #'); pnum(i,0);     pos( 9,21); pstring('- Adjust pots for a reading of 0');     pos(11,30); pstring('R31        R34');     pos(14,32); pstring('Spread:');     pos(16,10);      pstring('If spread adjust pot exists, adjust spread for a reading of 0.');     pos(status_line1);      pstring('Hit a key to go on to the next adjustment or  <BREAK> to exit.');     clear_typeahead;     do while peek = -1;                                 /*loop until char */        write(psf) = PSADVOL;                         write(psc) = 2*(i-1);     write(psd) = 0;        write(psc) = 2*(i-1)+1;   write(psd) = 0;        call delay;        call get_data;      call calc_ave;        ch0_dat = ave0;     ch1_dat = ave1;        write(psf) = PSADVOL;        write(psc) = 2*(i-1);        write(psd) = 31;        write(psc) = 2*(i-1)+1;      write(psd) = 31;        call delay;           call delay;  /* slow screen update */        call get_data;        call calc_ave;        ch0_dat = ch0_dat - ave0;        ch1_dat = ch1_dat - ave1;        spread = abs(ave0 - ave1);        pos(12,27);  erase_line;                   fprint(ch0_dat,3,2);     pstring('    ');          fprint(ch1_dat,3,2);     pos(14,40);        unum(Spread,0);          pstring(' ');     end;     chr = rchar; if chr = 0 then call exit(0);     if spread > spread_lim then do;        pos(status_line1);        pstring('WARNING: The spread between channels is out of spec. If the spread');        pos(status_line2);        pstring('cannot be adjusted to less than ');        pnum(spread_lim,2); pstring(' then the STM should be repaired. ');        pos(status_line4);        pstring('Press <RETURN> to continue ... ');        chr = rchar;        if chr = 0 then call exit(0);        erase_status_lines;        clear_typeahead;     end;     do j = 8 to 17;       pos(j,0); erase_line;     end;     pos(8,20); pstring('ADC offset adjust - PSAD #'); pnum(i,0);     pos(status_line1);      pstring('Hit a key to go on to the next adjustment or <BREAK> to exit.');     pos(12,20);     pstring('Adjust A/D Converter Offset for a reading of 0');     pos(13,30); pstring('Offset: ');     clear_typeahead;     write(psf) = PSADVOL;            /* input gain offset adjust */     write(psc) = 2*(i-1);     write(psd) = 0;     write(psc) = 2*(i-1)+1;     write(psd) = 0;     do while peek = -1;                            /* loop until char */        call delay;         call delay;        call get_data;      call calc_ave;              sum = ave0 + ave1;  pos(13,38);                 pnum(sum,0);        pstring(' ');     end;     chr = rchar; if chr = 0 then call exit(0);     clear_typeahead;     do j = 6 to 17;       pos(j,0); erase_line;     end;     pos(6,15); pstring('Gain Adjust - PSAD #'); pnum(i,0);     pstring('.  Connect a signal generator');      pos(7,15);     pstring('to input 1');     if i = 1 then pstring('A');     else pstring('B');     pstring(' and select a 100 Hz square wave.');     pos(status_line1); erase_line;     pstring('Type S to skip this test, any other key to continue. ');      chr = rchar;  if chr = 0 then call exit(0);     if (chr <> 83) & (chr <> 115) then do;       pos(status_line1); erase_line; pstring('     <BREAK> - Exit');       write(psf) = PSADVOL;       write(psc) = 2*(i-1);     write(psd) = 0;       write(psc) = 2*(i-1)+1;   write(psd) = 0;       do gain = 0 to 2;          do j = 10 to 12;             pos(j,0); erase_line;          end;          pos(9,15);          do case gain;            pstring('3X gain ADJUST    - Adjust signal generator so that');              pstring('9X gain ADJUST  - readjust signal generator so that');              pstring('27X gain ADJUST - readjust signal generator so that');            end; /* case */            pos(10,15);           pstring('channels 0 & 1 are in the range of 2000 - 2500.');          pos(12,30); pstring('Chan. 0     Chan. 1');          out_of_range = 1;          do while out_of_range;            clear_typeahead;            low_msg_flag = true;  ok_msg_flag = true; hi_msg_flag = true;            do while peek = -1;                        /* loop until char */              call delay;        call delay;      /* slow screen update */              call get_data;     call find_peak;              pos(13,31);        erase_line;              unum(ave0,0);      pos(13,43);                      unum(ave1,0);      pstring(' ');              if (ave0 < 2000) & low_msg_flag then do;                 ok_msg_flag = true;                 low_msg_flag = false; hi_msg_flag = true;                 pos(16,20); erase_line;                 pstring('Gain too low. Adjust signal generator. ');              end;              if (ave0 > 2500) & hi_msg_flag  then do;                 ok_msg_flag = true;                 low_msg_flag = true; hi_msg_flag = false;                 pos(16,20); erase_line;                 pstring('Gain too high. Adjust signal generator. ');              end;              if (ave0 >= 2000) & (ave0 <= 2500) & ok_msg_flag then do;                ok_msg_flag = false;                low_msg_flag = true;  hi_msg_flag = true;                pos(16,20); erase_line;                pstring('Level within range, hit a key to continue ... ');              end;            end;            chr = rchar; if chr = 0 then call exit(0);            call delay;   call get_data;  call find_peak;            if (ave0 >= 2000) & (ave0 <= 2500) then do;              do j = 8 to 17;                pos(j,0); erase_line;              end;              ch0_gain = ave0*3;              ch1_gain = ave1*3;              out_of_range = 0;            end;          end;          pos( 9,15); pstringr('Adjust pots for a reading of 0.  Values are % error. ');          pos(11,30);          do case gain;             do;                  pstring('R14        R17');   /* gain of 3 */                write(psf) = PSADVOL;                write(psc) = 2*(i-1);                write(psd) = 32;                write(psc) = 2*(i-1)+1;                write(psd) = 32;             end;             do;                  pstring('R12        R15');   /* gain of 9 */                write(psf) = PSADVOL;                write(psc) = 2*(i-1);                write(psd) = 96;                write(psc) = 2*(i-1)+1;                write(psd) = 96;             end;             do;                  pstring('R13        R16');   /* gain of 27 */                write(psf) = PSADVOL;                write(psc) = 2*(i-1);                write(psd) = 224;                write(psc) = 2*(i-1)+1;                write(psd) = 224;             end;          end;          pos(status_line1); erase_line;          pstring('     Hit a key to go to the next adjustment or <BREAK> to exit. ');          clear_typeahead;          do while peek = -1;               call delay;                call delay;  /* slow screen update */             call get_data;             call find_peak;             ch0_dat = ch0_gain - ave0;             ch0_dat = ch0_dat*100/ch0_gain;             ch1_dat = ch1_gain - ave1;             ch1_dat = ch1_dat*100/ch1_gain;             pos(12,27);           erase_line;                        fprint(ch0_dat,3,2);  pos(12,38);               fprint(ch1_dat,3,2);  pstring(' ');          end;          chr = rchar; if chr = 0 then call exit(0);          pos(status_line1); erase_line;      end; /* do gain = 0 to 2 */    end; /* if chr <> s */    do j = 6 to 17;      pos(j,0); erase_line;    end;    erase_status_lines;  end;end #adjust_ned_stm;/***************************************************************************/dcl adjust_analogic_stm lit 'call #adjust_analogic_stm';#adjust_analogic_stm: proc;   dcl (i,j) fixed;   dcl chr   fixed;   setup_channels;   do i = 1 to #_daughters(bin#);      write(psf) = PSADACT;      write(psd) = shl(3,2*(i-1)); /* Activate the appropriate channels */      pos( 6,18); pstring('Input ');      if i = 1 then pstring('1A');      else pstring('1B');      pstring(' should be terminated with 600 ohms.');      pos( 8,20); pstring('Interchannel offset adjust  - PSAD #'); pnum(i,0);      pos( 9,21); pstring('- Adjust spread for a reading of 0');      pos(11,30); pstring('  Spread:');      pos(14,29); pstring('Chan 0     Chan 1');      pos(status_line1); pstring('Hit a key to go on to the next adjustment or <BREAK> to exit.');      clear_typeahead;      do while peek = -1;                             /* loop until char */         write(psf) = PSADVOL;                     write(PSC) = 2*(i-1);   write(psd) = 0;         write(PSC) = 2*(i-1)+1; write(psd) = 0;         call delay; call delay; call delay;         call get_data;          call calc_ave;         ch0_dat = ave0;         ch1_dat = ave1;         spread  = abs(ave0-ave1);         pos(11,40);           pstring('     ');          pos(11,40);           unum(spread,0);         pos(15,28);           erase_line;                fprint(ch0_dat,2,2);  pstring('     ');         fprint(ch1_dat,2,2);  pstring(' ');      end;      chr = rchar; if chr = 0 then call exit(0);      if spread > spread_lim then do;         pos(status_line1);         pstring('WARNING: The spread between channels is out of spec. If the spread');         pos(status_line2);         pstring('cannot be adjusted to less than ');         pnum(spread_lim,2); pstring(' then the STM should be repaired. ');         pos(status_line4);         pstring('Press <RETURN> to continue ... ');         chr = rchar;         if chr = 0 then call exit(0);         erase_status_lines;         clear_typeahead;      end;      do j = 8 to 17;        pos(j,0); erase_line;      end;      pos(8,20); pstring('ADC offset adjust - PSAD #'); pnum(i,0);      pos(status_line1);       pstring('Hit a key to go on to the next adjustment or <BREAK> to exit.');      pos(12,20);      pstring('Adjust A/D Converter Offset for a reading of 0');      pos(13,30); pstring('Offset: ');      clear_typeahead;      write(psf) = PSADVOL;            /* input gain offset adjust */      write(PSC) = 2*(i-1);      write(psd) = 0;      write(PSC) = 2*(i-1)+1;      write(psd) = 0;      do while peek = -1;                            /* loop until char */         call delay;         call delay;         call get_data;         call calc_ave;      sum = ave0 + ave1;         pos(13,38);         pnum(sum,0);  pstring(' ');      end;      do j = 8 to 17;        pos(j,0); erase_line;      end;   end;   chr = rchar;end #adjust_analogic_stm;/***************************************************************************//*************************      MAIN PROGRAM     ***************************//***************************************************************************/clear_screen; crlf;if ^poly_exists then do;  pstring('No poly system found, adjust program aborted. ');  flush_term; call exit(0);end;if ^psadc_exists(bin#) then do;  pstring('No PSADC found, adjust program aborted. ');  flush_term; call exit(0);end;if #_daughters(bin#) = 0 then do;  pstring('No daughter boards found, adjust program aborted. ');  flush_term; call exit(0);end;if (ad_config(bin#) & 3) = 2 then do;   pstring('The PSAD is in the wrong position, adjust program aborted. ');   flush_term; call exit(0);end;pos(0,15); pstring('Sample-to-Memory offset adjust program ');display_release_date;pos(1,15); pstring('-------------------------------------------------');pos(2,15); pstring('STM  boxes: '); pnum(#_stm_boxes(bin#),3); pos(2,48); pstring('STM inputs: '); pnum(2 * #_daughters(bin#),3);pos(3,15); pstring('PSAD  type: ');  if daughter_type(bin#) = ned_daughter then pstring('N.E.D.');else pstring('Analogic');pos(3,48); pstring('PRM  found: ');if prm_exists(bin#) then pstring('Yes');else pstring(' No');if #_stm_boxes(bin#) > 1 then do;   pos(status_line1);    pstring('This system contains more than one STM box.  At present,  this');   pos(status_line2);   pstring('program can only adjust the first box in the chain. Additional');   pos(status_line3);   pstring('boxes will have to be configured as box #1 for adjustment.');   pos(status_line4);   pstring('Press <RETURN> to continue ... ');   chr = rchar; if chr = 0 then call exit(0);   erase_status_lines;end;if daughter_type(bin#) = ned_daughter then adjust_ned_stm;else adjust_analogic_stm;