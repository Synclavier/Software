/*Title           : M64K test module  - inserted in LOGGERProject Engineer: John SchwenkProject Start   : ????New England Digital CorporationModified:       WSL   Rel N     Converted to a module for LOGGER                 WSL   5/9/88    Added fix (by John S.) for d16/d137                                synchronization test                WSL   9/1/88    Changed timing method of d136/d3 comparison                                test because of intermittant errorsJan. 88     WSL - Converted test to a module for use in LOGGER*//***************************************************************************//************     Required for stand - alone compilation    ****************//*insert ':-xpl:asciidef';insert ':-xpl:termutil';insert ':-xpl:intrprtr';insert ':NEWDIAGS:sysinit';dcl status_line1 lit '18,10';  dcl status_line2 lit '19,10'; dcl status_line3 lit '20,10';  dcl status_line4 lit '21,10'; dcl erase_status_lines lit 'call clr_status';clr_status: proc;  pos(status_line4); erase_line;  pos(status_line3); erase_line;  pos(status_line2); erase_line;  pos(status_line1); erase_line;end clr_status;dcl iteration_number fixed;dcl milliseconds     fixed;when d03int then milliseconds = milliseconds + 5;*//***************************************************************************//*Global Lits, Dcls, and whens*/dcl int_ad       lit '"h200"'; /* D137 int mask reg add. */dcl d137         lit '"137"';  /* D137 address           */dcl d16_int_count     fixed;    /* Counts d16 interrupts                   */dcl d136_int_count    fixed;    /* Counts the number of d136 interrupts    */dcl d136_milliseconds fixed;    /* counts milliseconds */dcl d137_int_count    fixed;    /* Counts the number of d137 interrupts    */dcl d136_int_enabled  boolean;  /* Set only when D136 SHOULD be producing interrupts */dcl d137_int_status   fixed;    /* Holds D137 int status byte              *//***************************************************************************/when d16int then    d16_int_count = d16_int_count + 1;/***************************************************************************/when d136int then do;   d136_milliseconds = d136_milliseconds + 5;   if (d136_int_enabled = false)  /* if int occurred while disabled */   then do;     pos(status_line4); erase_line;      pstring('Error:  - Spurious d136 interrupt detected ');     flush_term;   end;   else d136_int_count = d136_int_count + 1;end;/***************************************************************************/when d137int then do;   write (d137) = int_ad;   d137_int_status = read (d137);   d137_int_count = d137_int_count + 1;end;/***************************************************************************/dcl m64k_errors fixed;dcl test_m64k lit 'call #test_m64k';/***************************************************************************//* PROGRAM: "M64K" thoroughly tests some subsystems of the M64K circuit    *//*    board and allows the setting of the D137 Clock/Calendar to the       *//*    correct date and time.                                               *//*       The subsystems tested are:                                        *//*                                                                         *//*          - D136 D3-type Poly-synchronisable clock                       *//*          - D16  Scientific Timer                                        *//*          - D137 Clock/Calendar                                          *//*                                                                         *//*       The subsystems NOT tested are:                                    *//*                                                                         *//*          - 64K words of memory                                          *//*          - D130 Keyboard interface                                      *//*                                                                         *//***************************************************************************/#test_m64k: proc;/************     LITERALS     ************/dcl beep         lit '"07"';   /* Ascii code for a beep  */dcl terminal     lit '"50"';   /* Terminal device number */dcl one_in_zeros lit '"H01"';  /* Bit patterns to test loading of  */dcl zero_in_ones lit '"HFE"';  /*   d16 and d137 registers.        */dcl d136         lit '"136"';  /* D136 address           */dcl d16          lit '"16"';   /* D16 address            */dcl d17          lit '"17"';   /* D17 address            */dcl d3           lit '"03"';   /* D3 address             */dcl data_ad      lit '"h100"'; /* D137 data regs address */dcl com_ad       lit '"h300"'; /* D137 command reg add.  */dcl set          lit '1';      /* For testing bits       */dcl clear        lit '0';      /* For testing bits       *//***********     DATA LISTS      ************//* Holds, in order, the max/min values that can be loaded into D137's time *//*   and alarm RAM registers.                                              */dcl max_times data (99, 12, 59, 59, 12, 31, 99, 6, 99, 12, 59, 59, 12, 31, 99, 6);dcl min_times data (0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0);/* Holds, in order, the values that bytes must be masked with before being *//*   written to D137 registers to prevent disturbance of unused bits       */dcl masks data ("H7F", "H0F", "H3F", "H3F", "H0F", "H1F", "H7F", "H07",                "HFF", "H0F", "H3F", "H3F", "H0F", "H1F", "HFF", "H07");/***********  LOCAL VARIABLES  *************/dcl i                 fixed;    /* Counter in several do loops             */dcl (hundreth,hour,             /* Holds time when reading d137 clock/     */     minute,second,             /*   calendar.                             */     month,date,year,     day_of_week)     fixed;  dcl dummy             fixed;    /* Used to provide short dly and to        */                                /*   receive read results that we don't    */                                /*   care about.                           *//***************************************************************************/print_test_message: procedure (test_code);   dcl test_code fixed;  /* number of subtest about to be performed  */      pos(status_line3); erase_line;      do case (test_code);         pstring('  - Status flag initially set');  /* 0 */         ;         pstring('  - Clear of status flag');         pstring('  - Gross synchronization to D3'); /* 3 */         pstring('  - Interrupts; generation, enable, disable');         pstring('  - Counter reg read/write through D16');         pstring('  - Counting');                   /* 6 */         pstring('  - Status flag setting and clearing');          ;         ;         pstring('  - Accuracy relative to D136');  /* 10 */         pstring('  - Interrupt generation and enable on load');         pstring('  - D16 interrupt disable function');         pstring('  - D16 interrupt enable function');         pstring('  - Hang on D17 write');          /* 14 */          ;         pstring('  - Filling time and alarm registers with maximum values');         ;         pstring('  - Filling time and alarm registers with minimum values');         ;         pstring('  - Filling time and alarm registers with bit patterns'); /* 20 */         pstring('  - Periodic interrupts; generation, enable, disable, status reg.');         ;         ;         pstring('  - AM/PM bits and alarm RAM interrupt mask bits'); /* 24 */          pstring('  - Alarm feature; interrupt generation, mask bits');         ;         ;         pstring('  - User setting and reading of time'); /* 28 */         pstring('  - Gross synchronization to D16 using D137 polling method');         pstring('  - Gross synchronization to D16 using interrupt driven method');          end;  /* do case */      pos(status_line4);      flush_term;end print_test_message;/***************************************************************************//* PROCEDURE: 'reset_int_status' puts all interrupts (D16, D136, D137,     *//*   XPL runtime package) back to their original and proper state upon     *//*   leaving this program.                                                 *//*-------------------------------------------------------------------------*/reset_int_status: proc;   disable;                   /* disable XPL interrupts    */   write (d136) = shl (2,8);  /* Disable D136 interrupts   */   write (d136) = shl (5,8);  /* Enable D16 interrupts     */   write (d137) = com_ad;     /* Set up and...             */   write (d137) = "010";      /* Disable D137 interrupts   */   write (d137) = int_ad;   write (d137) = 0;end reset_int_status;/***************************************************************************/error: procedure (error_code, diagnostic1, diagnostic2);   dcl error_code    fixed;  /* number corresponds to subtest failed    */   dcl (diagnostic1,         /* May be passed useful info to tell user. */        diagnostic2) fixed;  /* if not, they will be zero.              */   dcl chr fixed;   call reset_int_status;   pos(status_line4); erase_line;   pstring('Error: ');    /* Tell user precisely which subtest failed  */   do case (error_code);      pstring('  - D136 status flag not initially = 1');      pstring('  - D136 interrupt occurred while D136 interrupt disabled');      pstring('  - D136 status flag did not clear');      do;       pstring('  - D136 not grossly synchronized with D3.');        pnum(diagnostic1,0); pstring(' '); pnum(diagnostic2,0);      end;      pstring('  - D136 interrupts.  Enable, disable, or generation.');      pstring('  - D16 or D17 read, write, or count fault.');      pstring('  - D16 counting fault.');      pstring('  - D16 status flag did not set on counter turnover');  /* 7 */      pstring('  - D16 status flag did not clear on read of D16');     /* 8 */      pstring('  - D16 status flag did not clear on write');      pstring('  - Incorrect timing of D16 relative to D136.'); /*10*/      pstring('  - D16 interrupt generation malfunction. ');      pstring('  - D16 interrupt disable malfunction.');      pstring('  - D16 interrupt enable malfunction.');    /* 13 */      pstring('  - Hang on write to D17 too long.');      pstring('  - Hang on write to D17 too short.');      /* 15 */      pstring('  - Couldn''t fill D137 time registers with maximum values.');      pstring('  - Couldn''t fill D137 alarm registers with maximum values.');      pstring('  - Couldn''t fill D137 time registers with minimum values.');      pstring('  - Couldn''t fill D137 alarm registers with minimum values.'); /* 19 */      pstring('  - Fault in D137 registers bit pattern test.');      pstring('  - "Global Interrupt" set with D137 interrupts disabled.');      pstring('  - Processor didn''t get periodic interrupt.');      pstring('  - Interrupt status register bits not set after interrupt.');      pstring('  - Setting/clearing alarm RAM mask or AM/PM bit.');      pstring('  - Alarm interrupt received while mask bit set.');      pstring('  - Didn''t get alarm interrupt while testing alarm register');      pstring('  - Alarm bit in interrupt status reg (bit 0) not set.');      pstring('  - Global interrupt bit in interrupt status register.');/*28*/      pstring('  - Synchronization to D16 off by more than 1/2 percent.');      pstring('  - Synchronization to D16 off by more than 1/2 percent.');   end; /* do case */   flush_term;   if m64k_errors <> "HFFFF" then m64k_errors = m64k_errors + 1;end error;/***************************************************************************//* PROCEDURE: "test_d136" tests the operation of the d136 d3-type clock.   *//*    Note that the 50Mhz. sync. feature is NOT tested.                    *//* METHOD: There are 5 main subtests implemented in the code below.  Each  *//*    subtest is documented in the comments for the associated block.      *//*    This procedure works closely with an interrupt handling routine      *//*    (when statement), immediately below, to test the interrupt aspects   */ /*    of the d136.                                                         *//* GLOBALS ALTERED: Communication between the procedure and the interrupt  *//*    handling routine occurs through two global variables:                *//*     - d136_int_enabled - boolean flag lets 'when' routine know if       *//*          it's suposed to be receiving interrupts at any given time.     *//*     - d136_int_count - counts the interrupts that occur during one      *//*          of the subtests.  The procedure then tests to make sure this   *//*          count is correct.                                              *//*-------------------------------------------------------------------------*//***************************************************************************/test_d136: procedure;   dcl num_iterations lit '10'; /* Number of iterations in gross d3 sync test loop */   dcl d3_status      boolean; /* Temporarily holds status of d3 flag    */   dcl last_d3_status boolean; /* Saves last d3 status around loop       */   dcl d136_status    boolean; /* Temporarily holds status of d136 flag  */   pos(status_line2); erase_line;   pstring('  - D136 D3-type clock');  /* Alert user to start of this test */   flush_term;   /* Check that d136 status flag is initially set                       */   call print_test_message (0);  /* Tell user this subtest is about to begin  */   if (read (d136) <> set)       /* if clock flag is not initially set   */   then call error (0, 0, 0);    /* then error.         */   /* Test clearing of status flag                                       */   call print_test_message (2);  /* Tell user this subtest is about to begin  */   write (d136) = clear;         /* Clear d136 flag     */   d136_status = read (d136);    /* Get d136 flag       */   if (d136_status <> clear)     /* if it hasn't been cleared    */   then call error (2, 0, 0);    /* then error.         */   /* Test gross sync to d3 and hang ups on write to d136                */   call print_test_message(3);   /* Tell user this subtest is about to begin  */   do i = 1 to num_iterations;     d136_int_enabled = true;     write(d136) = "H0300"; /* Enable d136 interrupts */     disable;       milliseconds = 0;       d136_milliseconds = 0;       write(3) = 0;           write(d136) = 0;     enable;     do while milliseconds < 100; end;     write(d136) = 0;     disable;       if (d136_milliseconds < 95) \ (d136_milliseconds > 105)         then call error(3,0,0);     enable;   end;   write(d136) = "H0200";   /* disable d136 interrupts */   d136_int_enabled = false;   /* Test d136 interrupt capability including enable and disable  */   /* Set up...             */   call print_test_message (4);  /* Tell user this subtest is about to begin  */   d136_int_enabled = true;      /* Prepare int serv. routine for test */   write (d136) = shl (3,8);     /* Enable d136 interrupts         */   disable;                      /* @@ added for intermittant error problem WSL*/   d136_int_count = 0;           /* Prepare int. counter for test  */   milliseconds = 0;   enable;   do while milliseconds < 500; end;   /* Wait for ints...      */   /* Check number of ints. */   write (d136) = shl (2,8);     /* Disable d136 interrupts        */   d136_int_enabled = false;     /* Setup int. serv. rout. to catch any unauthorized ints. */   if (d136_int_count > 102)     /* if we didn't catch about 100...    */   or (d136_int_count < 98)      /* ...interrupts in the above loop    */   then call error (4, 0, 0);    /* then error                     */end test_d136;/***************************************************************************/test_d16: procedure;   dcl last_count    fixed; /* Keeps track of d16 counter while testing    */   dcl d16_val       fixed; /* Gets read value of D16                      */   dcl done boolean;   /************************************************************************/   d16_read_write_test: procedure (bit_pattern, reg);      dcl bit_pattern fixed;  /* Pattern to write, rotate, write, rotate,...  */      dcl reg         fixed;  /* Register to write.  Either d16 or d17.       */      dcl shift_count fixed;  /* Counts to 16 in loop to test all bits in reg */      dcl d16_val     fixed;  /* Gets read value of D16                       */      do shift_count = 0 to 15;     /* For all bits in counter register       */         write (d16) = 10;    /* Keep next write to d17 from hanging too long */         write (reg) = bit_pattern; /* Write and read  */         d16_val = read (d16);         if  (d16_val ine (not (bit_pattern)))  /* If the value isn't correct */         and (d16_val ine (not (bit_pattern)) + 1)         and (d16_val ine (not (bit_pattern)) + 2)         then call error (5, bit_pattern, d16_val);    /* then error.         */         bit_pattern = rot (bit_pattern,1);  /* set up to test next bit over  */      end;   end d16_read_write_test;   /************************************************************************/   set_d16_flag: procedure;      dcl i fixed;      write (d137) = shl (4,8);  /* Fastest rate for fastest turnover     */      write (d16) = 1;           /* (was 0) Prepare d16 to turn over and set flag */      do i = 0 to 10; end;       /* Waste time to insure turnover         */   end set_d16_flag;                        /************************************************************************/   test_d16_period: procedure (rate, correct_period);      dcl rate           fixed; /* (4,5,6, or 7) => (1,10,100uS,1mS) d16 rate */      dcl correct_period fixed; /* Period we SHOULD measure at that rate      */      dcl start_count    fixed; /* remembers last d16 counter value */      dcl end_count      fixed; /* latest d16 counter value         */      dcl period         fixed; /* difference between last & latest */      dcl min_period     fixed; /* smallest period measured         */      dcl max_period     fixed; /* largest period measured          */      write (d137) = shl (rate, 8);  /* Set D16 rate for this test  */      min_period = 64000;            /* Set up to measure it        */      max_period = 0;      write (d136) = 0;              /* Set up for loop             */      do i = 1 to 100;               /* Check period 100 times      */         write (d16) = 64000;        /* insure no turnover          */         write (d136) = 0;           /* wait for d136               */         start_count = read (d16);   /* Get the d16 count           */         write (d136) = 0;           /* wait for d136               */         end_count = read (d16);     /* Get the d16 count           */         period = end_count - start_count;   /* compute period      */         /* update min_period and max_period  */         if (period ilt min_period) then min_period = period;         if (period igt max_period) then max_period = period;      end;      /* Call error if the min or max period was not correct  */      if (min_period ine correct_period)      then call error (10, rate, min_period);      if (max_period ine correct_period)      then call error (10, rate, max_period);   end test_d16_period;   /************************************************************************/   pos(status_line2);  erase_line;      pstring('  - D16 Scientific timer'); flush_term;   write (d137) = shl (5,8); /* Set 10uS d16 rate.  Sets up for tests      */   call print_test_message (5);   disable; /* prevent interrupt from screwing up timing and reseting flag */   /* Test writing/reading counter register through d16 stressing each bit */   call d16_read_write_test (one_in_zeros, d16);   call d16_read_write_test (zero_in_ones, d16);   if peek <> -1 then return;   /* Test writing/reading counter register through d17 stressing each bit */   call d16_read_write_test (one_in_zeros, d17);   call d16_read_write_test (zero_in_ones, d17);   if peek <> -1 then return;   /* Test counting of d16 counter register  */   call print_test_message (6);   disable; /* prevent interrupt from screwing up timing and reseting flag */   write(d137) = shl (6,8);     /* 6 - Set 100uS rate.  Sets up for this test */   done = false;   write(d16) = not(0);   last_count = read(d16);   do while not done;      if peek <> -1 then return;      do while (read(d16) = last_count);       /* Wait until d16 counts   */      end;      d16_val = read(d16);                     /* Get the count           */      if (d16_val ine (last_count + 1))         /* if it didn't count by 1 */      then call error (6, last_count+1, d16_val); /* then error              */      last_count = d16_val;                     /* Set up for next count   */      if last_count = 0 then done = true;   end;   /* Test status flag sets, resets, loading of zero to d16                */   /* Partly test flag set  */   call print_test_message (7);   disable; /* prevent interrupt from screwing up timing and reseting flag */   call set_d16_flag;         /* Set flag and fastest rate   */   if (read (d17) <> set)     /* error if flag isn't set     */   then call error (7, 0, 0);   /* Test reset on read d16  */   dummy = read (d16);   if (read (d17) <> clear)   /* error if flag isn't clear   */   then call error (8, 0, 0);   /* Test reset on write d16 */   call set_d16_flag;   write (d16) = 32000;  /* Arbitrary large number so flag doesn't get set */   if (read (d17) <> clear)   /* error if flag isn't clear   */   then call error (9, d16, 0);      /* Test reset on write d17 */   call set_d16_flag;   write (d17) = 10;          /* Arbitrary number            */   if (read (d17) <> clear)   /* error if flag isn't clear   */   then call error (9, d17, 0);   if peek <> -1 then return;   /* Test timing relative to D136                                         */   call print_test_message (10);   disable; /* prevent interrupt from screwing up timing and reseting flag */   call test_d16_period (7,5);       /* 1mS rate  */   call test_d16_period (6,50);      /* 100uS     */   call test_d16_period (5,500);     /* 10uS      */   call test_d16_period (4,5000);    /* 1uS       */   /* Test interrupts                                                      */   /* Set up for tests  */   write (d137) = shl (4,8);  /* Set fastest rate         */   enable;                    /* enable interrupts        */   /* Test D16 interrupt enable on load  */   call print_test_message (11);   d16_int_count = 0;             /* clear interrupt counter         */   write (d16) = 1000;            /* Set up to get int in < 5mS      */   wait (2);                      /* wait >= 5 mS                    */   if d16_int_count = 0    then call error (11, 0, 0);    /* error if we don't get an int    */   /* Test D16 interrupt disable  */   call print_test_message (12);   write (d136) = shl (4,8);      /* disable d16 interrupt           */   d16_int_count = 0;   write (d16) = 1000;            /* Set up to get int in < 5mS      */   wait (1);                      /* wait 5 mS                       */   if d16_int_count <> 0    then call error (12, 0, 0);    /* error if we DO get an int       */     /* Test D16 interrupt enable  */   call print_test_message (13);   write (d136) = shl (5,8);      /* enable d16 interrupt            */   d16_int_count = 0;   write (d16) = 1000;            /* Set up to get int in < 5mS      */   wait (1);                      /* wait 5 mS                       */   if d16_int_count = 0    then call error (13, 0, 0);    /* error if we don't get an int    */   /* Test D17 write                                                       */   /* Test hang on write to D17    */   /* Make sure it's not too short */   call print_test_message (14);   disable; /* prevent interrupt from screwing up timing and reseting flag */   write (d136) = 0;   write (d136) = 0;   /* Sync execution to D136 clock     */   write (d16) = 4950; /* A hair short of one D136 period  */   write (d17) = 0;    /* Hang for that interval           */   if (read (d136) <> clear)   then call error (14, 0, 0);   /* Make sure it's not too long */   write (d136) = 0;   write (d136) = 0;   /* Sync execution to D136 clock        */   write (d16) = 5010; /* A hair longer than one D136 period  */   write (d17) = 0;    /* Hang for that interval              */   if (read (d136) <> set)   then call error (15, 0, 0);                       end test_d16;/***************************************************************************/test_d137: procedure;   dcl last_hundreth fixed; /* Used to dly time print until time change */   dcl period        fixed; /* Result of 1 sec. period time test        */   /************************************************************************/   set_time: proc (hundreth,hour,minute,second,month,date,year,day_of_week);      dcl (hundreth,hour,minute,second,month,date,year,day_of_week) fixed;            write (d137) = com_ad;    /* set command reg address        */      write (d137) = 0;         /* 00000000b, turns counters off  */      write (d137) = data_ad;   /* set data reg address           */      write (d137) = hundreth;  /* Set all the time regs...       */      write (d137) = hour;      write (d137) = minute;      write (d137) = second;      write (d137) = month;      write (d137) = date;      write (d137) = year;      write (d137) = day_of_week;   end set_time;   /************************************************************************/   set_alarm: proc (hundreth,hour,minute,second,month,date,year,day_of_week);      dcl (hundreth,hour,minute,second,month,date,year,day_of_week) fixed;      /* Holds alarm RAM contents to preserve mask bits while setting alarm */      dcl temp_time_holder (7) fixed;       /* Set up internal pointer to get alarm registers               */      write (d137) = data_ad;   /* Point to data registers            */      do i = 0 to 7;            /* Skip over time registers           */         dummy = read (d137);   /* Increment internal address pointer */      end;      /* Get alarm RAM values */      do i = 0 to 7;         temp_time_holder (i) = read (d137);      end;      /* Set up internal pointer to set alarm registers               */      write (d137) = data_ad;   /* Point to data registers            */      do i = 0 to 7;            /* Skip over time registers           */         dummy = read (d137);   /* Increment internal address pointer */      end;      /* Set alarm RAM regs preserving preexisting mask bits */      write (d137) = ((temp_time_holder (0) & "h80") or hundreth);      write (d137) = ((temp_time_holder (1) & "h40") or hour);      write (d137) = ((temp_time_holder (2) & "h80") or minute);      write (d137) = ((temp_time_holder (3) & "h80") or second);      write (d137) = ((temp_time_holder (4) & "h80") or month);      write (d137) = ((temp_time_holder (5) & "h80") or date);      write (d137) = ((temp_time_holder (6) & "h80") or year);      write (d137) = ((temp_time_holder (7) & "h80") or day_of_week);   end set_alarm;   /************************************************************************/   read_time: proc;      write (d137) = data_ad;       /* Set data register address       */      hundreth     = read (d137);   /* Set global vars to time values  */      hour         = read (d137);      minute       = read (d137);      second       = read (d137);      month        = read (d137);      date         = read (d137);      year         = read (d137);      day_of_week  = read (d137);   end read_time;   /************************************************************************/   d137_read_write_test: proc (bit_pattern);      dcl bit_pattern fixed;  /* Pattern to write, rotate, write, rotate...   */      dcl reg            fixed;  /* Counts through each time and alarm register  */      dcl shift_count    fixed;  /* Counts to 7 in loop to test all bits in reg  */      dcl masked_pattern fixed;  /* Bit_pattern masked by mask data  */      do shift_count = 0 to 7;     /* Ripple down the bits  */         write (d137) = data_ad;   /* Point to the data regs  */         /* Fill the regs with this pattern  */         do reg = 0 to 15;            /* For each time and alarm register  */            masked_pattern = (bit_pattern and masks (reg));            if  (masked_pattern >= min_times (reg)) /* If pattern doesn't  */            and (masked_pattern <= max_times (reg)) /* exceed max or min   */            then write (d137) = masked_pattern;     /* Write the pattern   */            else write (d137) = 1;   /* else just advance internal pointer */         end;         /* Check to see that they're correct  */         write (d137) = data_ad;         do reg = 0 to 15;            /* For each time and alarm register  */            masked_pattern = (bit_pattern and masks (reg));            if  (masked_pattern >= min_times (reg)) /* If pattern doesn't  */            and (masked_pattern <= max_times (reg)) /* exceed max or min   */            then do;                                /* then test...        */               if (read (d137) <> masked_pattern)               then call error (20, reg, bit_pattern);            end;            else dummy = read (d137);  /* else just advance internal pointer */         end;         bit_pattern = shl (bit_pattern, 1);  /* Derive next pattern  */      end;   end d137_read_write_test;   /************************************************************************/   d137_per_int_test: proc (int_bit_num,dly,hundreth,hour,minute,second,month,date,year,day_of_week) fixed;      dcl int_bit_num  fixed; /* Bit number of int being tested this call  */      dcl dly          fixed; /* Time to wait for int in 1/200th secs      */      dcl (hundreth,hour,minute,second,month,date,year,day_of_week) fixed;      dcl actual_int_bit_num fixed; /* Holds result of 'slowest_int_set'   */      /* since it's needed twice and a read of int stat reg resets flags   */      /************  LOCAL PROCEDURES  **************/         /*-------------------------------------------------------------------------*/      /* FUNCTION: 'slowest_int_set' looks at the D137 interrupt status register */      /*   and returns the bit number (1-6) of the slowest periodic interrupt    */      /*   flag that is set.  The SLOWEST is returned because, if it is set, all */      /*   the faster ones will be set as well.  The slowest one is the true     */      /*   source of any interrupt that has occurred.                            */      /* RETURNS: A fixed point number which is the bit number of the slowest    */      /*   interrupt bit in the D137 interrupt status register that is set.      */      /*   If no bit is set then 0 is returned.                                  */      /*-------------------------------------------------------------------------*/      slowest_int_set: proc returns (fixed);         dcl int_status_mask lit '"h7E"';    /* Mask to AND off unwanted bits */         dcl bit_num         fixed;    /* Counts for each bit in reg          */         d137_int_status = (d137_int_status and int_status_mask); /* Mask uninteresting bits */         /* Look for MS bit that's set and return its number.            */         do bit_num = 0 to 6;                          /* for each bit   */            d137_int_status = shr (d137_int_status, 1);  /* shift the reg  */            if (d137_int_status = 0)                    /* until it's = 0 */            then return (bit_num);                     /* That was the 1 */         end;      end slowest_int_set;      /*-------------------------------------------------------------------------*/      /* FUNCTION: 'power' raises the first arg to the power of the second arg.  */      /*   Fixed point only!  Exponents >= 1 only.  Used to get a VALUE to test  */      /*   the int status register with given the number of the bit to test      */      /* RETURNS: Result                                                         */      /* METHOD: Multiplies in a loop.                                           */      /* PARAMETERS: Mantissa, Exponent                                          */      /*-------------------------------------------------------------------------*/      power: proc (mantissa, exponent) returns (fixed);         dcl mantissa fixed;         dcl exponent fixed;         dcl result   fixed;         result = 1;         do i = 1 to exponent;            result = (result * mantissa);         end;         return (result);      end power;   /* PROCEDURE 'D137_PER_INT_TEST' CODE                                   */      write (d137) = int_ad;      write (d137) = 0;       /* Disable all periodic interrupts  */      dummy = read (d137);    /* Reset global int flag            */      d137_int_status = 0;    /* Reset int status var             */      /* Set time to just before int under test and stop the clock */      call set_time (hundreth,hour,minute,second,month,date,year,day_of_week);      write (d137) = com_ad;      write (d137) = "010";   /* Start clock and Disable ints  */      wait (dly);             /* Wait for turnover  */      /* Fail if 'Global Interrupt' flag gets set.  */      if (d137_int_status >= 128)       then call error (21, int_bit_num, d137_int_status);      /* Set time to just before int under test and stop the clock */      call set_time (hundreth,hour,minute,second,month,date,year,day_of_week);      write (d137) = int_ad;      /* Enable the periodic interrupt under test  */      write (d137) = power (2, int_bit_num);       dummy = read (d137);    /* Reset global int flag */      d137_int_count = 0;     /* Reset our int counter */      write (d137) = com_ad;      write (d137) = "030";   /* Start clock and Enable interrupts  */      wait (dly);             /* Wait for turnover  */      /* Fail if no interrupt was received  */      if (d137_int_count = 0)       then call error (22, int_bit_num, 0);      /* Fail if bit corresponding to periodic int under test isn't the    */      /* slowest periodic int bit set                                      */      actual_int_bit_num = slowest_int_set;      if (int_bit_num <> actual_int_bit_num)      then call error (23, int_bit_num, actual_int_bit_num);      write (d137) = com_ad;      write (d137) = 0;       /* Stop clock and Disable ints  */   end d137_per_int_test;   /************************************************************************/   alarm_test: proc (reg_under_test, hundreth,hour,minute,second,month,date,year,day_of_week,                     t_hundreth,t_hour,t_minute,t_second,t_month,t_date,t_year,t_day_of_week) fixed;      /* Alarm RAM reg being tested this call */      dcl reg_under_test fixed;      /* Time to set the ALARM for in this call */      dcl (hundreth,hour,minute,second,month,date,year,day_of_week) fixed;      /* Time to set the CLOCK to. (1/100 sec. before the alarm time) */      dcl (t_hundreth,t_hour,t_minute,t_second,t_month,t_date,t_year,t_day_of_week) fixed;      dcl reg        fixed;  /* Num of reg being worked on  */      /************  LOCAL PROCEDURE  **************/         /*-------------------------------------------------------------------------*/      /* PROCEDURE: 'point_to_reg' adjusts the auto-incrementing addressing      */      /*   aspect of the D137's data registers to point to an arbitrary register */      /*   whose number is passed in.                                            */      /* PARAMETERS: 'reg' - Number of clock/calendar data reg to point to.      */      /*-------------------------------------------------------------------------*/      point_to_reg: proc (reg);         dcl reg fixed;  /* The clock/calendar data reg to set up a reference to */         write (D137) = data_ad;         do i = 1 to reg;            dummy = read (d137);         end;      end point_to_reg;   /* PROCEDURE 'ALARM_TEST' CODE                                          */       /* Test that one alarm register's mask bit does disable its int */      /* At the outset, all alarm mask bits are set (ints DISabled)   */      /* Set alarm to test this alarm register */      call set_alarm (hundreth,hour,minute,second,month,date,year,day_of_week);      /* Set time to just before int under test */      call set_time (t_hundreth,t_hour,t_minute,t_second,t_month,t_date,t_year,t_day_of_week);      /* Enable the D137 alarm interrupts and disable periodic ints in the int mask reg */      write (d137) = int_ad;      write (D137) = 1;      d137_int_count = 0; /* Set up to detect int */      write (d137) = com_ad;      write (d137) = "030";   /* Start clock and Enable interrupts  */      wait (6);  /* wait 3/100th Secs for possible int */      write (d137) = com_ad;      write (d137) = 0;       /* Stop clock and Disable ints  */      if (d137_int_count <> 0)  /* Fail if we get an int */      then call error (25, reg_under_test, d137_int_status);      /* Test UNmasking (enabling) this alarm register  */      /* Unmask the mask bit in the reg under test */      write (d137) = data_ad;        /* Find the register */      do reg = 0 to (reg_under_test - 1);         dummy = read (d137);      end;      write (d137) = 1;   /* Unmask the bit (writes a 0 to the mask bit) */      /* Enable the D137 alarm interrupts and disable periodic ints in the int mask reg */      write (d137) = int_ad;      write (D137) = 1;      /* Set alarm to test this alarm register */      call set_alarm (hundreth,hour,minute,second,month,date,year,day_of_week);      /* Set time to just before int under test */      call set_time (t_hundreth,t_hour,t_minute,t_second,t_month,t_date,t_year,t_day_of_week);      d137_int_count = 0; /* Set up to detect int */      write (d137) = com_ad;      write (d137) = "030";   /* Start clock and Enable interrupts  */      wait (6);  /* wait 3/100th Secs for int */      write (d137) = com_ad;      write (d137) = 0;       /* Stop clock and Disable ints  */      if (d137_int_count = 0)  /* Fail if we didn't get an int */      then call error (26, reg_under_test, d137_int_status);      if (d137_int_status ilt 128)  /* Fail if global int bit not set */      then call error (28, reg_under_test, d137_int_status);      if ((d137_int_status & "h01") <> 1)  /* Fail if alarm bit not set */      then call error (27, reg_under_test, d137_int_status);      /* Remask the mask bit in the reg under test */      write (d137) = data_ad;        /* Find the register */      do reg = 0 to (reg_under_test - 1);         dummy = read (d137);      end;      write (d137) = "hC1";   /* Mask the bit (writes a 1 to the mask bit) */   end alarm_test;   /************************************************************************/   if peek <> -1 then return;   pos(status_line2); erase_line;   pstring('  - D137 Clock/Calendar');   flush_term;   /* Initialize command register                                       */   write (d137) = com_ad;  /* Set up to set modes:                      */   write (d137) = 0;       /* Crystal freq. 32K, 12 hour format, Stop,  */                           /*   Interrupts disabled, Normal mode        */   /* Write maximum values to all data registers and check                 */   call print_test_message (16);  /* Tell user of subtest if verbose mode  */   call set_time  (max_times (0), max_times (1), max_times (2), max_times (3),                   max_times (4), max_times (5), max_times (6), max_times (7));   call set_alarm (max_times (0), max_times (1), max_times (2), max_times (3),                   max_times (4), max_times (5), max_times (6), max_times (7));   /* Check time registers  */   if peek <> -1 then return;   call read_time;   if (hundreth <> max_times (0)) or (hour   <> max_times (1))   or (minute <> max_times (2))   or (second <> max_times (3))   or (month  <> max_times (4))   or (date   <> max_times (5))   or (year   <> max_times (6))   or (day_of_week <> max_times (7))   then call error (16, 0, 0);   /* Check alarm registers  */   if ((read (d137) & "h7F") <> max_times (0)) or ((read (d137) & "h0F") <> max_times (1))   or ((read (d137) & "h7F") <> max_times (2)) or ((read (d137) & "h7F") <> max_times (3))   or ((read (d137) & "h7F") <> max_times (4)) or ((read (d137) & "h7F") <> max_times (5))   or ((read (d137) & "h7F") <> max_times (6)) or ((read (d137) & "h7F") <> max_times (7))   then call error (17, 0, 0);   /* Write minimum values to all data registers and check                 */   call print_test_message (18);  /* Tell user of subtest if verbose mode  */   call set_time  (0, 1, 0, 0, 1, 1, 0, 0);   call set_alarm (0, 1, 0, 0, 1, 1, 0, 0);   /* Check time registers  */   call read_time;   if (hundreth <> 0) or (hour   <> 1)   or (minute <> 0)   or (second <> 0)   or (month  <> 1)   or (date   <> 1)   or (year   <> 0)   or (day_of_week <> 0)   then call error (18, 0, 0);   if peek <> -1 then return;   /* Check alarm registers  */   if ((read (d137) & "h7F") <> 0) or ((read (d137) & "h0F") <> 1)   or ((read (d137) & "h7F") <> 0) or ((read (d137) & "h7F") <> 0)   or ((read (d137) & "h7F") <> 1) or ((read (d137) & "h7F") <> 1)   or ((read (d137) & "h7F") <> 0) or ((read (d137) & "h7F") <> 0)   then call error (19, 0, 0);   /* Test reads and writes to all time and alarm regs stressing each bit  */   call print_test_message (20);   call d137_read_write_test (one_in_zeros);   call d137_read_write_test (zero_in_ones);   /* Test AM/PM and alarm int mask bits                                   */   call print_test_message (24);   /* Clear those bits  */   write (d137) = data_ad;   dummy = read (d137);    /* Skip to hours reg */   write (d137) = "h71";   /* Clear AM/PM bit   */   do i = 2 to 7;          /* Skip to first alarm reg */      dummy = read (d137);   end;   do i = 8 to 15;         /* Clear all mask bits */      write (d137) = 1;   end;   /* Check that they're cleared  */   dummy = read (d137);    /* Skip to hours reg */   if (read (d137) >= 128) /* Error if AM/PM bit is set */   then call error (24, 1, 0);   do i = 2 to 7;          /* Skip to first alarm reg */      dummy = read (d137);   end;   if (read (d137) >= 128) /* Error if mask bit in reg 8 is set */   then call error (24, 8, 0);   if (read (d137) >= 64) /* Error if AM/PM or mask bit in reg 9 is set */   then call error (24, 9, 0);   do i = 10 to 15;             /* Check all mask bits */      if (read (d137) >= 128)  /* Error if any are set */      then call error (24, i, 0);   end;   /* Set those bits  */   write (d137) = data_ad;   dummy = read (d137);    /* Skip to hours reg       */   write (d137) = "h81";   /* Set AM/PM bit in reg 1  */   do i = 2 to 7;          /* Skip to first alarm reg */      dummy = read (d137);   end;   write (d137) = "h80";   /* Set mask bit in reg 8 */   write (d137) = "hC1";   /* Set mask & AM/PM bit in reg 9 */   do i = 10 to 15;        /* Set rest of mask bits */      write (d137) = "h81";   end;   /* Check that they're set  */   write (d137) = data_ad;   dummy = read (d137);        /* Skip to hours reg */   if (read (d137) ine "h81")  /* Error if AM/PM bit in reg 1 is clear */   then call error (24, 1, 1);   do i = 2 to 7;              /* Skip to first alarm reg */      dummy = read (d137);   end;   if (read (d137) ine "h80")  /* Error if mask bit in reg 8 is clear */   then call error (24, 8, 1);   if (read (d137) ine "hC1")  /* Error if mask or AM/PM bit in reg 9 is clear */   then call error (24, 9, 1);   do i = 10 to 15;              /* Check rest of mask bits */      if (read (d137) ine "h81") /* Error if any are clear */      then call error (24, i, 1);   end;   goto NOGROSS;   /* @@ */   /************************************************************************/   /* Test gross synchronization to D16 using 1 sec periodic interrupt */   call print_test_message (30);   write (d137) = shl (6, 8);   write (d16) = 1;   /* (was 0) Set D16 rate = 100uS */   write (d137) = int_ad;   write (d137) = "010";   /* enable 1 sec per int only */   write (d137) = com_ad;   write (d137) = "030";   /* Start the clock and enable ints */   /* Wait for first interrupt */   d137_int_count = 0;   do while (d137_int_count = 0);   end;   period = read (d16); /* Set up to time a D137 second with d16 */   /* Wait for second interrupt */   d137_int_count = 0;   do while (d137_int_count = 0);   end;   period = read (d16) - period;  /* Read D137 period */   if (period < 9990)   or (period > 10010)   then call error (30, period, 0);   /* Test gross synchronization to D16 using polling */   call print_test_message (29);   disable;   write (d137) = shl (6, 8);   write (d16) = 1;  /* (was 0) set D16 rate = 100 us */   write (d137) = int_ad;    /* set up to read interrupt register */   d137_int_status = read (d137);            /* reset interrupt register */   do while (read (d137) & "10") = 0;  end;  /* wait for first tick     */   period = read (d16);  /* Set up to time a D137 second with d16 */   do while (read (d137) & "10") = 0; end;    /* wait for second tick */   period = read (d16) - period;  /* Read D137 period */   if (period < 9990)   or (period > 10010)   then call error (29, period, 0);   enable;/***************************************************************************/   NOGROSS:;   /* Disable ints and stop clock */   write (d137) = com_ad;   write (d137) = 0;   /* Test periodic interrupts                                             */   if peek <> -1 then return;   /* Call proc to test each per int, passing in int stat reg bit num and  */   /* a time just before that interrupt should occur.                      */   call print_test_message (21);   call d137_per_int_test (6, 3, 99, "h8B", 59, 59, 1, 1, 1, 1);  /* Day  */   call d137_per_int_test (5, 3, 99, 1, 59, 59, 1, 1, 1, 1);      /* Hour */   call d137_per_int_test (4, 3, 99, 1, 1, 59, 1, 1, 1, 1);       /* Min  */   call d137_per_int_test (3, 3, 99, 1, 1, 1, 1, 1, 1, 1);        /* Sec  */   call d137_per_int_test (2, 21, 38, 1, 1, 1, 1, 1, 1, 1);       /* 1/10 Sec  */   call d137_per_int_test (1, 3, 1, 1, 1, 1, 1, 1, 1, 1);         /* 1/100 Sec */   /* Test alarm feature (including alarm int mask feature)                */   if peek <> -1 then return;   call print_test_message (25);   call alarm_test (14, 0, "h0C", 0, 0, 1, 1, 2, 2,      /* ALARM time */                       98, "h8B", 59, 59, 12, 31, 1, 1); /* Clock time */ /* Year test */   call alarm_test (12, 0, "h0C", 0, 0, 1, 1, 2, 2,                       98, "h8B", 59, 59, 12, 31, 1, 1); /* Month */   call alarm_test (13, 0, "h0C", 0, 0, 1, 1, 2, 2,                       98, "h8B", 59, 59, 12, 31, 1, 1); /* Date */   call alarm_test (15, 0, "h0C", 0, 0, 1, 1, 2, 2,                       98, "h8B", 59, 59, 12, 31, 1, 1); /* Day */   call alarm_test (9, 0, "h0C", 0, 0, 1, 1, 2, 2,                      98, "h8B", 59, 59, 12, 31, 1, 1);  /* Hour */   call alarm_test (10, 0, "h0C", 0, 0, 1, 1, 2, 2,                       98, "h8B", 59, 59, 12, 31, 1, 1); /* Minute */   call alarm_test (11, 0, "h0C", 0, 0, 1, 1, 2, 2,                       98, "h8B", 59, 59, 12, 31, 1, 1); /* Second */   call alarm_test (8, 0, "h0C", 0, 0, 1, 1, 2, 2,                      98, "h8B", 59, 59, 12, 31, 1, 1);  /* Hundreth */   end test_d137;/***************************************************************************//**********************     Main Program     *******************************//***************************************************************************/pos(status_line1); erase_line; pstring('Testing M64K clocks/calendar... ');pos(status_line2);enable;           /* Enable all interrupts  */  if (interp_is_running != 0)  	return;/* Perform all tests: */call test_d136;if peek <> -1 then goto m64reset;call test_d16;if peek <> -1 then goto m64reset;call test_d137;m64reset:;call reset_int_status; /* Put interrupts back to original state  */   end #test_m64k;/***************************************************************************//*clear_screen;iteration_number = 1;do forever;  pos(2,10); pstring('Iteration #'); unum(iteration_number,0);  flush_term;  if peek <> -1 then call exit(0);  test_m64k;   crlf; pnum(m64k_errors,5);  flush_term;  iteration_number = iteration_number + 1;end;*/