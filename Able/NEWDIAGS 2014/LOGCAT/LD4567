/*Title           : D4567 Hardware MPY/DIV test module  - inserted in LOGGERProject Engineer: William LeathersProject Start   : Feb 1986New England Digital Corporation*//***************************************************************************//************     Required for stand - alone compilation    ****************//*insert ':-xpl:asciidef';insert ':-xpl:termutil';insert ':-xpl:intrprtr';insert ':NEWDIAGS:sysinit';dcl status_line1 lit '18,10';  dcl status_line2 lit '19,10'; dcl status_line3 lit '20,10';  dcl status_line4 lit '21,10'; dcl erase_status_lines lit 'call clr_status';clr_status: proc;  pos(status_line4); erase_line;  pos(status_line3); erase_line;  pos(status_line2); erase_line;  pos(status_line1); erase_line;end clr_status;*//***************************************************************************//***************************************************************************/dcl test_d4567        lit 'call #test_d4567';dcl d4567_errors      fixed;/***************************************************************************/#test_d4567: proc;  DCL (I,J,K,L,M,query,next,numtests,no_mul_error) FIXED;  DCL (passes,PHASE,TEM,outloop,inloop) FIXED;  dcl psw   lit '"1"'; /* program status word address */  dcl minus_flag lit '2';  dcl A_reg lit '"4"'; dcl rem lit 'A_reg'; dcl msb lit 'A_reg';  dcl B_reg lit '"5"'; dcl quo lit 'B_reg'; dcl lsb lit 'B_reg';  dcl mul   lit '"6"';  dcl div   lit '"7"';    /*************************************************************************/  dcl log_d4567_error lit 'call #log_d4567_error';  #log_d4567_error: proc;     if d4567_errors <> "HFFFF" then         d4567_errors = d4567_errors + 1;  end #log_d4567_error;  /*************************************************************************/  pos(status_line1); erase_line;  pstring('Testing D4567 ... ');  pos(status_line2);  erase_line;  pstring('  - Test loading A and B registers.');  pos(status_line3); erase_line;  do i= 0 to 32767;     if peek >= 0 then return;     WRITE(B_reg)=I; WRITE(A_reg)=^I;     J=READ(B_reg);  K=READ(A_reg);     IF (I^=J) or (K^=(^I)) THEN DO;        log_d4567_error;        pos(status_line3); erase_line;        pstring('  - Register load error'); pos(status_line4);     END;  end;  do i= -32768 to -1;     if peek >= 0 then return;     WRITE(B_reg)=I; WRITE(A_reg)=^I;     J=READ(B_reg);  K=READ(A_reg);     IF (I^=J) or (K^=(^I)) THEN DO;        log_d4567_error;        pos(status_line3); erase_line;        pstring('  - Register load error'); pos(status_line4);     END;  end;  pos(status_line3); erase_line;    pos(status_line2); erase_line;  /* now test multiply/divide */  NEXT=0;  DO outloop=0 TO 15; /* TRY 16 VALUES FOR NEXT H0000 H1111 H2222, ETC */    pos(status_line2); erase_line;    pstring('  - Start of test with '); hnum(NEXT,5);    pos(status_line3); erase_line;    I=0;J=0;K=0;PHASE=0; no_mul_error = true;    do passes = 0 to 3; /* to get 65,536 different I values */     do inloop = 0 to 32767; /* completed inloop gives 16384 different I's */       if peek >= 0 then return;       WRITE(B_reg)=I;WRITE(mul)=NEXT;       L=READ(lsb);M=READ(msb);       IF (J^=L)\(K^=M) THEN DO;         log_d4567_error;         pos(status_line3); erase_line;         no_mul_error = false; /* mult wrong means divide probably wrong */         pstring('  - Multiply error ');       END;       IF NEXT^=0 and no_mul_error THEN DO; /* Not on zero divide or mult error */         WRITE(div)=NEXT; /* DIVIDE BACK BY NEXT */         L=READ(quo);M=READ(rem); /* quotient AND REMAINDER */         IF (L^=I) or (M^=0) THEN DO;           log_d4567_error;           pos(status_line3); erase_line;           pstring('  - Divide error ');         END;       END;/* NOT DIVIDING BY ZERO */       else if not(no_mul_error) then no_mul_error = true; /* reset for next pass */        IF PHASE=0 THEN DO; /* TRY OTHER WAY AROUND */         TEM=I;I=NEXT;NEXT=TEM;         PHASE=1;       END;       ELSE DO;         TEM=I;I=NEXT;NEXT=TEM; /* RESTORE ORIGINAL */         PHASE=0;         I=I+1; J=J+NEXT;         IF (READ(psw) and minus_flag)^=0 THEN K=K+1; /* carry on j+next */       END;      END; /* inloop */     end; /* passes */     next = next + "H1111";   end; /* outloop */end #test_d4567;/***************************************************************************//*clear_screen; test_d4567;  crlf; pnum(d4567_errors,0); flush_term;*/