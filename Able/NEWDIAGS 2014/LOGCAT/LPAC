/*Title           : PSPA1/PSPA2 test module  - inserted in LOGGERProject Engineer: William LeathersProject Start   : Feb 1986New England Digital CorporationTaken from POLYTRON written by A. DombeckModified:                  05/23/89  WSL - Added routine pinit with PSPA2 unmoding     (friday) 01/13/89  WSL - general clean-up, optimization              02/08/86  WSL - Made into a module for LOGGER*//***************************************************************************//************     Required for stand - alone compilation    ****************//*insert ':-xpl:asciidef';insert ':-xpl:termutil';insert ':-xpl:intrprtr';insert ':NEWDIAGS:sysinit';dcl status_line1 lit '18,10';  dcl status_line2 lit '19,10'; dcl status_line3 lit '20,10';  dcl status_line4 lit '21,10'; dcl erase_status_lines lit 'call clr_status';clr_status: proc;  pos(status_line4); erase_line;  pos(status_line3); erase_line;  pos(status_line2); erase_line;  pos(status_line1); erase_line;end clr_status;*//***************************************************************************//***************************************************************************//*   When the PSPA2 and PSF were modified to provide an additional 4 poly   memory addressing bits, the capability to address individual sound files   in excess of 32 MB was added to the PSPA2. In other words, the wave table    length (and loop length) hardware were extended by four bits.    Unfortunately, the wave table length (and loop length) hardware expect   2's complement numbers, and software releases up to and including 1.0   were writing 0's to those don't care bits instead of 1's.  This means that   if a new PSPA2 got into the hands of a user who was running older   releases, his memory addressing would be all screwed up.   Solution: (as of 1/13/89)        1) Modify the PSPA2s by hand to undo those four bits and restore the           original don't care state.       2) Decide that we don't really need more than 32 Meg in a sound file          anyway.   The point of all this is that the most significant byte of the least   significant (second) data word for loop length or wave table length   still doesn't care. - WSL*//***************************************************************************/dcl test_phase_accumulator lit 'call test_pacs';dcl phase_accumulator1_errors(psmaxbins) fixed;dcl phase_accumulator2_errors(psmaxbins) fixed;/*******************************************************************/test_pacs: proc(bin#,pac_number);   dcl (bin#,pac_number) fixed;        /* 1 or 2 */   dcl (bin_base,num_mbytes) fixed;   dcl buf("H4000") fixed;    /*@@ this was 16834(H41C2) transposed 3 & 8? */  /*******************************************************************/  dcl log_pac_error lit 'call log_pac_err';  log_pac_err: proc(bin#,num);     dcl (bin#,num) fixed;     bin_base = bin# * 64;     if num = 1 then do;       if phase_accumulator1_errors(bin#) = 0 then do;         pos(status_line3); erase_line;         pstring('  - Error in phase accumulator #1 ');       end;       if phase_accumulator1_errors(bin#) <> "HFFFF" then           phase_accumulator1_errors(bin#) = phase_accumulator1_errors(bin#) + 1;     end;     else do;       if phase_accumulator2_errors(bin#) = 0 then do;         pos(status_line3); erase_line;         pstring('  - Error in phase accumulator #2 ');       end;       if phase_accumulator2_errors(bin#) <> "HFFFF" then           phase_accumulator2_errors(bin#) = phase_accumulator2_errors(bin#) + 1;     end;  end log_pac_err;  /*******************************************************************/  pinit: proc(bin#);    dcl bin# fixed;    dcl (i,j,bin_base) fixed;    bin_base = bin# * 64;     do i = 0 to 31;                /* zero out each channel- including refresh channel */        WRITE(PSC) = bin_base + i;         WRITE(PSF) = PSWL;        WRITE(PSD) =  -1; WRITE(PSD)=0;   /* wave table length of 256 */        WRITE(PSD) =   0; WRITE(PSD)=0;   /* base address of 0        */        WRITE(PSD) =  -1; WRITE(PSD)=0;   /* loop length of 256       */        WRITE(PSD) =   0; WRITE(PSD)=1;   /* phase incr of 1          */        WRITE(PSD) =   0;                 /* incr of 1                */        WRITE(PSD) = 255;                 /* modulus of 1             */        WRITE(PSD) =   0;                 /* off and no looping       */     END;           end pinit;  /*******************************************************************/  pa1_test:proc(bin#);     dcl bin# fixed;     dcl (i,j,bin_base) fixed;     dcl xwrd fixed;     dcl x_msecs fixed;     dcl x fixed;     dcl y fixed;     bin_base = bin# * 64;     erase_status_lines;     pstring('Testing phase accumulator #1 in bin ');      pnum(bin#+1,1); pstring('...');	 interp_run_host();     call polyinit;     call pinit(bin#);     call pbmwrite(bin#,0,0);   /* fill the lower 16 bits with an address */     i = 0;     do while i <> "HFFFF";       write(psd) = ^i;       i = i + 1;     end;     write(psd) = ^i;               /* write the ^"HFFFF" */     /* @@ The code's original sector value was FF80 and comment said 64K */     /* that wave table length would really be 127 sectors of 256 words.  */     /* 64K (bytes) is really "HFF7F" and "HFF00" (or "H0000", don't care)*/     write(psc) = bin_base;      write(psf) = pswl;     write(psd) = "HFF7F"; write(psd) = "HFF00"; /* wave table length of 64k */     write(psd) =       0; write(psd) = 0;       /* base address of 0        */     write(psd) = "HFF7F"; write(psd) = "HFF00"; /* loop length of 64k */     write(psd) =       0; write(psd) = 1;       /* phase incr of 1          */     write(psd) =       0;                       /* incr of 1                */     write(psd) = 255;                           /* mod of 1(SR = 101.01 KHz)*/     do j = 0 to 3;           if peek >= 0 then return;               x_msecs=interp_fetch_real_msecs(0);                   write(psf) = psrma;        write(psd) = 0;                  /* reset the fifo            */        write(psf) = pspat;              /* PA test function code     */        write(psd) = 3;                  /* on and looping            */        		if (interp_is_running != 0)		{	   	   // Software is designed to read 16k samples at one sample per 9.9 microseconds per sample.	   	   // thus taking 160 milliseconds.	   	   	   	   // Read for 150 milliseconds and see how many samples we got. Test all but the last one.	   	   	   	   // That is, while reading data we are sure to miss samples because of computer	   	   // interrupts. we will only verify those that we actually captured.	   	   	   	   i = 0;	   	   	   	   while ((interp_fetch_real_msecs(0) - x_msecs) < 150)	   	   {           	  buf(i) = read(psd);           	  i = i + 1;           }                     write(psf) = pson;           write(psd) = 0;                      if (i > 5)           {               y = 0;           	   do x = 0 to i - 2;	              while (buf(x) <> not (y + shl(J,14)))	              {	                y = y + 1;	                	                if (y >= 16384)	                {	           	  		send 'log_pac_error 1', x, buf(x), y, not (y + shl(J,14)), i;	              	              		log_pac_error(bin#,1);	              		return;	              	}	              }	              y = y + 1;           	   end;           }		}				else		{	        do i = 0 to "H3FFF";             /* to 16383 */	           buf(i) = read(psd);	        end;	        write(psf) = pson;	        write(psd) = 0;                  /* off with no looping */	       	        do i = 0 to "H3FFF";             /* to 12k - normal to miss a few samples on PowerPC */	           if buf(i) <> not (i + shl(J,14)) then log_pac_error(bin#,1);	        end;  		}  		        write(psf) = psba;               /* wave table base address */        write(psd) = shl(j+1,6); write(psd) = "00"; /* H40 00, H80 00, HC0 00, H100 00 */     end;  end pa1_test;  /*******************************************************************/  pa2_test:proc(bin#);     dcl bin# fixed;     dcl (i,j,k,bin_base) fixed;     dcl xwrd fixed;     dcl x_msecs fixed;     dcl x fixed;     erase_status_lines;     pstring('Testing phase accumulator #2 in bin ');     pnum(bin#+1,1); pstring('...');	 interp_run_host();     /* test the upper 8 bits of address  */     call polyinit;     call pinit(bin#);     bin_base = bin# * 64;     write(psc) = bin_base;     pos(status_line2); erase_line;      pstring('  - Filling memory bank ');     do i = 1 to (#_poly_mbytes(bin#) * 8)-1; /* 8 banks of 64K per board */       pos(status_line2 + 24); erase_line; unum(i,0); pstring('  ');       flush_term;       if peek >= 0 then return;       do k = 0 to 255;          xwrd = i & "HFF00";         call pbmwrite(bin#,shl(i,8) or k,xwrd);         do j = 0 to 255;           write(psd) = i;     /* i denotes the section of 64K memory   */         end;       end;     end;     pos(status_line2); erase_line;      pstring('  - Testing memory bank ');     write(psf) = pson;     write(psd) = 0;     write(psf) = psba;     write(psd) = 256; write(psd) = 0;     do j = 1 to (#_poly_mbytes(bin#) * 8)-1;        pos(status_line2 + 24); erase_line; unum(j,0); pstring('  ');        if peek >= 0 then return;        flush_term;        do k = 0 to 3;                     /* 16K at a time           */           i = 0;                      x_msecs=interp_fetch_real_msecs(0);                      write(psf) = psrma;           write(psd) = 0;                 /* reset the fifo           */           write(psf) = pspat;             /* PA test function code    */           write(psd) = 3;                  /* on and looping           */		   if (interp_is_running != 0)		   {		   	   // Software is designed to read 16k samples at one sample per 9.9 microseconds per sample.		   	   // thus taking 160 milliseconds.		   	   		   	   // Read for 150 milliseconds and see how many samples we got. Test all but the last one.		   	   		   	   // That is, while reading data we are sure to miss samples because of computer		   	   // interrupts. we will only verify those that we actually captured.		   	   		   	   i = 0;		   	   		   	   while ((interp_fetch_real_msecs(0) - x_msecs) < 150)		   	   {	           	  buf(i) = read(psd);	           	  i = i + 1;	           }	          	           write(psf) = pson;	           write(psd) = 0;	           	           if (i > 5)	           {	           	   do x = 0 to i - 2;		              if (buf(x) <> j)		              {		           	  	send 'log_pac_error 2', x, buf(x), j, i;		              	log_pac_error(bin#,2);		              }	           	   end;	           }		   }		   		   else		   {	           do i = 0 to "H3FFF";	              buf(i) = read(psd);	           end;	          	           write(psf) = pson;	           write(psd) = 0;	           	           do i = 0 to "H3FFF";	              if (buf(i) <> j) log_pac_error(bin#,2);	           end;	       }           write(psf) = psba;           xwrd = shr( (k+1+(j*4)),2 ) & "HFF00";           write(psd) = shl(k+1+(j*4),6); write(psd) = xwrd;        end;     end;  end pa2_test;  /*******************************************************************/  if pac_number = 1 then call pa1_test(bin#);  else call pa2_test(bin#);end test_pacs;/*******************************************************************//*begin;   dcl i fixed;   clear_screen;   do i = 0 to #_poly_bins - 1;     test_phase_accumulator(i,1);      crlf;     unum(phase_accumulator1_errors(i),6);   end;   do i = 0 to #_poly_bins - 1;     test_phase_accumulator(i,2);      crlf;     unum(phase_accumulator2_errors(i),6);   end;   flush_term;end;*/