/*ииииииииииииииииииии  A B O U T   T H I S   F I L E  ииииииииииииииииииии*//*FILENAME: L#ASM.0PATH:		 :SYNLITS:L#ASM.0CONTAINS: LITERAL DECLARATIONSREVISION HISTORY:00	1998/07/30	Todd Yvega	Created.*//*ииииииииииииииииииииииии  D E S C R I P T I O N  ииииииииииииииииииииииии*//*THIS FILE CONTAINS A LIBRARY OF LITERAL DECLARATIONS TO ASSIST IN WRITINGPSEUDO-ASSEMBLY LANGUAGE IN XPL PROGRAMS.*//*иииииииииииииии  L I T E R A L   D E C L A R A T I O N S  иииииииииииииии*///	Literals for pseudo-assembly language programming://	Registers:dcl r0	lit	'"00"',	//	register  0	(also accumulator 0)	 r1	lit	'"01"',	//	register  1	(also accumulator 1)	 r2	lit	'"02"',	//	register  2	(also accumulator 2)	 r3	lit	'"03"',	//	register  3	(also accumulator 3)	 r4	lit	'"04"',	//	register  4	 r5	lit	'"05"',	//	register  5	 r6	lit	'"06"',	//	register  6	 r7	lit	'"07"',	//	register  7	 r10	lit	'"10"',	//	register 10	 r11	lit	'"11"',	//	register 11	 r12	lit	'"12"',	//	register 12	NOTE:	r12 decrements rather than increments on write(mem_dst|incr|r12)	 r13	lit	'"13"',	//	register 13	ALWAYS FREE	 r14	lit	'"14"',	//	register 14	CURRENT MACHINE STATE	 r15	lit	'"15"',	//	register 15	STACK POINTER	 r16	lit	'"16"',	//	register 16	PROGRAM COUNTER during interrupt processing	 r17	lit	'"17"';	//	register 17	PROGRAM COUNTER during normal program flowdcl a0	lit	'"00"',	//	accumulator 0	(also register 0)	 a1	lit	'"01"',	//	accumulator 1	(also register 1)	 a2	lit	'"02"',	//	accumulator 2	(also register 2)	 a3	lit	'"03"';	//	accumulator 3	(also register 3)//	Sources:dcl imm_src		lit	'0x80';	//	10.. ....	immediate sourcedcl imm_mask	lit	'0x3F';	//	..11 1111	mask for -32 to +31dcl reg_src		lit	'0xC0';	//	110. rrrr	register source	(get value stored in register)dcl mem_src		lit	'0xE0';	//	111. rrrr	memory source		(get value stored in memory pointed to by register)dcl incr			lit	'0x10';	//	...1 ....	bit to set for "increment after read" or "increment after write" //	Destinations:dcl reg_dst		lit	'0xC0';	// 1100 rrrr	register destination	(store value in register.	NOTE: No increment bit available)dcl mem_dst		lit	'0xE0';	//	111. rrrr	memory destination	(store value in memory pointed to by register)// Destinations:	test operations (won't actually affect accumulators):dcl test_load	lit	'0xA0';	//	1010 00aadcl test_and	lit	'0xA4';	//	1010 01aadcl test_add	lit	'0xA8';	//	1010 10aadcl test_sub	lit	'0xAC';	//	1010 11aa// Destinations:	operations on accumulators:dcl load_acc	lit	'0x80';	//	1000 00aa	load source into accumulatordcl bit_and		lit	'0x84';	//	1000 01aa	bitwise logical and (accumulator && source)dcl add			lit	'0x88';	//	1000 10aa	add source to accumulator			(ignore carry bit)dcl subtract	lit	'0x8C';	//	1000 11aa	subtract source from accumulator	(ignore carry bit)dcl bit_xor		lit	'0x90';	//	1001 00aa	bitwise logical exclusive or (accumulator xor source)dcl left_rot	lit	'0x94';	//	1001 01aa	left rotate accumulator (source not used, so use imm_src for source to save time)dcl bit_or		lit	'0x98';	//	1001 10aa	bitwise logical or (accumulator or source)dcl load_compl	lit	'0x9C';	//	1001 11aa	load one's complement of source into accumulator (i.e., each bit will be changed to its opposite)dcl bswap_or	lit	'0xB0';	//	1011 00aa	byte-swap accumulator, then or with sourcedcl shr_add		lit	'0xB4';	//	1011 01aa	shift right by 1, then add sourcedcl add_carry	lit	'0xB8';	//	1011 10aa	add source to accumulator, then add 1 if carry bit is setdcl sub_borrow	lit	'0xBC';	//	1011 11aa	subtract source from accumulator, then subtract 1 if carry bit is not set//	Conditional Transfers:dcl cond			lit	'0xD0';	//	1101 .ccc	conditional transfer (load absolute source value into current program counter)dcl rel			lit	'0x08';	//	.... 1...	bit to set for relative transfer (add source value into current program counter, rather than load)//	Conditions:dcl always		lit	'0x00';	//	.... .000	alwaysdcl if_zero		lit	'0x01';	//	.... .001	zero flag ondcl if_carry	lit	'0x02';	//	.... .010	carry flag ondcl if_minus	lit	'0x03';	//	.... .011	minus flag ondcl never		lit	'0x04';	//	.... .100	neverdcl non_zero	lit	'0x05';	//	.... .101	non-zero	(zero flag off)dcl no_carry	lit	'0x06';	//	.... .110	no carry	(carry flag off)dcl positive	lit	'0x07';	//	.... .111	positive	(minus flag off)//	For masking upper and lower bytes (useful for specifying data words)dcl msb_mask	lit	'0xFF00';dcl lsb_mask	lit	'0x00FF';/*	NIFTY "HOW TO" EXAMPLESwrite("10")			= read(imm_src|2);	// repeat next instruction 3 timeswrite(cond|never)	= read(5);				//	"MWAIT" aka "D5 to ATNV"*/