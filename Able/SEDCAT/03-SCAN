/* 03-SCAN  $TITLE  Scan, Search, Indent, and Global Change commands *//* This module contains the token scanner, the search command, find partner,.  indent, rhythmic length, and global change routines. *//* XPL, SCRIPT and text keyword definitions - coded as length, chars, action */dcl nk.xpl lit '6';  dcl keys.xpl data(   2,a.D,a.O,+1,             /* DO */    3,a.E,a.N,a.D,-1,         /* END */    4,a.P,a.R,a.O,a.C,+1,     /* PROC */    5,a.B,a.E,a.G,a.I,a.N,+1, /* BEGIN */    6,a.M,a.O,a.D,a.U,a.L,a.E,+1, /* MODULE */   9,a.P,a.R,a.O,a.C,a.E,a.D,a.U,a.R,a.E,+1); /* PROCEDURE */dcl nk.scr lit '5';  dcl keys.scr data(   3,a.N,a.O,a.T,+1,                /* NOT */    3,a.D,a.E,a.F,+1,                /* DEF */   6,a.D,a.E,a.F,a.I,a.N,a.E,+1,    /* DEFINE */   8,a.N,a.O,a.T,a.E,a.L,a.I,a.S,a.T,+1, /* NOTELIST */    3,a.E,a.N,a.D,-1);               /* END */dcl scan.line fixed; /* number of recent line break found during scan */scanner:  proc(ptr,key.list,num.keys); /* looks for indent keywords in indicated line */  dcl key.list            array; /* coded key list */  dcl (num.keys,ptr,i,j)  fixed; /* number of keys, pointer to line */  dcl (ch,prev.ch,level)  fixed;  dcl (comment,quoted)    boolean; /* parse states */  dcl quote.char          fixed; /* single or double quote, as per type */  dcl first.char          fixed; /* first char of line, used for text commands */  dcl token(10)           fixed; /* space for identifiers */  dcl token.length        fixed; /* length of identifier */  dcl (word.ptr,word)     fixed; /* word pointer, word contents */  dcl (p,len)             fixed; /* string matching vars */  dcl match               boolean; /* flag for keyword matches */  level=0; /* assume no keys */  comment=false; quoted=false; /* assume not in comment or quoted string */  token.length=0; /* no token yet */  scan.charx=charx(ptr+1)+first.non.blank(ptr)-1; /* start at charx of first non-blank */  word.ptr=wordx(scan.charx); /* get pointer in words */  if scan.charx then do; word=buf(word.ptr); word.ptr=word.ptr+1; end; /* preload first word */  quote.char=a.apost; if cur.file.type>=C.TYPE then quote.char=a.quote;  prev.ch=-1; /* no previous char */  do while prev.ch<>0; /* step along chars of current line, plus ending 0 as delim */     ch=shr(word&"177400",8); /* assume odd byte */     if not scan.charx then do; /* update for even byte */        word=buf(word.ptr); word.ptr=word.ptr+1; /* get next word */        ch=(word&"377"); /* get even byte */     end;     if prev.ch=-1 then first.char=ch; /* save first char */     if ch=a.star and prev.ch=a.slash then comment=true; /* start of comment */     if ch=a.slash and prev.ch=a.star then comment=false; /* end of comment */     if not comment and ch=quote.char then quoted=quoted xor 1; /* quoted string */     if (not comment) and (not quoted) then do; /* program text char */        if cur.file.type<TEXT.TYPE then do; /* case for XPL, SCRIPT */           if delim(ch) then do; /* end of token, check against key list */              if token.length>1 then do; /* look up the token */                 p=0; /* p moves through keyword def fields */                 do i=0 to num.keys-1; /* loop over possible keys */                    len=key.list(p); /* look up length of this keyword */                    if token.length=len then do; /* if length matches */                       p=p+1; /* advance to first char of key */                       match=true; /* assume key found */                       do j=0 to len-1; /* loop over chars */                          if key.list(p)<>token(j) then match=false; /* match fails */                          p=p+1; /* advance to next char of key */                       end;                       if match then do; /* found key */                          level=level+key.list(p); /* apply key action to level */                          goto break.out; /* finished with this token */                       end; /* of found key */                       p=p+1; /* skip to next field */                    end; /* of length matches */                    else p=p+len+2; /* length does not match - advance to next key */                 end; /* loop over possible keys */              end; /* of token lookup */              BREAK.OUT:              token.length=0; /* clear out token */           end; /* of identifier test */           else if token.length<11 then do; /* add to string */              if (ch>=l.a) and (ch<=l.z) then ch=ch-"40"; /* up the case */              token(token.length)=ch; /* add to token string */              token.length=token.length+1; /* bump length */           end;        end; /* of case for XPL, SCRIPT */        else if (cur.file.type=C.TYPE) or (first.char=a.period) then do; /* case for C and Text types */           if      ch=a.lbrace then level=level+1;           else if ch=a.rbrace then level=level-1;        end;     end; /* program text char */     scan.charx=scan.charx+1; /* advance in buffer */     prev.ch=ch; /* save this char */     ch=byte(buf,scan.charx); /* get next char */  end; /* of do while */  return level;end scanner;key.search:  proc(ptr); /* invoke the scanner with the correct key list */   dcl ptr fixed;   if cur.file.type=SCRIPT.TYPE then return scanner(ptr,keys.scr,nk.scr); /* Script file */   if cur.file.type<LISP.TYPE   then return scanner(ptr,keys.xpl,nk.xpl); /* XPL, C, or Text */   return 0; /* Lisp or Fortran */end key.search;indent:  proc(ptr); /* compute the indent amount for the next line */   dcl (ptr,i,j) fixed;   i=first.non.blank(ptr); /* find where most recent non-blank line begins */   do while (i=0) and (ptr IGT text.ptr); /* scan back if all blank */      ptr=step.lines(ptr,-1); /* step back */      i=first.non.blank(ptr); /* look for non-blank */   end;   if i=0 then i=1; /* force first line to start at one */   j=indent.amount*key.search(ptr); /* check indents */   if (j>0) and (cur.file.type<>TEXT.TYPE) then i=i+j; /* add indents if not text */   return i;end indent;insert.line:  proc(line); /* to insert a blank line at given line and indent */   dcl (line,ptr,i) fixed;   ptr=point.to(line); /* point to line number of line being moved */   i=1; /* assume indent to column 1 */   if      left.margin>0 then i=left.margin; /* use left margin value */   else if line>1        then i=indent(point.to(line-1)); /* compute the indent position from prior line */   call slide(ptr,2); /* open space in file */   buf(ptr)=-1; /* insert line number into hole */   current.line=line; current.col=i; /* position to start of this new line */   call adjust.lines(1); /* count another line and update */   part.rewrite=true; /* rewrite screen from here on */   call show.line;end insert.line;return.cmd:  proc; /* return key */   dcl (i,j) fixed;   call write.cursor(1,false); /* restore current line */   if line.insert.mode & (current.col>current.line.length) then      call insert.line(current.line+1); /* insert new line */   else if current.line=cur.file.lines then call insert.line(current.line+1); /* split it to add new line */   else do; /* simply move to next line */      i=left.margin; /* assume use of left margin value */      if left.margin=0 then i=indent(current.ptr); /* must compute and save indent position */      current.line=current.line+1; /* go to next line */      current.col=i; /* move to indent position */      call show.line;   end; /* of case to move to next line */end return.cmd;/* $SUBTITLE  Read String, Use Text String, Find Partner */read.string:  proc(prompt,str); /* print prompt and accept str */   dcl (prompt,str) array;   dcl (i,ch)       fixed;   pcmd(prompt); /* prompt the user */   str(0)=0; /* clear returned string */   col.change=true; /* signal to restore cursor position */   ch=get.next.char; /* get first char */   do while ch<>a.CR; /* take chars until return key */      if ch>=a.del then do; /* case for rubouts */         if str(0)=0 then return; /* zero length line */         wchar(a.BS); wchar(a.SP); wchar(a.BS); str(0)=str(0)-1; /* subtract from length */      end; /* of case for rubouts */      else if str(0)<STRING.LENGTH then do; /* real char, if no match, convert to upper case here */         call pchar(ch); /* type it */         call pbyte(str,str(0),ch); str(0)=str(0)+1; /* put in the char */      end;      ch=get.next.char; /* get next char */   end; /* of char entry loop */end read.string;use.text.string:  proc; /* place current token in search string text */   dcl (i,p,ch) fixed; /* token is defined by delimeters */   search.string.length=0; /* clear the search string */   if current.col-1>current.line.length then return; /* skip if past end */   p=current.charx+current.col-2; /* start at current place-1 */   ch=byte(buf,p); /* get the char */   do while not delim(ch); /* scan back to start of token */      current.col=current.col-1; /* back up */      p=p-1; ch=byte(buf,p);   end; /* scan back */   p=p+1; /* reset to start of token */   ch=byte(buf,p); /* first char to keep */   do while not delim(ch); /* move forward, putting chars into search string */      call pbyte(search.string.text,search.string.length,ch);      search.string.length=search.string.length+1; p=p+1;      ch=byte(buf,p); /* get next char */   end;   if (cur.file.type<>TEXT.TYPE) and (search.string.length>0) then do; /* add code to check for delims */      call pbyte(search.string.text,search.string.length,0); /* add null */      search.string.length=search.string.length+1; /* count it in length */   end;end use.text.string;decode.scan.pointers:  proc; /* set current pos to scan pos */   current.line =scan.line; /* locate the line */   current.ptr  =point.to(current.line);   current.charx=charx(current.ptr+1);   current.col  =scan.charx-current.charx+1; /* locate the column */end decode.scan.pointers;/* $SUBTITLE  Find Partner command */find.partner:  proc; /* jump to matching 'DO' or 'END' */   dcl (level,dir,i) fixed;   dcl f.charx       fixed; /* ending charx value in search */   if (cur.file.type=TEXT.TYPE) or (cur.file.type=FTN.TYPE) then return; /* not for Fortran */   call write.cursor(1,false); /* restore the current line */   pcmd('Searching for partner...'); /* tell the user to wait */   scan.charx=current.charx+current.col-1; /* set scan pointer to current char */   scan.line =current.line; /* set up scan line */   i=byte(buf,scan.charx); /* get current char */   if (i=a.lparen) or (i=a.rparen) or (cur.file.type=LISP.TYPE) then do; /* paren match */      level=0; /* assume no parens */      if i=a.lparen then do; level= 1; dir= 1; f.charx=charx(last.ptr);   end;      if i=a.rparen then do; level=-1; dir=-1; f.charx=charx(text.ptr+1); end;      do while (level<>0) and (scan.charx<>f.charx); /* scan until match found or finish */         scan.charx=scan.charx+dir; /* move to next char */         i=byte(buf,scan.charx); /* get char */         if      i=a.lparen then level=level+1; /* update level */         else if i=a.rparen then level=level-1;         else if ((i=a.rbracket) and (cur.file.type=LISP.TYPE)) /* LISP ']' */         or      ((i=a.semicolon)  and (cur.file.type<TEXT.TYPE)) then level=0; /* break on semicolon */         else if i="377" then do; /* line break */            scan.line=scan.line+dir; scan.charx=scan.charx+dir; /* skip */         end;      end; /* of scan loop */      call decode.scan.pointers; /* get position */   end;   else do; /* regular find partner command */      level=key.search(current.ptr)\1; /* scan the current line (change 0 to 1) */      dir=-1; /* assume reverse direction */      if level>0 then dir=1; /* if positive level change, use forward direction */      do while level<>0; /* repeat until same indent level reached */         i=current.line+dir; /* find next current line */         if (i>cur.file.lines) or (i<1) then goto break.out; /* break if not valid */         current.line =i; /* next current line is valid */         current.ptr  =point.to(current.line); /* set pointer to the line */         current.charx=charx(current.ptr+1);         level=level+key.search(current.ptr); /* scan the current line */      end;      BREAK.OUT:      if current.col>0 then current.col=first.non.blank(current.ptr); /* find first char */   end;   erase_command; /* clear the message */   call show.line; /* point to the line */   col.change=true;end find.partner;/* $SUBTITLE  String locate routine, Search command */string.locate:  proc(str,dir,stop); /* advance scan.charx to next occurrence of str */   /* if found, returns true with current.line, current.col, current.ptr, scan.charx all set to position */   dcl str              array; /* target string */   dcl (dir,stop,i)     fixed; /* direction of scan, stop charx */   dcl (word.ptr,word)  fixed; /* word pointer in buf to scan point, scan point value */   dcl (ch1,ch2,t.char) fixed; /* chars in string match check */   dcl match            boolean; /* true when possible match found */   dcl (s1,s2,c1,c2)    fixed; /* four possible bytes to look for - precomputed */   scan.line=current.line; /* start scan on current line */   s1=byte(str,0); /* get first byte of search string */   c1=s1; /* assume case adjusted copy is the same */   if not case.matching then do; /* create the other case */      if      (s1-l.a) ILE (l.z-l.a) then c1=s1-"40"; /* adjust down */      else if (s1-a.a)   ILE (a.z-a.a)     then c1=s1+"40"; /* adjust up */   end;   s2=shl(s1,8); /* make copy with byte in upper half */   c2=shl(c1,8); /* make shifted copy of case adjusted copy */   word.ptr=wordx(scan.charx); /* compute word pointer */   if ((scan.charx)     and (dir>0))   or ((not scan.charx) and (dir<0)) then do; /* get first word */      word=buf(word.ptr); word.ptr=word.ptr+dir;   end;   do forever; /* repeat until stop point reached */      match=false; /* assume no match */      if not scan.charx then do; /* even numbered byte */         if dir>0 then do; word=buf(word.ptr); word.ptr=word.ptr+1; end; /* move to next word */         if s1=(word&"377") or c1=(word&"377") then match=true;      end;      else do; /* odd numbered byte */         if dir<0 then do; word=buf(word.ptr); word.ptr=word.ptr-1; end; /* move back a word */         if s2=(word&"177400") or c2=(word&"177400") then match=true;      end;      if match then do; /* found a possible match */         do i=1 to str(0)-1; /* loop over rest of string */            t.char=byte(str,i); /* get char of search string */            if t.char<>"03" then do; /* if not ^C (match any char), must test the char */               ch1=byte(buf,scan.charx+i); /* get char */               if t.char="00" then do; /* match delim */                  if not delim(ch1) then goto break.out; /* ending delim */                  if not delim(byte(buf,scan.charx-1)) then goto break.out; /* prior delim */               end;               else if t.char="14" then do; /* ^L (match letter) */                  if (ch1&"137")<a.a then goto break.out;                  if (ch1&"137")>a.z then goto break.out;               end;               else if t.char="04" then do; /* ^D (match digit) */                  if (ch1-a.0) IGT (a.9-a.0) then goto break.out;               end;               else do; /* must do regular char match */                  if case.matching then ch2=ch1; /* other case is the same */                  else do; /* compute other case */                     if      (ch1-a.a)   ILE (a.z-a.a)     then ch2=ch1+"40";                     else if (ch1-l.a) ILE (l.z-l.a) then ch2=ch1-"40";                     else ch2=ch1;                  end;                  if (t.char<>ch1) and (t.char<>ch2) then goto break.out; /* fails */               end; /* of reg char match */            end; /* of must test the char */         end; /* of loop on rest of string */         call write.cursor(1,false); /* shift prior line back if needed */         call decode.scan.pointers; /* set to position indicated by scan ptrs */         return true; /* success */      end; /* of possible match */      else if word=-1 then do; /* line boundary */         scan.charx=scan.charx+dir; /* skip over other byte */         scan.line =scan.line +dir; /* step a line */         if scan.line<1 then do; /* wrap backwards */            scan.charx=charx(last.ptr)+1; scan.line=cur.file.lines;            word=      buf(last.ptr); word.ptr=last.ptr-1;         end;         else if scan.line>cur.file.lines then do; /* wrap forwards */            scan.charx=charx(text.ptr)+1; scan.line=1; /* to line 1 */            word.ptr  =text.ptr+1;         end;      end;      BREAK.OUT:      scan.charx=scan.charx+dir; /* move to next byte */      if scan.charx=stop then return false; /* reached stop point */   end; /* of do forever */end string.locate;search.cmd:  proc(dir, rcode); /* read search string if rflag and search for it */   dcl (dir,p,i) fixed; /* dir: -1 for backward search, 1 for forward search */   dcl direction fixed; /* previous or current direction */   dcl rcode     fixed; /* 0: search again, 1: get new string, 2: use token from text */   if dir<>0 then direction=dir; /* save the direction */   if      rcode=1 then call read.string('Enter search string: ',search.string.text);   else if rcode=2 then call use.text.string; /* use the current text token */   col.change=true; /* signal for cursor pos restore */   if search.string.length>0 then do; /* search string is present */      pcmd('Searching...'); /* put up message */      if rcode<>0 then call save.screen; /* push screen if not search again */      p=current.charx+current.line.length; /* assume end of line */      if current.col<=current.line.length then p=current.charx+current.col-1; /* use present position */      if current.col=0 then do; p=p+1; scan.charx=p; end; /* set up ptrs */      else                  scan.charx=p+direction;      if string.locate(search.string.text,direction,p) then do; /* found the string */         erase_command; col.change=true; /* remove the 'searching...' msg */         call show.line; /* show it */      end; /* found */      else do; /* not found */         pos(22,0); wchar(a.quote);         do p=0 to search.string.length-1; /* write out the string */            i=byte(search.string.text,p); if i>0 then call pchar(i);         end;         pstring('" not found'); erase_line;      end; /* not found */   end; /* of search string present */   else pcmd('Search string is null');end search.cmd;/* $SUBTITLE  Global Change command */global.cmd:  proc(code); /* code is 0 for all, 1 for selective */   dcl (code,count,i,j,k) fixed;   dcl (orig,rep)(20)     fixed; /* the strings */   dcl f.charx            fixed; /* ending point in region */   dcl message            data ('Global change in progress...');   if mark.line>0 then call region.arg; /* use the marked lines */   else do; first=1; start=text.ptr; finish=last.ptr; end; /* use whole file */   call read.string('Enter original string: ',orig); /* get string */   if orig(0)=0 then do; erase_command; return; end; /* cancelled */   call read.string('Enter replacement string: ',rep); /* keep rep string in original case */   if rep(0)=0  then do; erase_command; return; end;   call save.screen; /* save where we are now */   pcmd(message); /* put up the sign */   current.line=first; current.ptr=point.to(first); /* point to first line of region */   scan.charx  =charx(current.ptr+1); /* set scan pointer to start of region */   count=0; /* count up changes made */   f.charx=charx(finish)+1; /* mark ending point */   do while scan.charx<>f.charx and string.locate(orig,1,f.charx); /* repeat for occurrence */      call show.line; /* access the new current line */      if code=1 then do; /* query the user */         call check.screen.changes; /* check for screen updates */         if page.rewrite then call write.page(0); /* do page rewrite here */         RETRY:         pcmd('Make change here?  Hit  Y(es), N(o), A(ll), or C(ancel) : '); /* ask the user what to do */         call write.cursor(current.col,true); /* indicate screen position */         i=get.next.char.upcase; /* get user's reply char */         if      i=a.a  then do; code=0; pcmd(message); end; /* 'a' means make all further changes */         else if i=a.n  then goto break.out1; /* 'n': no change here */         else if i=a.c  then goto break.out2; /* cancel */         else if i<>a.y then goto retry; /* not a valid input */      end; /* of user query */      k=orig(0); if byte(orig,k-1)=0 then orig(0)=orig(0)-1; /* ignore identifier search marker */      i=orig(0); if rep(0)<i then i=rep(0); /* find common length in strings */      do j=0 to i-1; call pbyte(buf,scan.charx+j,byte(rep,j)); end; /* replace chars */      modified=true; /* this has modified the file */      do j=i to rep(0)-1; /* insert remaining chars from rep */         call insert.char(current.col+j,byte(rep,j),2);      end;      do j=i to orig(0)-1; /* delete extra chars in orig */         call delete.char(current.col+rep(0),2);      end;      scan.charx=scan.charx+rep(0)-1; /* move scan over replacement string */      f.charx=charx(finish)+1; /* update ending point */      orig(0)=k; /* restore identifier search marker */      count=count+1; /* add this change to total */      BREAK.OUT1:      if code then do; /* force a restore of line */         pos(current.line-top.line+header.lines,2); /* move to start */         call write.line(current.ptr,1); /* write the line */          pcmd('Searching...');      end;      scan.charx=scan.charx+1; /* move one more position */   end; /* of do while */   BREAK.OUT2:   call move(6); /* pop back to where command was entered */   call check.screen.changes; /* test if this changes screen */   if (page.rewrite) or ((count>0) and (code=0)) then /* must update screen */       call write.page(0); /* write screen now */   erase_command; pnum(count,0); pstring(' changes made'); /* put up count */   col.change=true; /* signal to restore cursor */end global.cmd;