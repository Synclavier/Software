/* 04-IOMOD   $TITLE  File Input and Output Module *//* File input and output module, also handles overlay and run */dcl treename(string.length/2) fixed;dcl fcb(F#Len - 1) fixed; /* FCB */dcl (secs.usedMSW,secs.usedLSW) fixed; /* counter for sector usage */print.header:  proc; /* print the catalog header */   dcl header data ('------------------------');   pstring(header); pstring('   '); pstring(header); pstring('   '); pstringr(header);end print.header;section.print:  proc(index,n.entries); /* print requested no. entries starting at FCB given */   dcl index     fixed; /* first FCB entry to display */   dcl n.entries fixed; /* number of entries to display */   dcl (i,count) fixed;   dcl str(F#Name_Len) fixed;   clear_screen; call print.header; /* initialize screen */   count = 0; /* no entries printed on this page yet */   do while (count < n.entries); /* print requested number of entries */      call Get_FCB(index,fcb); /* get FCB */      call Clean_FCBname(fcb,str); str(0) = shl(F#Name_Len,1); /* set up length */      pstring(str);      if fcb(F#TY) <= t#max then do case fcb(F#TY); /* print file type */         pstring(' Text ');         pstring(' Exec ');         pstring(' Reloc');         pstring(' Data ');         pstring(' Sync ');         pstring(' Sound');         pstring(' Subc ');         pstring(' LSubc');         pstring(' Dump ');         pstring(' Spect');         pstring(' Index');         pstring(' Timb ');      end;      else pstring('      '); /* dummy type */      if (fcb(F#ML) = 0) and (fcb(F#LL) ile 256) then do; /* file less than 256 sectors long */         unum(fcb(F#WD),6); pstring(' Wds');      end;      else do;         lnum(fcb(F#ML),fcb(F#LL),6); pstring(' Sec');      end;      count = count + 1; /* one more entry printed */      if (((count mod 3) = 0) or (count = n.entries)) then crlf; /* end line */      else pstring('   '); /* end entry */      index = index + 1; /* next entry in catalog */      secs.usedMSW = secs.usedMSW + fcb(F#ML); /* add to usage count */      secs.usedLSW = secs.usedLSW + fcb(F#LL);      if secs.usedLSW ilt fcb(F#LL) then secs.usedMSW = secs.usedMSW + 1;   end; /* for all blocks */   call print.header; /* print trailer */end section.print;catalog.print:  proc(page.size); /* print the current user catalog */   dcl page.size fixed;    /* no. entries to display on last page */   dcl nentry    fixed;    /* no. entries in catalog */   dcl entry.index fixed;  /* FCB entry of a file in catalog */   dcl max.entry lit '57'; /* maximum no. entries on a page */   dcl found     boolean;  /* TRUE when last entry in catalog is found */   dcl i         fixed;   if not Read_Catalog('', 1) then return; /* get user catalog */   call Sort_Catalog; /* sort by name */   i = 0; nentry = 0; found = false; /* nothing found yet */   do while (i < C#Dir_Size/C#Len) and (not found); /* search for last entry in catalog */      call Get_FCB(i,fcb); /* get FCB */      if fcb(F#NM) <> 0 then nentry = nentry + 1; else found = true; /* count non-zero names */      i = i + 1; /* next FCB */   end;   secs.usedMSW = 0; secs.usedLSW = 0; /* init the sector usage counter */   entry.index = 0; /* init the FCB index */   do while nentry > page.size; /* loop producing preceding pages */      i = nentry - page.size; if i > max.entry then i = max.entry; /* number to print this time */      call section.print(entry.index,i); /* print these entries */      entry.index = entry.index + i; /* update entry pointer */      nentry = nentry - i; /* decrement by number of entries printed */      pcmd('Strike any key for next section of catalog... '); call get.next.char;   end;   call section.print(entry.index,nentry); /* print the final page */   page.rewrite = true; /* want file page back */end catalog.print;/* $SUBTITLE  Filename and Device-name Processing Routines */confirm:  proc returns (boolean); /* asks user for confirmation CR */   pstring(' [Confirm with Return key]');   if get.next.char <> a.CR then do; erase_command; return (false); end;   return (true);end confirm;print.dev:  proc(dev); /* print the device name as f0 */   dcl dev fixed;   dev = shr(dev,8); /* shift it into bottom byte */   call pchar(byte('*FRW',shr(dev,1))); call pchar(a.0 + (dev and 1));end print.dev;get.filename:  proc(prompt.str,use.default,tnam) returns (boolean); /* read in a filename, handle special chars */   /* returns true with tree name in treename, else false */   dcl prompt.str  fixed array; /* prompt to display */   dcl use.default boolean; /* TRUE if it is alright to pad treename with default filename */   dcl tnam        fixed array; /* tree name returned */   dcl (i,ch)      fixed;   RETRY:   col.change=true; /* signal for cursor restore after this */   pcmd(prompt.str); /* put up the prompt */   tnam(0) = 0; /* clear the treename */   ch = get.next.char.upcase; /* get first char */   do while ch <> a.CR; /* take chars until return key hit */      if (ch = a.question) and (tnam(0) = 0) then do; /* wants catalog */         call catalog.print(57);         call write.status(false); /* put up status line */         goto retry;      end;      else if ch >= a.del then do; /* (rubout) back up a char */         if tnam(0) = 0 then do; erase_command; return (false); end;         else do;            wchar(a.BS); wchar(a.SP); wchar(a.BS); /* backspace */            tnam(0) = tnam(0) - 1; /* back up */            call pbyte(tnam,tnam(0),0); /* zero fill */         end;      end; /* of case for DEL */      else if (tnam(0) < STRING.LENGTH) /* real char */      and (valid_filechar(ch) or (ch = a.colon)) then do; /* allow COLON at start of catalogs */         call pbyte(tnam,tnam(0),ch); /* drop it in */         wchar(ch);         tnam(0) = tnam(0) + 1; /* add to length */      end;      ch = get.next.char.upcase; /* get next char */   end; /* of char entry loop */   if tnam(0) = 0 then do; /* special case for default filename */      pstring(def.filename); /* print the default name */      if not confirm then return (false); /* user must confirm */      do i = 0 to f#name_len; tnam(i) = def.filename(i); end; /* use name */   end;   else if (use.default and (byte(tnam, tnam (0) - 1) = a.colon)) /* if okay and ends with a colon */   then do i = 0 to def.filename (0) - 1; /* append default filename to treename */      call pbyte(tnam, tnam (0), byte(def.filename, i));      tnam (0) = tnam (0) + 1; /* increment treename length by one character */   end;   return (tnam(0) <> 0); /* true if we got a name */end get.filename;cat.error:  proc; /* prints out catalog routine error messages */   do case (c#status);      pcmd('>> No catalog error! <<');             /* E#None */      pcmd('>> Magic number not set! <<');         /* E#OS */      pcmd('>> No catalog buffer allocated! <<');  /* E#Buffer */      pcmd('>> No catalog in memory! <<');         /* E#No_Dir */      do;                                          /* E#No_Config */         pcmd('Device ');         if F#Name(0) <> 0 then do; pstring(F#Name); wchar(a.SP); end;         pstring('is not in configuration');      end;      pcmd('No floppy disk in drive');             /* E#No_Floppy */      pcmd('>> FCB number out of bounds! <<');     /* E#FCB */      pcmd('>> Level number out of bounds! <<');   /* E#Level */      pcmd('No Available Space on Disk');          /* E#Storage */      pcmd('No Contiguous Space on Disk');         /* E#CStorage */      pcmd('No Room for More Entries in Catalog'); /* E#Dir_Full */      pcmd('Validity Error in Catalog');           /* E#Invalid */      pcmd('Invalid character in filename');       /* E#Name */      pcmd('>> Duplicate file name! <<');          /* E#Duplicate */      do;                                          /* E#No_File */         pcmd('File '); pstring(F#Name); pstring(' is not on disk');      end;      do;                                          /* E#Not_Cat */         pcmd('File '); pstring(F#Name); pstring(' is not a subcatalog');      end;      pcmd('Incorrect format for treename');       /* E#Treename */      do;                                          /* E#No_Path */         pcmd('Subcatalog '); pstring(F#Name); pstring(' is not on disk');      end;      pcmd('File type must match for Replace');    /* E#Type */      pcmd('Disk is write-protected');      /* E#Protect */      pcmd('>> File too large! <<');               /* E#Too_Large */   end;end cat.error;file.not.saved:  proc returns (boolean); /* confirm if file not saved */   pcmd('Your current file is not saved'); /* prompt */   col.change = true; /* signal to restore cursor */   return (not confirm);end file.not.saved;/* $SUBTITLE  Read in a file routine */rfile:  proc(start,code) returns (fixed); /* read a new file, returns number of lines read */   dcl start       fixed; /* where to read it in */   dcl code        fixed; /* 0=read new active file, 1=insert file, 2=read macros */   dcl (i,j,t.ptr) fixed; /* temporary pointer */    if f#type <> t#text then do; /* verify that it is a text file */      pcmd('File is not text');      return (-1);   end;   t.ptr = text.ptr; /* assume start at text buffer origin */   if code > 0 then t.ptr = last.ptr; /* insert - compute from end of buffer */   if (f#ms_length <> 0) or (f#ls_length igt shr(buflen,8))   or ((t.ptr + f#words) ige buflen) then do; /* test the size */      pcmd('File is too large');      return (-1);   end;   if (code = 0) and (modified) /* overwriting unsaved file */   then if file.not.saved then return (-1); /* confirm */   pcmd('Reading...'); flush_term;   if code = 0 then do; /* if reading whole new file */      last.ptr = text.ptr; /* clear out buffer */      cur.file.length = f#words; /* get the length */      core(loc.csln) = shr(f#words + 255,8);      cur.sector.ms = f#ms_sector;      cur.sector.ls = f#ls_sector;      core(loc.svd) = true; core(loc.strd) = true; /* old files are saved */      modified = false;      do i = 0 to f#name_len; /* store name as default name */         j = f#name(i); def.filename(i) = j;          core(loc.cfn + i) = j; core(loc.strn + i) = j;      end;      last.ptr = text.ptr + f#words - 1; /* prepare buffer space */   end; /* of whole new file case */   else call slide(start,f#words); /* make room for insertion */   call readdata(f#ms_sector,f#ls_sector,location(addr(buf(start))),f#words);   pcmd('Read Complete');   if code = 0 then page.rewrite = true; /* new file, write page */   if code = 1 then part.rewrite = true; /* insertion, write from here on */   buf(last.ptr + 1) = -1; /* pretend another line starts here (flag end of last line) */   return (unnumber.buffer(start,start + f#words - 1)); /* line count */end rfile;insert.file:  proc(line); /* insert a file at line */   dcl (line,lines) fixed;   if not get.filename('Name of file to insert? ',true,treename) then return;   if locate(treename,1) then do; /* file found, so insert */      lines = rfile(point.to(line),1);      if lines > 0 then call adjust.lines(lines);   end;   else call cat.error; /* display error */end insert.file;setup.null.file:  proc; /* create a null file */   buf(text.ptr) = -1; buf(text.ptr + 1) = 0; last.ptr = text.ptr + 1; /* set up buf */   buf(last.ptr + 1) = -1; /* simulate extra last line */   cur.file.length = 2; cur.file.lines = 1; /* one line, no chars */   core(loc.csln) = 1; /* one sector */   core(loc.strd) = false; core(loc.svd) = false; modified = true;   call setup.screen(1); /* set up the initial screen */end setup.null.file;unsave:  proc; /* unsaves a file */   if not get.filename('Name of file to unsave? ',true,treename) then return;   if delete(treename,1) then do; /* file deleted successfully */      pcmd('File '); pstring(F#Name); pstring(' has been unsaved');   end;   else call cat.error; /* otherwise display error */end unsave;/* $SUBTITLE  Write Out a File routine, and Enter Subcatalog routine */wfile:  proc(code,moving); /* to write buffer to file, creating if necessary */   dcl (code,lines,i)      fixed; /* code: 0=> whole file, 1=> use region */   dcl moving              boolean; /* true if lines are to be deleted after write */   dcl (length,sec.length) fixed;   if not get.filename('Name of file to write? ',true,treename) then return; /* get the name */   start = text.ptr; finish = last.ptr; /* set ptrs for whole file */   if code = 1 then lines = region.arg; /* must get region */   length = finish - start + 1; /* find length of region */   sec.length = shr(length + 255,8); /* find sector length of region */   pcmd('Writing...'); flush_term;   if Replace(treename,t#text,0,sec.length,length,1) then do; /* try to replace */      call number.buffer(start,finish); /* put line numbers on */      call writedata(f#ms_sector,f#ls_sector,location(addr(buf(start))),length); /* write out file */      call unnumber.buffer(start,finish); /* take off the line numbers */      pcmd('Write Complete');      if moving then call remove(start,length,lines); /* delete text */      if (not moving) and (length = cur.file.length) then do; /* saving entire file */         cur.sector.ms = f#ms_sector; /* remember where it went */         cur.sector.ls = f#ls_sector;         cur.file.length = f#words; /* save length */         core(loc.csln) = shr(f#words + 255,8);         do i = 0 to f#name_len; /* copy over name */            def.filename(i) = f#name(i);            core(loc.cfn + i) = f#name(i);            core(loc.strn + i) = f#name(i);         end;         core(loc.svd) = 1; core(loc.strd) = 1; /* it is stored on disk and saved */         core(loc.cmed) = 0; /* disk file */         modified = false; /* when we write whole file it is saved */         status.change = true; /* must rewrite status in case name changed */      end;      end;   else do; /* error during replace */      wchar(a.bel); /* ring bell */      call cat.error; /* display error */   end;end wfile;enter.subcat:  proc;   if not get.filename('Name of catalog to enter? ',false,treename) then return;   if not enter_catalog(treename,1) then call cat.error; /* error occurred entering subcatalog */end enter.subcat;/* $SUBTITLE  Save the Current file, and Exit routines */curfile:  proc(disk) returns (boolean); /* tries to save current file, return true if done */   /* try to get the current file on the disk:       1. If it is unmodified, then just point to the disk.       2. If it is modified, then save it on the specified disk.       3. If disk = 1, we can not save it in .WORK */   dcl (disk,i,j) fixed; /* prefered disk drive */   dcl not_stored boolean; /* TRUE if file isn't stored */   call number.buffer(text.ptr,last.ptr); /* put the line numbers back */   not_stored = true; /* assume it's not stored */   if core(loc.strd) and (core(loc.strn + 1) <> 0) then do; /* see if still in same place */      if locate(location(loc.strn),1) then do; /* get file params */         if ((cur.sector.ms = f#ms_sector) and (cur.sector.ls = f#ls_sector))         then not_stored = false; /* it's stored if at same address */      end;   end;   if not_stored then do; /* if it isn't stored, make sure we store it */      modified = true;      core(loc.strd) = 0;   end;   if (modified) or (core(loc.cmed) <> 0) then do; /* has been modified */      if disk = 1 then do; /* doesn't want to put it in work file */         call delete(dummy,0); /* unconditionally remove dummy from system catalog */         if replace(dummy,t#text,0,shr(cur.file.length + 255,8),cur.file.length,0) /* replace into system catalog */         then do; /* set up file attribs */            cur.sector.ms = f#ms_sector;            cur.sector.ls = f#ls_sector;            core(loc.csln) = f#ls_length; /* number of sectors */            core(loc.cmed) = 0; /* the media is the disk */         end;         else return (false); /* could not save */      end; /* must put it in user cat */      else do;         cur.sector.ms = core(loc.wsec + 1); /* point to .work */         cur.sector.ls = core(loc.wsec);         core(loc.cmed) = core(loc.wmed); /* set the media the same */      end;      core(loc.strd) = 1; /* stored but not saved */      if core(loc.cmed) = 0 /* has to go to the disk */      then call writedata(cur.sector.ms,cur.sector.ls,location(addr(buf(text.ptr))),cur.file.length); /* write it out */      else call slide(0,-text.ptr); /* remove text bufs from current file area */   end; /* has been modified */   return (true); /* has been saved */end curfile;exit.cmd:  proc; /* exit the editor */   if systyp = 0 then do;      do while read("100"); end; /* wait in case of restore */      write("104") = 0; write("104") = 1; /* start both disks */   end;   clear_screen;   pstring('File edited was '); pstring(def.filename); pstring(', final status:  ');   call write.mod; crlf; /* tell user about final status */   unum(cur.file.lines, 0); pstring(' lines:  ');   unum(cur.file.length,0); pstring(' words, or ');   unum(core(loc.csln), 0); pstring(' sectors'); crlf;   core(loc.sed2) = shl(current.line,1); /* store current line in high core */   call curfile(0); /* save it as the current file */   core(loc.rst) = 2; /* good termination */   core(loc.psys) = old.psys; /* store old LOC.PSYS to deny cold boot */   flush_term;   call exit(0);end exit.cmd;new.file:  proc; /* clear to new file */   dcl i fixed;   if not get.filename('Name of new file? ',false,treename) then return;   if ((treename (0) > shl(f#name_len, 1)) or (not valid_filename (treename))) then do; /* name too long or invalid */      c#status = e#name; /* set C#STATUS for correct error */      call cat.error; /* display error */      return; /* abort command */   end;   if modified then if file.not.saved then return; /* clearing unsaved file */   do i = 0 to f#name_len; /* remember name */      def.filename(i) = treename(i);      core(loc.cfn + i) = treename(i);   end;   call setup.null.file;end new.file;/* $SUBTITLE  Overlay to another program, and Run routine */overlay:  proc(device,start,wlen); /* overlay to specified program */   dcl (device,start,wlen) fixed;   dcl (i)                 fixed;   flush_term;   i = loc.load + 1; /* enter word 1 of loader */   write("300") = device;   write("301") = start;   write("302") = 0;   write("303") = wlen;   write("320") = i;end overlay;user.dev.valid:  proc returns (boolean); /* returns TRUE if we can ovelay to current user device */   dcl dev fixed;   dev = shr(core(loc.ucat + 1),8); /* get device */   return (((systyp = 0) and (dev < 6)) or ((systyp = 1) and (dev > 5))); /* valid floppy and winchester types */end user.dev.valid;openfile:  proc(name,loc,fatal.error) returns (boolean); /* search for a file and mark it as open */   dcl name        fixed array; /* name of file to open */   dcl loc         fixed; /* core location for file information */   dcl fatal.error boolean; /* TRUE if not finding a file is a fatal error */   dcl found       boolean; /* TRUE if file is found */   dcl i           fixed;   found = false; /* have not found file yet */   i = 0; /* start search at path catalog */   do while (i < 3) and (not found); /* search 3 different catalogs */      do case i;         found = locate(name,-2); /* search path catalog */         found = locate(name,0); /* search system catalog */         found = ((user.dev.valid) and (locate (name,1))); /* search current catalog */      end;      i = i + 1;   end;   if found then do; /* file found */      core(loc + 1) = f#ms_sector; /* save the file information at location given */      core(loc    ) = f#ls_sector;      core(loc - 1) = f#words;   end;   else do; /* file not found */      core(loc    ) = 0; /* zero out location given */      core(loc - 1) = 0;      if fatal.error then do; /* this is a fatal error */         wchar(a.bel); pcmd('System file '); pstring(name); pstring(' not found');      end;   end;   return(found); /* return TRUE if file was found */end openfile;run:  proc(type); /* run, play, execute or process the file */   dcl type   fixed;   /* 0 = XPL compile, 1 = SCRIPT compile, 2 = HFORM */   dcl found  boolean; /* TRUE if a file was opened successfully */   dcl cnum   fixed;   /* cache number */   dcl i      fixed;   if type = 1 then pcmd('Play '); else pcmd('Execute '); /* action message */   pstring(def.filename); flush_term; /* display default file name */   col.change = true; /* signal to restore cursor */   if systyp = 0 then do; /* floppy */      do while read("100"); end; /* wait for disk activity to die */      write("104") = 0; write("104") = 1; /* turn on drives */   end;   if (type = 1) and (core(loc.synrtpn) = 0) then do; /* no rtp set for play */      wchar(a.bel); pcmd('No Real-Time Program specified'); flush_term;      return;   end;   cnum = Cache(C#BufPtr,C#BufMed); /* cache this catalog buffer */   found = openfile('.ED-7',loc.mon,true); /* try to open SED system file */   if found then do; /* open system files */      /* NOTE: .WORK already opened, in either startup or the monitor */      i = 0;      do case type; /* run different things depending on type */         do while (i < 5) and (found); /* 0: means XPL compile and run */            do case i;               found = openfile('.P1-7',loc.p1,true);               found = openfile('.P2-7',loc.p2,true);               found = openfile('.P3-7',loc.p3,true);               found = openfile('.ST-7',loc.st,true);               if (processor_type) < 2 /* select RTP based on processor type */               then found = openfile('.RTB-7',loc.rt,true); /* Model B or less */               else found = openfile('.RTC-7',loc.rt,true); /* Model C or greater */            end;            i = i + 1; /* next file */         end; /* of searching for XPL system files */         do while (i < 6) and (found); /* 1: means SCRIPT compile and play */            do case i;               found = openfile(location(loc.synrtpn),loc.p2,true);               found = openfile('.STAB-7',loc.p3,true);               found = openfile('.SSYM-7',loc.st,true);               found = openfile('.SCON-7',loc.rt,true);               found = openfile('.SCOM-7',loc.p1,true);               do; found = openfile('.SPLT-7',loc.mplt,false); found = true; end; /* don't care if this is found or not */            end;            i = i + 1; /* next file */         end; /* of searching for SCRIPT system files */         found = openfile('.ROFF-7',loc.p1,true); /* 2: means invoke HFORM */      end; /* of do case */      if found then do; /* all system files found, so overlay */         core(loc.rst) = 0; /* this is a run */         if curfile(1) then do; /* if file can be saved, run it */            pos(status.line,0); flush_term; /* move to bottom of screen */            core(loc.psys) = old.psys; /* set the magic number */            call overlay(core(loc.p1 + 1),core(loc.p1),core(loc.p1 - 1));         end;         else do; /* file cannot be saved */            pcmd('No space to save current file');            f#words = cur.file.length; /* length to number is current file length */            call unnumber.buffer(text.ptr,last.ptr); /* just in case we have changed it */         end;      end; /* of overlay system files found */   end; /* of SED system files found */   call disable_cache(cnum); /* disable caching */end run;