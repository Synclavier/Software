/* 05-COMND   $TITLE  Main command parser and driver, also Macro expander *//* This module contains the macro catalog and expander routines, the line.  adjust expander, and the command parser and driver. */scan.macro:  proc; /* advances macro.index to start of next macro name */   dcl (ch,prev.ch)     fixed;   dcl (comment,quoted) boolean;   dcl new.statement    boolean; /* true for new macro def statement */   comment=false; quoted=false;   new.statement=false; /* assume not new statement */   if macro.index=0 then new.statement=true; /* always new statement at start */   prev.ch=0; /* no prior character */   do while macro.index ILT charx(intext.ptr(1)-1); /* scan over macro area */      ch=byte(buf,macro.index);      if (ch-l.a) ILE (l.z-l.a) then ch=ch-"40"; /* up the case */      if (not comment) and (not quoted) and new.statement          and (ch-a.a) ILE (a.z-a.a) then return; /* got a char of name */      if (not quoted) and (ch=a.star) and (prev.ch=a.slash) then comment=true; /* begin comment */      if (not quoted) and (ch=a.slash) and (prev.ch=a.star) then comment=false; /* end comment */      if (not comment) and (ch=a.apost) then quoted=quoted xor 1; /* toggle for quotes */      if (not comment) and (not quoted) and (ch=a.semicolon) then new.statement=true;      prev.ch=ch; macro.index=macro.index+1; /* advance to next char */   end; /* of do while */end scan.macro;macro.cmd:  proc; /* search for macro def and enter macro mode if found */   dcl (i,j,ch) fixed;   dcl found    boolean; /* macro name found flag */   if macro.level>STACK.SIZE then do; /* check nesting level */      pcmd('Macros nested too deep');      macro.level=0; return;   end;   macro.stack(macro.level)=macro.index; /* push macro expansion index */   macro.level=macro.level+1;   macro.index=0; /* search from the start of the macro area */   call scan.macro; /* find first macro */   do while macro.index ILT charx(intext.ptr(1)-1);      found=true; /* assume found */      do i=0 to macro.name(0)-1; /* check chars of name */         if extr(buf,macro.index+i)<>extr(macro.name,i) then found=false;      end;      i=byte(buf,macro.index+macro.name(0)); /* check next char */      if (i<>a.SP) and (i<>0) then found=false; /* must be space or eol */      if found then do; /* got the name */         ch=byte(buf,macro.index);         do while ch<>a.apost; /* scan to starting quote */            macro.index=macro.index+1;            ch=byte(buf,macro.index);         end;         macro.index=macro.index+1; /* move past starting quote */         if byte(buf,macro.index)=a.apost then /* string begins with quote pair */            if byte(buf,macro.index+1)=a.apost then macro.index=macro.index+1; /* skip to second quote */            else do; macro.level=macro.level-1; macro.index=macro.stack(macro.level); end; /* null string - pop level */         return;      end; /* of case for name found */      macro.index=macro.index+1; /* move ahead in def area */      call scan.macro; /* find next macro name */   end; /* of do while */   pcmd('Not a defined macro'); macro.level=0; /* macro char was never found */end macro.cmd;short.macro.cmd:  proc;   pcmd('Hit key for macro name: ');   call pbyte(macro.name,0,get.next.char); /* put in name */   macro.name(0)=1; /* one char */   erase_command; col.change=true; /* signal to restore cursor position */   call macro.cmd; /* process the name */end short.macro.cmd;pause:  proc; /* put up status line and wait for input char */   call write.status(false); /* put up the status line */   pcmd('Strike any key to continue... '); call get.next.char;end pause;/* $SUBTITLE  Macro catalog routine, and Set Edit Modes routine */macro.catalog:  proc; /* print the defined macros */   dcl (i,j,count,ch) fixed;   col.change=true; /* ask to restore cursor */   if intext.ptr(1)<2 then do; pcmd('No macros are defined'); return; end; /* macro area empty */   clear_screen;   pstring('Defined Macros from file: '); pstringr(mac.filename); crlf;   count=0; macro.index=0; /* init the counter and macro area pointer */   call scan.macro; /* find first macro */   do while macro.index ILT charx(intext.ptr(1)-1); /* loop over macro area */      ch=byte(buf,macro.index); i=0; /* get first char and count */      do while (ch<>a.SP) and (ch<>0); /* print name until space or eol */         call pchar(ch); i=i+1; /* print and count char */         macro.index=macro.index+1;         ch=byte(buf,macro.index);      end;      count=count+1; /* count this macro */      if (count mod 4)=0 then crlf; /* new line */      else do j=1 to 19-i; wchar(a.SP); end; /* advance to next col */      call scan.macro; /* find next macro */   end; /* of do while */   call pause; /* put up status line, wait for char from user */   page.rewrite=true; /* ask for real page back */end macro.catalog;read.value:  proc(prompt,def.val,min,max); /* ask user for value between min and max */   dcl prompt    array; /* prompting string */   dcl def.val   fixed; /* default value to be returned if rubout */   dcl (min,max) fixed; /* min and max limits for input value */   dcl (ch,sum)  fixed;   do forever; /* repeat until a valid answer is given */      pcmd(prompt); /* ask the question */      sum=0; /* init the summation of digits */      ch=get.next.char; /* get first char */      if ch=a.CR then do; erase_command; return def.val; end; /* if null entry, re-use current val */      do while ch<>a.CR; /* loop till return key */         if ch=a.del then do; erase_command; return def.val; end; /* re-use old value */         wchar(ch); /* print the digit */         sum=sum*10+(ch-a.0); /* add to the number */         ch=get.next.char; /* get next char */      end;      if (sum<=max) and (sum>=min) then return sum; /* okay, got it */   end; /* of do forever */end read.value;set.mode:  proc; /* process set editor mode commands */   dcl (ch,i) fixed;   ch=get.next.char.upcase; /* get char and upcase */   if ch=a.i then indent.amount=read.value(      'Enter indent amount: ',indent.amount,0,10);   if ch=a.c then case.matching=read.value(      'Enter 0 for case matching OFF, or 1 for case matching ON: ',case.matching,0,1);   if ch=a.t then cur.file.type=read.value(      'Enter file type as 0=XPL, 1=SCRIPT, 2=text, 3=C, 4=LISP : ',cur.file.type,0,5);   if ch=a.r then right.margin=read.value(      'Enter right margin value: ',right.margin,15,500);   if ch=a.a then char.insert.mode=read.value(      'Enter 0 for Overstrike, or 1 for Append Mode: ',char.insert.mode,0,1);   if ch=a.h then header.lines=read.value(      'Enter 0 for no header, or 1 for column header: ',header.lines,0,1);   if ch=a.m then do; /* read macros */      if not get.filename('Name of macro definitions file? ',true,treename) then return;      if locate(treename,1) then do;         call slide(0,-(intext.ptr(1)-1)); /* remove the present ones */         call rfile(0,2); /* read file into macro area */         do i = 0 to F#Name_Len; /* save filename */            mac.filename(i) = F#Name(i);         end;      end;      else do; /* file not found */         call cat.error;         return;      end;   end; /* of read macros case */   core(loc.sed1)=shl(shl(shl(indent.amount,1)+case.matching,3)+cur.file.type,1)+1; /* store status */   col.change=true; /* signal to restore cursor position */end set.mode;/* $SUBTITLE  Process commands that begin with a dot */show.buffer:  proc(num,label); /* print first line of buffer */   dcl num   fixed;   dcl label array;   pos(16+num,0); pstring('Buffer '); pstring(label); pstring('  '); /* print label */   unum(lines.saved(num),5); pstring('  '); /* print number of lines */   if lines.saved(num)>0 then call write.line(intext.ptr(num),0); /* print first line */end show.buffer;afterdot:  proc; /* special cases for after dot */   dcl (ch,i) fixed;   if modified then do; core(loc.svd)=0; core(loc.strd)=0; end; /* indicate change */   ch=get.next.char.upcase; /* get the next char and upcase */   if      ch=a.plus then ch=a.a; /* .+ is synonym for .A file insert */   else if ch=a.minus  then ch=a.i; /* .- is synonym for .I file insert */   else if ch=a.star     then ch=a.v; /* .* is synonym for .V center */   if ch=a.period then do; /* mark lines */      if mark.line=current.line then mark.line=0; /* clear mark */       else                           mark.line=current.line; /* begin mark here */      line.change=true; /* call for new line flags */   end; /* mark lines */   else if ch=a.lbracket  then call format.text(3); /* .[ flush left  */   else if ch=a.rbracket  then call format.text(4); /* .] flush right */   else do case (ch-a.a); /* case for letters */      call insert.file(current.line+1); /* .A file insert */        call scroll(2); /* .B scroll to bottom */      call scroll(0); /* .C scroll to center */      if mark.line<>0 then call delete.text(1,0); /* .D delete text */      call exit.cmd; /* .E exit */      call format.text(0); /* .F format text */      call global.cmd(0); /* .G global change */      if cur.file.type=TEXT.TYPE then call run(2); /* .H hardcopy (invoke HFORM) */      call insert.file(current.line); /* .I insert file */      call format.text(1); /* .J justify text */      ; /* .K unused */      ; /* if cur.file.type=LISP.TYPE then call run(3); .L invoke LISP */      if mark.line<>0 then call wfile(1,true); /* .M move lines to file */      call new.file; /* .N new file */      if get.filename('Name of file to read? ',true,treename) then do; /* .O read an old file */         if locate(treename,1) then do;            i=rfile(text.ptr,0); /* do the read */            if i>0 then do; /* got some lines */               cur.file.lines=i; current.line=1; top.line=1; /* set up current line */               call setup.screen(1); /* set up other screen status */            end;         end;         else call cat.error; /* display error */      end;      call run(1); /* .P play file */      call macro.catalog; /* .Q print catalog of macros */      call wfile(0,false); /* .R replace file */      do; /* .S status and catalog */         call catalog.print(33);         pos(14,0); pstring('Device:        '); call print.dev(core(loc.ucat+1));         pstring('     File Lines:  '); unum(cur.file.lines,5);         pstring('     Case Matching:   ');         if case.matching then pstring(' ON'); else pstring('OFF');         pos(15,0); pstring('Catalog:'); pos(15,17-core(loc.ccnm)); pstring(location(loc.ccnm));         pstring('     File Length: '); unum(cur.file.length,5);         pstring('     Right Margin:  '); unum(right.margin,5);         pos(16,0); pstring('Secs Used: '); lnum(secs.usedMSW,secs.usedLSW,6);         pstring('     Max  Length: '); unum(buflen-text.ptr,5);         pstring('     Indent Amount: '); unum(indent.amount,5);         call show.buffer(2,'< >'); call show.buffer(3,'[ ]');         call show.buffer(4,'{ }');         call pause; /* put up status line, wait for char */      end; /* .S  */      call scroll(1); /* .T scroll to top */      call unsave; /* .U unsave */      call format.text(2); /* .V center text block */      if mark.line<>0 then call wfile(1,false); /* .W write file */      call run(0); /* .X execute file */      call global.cmd(1); /* .Y selective global change */      call enter.subcat; /* .Z enter subcatalog */   end; /* of case for letters */end afterdot;/* $SUBTITLE  Main command driver routine */do.command:  proc(ch); /* the main command driver */   dcl (ch,i) fixed; /* command character */   if ch<a.SP then do case (ch); /* case for control chars */      call exit.cmd;      char.insert.mode=char.insert.mode xor 1; /* ^A toggle Append/overstrike mode */      if current.col>0 then call split; /* ^B break line */      call scroll(0); /* ^C center line */      if current.col=current.line.length+1 then call join; /* ^D delete char/join line */      else if (current.col>0) and (current.col<=current.line.length) then do;         call delete.char(current.col,force(peek.next.char));          col.change=true;       end;      if current.col>0 then call delete.rest; /* ^E delete the rest of the line */      call move(5); /* ^F flip to prior screen */      do; /* ^G use macro (long name) */         call read.string('Enter macro name: ',macro.name);         call macro.cmd; /* process the name */      end;      call move(1); /* ^H backspace */      call move(0); /* ^I tab */      call move(3); /* ^J (linefeed) move down line */      call move(4); /* ^K move up line */      call move(2); /* ^L move right char */      call return.cmd; /* ^M return key */      call column.goto; /* ^N goto column */      call set.origin.col; /* ^O set column origin */      call move(6); /* ^P pop screen position */      ; /* ^Q reserved */      current.col=0; /* ^R return cursor to command line */      ; /* ^S cannot be used on VT series */      call scroll(1); /* ^T move to top */      if line.adjust.mode=0 then do; /* ^U toggle line adjust mode */         line.adjust.mode=1; line.adjust.index=0; line.adjust.col=current.col;      end;      else line.adjust.mode=0; /* cancel it */      call find.partner; /* ^V find the partner */      call short.macro.cmd; /* ^W invoke single letter macro */      if current.col>0 then literal.mode=true; /* ^X literal mode */      if terminal.type=T#DATAMEDIA      then current.col=0; /* home on datamedia */      else line.insert.mode=line.insert.mode XOR 1; /* ^Y toggle auto line insert mode */      call save.screen; /* ^Z push this screen position */      call move(2); /* ESC cursor move right */      if terminal.type=T#DATAMEDIA      then call move(2); /* right arrow on datamedia */      else call search.cmd(-1,2); /* "034" ^\ take and backward search */      call search.cmd( 1,2); /* "035" ^] take and forward search */      current.col=0; /* "036" home return cursor to command col */      if terminal.type=T#DATAMEDIA      then call move(4); /* up arrow on datamedia */      else call search.cmd( 1,2); /* "037" ^/ take and forward search (VT100 only) */   end; /* of do case for control chars */   else if ch>=CUR.UP then do case ch-CUR.UP; /* meta chars on VT series */      call move(4);  /* cursor up */      call move(3);  /* cursor down */      call move(2);  /* cursor right */      call move(1);  /* cursor left */      current.col=0; /* cursor home */      current.col=0;        /* PF1 cursor return to command col */      call scroll(0);       /* PF2 scroll to center */      call short.macro.cmd; /* PF3 call single letter macro */      call find.partner;    /* PF4 find partner */   end;   else if ch=a.grave then call search.cmd(0,0); /* search again */   else if ch=a.del    then call rubout; /* rubout or delete key */   else if current.col=0 then do; /* special chars in command col */      if (ch-l.a) ILE (l.z-l.a) then ch=ch-"40"; /* up case */      if      ch=a.comma   then move.type=move.type or "20"; /* update move type */      else if ch=a.exclam  then move.type=1 or (move.type & "20");      else if ch=a.sharp   then move.type=2 or (move.type & "20");      else if ch=a.and then move.type=3 or (move.type & "20");      else if ch=a.less  then call delete.text(2,0); /* extract < */      else if ch=a.lbracket then call delete.text(3,0); /* extract [ */      else if ch=a.lbrace  then call delete.text(4,0); /* extract { */      else if ch=a.quote  then do; move.type=2\"20"; call delete.text(0,0); end; /* push macro def */      else move.type=0; /* reset move type */      if      ch=a.equals   then call set.mode; /* 'set' command */      else if ch=a.cflex    then call move(4); /* move up a line */      else if ch=a.slash     then call search.cmd( 1,1); /* / search */      else if ch=a.backslash       then call search.cmd(-1,1); /* \ back search */      else if ch=a.dollar     then call move(7); /* move to eof */      else if ch=a.semicolon    then call recover.text(1); /* recover */      else if ch=a.plus  then call insert.line(current.line+1);      else if ch=a.minus   then call insert.line(current.line);      else if ch=a.greater    then call recover.text(2); /* insert > */      else if ch=a.rbracket   then call recover.text(3); /* insert ] */      else if ch=a.rbrace    then call recover.text(4); /* insert } */      else if ((ch-a.a) ILE (a.v-a.a))      or      ((ch-a.0) ILE (a.9-a.0))      then call line.goto(ch); /* goto specified line */      else if ch=a.period       then call afterdot; /* if dot in command col */   end; /* of special chars in command col */   else if current.col>0 then call newchar(ch); /* its a regular char in text */   i=buflen-text.ptr-cur.file.length; /* remaining space */   if i ILE 64 then do; /* file getting big */      wchar(a.bel); pcmd('File getting too large, '); unum(i,0); pstring(' words left');      col.change=true; /* signal to restore cursor */   end; /* file getting big */   if cur.file.length=0 then call setup.null.file; /* empty file - create a line */end do.command;