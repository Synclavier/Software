/* 02-BLOCK   $TITLE  Text Block Manipulation Routines *//* This module contains the text block manipulation routines, such as.  region definition, delete, and recover.  It contains the action.  primitives to split and join lines, handle the screen position stack,.  move the cursor, go to a line, and reformat text. */dcl (first,last)  fixed; /* sorted region of lines */dcl clear.cursors boolean; /* TRUE to clear typeahead cursor controls */region.arg:  proc; /* determine the region indicated by marked lines */   if mark.line=0 then do; first=current.line; last=first; mark.line=first; end; /* single line */   else if mark.line<current.line then do; first=mark.line; last=current.line; end;   else                                do; first=current.line; last=mark.line; end;   start=point.to(first); finish=point.to(last+1)-1; /* compute pointers */   return last-first+1; /* return number of lines */end region.arg;no.room:  proc; /* print no room message */   pcmd('Insufficient memory'); col.change=true;   move.type=0; /* restore normal move type */end no.room;delete.text:  proc(buf#,mode); /* eval region, delete text, and place in indicated buffer */   dcl (buf#,mode)    fixed; /* buf#: number of internal text buffer 0-4 */   dcl (ptr,big)      fixed;   dcl (length,lines) fixed;   dcl block.size     lit '256'; /* move in blocks of 256 */   if (move.type&3)<2 then do; /* wants buffer cleared */      call slide(intext.ptr(buf#),-(intext.ptr(buf#+1)-1-intext.ptr(buf#))); /* clear the buffer */      lines.saved(buf#)=0; /* no lines */   end;   if (move.type&3)=1 then return; /* just wanted to clear buffer */   if mode=1 then do; /* special case to delete current line */      start=current.ptr; finish=point.to(current.line+1)-1; lines=1;      mark.line=20000; /* push marked line out of range */   end;   else lines=region.arg; /* evaluate region and number of lines */   length=finish-start+1; /* number of words */   if (move.type&3)<3 then ptr=intext.ptr(buf#); /* insert at start */   else                    ptr=intext.ptr(buf#+1)-1; /* append to end */   big=0; /* assume no message */   if length>block.size then do; pcmd('Working...'); big=1; end; /* print msg and set flag */   do while length>block.size; /* move in chunks */      if not slide(ptr,block.size) then do; call no.room; return; end; /* open up a block */      call copy.text(start,ptr,block.size); /* copy block to it */      if move.type<16 then call slide(start,-block.size); /* remove it from text */      else                 start=start+block.size; /* advance pointer */      length=length-block.size; /* decrement length by block */      ptr=ptr+block.size; /* move ahead in buffer */   end;   if big=1 then erase_command; /* clear the message line if printed */   if not slide(ptr,length) then do; call no.room; return; end; /* move last fractional block */   call copy.text(start,ptr,length);   lines.saved(buf#)=lines.saved(buf#)+lines; /* remember number of lines saved in buffer */   if move.type<16 then call remove(start,length,lines); /* remove the lines */   else do; pcmd('Internal Buffer Updated'); mark.line=0; line.change=true; end; /* print msg, remove the region mark */   move.type=0; /* reset move type to normal */end delete.text;recover.text:  proc(code); /* recover text from hold buffer, insert after current line */   dcl code   fixed; /* code: number of internal text buffer, 0 to 3 */   dcl length fixed;   length=intext.ptr(code+1)-1-intext.ptr(code); /* get length */   col.change=true;   if length=0 then pcmd('No text to recover');   else do; /* some text is there */      if slide(current.ptr,length) then do; /* there is room to add text */         call copy.text(intext.ptr(code), current.ptr,length); /* drop it in */         call adjust.lines(lines.saved(code)); /* adjust line counts */         call show.line; /* find the length of the new current line */         part.rewrite=true; /* rewrite from here down */      end;      else call no.room; /* print message */   end; /* of text there */end recover.text;/* $SUBTITLE  Line Join and Split routines, Rubout, and Screen Ops */join:  proc; /* join onto current line */   dcl (i,ch) fixed;   if current.line<>cur.file.lines then do; /* do not erase last eol */      i=current.charx+current.col-1; /* compute position */      ch=byte(buf,i-1); /* get last char */      call slide(wordx(i),-2); /* cover up eol and bol */      if not current.col then call insert.char(current.col-1,ch,2); /* handle odd char */      call adjust.lines(-1); /* one fewer lines */      call show.line; /* check length of new current line */      part.rewrite=true;   end; /* not at last eol */end join;split:  proc; /* split the current line at the current column */   dcl p fixed;   p=wordx(current.charx+current.col-1); /* point to current word */   if not current.col then do;      call insert.char(current.col,0,2); /* mark eol */      call slide(p+1,1); /* make room for line number */   end;   else call slide(p,2); /* insert eol and bol */   buf(p+1)=-1; /* line number */   call write.cursor(1,false); /* if needed, rewrite revised current line */   erase_line; /* clear rest of line from screen */   call adjust.lines(1); /* another line has been added */   current.line=current.line+1; current.col=1; /* point to start of second part */   call show.line; /* bring new current line to screen */   part.rewrite=true; /* force rewrite from here on */end split;rubout:  proc; /* character or line delete */   if current.col>1 then do; /* in text area */      current.col=current.col-1; /* move to previous char */      wchar(a.BS); /* move back on screen */      if current.col<=current.line.length then call delete.char(current.col,         force(peek.next.char) or (current.col=1)); /* delete char before */      char.insert.mode=true; /* go to insert mode */   end;   else if current.col=0 then call delete.text(1,1); /* delete current line */end rubout;save.screen:  proc; /* push the current screen position onto the stack */   stack.top=stack.top+1; /* advance stack top */   if stack.top>=STACK.SIZE then stack.top=0; /* wrap around */   if stack.bottom=stack.top then stack.bottom=stack.bottom+1; /* check bottom */   if stack.bottom>=STACK.SIZE then stack.bottom=0; /* wrap around */   current.line.stack(stack.top)=current.line;   top.line.stack    (stack.top)=top.line;   current.col.stack (stack.top)=current.col;   origin.col.stack  (stack.top)=origin.col;end save.screen;skip.line:  proc(dir); /* skip to next line according to direction */   dcl dir fixed;   call write.cursor(1,false); /* fix up present line if needed */   current.line=current.line+dir; /* mode to next line */end skip.line;delim:  proc(ch); /* returns TRUE if char is a delimeter for current file type */   dcl ch fixed;   if (ch=a.SP) then return true; /* spaces are always delimeters */   if (ch>=l.a) and (ch<=l.z) then ch=ch-"40"; /* up the case */   if (ch>=a.a)   and (ch<=a.z)   then return false; /* letters are never delims */   if (ch>=a.0)   and (ch<=a.9)   then return false; /* digits are never delims */   if ((cur.file.type=XPL.TYPE) or (cur.file.type=SCRIPT.TYPE)) and      ((ch=a.period) or (ch=a.dollar) or (ch=a.score) or (ch=a.sharp)) then return false; /* conditional delims */   if (cur.file.type=C.TYPE)    and (ch=a.score) then return false;   if (cur.file.type=LISP.TYPE) and (ch=a.minus) then return false;   return true; /* all others are delimeters */end delim;/* $SUBTITLE  Cursor Movement routine with special TAB features */dcl tab.ptr fixed; /* pointer for tab searches */find.tab:  proc(col,dir); /* find the next tab stop past col in given direction */   dcl (col,dir,i,ch) fixed;   scan.charx=charx(tab.ptr+1); /* init scan charx for this line */   do i=1 to col-1; /* scan out to column */      if byte(buf,scan.charx)=0 then return 0; /* hit end of line */      scan.charx=scan.charx+1;   end;   ch=byte(buf,scan.charx); /* get first char */   do while (ch<>a.SP) and (ch<>0); scan.charx=scan.charx+dir; ch=byte(buf,scan.charx); end; /* of current field scan */   do while (ch=a.SP); /* skip over following spaces */      scan.charx=scan.charx+1; ch=byte(buf,scan.charx);   end;   if ch=0 then return 0; /* hit end of line */   return scan.charx-charx(tab.ptr+1)+1; /* return column position */end find.tab;move:  proc(code); /* codes:  0=tab, 1=left, 2=right, 3=down, 4=up, 5=flip, 6=pop, 7=eof */   dcl (code,i) fixed;   if (code=3) or (code=4) then do; /* special case for up and down */      if line.adjust.mode=2 then do; line.adjust.mode=3; return; end; /* put adjust into idle mode */      if (line.adjust.mode>0) and (current.col>0) then do; /* activate line adjust */         current.col=line.adjust.col; line.adjust.mode=2; line.adjust.index=0;      end;   end; /* of special case */   do case (code); /* branch according to code */      do; /* 0: tab */         tab.ptr=current.ptr; i=find.tab(current.col,1); /* make first scan on current line */         do while (i=0) and (tab.ptr IGT text.ptr); /* loop until tab stop found */            tab.ptr=step.lines(tab.ptr,-1); i=find.tab(current.col,1); /* step back, scan again */         end;         current.col=i; /* store result */      end; /* tab */      if      current.col=0          then current.col=current.line.length+1; /* 1: cursor move left */      else if current.col=origin.col then current.col=0;      else                                current.col=current.col-1;      if current.col=0 then current.col=origin.col; /* 2: cursor move right */      else                  current.col=current.col+1;      if (line.adjust.mode=0) and (current.line=top.line+PAGE.LENGTH-header.lines-1) then do; /* 3: cursor move down */         top.line=top.line+PAGE.LENGTH-header.lines; /* roll to next screen */         current.line=top.line+PAGE.LENGTH-header.lines-1; /* point to line 'V' */         clear.cursors = true; /* clear typeahead */      end;      else call skip.line(1); /* just skip down */      if (line.adjust.mode=0) and (current.line=top.line) then do; /* 4: cursor move up */         top.line=top.line-(PAGE.LENGTH-header.lines); /* roll up a page */         current.line=top.line; /* point to line 'A' */         clear.cursors = true; /* clear typeahead */      end;      else call skip.line(-1); /* just skip up */      do; /* 5: flip with stack top */         if top.line=top.line.stack(stack.top) then call write.cursor(1,false); /* fix current line */         i=current.line; current.line=current.line.stack(stack.top); current.line.stack(stack.top)=i;         i=top.line; top.line=top.line.stack(stack.top); top.line.stack(stack.top)=i;         i=current.col; current.col=current.col.stack(stack.top); current.col.stack(stack.top)=i;         i=origin.col; origin.col=origin.col.stack(stack.top); origin.col.stack(stack.top)=i;      end; /* of flip */      do; /* 6: pop position from stack */         call write.cursor(1,false); /* restore current line */         current.line=current.line.stack(stack.top);         top.line    =top.line.stack(stack.top);         current.col =current.col.stack(stack.top);         origin.col  =origin.col.stack(stack.top);         if stack.top<>stack.bottom then stack.top=stack.top-1;         if stack.top<0 then stack.top=STACK.SIZE-1;      end; /* of pop */      do; call save.screen; current.line=cur.file.lines; end; /* 7: goto end of file */   end; /* of do case */   call show.line; /* set up to display the new current line */end move;/* $SUBTITLE  Screen Setup, Add New Char, Buffer Numbering, Char Ops */check.screen.changes:  proc; /* find what parts of the screen need to be changed */   check:  proc(value,index); /* compare with previous value */      dcl (value,index,i) fixed;      dcl prior.value(11) fixed;      i=(value<>prior.value(index)); /* indicate change */      prior.value(index)=value; /* keep new value */      return i;   end check;   page.rewrite =page.rewrite  or check(top.line,0)         or check(origin.col,1) or check(header.lines,2);   head.rewrite =(header.lines>0) and (check(left.margin,3) or check(right.margin,4));   status.change=status.change or check(char.insert.mode,5) or check(modified,6);   status.change=status.change or check(line.adjust.mode,7) or check(line.insert.mode,8) or check(cur.file.type,9);   line.change  =line.change   or check(current.line,10);   col.change   =col.change    or check(current.col, 11);end check.screen.changes;setup.screen:  proc(initial.line); /* initialize the screen window state, and save state */   dcl initial.line fixed; /* initial current line */   current.line=1; mark.line=0; current.col=0; origin.col=1; /* set screen position */   stack.top=-1; stack.bottom=STACK.SIZE; /* create screen position stack */   current.ptr=text.ptr; call point.to(1); /* set up buffer pointers */   current.line=initial.line; call show.line; /* set up the current line */   call save.screen; /* save this screen */   call check.screen.changes; /* preset the current screen */   page.rewrite=true; /* force page rewrite */end setup.screen;newchar:  proc(ch); /* add a new character to file */   dcl ch       fixed;   dcl past.end boolean; /* special logic to avoid blanks at end of line */   past.end=(current.col>current.line.length);   if (char.insert.mode and ^past.end) or ((ch<>a.SP) and past.end) then      call insert.char(current.col,ch,force(peek.next.char)); /* insert char in buffer */   else if not (char.insert.mode or past.end) then do; /* overstriking within line */      call pbyte(buf,current.charx+current.col-1,ch); call pchar(ch); /* overwrite and echo */      modified=true; /* this changes file */   end;   current.col=current.col+1; /* move past inserted char */end newchar;number.buffer:  proc(start,finish); /* put line numbers in buffer */   dcl (start,finish,line.number) fixed; /* go from 'start' to 'finish' */   line.number=1;   do while start ILE finish; /* loop over the range */      if buf(start)=-1 then do; /* test for line number */         buf(start)=line.number; /* put in line number */         line.number=line.number+1; /* advance count */      end;      start=start+1; /* go to next word of buffer */   end; /* of do while */end number.buffer;unnumber.buffer:  proc(start,finish); /* remove line numbers, return count */   dcl (start,finish,count) fixed;   count=0; /* count the lines */   do while start ILE finish;      buf(start)=-1; start=start+1; /* put mark down and move past */      count=count+1; /* count this line */      do while (buf(start)&"177400")<>0; /* scan to end */         buf(start)=buf(start)&"077577"; /* clear parity bits */         start=start+1;      end;      start=start+1; /* move past the end of line code */   end;   return count;end unnumber.buffer;/* $SUBTITLE  Scan for Non-blank, Goto, and Erase Rest of Line routines */first.non.blank:  proc(ptr); /* find the first non-blank in line indicated by ptr */   dcl (ptr,i,j,ch) fixed;   i=charx(ptr+1); j=0; /* index to start of line */   ch=byte(buf,i); /* get first char */   do while ch=a.SP; /* loop over spaces */      j=j+1; ch=byte(buf,i+j);   end;   if ch=0 then return 0; /* no non-blank in line */   return j+1; /* return col number */end first.non.blank;adjust.value:  proc(val,ch); /* adjust given value absolute or relative */   dcl (val,ch,sum) fixed; /* present value, first char */   sum=(ch-a.0); /* init the sum */   col.change=true; /* call to restore column */   ch=get.next.char; /* get the next char */   do while (ch<>a.CR) and (ch<>a.plus) and (ch<>a.minus); /* loop until ending char */      if (ch-a.0) IGT (a.9-a.0) then return val; /* invalid, do nothing */      wchar(ch); /* type the char */      sum=sum*10+(ch-a.0); /* add in */      ch=get.next.char; /* next char */   end;   if ch<>a.CR then wchar(ch); /* type + or - */   if      ch=a.CR       then val=sum; /* absolute value */   else if ch=a.plus then val=val+sum; /* rel plus */   else if ch=a.minus  then val=val-sum; /* rel minus */   if val IGT 20000 then val=0; /* limit to avoid wrap around */   return val; /* return the value */end adjust.value;line.goto:  proc(ch); /* process line goto command */   dcl ch fixed; /* first char of line number */   if (ch-a.a) ILE (a.v-a.a) then current.line=top.line+(ch-a.a);   else do; /* numeric value */      pcmd('Enter line number: '); wchar(ch); /* prompt and first char */      call save.screen; /* push where we are now on stack */      current.line=adjust.value(current.line,ch); /* get new value */      origin.col  =1; /* restore screen origin to 1 */   end;   call show.line; /* adjust window accordingly */end line.goto;column.goto:  proc; /* process column goto command */   dcl ch fixed;   pcmd('Enter R, L, or column number: '); ch=get.next.char.upcase; wchar(ch);   col.change=true; /* call for column change */   if       ch=a.r then right.margin=current.col;   else if  ch=a.l then left.margin =current.col;   else if (ch-a.0) ILE 9 then do; /* numeric:  goto column */      current.col=adjust.value(current.col,ch); /* get new value */      return;   end;   erase_command;end column.goto;set.origin.col:  proc; /* process set screen origin command */   pcmd('Enter column origin: ');   origin.col=adjust.value(origin.col,a.0); /* get new value */   if origin.col<1 then origin.col=1; /* lower limit to 1 */   if current.col<origin.col then current.col=0; /* shift current col if needed */end set.origin.col;delete.rest:  proc; /* delete the text past the current column */   dcl (i,p,ch) fixed;   if current.col>current.line.length then return; /* simple case */   p=current.charx+current.col-1; /* get word pointer to where we are */   i=wordx(p); /* compute word index to position */   ch=byte(buf,p-1); /* get prior character */   call slide(i,i+1-point.to(current.line+1)); /* remove remaining text */   if current.col then buf(i)=0; /* put in end of line code */   else                buf(i)=ch; /* put back last char */   erase_line; /* blank out the rest of the line */   current.line.length=current.col-1; /* set new length */end delete.rest;/* $SUBTITLE  Text Formatting Routine - Center, Flush, Fill */extr:  proc(str,ptr); /* works like 'byte' but converts to upper case if no case.matching */   dcl str     array; /* in time critical loops this routine is coded in-line */   dcl (ptr,i) fixed;   i=byte(str,ptr); /* get the byte */   if ((i-l.a) IGT (l.z-l.a)) or (case.matching) then return i;   return i-"40"; /* up the case */end extr;format.text:  proc(code); /* text format the marked lines */   dcl code            fixed; /* 0: fill, 1: justify, 2: center text, 3: flush left, 4: flush right */   dcl (lines,i,j,k,m) fixed; /* number of lines to process */   if cur.file.type<>TEXT.TYPE then do; /* locked out if not text type */      pcmd('Must be Text type for format command');      col.change=true; /* signal to restore cursor */      return;   end;   pcmd('Formatting...'); /* put up message */   lines=region.arg; /* get the region */   current.line=first; current.ptr=point.to(first); /* set up pointer to start */   call show.line; /* set up first line */   do while lines>0; /* process a line */      call delete.trailing.spaces; /* move to end and remove spaces */      if code<2 then do; /* paragraph format */         do while (current.line.length<right.margin) and (lines>1); /* extend line */            if byte(buf,current.charx+current.col-2)=a.period then do; /* ending period */               call insert.char(current.col,a.SP,2); /* add space */               current.col=current.col+1; /* move to end */            end;            call join; /* add on next line */            lines=lines-1; /* decrement line count */            call insert.char(current.col,a.SP,2); /* insert space */            call delete.trailing.spaces; /* move to end and remove spaces */         end;         tab.ptr=current.ptr; current.col=find.tab(right.margin+1,-1); /* check for break point */         if current.col>1 then call split; /* split at break point */         else do; /* move to next line */            current.line=current.line+1; /* advance */            call show.line; /* update pointer */            lines=lines-1;         end;      end; /* of case for paragraph format */      else do; /* center or flush line */         m=left.margin; if m=0 then m=1; /* get real left margin */         k=first.non.blank(current.ptr); /* locate first char */         if      code=2 then do; /* compute to center line */            i=(right.margin-m)-(current.line.length-k);            j=shr(i+1,1)+(m-k); /* amount to shift */         end; /* center */         else if code=3 then do; /* compute to flush left */            i=1; j=m-k;         end; /* flush left */         else do; /* compute to flush right */            j=right.margin-current.line.length; i=k-1+j;         end;         if i>0 then do i=1 to abs(j); /* line will fit, shift it */            if j>0 then call insert.char(1,a.SP,2); /* insert spaces */            else        call delete.char(1,0); /* delete char */         end; /* of shift line */         current.line=current.line+1; /* advance to next line */         call show.line; /* update pointer */         lines=lines-1;      end; /* of center or flush line */   end; /* of do while for line processing */   mark.line=0; current.col=0; /* remove region mark, return to command col */   page.rewrite=true; /* call for page rewrite */end format.text;