/* $TITLE  Buffer Manipulation Routines *//* This module contains the buffer operations, such as indexing,.  sliding, pointing, inserting, deleting, etc., as well as the.  character input and macro expander routines. */wordx:  proc(chx) fixed; /* converts char index to word index */   dcl chx fixed;   return shr(chx,1)+1;end wordx;charx:  proc(wdx) fixed; /* converts word index to char index */   dcl wdx fixed;   if wdx=0 then return 0; /* use 0 for location 0 of file */   return shl(wdx-1,1);end charx;step.lines:  proc(loc,nlines); /* step 'nlines' from given location */   dcl (loc,nlines,forb) fixed;   forb=1; if nlines<0 then forb=-1; /* choose direction */   do while nlines<>0; /* decrement count till done */      loc=loc+forb; /* go to next word */      if (loc=text.ptr) or (loc=last.ptr+1) then return loc; /* quit at file end */      if buf(loc)=-1 then nlines=nlines-forb; /* count line breaks */   end;   return loc; /* pointer to resulting line */end step.lines;point.to:  proc(line); /* return pointer to start of specified line */   dcl (line,i,j,k) fixed;   dcl old.current.line fixed; /* line # indicated by cline.ptr */   i=line-old.current.line; /* # of lines from current line */   j=cur.file.lines-line+1; /* # of lines from end of file */   k=abs(i); /* # of lines to move from current line */   old.current.line=current.line; /* remember the current line */   /* step minimum number of lines from known position */   if (k<=line) & (k<=j)    then return step.lines(current.ptr,i); /* step from current line */   if (line<=k) & (line<=j) then return step.lines(text.ptr,line-1); /* step from start */   else return step.lines(last.ptr+1,-j); /* step from end of file */end point.to;show.line:  proc; /* adjust screen and locate the current line */   if current.line<1 then current.line=1; /* check current line for validity */   if current.line>cur.file.lines then current.line=cur.file.lines;   if current.line<top.line or current.line>top.line+PAGE.LENGTH-header.lines-1 then      top.line=current.line-(PAGE.LENGTH-header.lines)/2; /* if off page, roll to center */   if top.line>cur.file.lines-10 then top.line=cur.file.lines-10; /* check top line */   if top.line<1 then top.line=1;    current.ptr=point.to(current.line); /* locate the new current line */   current.charx=charx(current.ptr+1);   current.line.length=0;   do while byte(buf,current.charx+current.line.length)<>0;      current.line.length=current.line.length+1;   end;   if (current.col<origin.col) and (current.col>0) then origin.col=current.col; /* shift origin if needed */end show.line;scroll:  proc(code); /* code: 0=center, 1=top, 2=bottom */   dcl code fixed;   do case (code);      top.line=current.line-(PAGE.LENGTH-header.lines)/2; /* center */      top.line=current.line; /* top */      top.line=current.line-(PAGE.LENGTH-header.lines)+1; /* bottom */   end;   call show.line;end scroll;copy.text:  proc(source,dest,w.length); /* copy words from source to dest */   dcl (source,dest,w.length,i) fixed;   do i=0 to w.length-1;      buf(dest+i)=buf(source+i); /* copy word */   end;end copy.text;/* $SUBTITLE  Routine to slide memory contents and update pointers */slide:  proc(loc,n); /* slides words from word loc to end of file */   /* +n towards end, vacated words are zero, word at loc is moved */   /* return true if slide successful, or false if it would exceed memory */   dcl (loc,n,i,j,res,temp1,temp2) fixed;   dcl subt lit '"214"'; /* subtract       */   dcl reg  lit '"300"'; /* load register  */   dcl mr   lit '"340"'; /* memory reg     */   dcl mri  lit '"360"'; /* memory reg inc */   dcl mask lit '64'; /* size of block to be moved */   copy:  proc(arr1,arr2,length);      dcl (arr1,arr2) array;      dcl length      fixed;      dcl c lit 'write(mri+2)=read(mri+3)'; /* mem inc to mem inc transfer */      dcl d lit 'c;c;c;c;c;c;c;c'; /* eight transfers */      res=(length & (mask-1)); /* fraction of block portion */      j=0; /* start at offset 0 */      do i=1 to res; /* move individual words */         arr2(j)=arr1(j); /* word transfer */         j=j+1;      end;      do i=mask to length-res by mask; /* block move the rest */         temp1=addr(arr1(j));         temp2=addr(arr2(j));         write(reg+2)=temp2;         write(reg+3)=temp1;         d;d;d;d;d;d;d;d; /* move the block of 64 */         j=j+mask;      end;   end copy;   copyu:  proc(arr1,arr2,length); /* copy up */      dcl (arr1,arr2) array;      dcl length      fixed;      dcl c lit 'write(mr+2)=read(mr+3);write(subt+2)=1;write(subt+3)=1';      dcl d lit 'c;c;c;c;c;c;c;c'; /* eight of them */      res=(length & (mask-1)); /* fractional part */      j=length-1; /* point to last */      do i=1 to res; /* move individual words */         arr2(j) = arr1(j); /* word transfer */         j=j-1; /* back up */      end;      do i=mask to length-res by mask; /* block move the rest */         temp1=addr(arr1(j));         temp2=addr(arr2(j));         write(reg+2)=temp2;         write(reg+3)=temp1;         d;d;d;d;d;d;d;d; /* move the block of 64 */         j=j-mask;      end;   end copyu;   if n=0 then return true; /* that was easy */   if last.ptr+2+n IGE buflen then return false; /* exceeds memory */   if n>0 then do; /* forward */      call copyu(location(addr(buf(loc))),location(addr(buf(loc+n))),last.ptr+2-loc);      do i=loc to loc+n-1; buf(i)=0; end; /* store zeros in hole */   end;   else call copy(location(addr(buf(loc-n))),location(addr(buf(loc))),last.ptr+2-loc+n);   do i=0 to 5; /* update buffer pointers */      if loc ILT intext.ptr(i) then intext.ptr(i)=intext.ptr(i)+n;   end;   if loc ILT wordx(scan.charx) then scan.charx =scan.charx +n+n; /* in chars */   if loc ILT current.ptr       then current.ptr=current.ptr+n;   if loc ILT start             then start      =start      +n;   finish         =finish+n;   current.charx  =charx(current.ptr+1);   last.ptr       =last.ptr+n; /* update buffer pointers */   cur.file.length=last.ptr-text.ptr+1; /* change length of file */   core(loc.csln) =shr(cur.file.length+255,8); /* set length in sectors */   if loc IGE text.ptr then modified=true; /* the slide has changed the file */   return true; /* the slide was done */end slide;/* $SUBTITLE  Character Handling Routines */get.macro.char:  proc; /* return next char from macro def */   dcl ch fixed; /* current character */   ch=byte(buf,macro.index); /* get char */   if ch=0 then do; /* line break - return a carriage return key */      ch=a.CR;      macro.index=(macro.index\1)+3; /* skip over the break */   end;   else macro.index=macro.index+1; /* advance */   if byte(buf,macro.index)=a.apost then do;      if byte(buf,macro.index+1)=a.apost then macro.index=macro.index+1;      else do; /* end of this macro, pop up a level */         macro.level=macro.level-1;         macro.index=macro.stack(macro.level); /* pop the macro expansion index */      end;   end;   return ch; /* return the char */end get.macro.char;store.line.adjust.char:  proc(ch);   dcl ch fixed;   if ch=a.nak then return; /* don't let line adjust toggles get into buffer */   call pbyte(line.adjust.buffer,line.adjust.index,ch); /* store char */   if line.adjust.index<STRING.LENGTH-1 then line.adjust.index=line.adjust.index+1; /* limit on buffer size */end store.line.adjust.char;get.line.adjust.char:  proc; /* return the next line adjust command */   line.adjust.index=line.adjust.index+1; /* advance index */   return byte(line.adjust.buffer,line.adjust.index-1); /* return the char */end get.line.adjust.char;get.next.char:  proc; /* return next char, according to input modes */   dcl ch fixed;   if      macro.level>0      then ch=get.macro.char; /* get from macro expander */   else if line.adjust.mode=2 then ch=get.line.adjust.char; /* from line adjust expander */   else do; /* user */      ch=rchar; /* get next char from user */      if (line.adjust.mode=3) and (current.col>0) and      ((ch>=a.SP) and (ch<"200")) then line.adjust.mode=0; /* automatic cancel of line adjust mode */   end;   if line.adjust.mode=1 then call store.line.adjust.char(ch); /* keep it if recording */   return ch;end get.next.char;get.next.char.upcase:  proc; /* get the next char and upcase it */   dcl ch fixed;   ch=get.next.char; /* get char */   if (ch-l.a) ILE (l.z-l.a) then ch=ch-"40"; /* up the case */   return ch;end get.next.char.upcase;peek.next.char:  proc; /* returns next char in input stream, without advancing */   dcl char fixed;   if macro.level>0 then do; /* input is coming from macro */      char=byte(buf,macro.index);      if char=0 then char=a.CR; /* apply macro expansion logic */   end;   else if line.adjust.mode=2 then char=byte(line.adjust.buffer,line.adjust.index);   else char=peek; /* peek at the terminal input buffer */   return char;end peek.next.char;force:  proc(ch); /* returns true if ch forces a screen update of current line */   dcl ch fixed;   if      ch<a.SP     then return true; /* all control codes force update */   else if ch>"200"  then return true; /* all meta force update */   else if ch=a.grave then return true; /* search again forces update */   else                   return false; /* others do not force update */end force;/* $SUBTITLE  Output Routines */pchar:  proc(ch); /* print a char, indicating control chars by reverse cap */   dcl ch fixed;   if ch>=a.SP then wchar(ch);   else do; reverse(true); wchar(ch+a.a-1); reverse(false); end;end pchar;write.line:  proc(ptr,col); /* print line indicated by ptr, starting at col */   dcl (ptr,col,i,j,ch) fixed;   i=charx(ptr+1); /* start at first col */   do j=1 to col-1; if byte(buf,i)=0 then goto break.out; i=i+1; end; /* step out to col */   ch=byte(buf,i); /* get first char */   do while ch<>0; /* loop over rest of line */      call pchar(ch);      i=i+1; ch=byte(buf,i); /* get next char */   end;   BREAK.OUT:   Erase_line; /* erase the rest */   return wordx(i+2); /* return word pointer to next line */end write.line;write.cursor:  proc(col,move); /* position the cursor, shifting current line if needed */   dcl (col,i,prior.i,ch) fixed;   dcl move               boolean;   ch=peek.next.char; /* check the next char */   if (ch="010") or (ch="014") or (ch=cur.left) or (ch=cur.right) then return; /* can skip this */   i=(col-origin.col)-(PAGE.WIDTH-10); if i<0 then i=0; /* compute first col to print */   if ((i>0) or (prior.i>0)) and ((i<>prior.i) or (col.change)) then do; /* must rewrite shifted current line */      if force(ch) then do; /* must do rewrite now */         pos(current.line-top.line+header.lines,2);         if i>current.line.length then erase_line; /* past end, erase line */          else call write.line(current.ptr,i+origin.col); /* rewrite the line */         prior.i=i; /* remember this print position */      end;   end; /* of line rewrite */   if move then if current.col=0 then pos(current.line-top.line+header.lines,0); /* in command line */                else pos(current.line-top.line+header.lines,(col-origin.col)-i+2); /* position in text */   col.change=false; /* we've done it */end write.cursor;write.flag:  proc(line,must); /* flag or unflag line */   dcl (line,new)        fixed;   dcl must              boolean;   dcl flag(PAGE.LENGTH) fixed;   new=a.SP; /* assume no flag */   if (mark.line<>0) & (((mark.line   <=line) & (line<=current.line)) or                        ((current.line<=line) & (line<=mark.line   ))) then new=a.period;   if (new<>flag(line-top.line)) or must then do; /* flag has changed */      pos(line-top.line+header.lines,1); wchar(new); /* print new flag char */      col.change=true; /* signal to restore cursor */   end;   flag(line-top.line)=new; /* keep it */end write.flag;write.all.flags:  proc; /* update the flags for all lines */   dcl i fixed;   do i=0 to PAGE.LENGTH-header.lines-1; /* update the flags */      call write.flag(i+top.line,false);   end;end write.all.flags;write.line.number:  proc; /* update the line number field in status line */   call write.all.flags; /* update the flags */   pos(status.line,4); pnum(current.line,5); /* write the new current line number */   call write.cursor(current.col,true); /* check current line and set position */   line.change=false; /* we've written it */end write.line.number;/* $SUBTITLE  Status Line and Text Page write routines */write.mod:  proc; /* indicate if file is modified or unmodified */   if modified then pstring('Modified    ');   else             pstring('Unmodified  ');end write.mod;write.status:  proc(flag); /* write the status line */   dcl flag boolean; /* true when write.cursor should be called at end *//*   if peek.next.char=-1 then do;  */ /* write only if no char is waiting */      pos(status.line,0); /* position the cursor */      pstring('Line'); pnum(current.line,5);      pos(status.line,11); pstring(def.filename);      do case cur.file.type; /* print the file type */         pstring('.XPL  '); /* XPL file */         pstring('.SCR  ');         pstring('   '); /* typeless text */         pstring('.C  ');         pstring('.LSP  ');         pstring('.FTN  ');      end;      call write.mod; /* modified status */      if char.insert.mode   then pstring('Append Mode   ');      else                       pstring('Overstrike    ');      if line.insert.mode   then pstring('Line Insert   ');      else                       pstring('No Line Insert  ');      if line.adjust.mode=1 then pstring('Adjust Mode');      if line.adjust.mode>1 then pstring('Adjust Active');      Erase_line; /* erase the rest of the line */      status.change=false; /* we've written it *//*   end; */   if flag then call write.cursor(current.col,true);end write.status;write.header:  proc; /* print the column header if turned on */   dcl i fixed;   pos(0,0); pstring('  '); /* get in position */   do i=origin.col to origin.col+PAGE.WIDTH; /* loop over columns */      if      i=left.margin  then wchar(a.l); /* left margin */      else if i=right.margin then wchar(a.r); /* right */      else if (i mod 10)=0   then wchar(a.0+((i mod 100)/10)); /* number */      else if (i mod 5 )=0   then wchar(a.plus); /* plus */      else                        wchar(a.minus); /* minus */   end; /* of loop over columns */   head.rewrite=0;end write.header;write.page:  proc(line); /* print screen from specified line down */   dcl (i,j,k,line,ptr) fixed;   if line=0 then do; /* whole page rewrite */      clear_screen; status.change=true;      if header.lines>0 then call write.header; /* put up header if selected */   end; /* of whole page rewrite */   j=(current.col-origin.col)-(PAGE.WIDTH-10); /* compute first column to display of current line */   if j<0 then j=0; /* limit */   ptr=point.to(top.line+line); /* get pointer to first line */   do i=line to PAGE.LENGTH-header.lines-1;      k=i+top.line; /* compute actual line number */      pos(i+header.lines,0); /* point to start of line */      if ptr ILT last.ptr then do; /* print if in file */         wchar(a.a+i); /* print line as letter */         call write.flag(k,true); /* flag or unflag line */         if k=current.line then ptr=write.line(ptr,j+origin.col);         else                   ptr=write.line(ptr,  origin.col); /* print line, return pointer to next */      end; /* of in file */      else erase_line; /* blank out line */   end;   if line<>0 then call write.all.flags; /* if part.rewrite, update flags for all lines */   if first.time then pcmd(version.msg); /* indicate version on first screen */   col.change=false; line.change=false; /* current line shifting has already been done */   call write.status(true); /* put up the status display and position cursor */   page.rewrite=false; part.rewrite=false; /* we've written it */end write.page;/* $SUBTITLE  Character Insert and Delete, Line Count Operations */insert.char:  proc(col,char,pflag); /* inserts char at col in current line */   dcl (col,char,pflag,nchar,hold.char,i,p,n) fixed;   if col>current.line.length+1 then do; /* if needed, extend line with blanks */      p=current.charx+current.line.length; /* compute location of eol */      n=col-(current.line.length+1); /* number of spaces to add */      nchar=byte(buf,p); /* keep odd ncharacter */      if current.line.length then call slide(wordx(p)+1,shr(n+1,1)); /* open the space */      else                        call slide(wordx(p),shr(n,1));      do i=p to p+n-1; call pbyte(buf,i,a.SP); end; /* insert the blanks */      call pbyte(buf,p+n,nchar); /* replace odd nchar after break */      current.line.length=current.line.length+n;   end;   p=current.charx+col-1; /* compute location for char */   nchar=byte(buf,p); /* get first character to move */   call pbyte(buf,p,char); /* insert character */   hold.char=char; /* remember char for print */   do while nchar<>0; /* loop till null */      p=p+1; /* advance */      char=byte(buf,p); /* get char to move down */      call pbyte(buf,p,nchar); /* put in char */      nchar=char; /* swap */   end;   if p&1 then call slide(wordx(p)+1,1); /* if no null left, slide down a word */   current.line.length=current.line.length+1; /* add to length */   if pflag then call write.line(current.ptr,col); /* write line if flag set */   else if pflag<>2 then call pchar(hold.char); /* else just write this char */   modified=true; /* insert has changed file */end insert.char;delete.char:  proc(col,pflag); /* delete character at col in current line */   dcl (col,p,pflag) fixed;   p=current.charx+col-1; /* locate in buffer */   do while byte(buf,p)<>0; /* loop until null */      call pbyte(buf,p,byte(buf,p+1)); p=p+1; /* move char foward */   end;   if (p&1)=0 then call slide(wordx(p),-1); /* if pointing to start of word, slide it out */   current.line.length=current.line.length-1; /* subtract from length */   if pflag then call write.line(current.ptr,col); /* write result if flag set */   modified=true;end delete.char;adjust.lines:  proc(lines); /* adjust line markers for change in number of lines */   dcl (lines,i) fixed; /* number of lines added (+), or deleted (-) */   cur.file.lines=cur.file.lines+lines; /* update number of lines */   if mark.line>=current.line then mark.line=mark.line+lines; /* update mark point */   do i=0 to stack.size-1; /* loop over the stack */      if current.line.stack(i)>=current.line then /* adjust this entry */         current.line.stack(i)=current.line.stack(i)+lines; /* shift it by change */      if top.line.stack(i)>=current.line then /* adjust */         top.line.stack(i)=top.line.stack(i)+lines; /* shift window pos */   end; /* of stack loop */end adjust.lines;remove:  proc(loc,len,lines); /* clean up after line delete */     dcl (loc,len,lines) fixed; /* location, length, and number of lines in block */   call slide(loc,-len); /* remove the text block */   if mark.line<current.line then current.line=mark.line; /* point to start of marked area */   mark.line=0; /* lines no longer there to mark */   call adjust.lines(-lines); /* adjust line markers for this deletion */   call point.to(current.line); /* change the old current line in point.to */   current.ptr=start; /* restore current ptr to beginning of delete area */   current.charx=charx(current.ptr+1);   part.rewrite=true; /* rewrite from current line down */   call show.line; /* adjust if needed to bring current line onto screen */end remove;delete.trailing.spaces:  proc; /* move to end of line and remove spaces */   current.col=current.line.length+1; /* move to end of line */   do while (byte(buf,current.charx+current.col-2)=a.SP); /* loop on spaces */      current.col=current.col-1; /* back up to space */      call delete.char(current.col,0); /* remove it */   end; /* of spaces loop */end delete.trailing.spaces;