/* $TITLE  Screen Editor 2.11J *//* Supports the following terminals:  VT-100, VT-640, VT-52,                                      ADM-3a, ADM-5, Datamedia.Original:  Stan DuntenRevision:  Jeffrey Risberg  added more control command codes, global change, selective multiple   change, error recovery, internal text buffers, screen position stack,   relative moves, macros (extensible commands), automatic line indent,   case matching, partner search, line adjust, right and left margins,  identifier search, text formatting, and use of ADM-5 cursor arrows.Modification History:  Summer 1982    Revised [JSR]  5/1/86         Revised for -7 catalog structure [KJO]       commands at left margin:    A-V     moves to the specified line letter    ^       if at top of screen, up one screen; else up one line    $       pushes screen and moves to last line in file    <n>     pushes screen and moves to line number <n>    <n>+    pushes screen and moves <n> lines beyond current line    <n>-    pushes screen and moves <n> lines prior to current line    .T      moves current line at Top of screen    .B      moves current line to Bottom of screen    .C      moves current line at Center of screen     .X      eXecutes the file on the disk with the name of the default file    .P      Play the current file    .S      prints out editor States and contents of user current catalog    .Q      print names of defined macros /<string>  pushes screen and searches forward for the <string> \<string>  pushes screen and searches backward for the <string>    |       searches again    +       appends a blank line after current line    -       inserts a blank line before current line    .G      initiates multiple change Globally or in marked lines    .Y      initiates selective mulitple change globally or in marked lines    .F      Formats a marked block     .[  left  flushes a block  .V or .*  centers a marked block     .]  right flushes a block  .A or .+  Appends a file after current line  .I or .-  Inserts a file before current line    ..      marks first line of marked lines    .W      Writes marked lines out to a file    .D      Deletes marked lines     .M      Moves marked lines to disk file    ;       recover deleted lines    .O      reads in an Old file    .R      (Replace) copies everything out to a file    .Z      enters a subcatalog on Winchester    .N      New file (clears text and asks for new file name)    .U      Unsaves a file    .E      Exits    =M      set Macro (pre-defined text) definitions file    =I      set Indent amount for DO, END    =C      set Case matching for searches    =T      set Type of file (XPL, SCRIPT, C, other)    =R      set Right margin for format command    =A      set Append mode (1=append, 0=overstrike)    =H      set Header mode (0=off, 1=on)internal text buffers commands and modifiers (commands typed at left margin)    There are 3 internal text buffers (in addition to the delete/recover    buffer).  They are referenced by the command pairs < and >, [ and ],    and { and }, as follows:    <, [, or {   move marked lines into specified internal text buffer    >, ], or }   insert lines from specified internal text buffer at current line    Modifiers for <, [, and { commands:    ,    move marked lines to buffer but do not delete from file    &    append marked lines to end of text buffer contents    #    insert marked lines at start of text buffer contents    !    clear text buffer and do not move lines to it    The &, # and ! modifiers are mutually exclusive.  Last one typed is used.     If no modifiers are specified, the buffer will be cleared, then the    marked lines moved to the buffer, and then the marked lines will be    deleted from the current file.control character commands (apply anywhere):    ^A      toggle Append mode/overstrike    ^B      Break line (not at left margin)    ^C      move current line to Center    ^D      Delete character (at end of line, join lines)    ^E      delete to End of current line    ^F      Flip - exchange current screen and top of prior screen stack    ^G      invoke pre-defined text macro (asks for name)    ^H      (backspace) move cursor left    ^I      (tab) move right to next field    ^J      (line feed) move cursor down    ^K      move cursor up    ^L      move cursor right    ^M      (return) same as return key    ^N<n>   goto column <n> (follow with +, - for relative)    ^NR     define Right margin to be current column    ^NL     define temporary Left margin instead of automatic indent    ^O<n>   set screen Origin to column <n> (follow with +, - for relative)    ^P      Pop from prior screen position stack    ^Q      reserved    ^R      Return cursor to command column    ^T      move current line to Top    ^U      toggle line adjUst mode    ^V      find partner    ^W      invoke macro with single letter name    ^X      use next keystroke literally (not in left margin)    ^Y      toggle line insert mode (not on datamedia)    ^Z      push this position on prior screen position stack    ^]      pushes screen, stores current token as search string, and searches forward    ^/      (VT100)         pushes screen, stores current token as search string, and searches forward    ^\      (VT100 and ADM) pushes screen, stores current token as search string, and searches backwardspecial characters in search strings:    ^C      matches any ASCII character      ^D      matches any digit    ^L      matches any letter (upper or lower case)special character commands:    rubout     if in text, deletes character before cursor,                else deletes current line    cr         if past eol and line insert, appends a blank line;                else moves to indent position on next line    lf         moves cursor down one line    esc        non VT100 - moves forward one character    esc seqs.  VT100 - moves cursor (do not use in macros)    home       return cursor to command column    bs         moves backward one character, wrapping    tab        tabs forward to next field    PF1  return cursor to command column     PF2  move current line to center of screen     PF3  invoke single-letter name macro     PF4  find partner    (note:  in macros, use ^R, ^C, ^W, ^V for PF1 through PF4)when a filename is asked for:    carriage return    use default filename (last used on .R, .O, or .N)    rubout             ignore command    ? (as first char)  print catalog and ask again    <filename>         use the name*//* $SUBTITLE  Global Variables */insert ':-xpl:literals';  /* literals */insert ':-xpl:asciilit';  /* ASCII literals */insert ':-xpl:catrtns';   /* catalog routines */insert ':-xpl:catutil';   /* catalog utilities */insert ':-xpl:termutil';  /* terminal utilities */dcl version.msg data ('SED version 2.15 (15 Jan 15)');dcl dummy       data (':USER:.CURRENT'); /* name of temporary file *//* Flags */dcl literal.mode     boolean; /* true => literal mode */dcl char.insert.mode boolean; /* true => insert, false => overstrike */dcl line.insert.mode boolean; /* true => insert line on return at eol */dcl modified         boolean; /* true => file has been modified */dcl page.rewrite     boolean; /* true => rewrite all of text page */dcl part.rewrite     boolean; /* true => rewrite from current line down */dcl head.rewrite     boolean; /* true => rewrite header line */dcl status.change    boolean; /* true => rewrite status line */dcl line.change      boolean; /* true => rewrite line number in status */dcl col.change       boolean; /* true => move to new column in line */dcl case.matching    boolean; /* true when case must be matched in searches */dcl first.time       boolean; /* true on first time through command loop */dcl macro.level      fixed;   /* nesting level of macros, 0=not in macro */dcl line.adjust.mode fixed;   /* 0=not in mode, 1=filling, 2=applying, 3=idle */dcl move.type        fixed;   /* type of move to buffer: 0=load, 1=clear, 2=insert, 3=append *//* Line Variables */dcl current.line     fixed;   /* current line number */dcl current.col      fixed;   /* current column */dcl top.line         fixed;   /* line at top of window */dcl origin.col       fixed;   /* origin of screen columns */dcl right.margin     fixed;   /* right margin value */dcl left.margin      fixed;   /* temp left margin - 0 for autoindent */dcl current.ptr      fixed;   /* word index to current line */dcl current.charx    fixed;   /* character index to col 1 of current line */dcl current.line.length fixed; /* length of current line in chars */dcl cur.file.lines   fixed;   /* length in lines */dcl header.lines     fixed;   /* lines reserved for header at top *//* Stack Variables */dcl stack.size                       lit '6'; /* size of pushdown stacks for position and macros */dcl current.line.stack(stack.size-1) fixed; /* previous current line */dcl current.col.stack (stack.size-1) fixed; /* previous current column */dcl top.line.stack    (stack.size-1) fixed; /* previous top line */dcl origin.col.stack  (stack.size-1) fixed; /* previous origin */dcl (stack.top,stack.bottom)         fixed; /* stack pointers *//* System Variables */dcl old.psys        fixed; /* old value of psys *//* File Variables */dcl cur.sector.ms    lit 'core(loc.csec+1)'; /* device and MSB of starting sector */dcl cur.sector.ls    lit 'core(loc.csec  )'; /* LSW of starting sector for file */dcl cur.file.length  lit 'core(loc.clen)';   /* length in words */dcl cur.file.type    fixed; /* internal type of file */dcl def.filename(F#Name_Len) fixed; /* default filename */dcl mac.filename(F#Name_Len) fixed; /* macro def filename */dcl XPL.TYPE         lit '0';  dcl SCRIPT.TYPE lit '1';dcl TEXT.TYPE        lit '2';  dcl C.TYPE      lit '3';dcl LISP.TYPE        lit '4';  dcl FTN.TYPE    lit '5';dcl Catalog(C#Dir_Max - 1) fixed; /* Catalog buffer *//* Screen Variables */dcl page.length  lit '22'; /* screen definition */dcl page.width   lit '79';dcl command.line lit '22'; /* location of command line */dcl status.line  lit '23'; /* location of status line */dcl indent.amount fixed;   /* columns to indent for each DO *//* Buffer Variables */dcl mark.line        fixed; /* line number of first DOT mark */dcl (start,finish)   fixed; /* regions of file refered to in delete and move */dcl intext.ptr(5)    fixed; /* ptrs to internal text buffers */dcl text.ptr         lit 'intext.ptr(5)'; /* start of text area */dcl last.ptr         fixed; /* ptr to last word used */dcl lines.saved(4)   fixed; /* # of lines saved in the internal text buffers *//* Search Variables */dcl string.length    lit '50'; /* length of search and line adjust strings */dcl search.string.text(STRING.LENGTH/2) fixed; /* holds past search arg */dcl search.string.length lit 'search.string.text(0)'; /* its length */dcl scan.charx       fixed; /* char index var for 'text.scan' */dcl line.adjust.buffer(STRING.LENGTH/2) fixed; /* holds line adjust command chars */dcl line.adjust.index fixed; /* pointer for line adjust buffer */dcl line.adjust.col  fixed; /* starting column for line adjust *//* Macro Variables */dcl macro.index      fixed; /* char index for macro expansion */dcl macro.stack(stack.size) fixed; /* stack for macros within macros */dcl macro.name(12)   fixed; /* name of macro *//* $SUBTITLE  Main Procedure */main:  proc(buf,buflen); /* procedure with main control loop */   dcl buf    array; /* buffer for file */   dcl buflen fixed; /* length of buffer */   insert ':SEDCAT:01-BUFFR'; /* editor buffer and output routines */   insert ':SEDCAT:02-BLOCK'; /* text block manipulation routines */   insert ':SEDCAT:03-SCAN' ; /* scan, search, and global change routines */   insert ':SEDCAT:04-IOMOD'; /* file input and output routines */   insert ':SEDCAT:05-COMND'; /* command parser, macro expander */   dcl (i,char) fixed; /* main loop vars */   call Set_CatBuf (addr(catalog(0)), 0); /* set the catalog buffer */   do i = 0 to 5; intext.ptr(i) = i; end; /* set buffer ptrs */   if core(loc.sed1) = 0 then do; /* no prior file type */      indent.amount = initial.indent.amt; /* set initial indent amt */      case.matching = initial.case.mat; /* set initial case match mode */      cur.file.type = initial.file.type; /* use initial file type */   end;   else do; /* use stored status */      i = shr(core(loc.sed1),1); cur.file.type = (i and "7");      i = shr(i,3); case.matching = (i and "1");      i = shr(i,1); indent.amount = (i and "17");   end;   char.insert.mode=true; line.insert.mode=true; /* set up insert modes */   left.margin=0;  right.margin=69; /* set up margins */   header.lines=0; first.time=true; /* no header, first time init */   if (not core(loc.strd)) or (core(loc.cfn) = 0) then do; /* no file stored, get from disk */      call get.filename('Name of file to read? ',false,treename); /* ask for name */      if locate(treename,1)      then cur.file.lines = rfile(text.ptr,0); /* must read new file from disk */      else cur.file.lines = 0;      if cur.file.lines < 1 then do; /* wants to create new file */         do i = 0 to F#Name_Len;            def.filename(i) = F#Name(i);            core(loc.cfn + i) = F#Name(i);         end;         call setup.null.file;      end;   end; /* of get from disk */   else do; /* use the current file */      if core(loc.rst) = -1 then do; /* compiler found errors */         crlf; pstring('Strike any key to continue... ');         call rchar; /* get dummy char */      end;      do i = 0 to F#Name_Len; /* get name from high core area */         char = core(loc.cfn + i);         def.filename(i) = char; core(loc.strn + i) = char;      end;      f#ms_sector = cur.sector.ms; /* store starting sector */      f#ls_sector = cur.sector.ls;      f#words = cur.file.length; /* store length */      if core(loc.cmed) = 0      then call readdata(cur.sector.ms,cur.sector.ls,location(addr(buf(text.ptr))), cur.file.length);      else do; /* file is in memory */         i = 0; /* start at zero */         do while i ILT cur.file.length; /* copy it to buffer space */            buf(text.ptr + i)=core(core(loc.csec) + i);            i = i + 1;         end;      end; /* file in memory */      if cur.file.length = 0 then do; /* create one line file */         cur.file.length = 2; core(loc.csln) = 1;         buf(text.ptr + 1) = 0; core(loc.svd) = 0;      end;      last.ptr = text.ptr + cur.file.length - 1; /* add in the length */      buf(last.ptr + 1)= -1; /* simulate last line */      modified = not core(loc.svd); /* file is modified if not saved */      cur.file.lines = unnumber.buffer(text.ptr,last.ptr); /* remove and count the lines */   end; /* of use the current file */   /* $SUBTITLE  Main Loop Editor Loop, Initialization Code */   i = 1; /* assume start at line 1 */   if core(loc.sed2) then i = shr(core(loc.sed2),1); /* use stored current line */   call setup.screen(i); /* initialize the screen variables */   if shr(cur.sector.ms,8) = shr(core(loc.scat + 1),8) /* if current file is on system dev */   then call delete(dummy,0); /* delete dummy from system cat */   clear.cursors = false; /* don't clear typeahead cursor controls yet */   do forever; /* the main loop */      if clear.cursors then do; /* screen was refreshed - may need to clear typeahead cursor controls */         flush_term; /* output all pending characters */         do while ((char = c.j) or (char = cur.down) or (char = a.lf)) and (char = peek);            call rchar; /* remove repeated down arrow keystrokes from buffer */         end;         do while ((char = c.k) or (char = cur.up  ) or (char = a.vt)) and (char = peek);            call rchar; /* remove repeated up arrow keystrokes from buffer */         end;         clear.cursors = false; /* do not clear typeahead any more */      end;      if      page.rewrite  then call write.page(0); /* whole page */      else if part.rewrite  then call write.page(current.line-top.line); /* write from current line down */      else if head.rewrite  then call write.header; /* header line */      else if status.change then call write.status(true); /* change status line */      if line.change        then call write.line.number; /* new line number */      if col.change         then call write.cursor(current.col,true); /* shift current line and/or set cursor */      char = get.next.char; /* next char from user or expanders */      if literal.mode then do;          call newchar(char); /* literal mode char always goes to text */         literal.mode = false;       end; /* literal mode */      else call do.command(char); /* call command parser */      call check.screen.changes; /* check for screen updates */      first.time = false; /* end of first time through */   end; /* of do forever */end main;/* Editor and High Core Area initialization */ dcl (i,endsed) fixed;old.psys = core(loc.psys); /* store current value of PSYS */core(loc.psys) = -1; /* cause cold boot */if core(loc.ftyp) <> T#Text then do; /* not a text file */   pstring('Compiled files, sound files, or data files may not be edited');end;else do; /* text file */   if core(loc.wmed) = 0 /* disk work file - set up user memory buffer after SED */   then endsed = core(c#contab+c#vstart)+core(c#contab+c#vlngth)+core(c#contab+c#stklen);   else endsed = core(loc.wsec); /* use monitor's WORK area  */   i = loc.load - endsed; /* find buffer size */   if i IGT (32*1024 - 1) then i = (32*1024 - 1); /* limit to 32K-1 */   if (core(loc.csln) > 255) or (core(loc.clen) IGE (i - 6)) then do;      pstring('File length exceeds editor limit of ');      pnum(i - 6,0); pstring(' words');   end;   else call main(location(endsed),i); /* system environment is set, start editing */end;crlf; /* end error message lines */core(loc.rst) = 2; /* set for good termination */core(loc.psys) = old.psys; /* set psys to avoid re-boot */flush_term;